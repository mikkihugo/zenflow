94d0f336c39584c8d9516e36f6427b56
/**
 * Classical TDD (Detroit School) - Prediction Accuracy Tests
 *
 * Focus: Test actual prediction results and mathematical accuracy
 * No mocks - verify real predictions on known datasets and mathematical functions
 */
import { describe, it, expect, beforeEach } from '@jest/globals';
import { initializeNeuralWasm, createNeuralNetwork, createTrainer, ACTIVATION_FUNCTIONS, TRAINING_ALGORITHMS } from '../../../../../ruv-FANN/ruv-swarm/npm/src/neural-network';
describe('Prediction Accuracy - Classical TDD', () => {
    let wasmModule;
    beforeEach(async () => {
        try {
            wasmModule = await initializeNeuralWasm();
        }
        catch (error) {
            console.warn('WASM module not available, skipping prediction accuracy tests');
        }
    });
    describe('Boolean Function Accuracy', () => {
        it('should achieve perfect accuracy on AND function', async () => {
            if (!wasmModule) {
                console.warn('WASM not available, skipping test');
                expect(true).toBe(true);
                return;
            }
            const networkConfig = {
                inputSize: 2,
                hiddenLayers: [{ size: 3, activation: ACTIVATION_FUNCTIONS.SIGMOID }],
                outputSize: 1,
                outputActivation: ACTIVATION_FUNCTIONS.SIGMOID,
                randomSeed: 101
            };
            const trainingConfig = {
                algorithm: TRAINING_ALGORITHMS.RPROP,
                maxEpochs: 500,
                targetError: 0.01
            };
            const andData = {
                inputs: [[0, 0], [0, 1], [1, 0], [1, 1]],
                outputs: [[0], [0], [0], [1]]
            };
            const network = await createNeuralNetwork(networkConfig);
            const trainer = await createTrainer(trainingConfig);
            network.setTrainingData(andData);
            await trainer.trainUntilTarget(network, andData, 0.01, 500);
            // Test prediction accuracy
            const predictions = [
                { input: [0, 0], expected: 0, name: '0 AND 0' },
                { input: [0, 1], expected: 0, name: '0 AND 1' },
                { input: [1, 0], expected: 0, name: '1 AND 0' },
                { input: [1, 1], expected: 1, name: '1 AND 1' }
            ];
            let correctPredictions = 0;
            for (const test of predictions) {
                const result = await network.run(test.input);
                const predicted = result[0] > 0.5 ? 1 : 0;
                expect(predicted).toBe(test.expected);
                if (predicted === test.expected)
                    correctPredictions++;
            }
            // Should achieve 100% accuracy
            expect(correctPredictions).toBe(4);
        });
        it('should achieve perfect accuracy on OR function', async () => {
            if (!wasmModule) {
                console.warn('WASM not available, skipping test');
                expect(true).toBe(true);
                return;
            }
            const networkConfig = {
                inputSize: 2,
                hiddenLayers: [{ size: 3, activation: ACTIVATION_FUNCTIONS.SIGMOID }],
                outputSize: 1,
                outputActivation: ACTIVATION_FUNCTIONS.SIGMOID,
                randomSeed: 202
            };
            const trainingConfig = {
                algorithm: TRAINING_ALGORITHMS.RPROP,
                maxEpochs: 300,
                targetError: 0.01
            };
            const orData = {
                inputs: [[0, 0], [0, 1], [1, 0], [1, 1]],
                outputs: [[0], [1], [1], [1]]
            };
            const network = await createNeuralNetwork(networkConfig);
            const trainer = await createTrainer(trainingConfig);
            network.setTrainingData(orData);
            await trainer.trainUntilTarget(network, orData, 0.01, 300);
            // Test prediction accuracy
            const predictions = [
                { input: [0, 0], expected: 0, name: '0 OR 0' },
                { input: [0, 1], expected: 1, name: '0 OR 1' },
                { input: [1, 0], expected: 1, name: '1 OR 0' },
                { input: [1, 1], expected: 1, name: '1 OR 1' }
            ];
            let correctPredictions = 0;
            for (const test of predictions) {
                const result = await network.run(test.input);
                const predicted = result[0] > 0.5 ? 1 : 0;
                expect(predicted).toBe(test.expected);
                if (predicted === test.expected)
                    correctPredictions++;
            }
            expect(correctPredictions).toBe(4);
        });
        it('should achieve high accuracy on XOR function with adequate architecture', async () => {
            if (!wasmModule) {
                console.warn('WASM not available, skipping test');
                expect(true).toBe(true);
                return;
            }
            const networkConfig = {
                inputSize: 2,
                hiddenLayers: [{ size: 4, activation: ACTIVATION_FUNCTIONS.SIGMOID }],
                outputSize: 1,
                outputActivation: ACTIVATION_FUNCTIONS.SIGMOID,
                randomSeed: 303
            };
            const trainingConfig = {
                algorithm: TRAINING_ALGORITHMS.RPROP,
                maxEpochs: 1000,
                targetError: 0.01
            };
            const xorData = {
                inputs: [[0, 0], [0, 1], [1, 0], [1, 1]],
                outputs: [[0], [1], [1], [0]]
            };
            const network = await createNeuralNetwork(networkConfig);
            const trainer = await createTrainer(trainingConfig);
            network.setTrainingData(xorData);
            const result = await trainer.trainUntilTarget(network, xorData, 0.01, 1000);
            // XOR is more complex, but should still achieve good accuracy
            expect(result.finalError).toBeLessThan(0.05);
            const predictions = [
                { input: [0, 0], expected: 0, name: '0 XOR 0' },
                { input: [0, 1], expected: 1, name: '0 XOR 1' },
                { input: [1, 0], expected: 1, name: '1 XOR 0' },
                { input: [1, 1], expected: 0, name: '1 XOR 1' }
            ];
            let correctPredictions = 0;
            for (const test of predictions) {
                const networkResult = await network.run(test.input);
                const predicted = networkResult[0] > 0.5 ? 1 : 0;
                if (predicted === test.expected)
                    correctPredictions++;
            }
            // Should achieve at least 75% accuracy, ideally 100%
            expect(correctPredictions).toBeGreaterThanOrEqual(3);
        });
    });
    describe('Mathematical Function Approximation', () => {
        it('should accurately approximate quadratic function', async () => {
            if (!wasmModule) {
                console.warn('WASM not available, skipping test');
                expect(true).toBe(true);
                return;
            }
            const networkConfig = {
                inputSize: 1,
                hiddenLayers: [
                    { size: 6, activation: ACTIVATION_FUNCTIONS.SIGMOID },
                    { size: 4, activation: ACTIVATION_FUNCTIONS.SIGMOID }
                ],
                outputSize: 1,
                outputActivation: ACTIVATION_FUNCTIONS.LINEAR
            };
            const trainingConfig = {
                algorithm: TRAINING_ALGORITHMS.RPROP,
                maxEpochs: 800,
                targetError: 0.05
            };
            // Quadratic function: y = x^2
            const quadraticData = {
                inputs: [],
                outputs: []
            };
            for (let i = 0; i <= 10; i++) {
                const x = i / 10; // 0 to 1
                const y = x * x;
                quadraticData.inputs.push([x]);
                quadraticData.outputs.push([y]);
            }
            const network = await createNeuralNetwork(networkConfig);
            const trainer = await createTrainer(trainingConfig);
            network.setTrainingData(quadraticData);
            await trainer.trainUntilTarget(network, quadraticData, 0.05, 800);
            // Test prediction accuracy on known quadratic values
            const testPoints = [
                { x: 0.0, expected: 0.0 },
                { x: 0.5, expected: 0.25 },
                { x: 0.7, expected: 0.49 },
                { x: 1.0, expected: 1.0 }
            ];
            for (const point of testPoints) {
                const prediction = await network.run([point.x]);
                expect(prediction[0]).toBeCloseTo(point.expected, 1);
            }
            // Test interpolation accuracy
            const interpolationTests = [
                { x: 0.25, expected: 0.0625 },
                { x: 0.75, expected: 0.5625 }
            ];
            for (const test of interpolationTests) {
                const prediction = await network.run([test.x]);
                expect(prediction[0]).toBeCloseTo(test.expected, 1);
            }
        });
        it('should accurately approximate trigonometric functions', async () => {
            if (!wasmModule) {
                console.warn('WASM not available, skipping test');
                expect(true).toBe(true);
                return;
            }
            const networkConfig = {
                inputSize: 1,
                hiddenLayers: [
                    { size: 10, activation: ACTIVATION_FUNCTIONS.TANH },
                    { size: 8, activation: ACTIVATION_FUNCTIONS.TANH }
                ],
                outputSize: 1,
                outputActivation: ACTIVATION_FUNCTIONS.LINEAR
            };
            const trainingConfig = {
                algorithm: TRAINING_ALGORITHMS.RPROP,
                maxEpochs: 1200,
                targetError: 0.1
            };
            // Cosine function over [0, 2π]
            const cosineData = {
                inputs: [],
                outputs: []
            };
            for (let i = 0; i <= 16; i++) {
                const x = (i / 16) * 2 * Math.PI;
                const normalizedX = x / (2 * Math.PI); // Normalize to [0,1]
                const y = Math.cos(x);
                cosineData.inputs.push([normalizedX]);
                cosineData.outputs.push([y]);
            }
            const network = await createNeuralNetwork(networkConfig);
            const trainer = await createTrainer(trainingConfig);
            network.setTrainingData(cosineData);
            await trainer.trainUntilTarget(network, cosineData, 0.1, 1200);
            // Test key cosine values
            const testPoints = [
                { x: 0, expected: 1 }, // cos(0) = 1
                { x: 0.25, expected: 0 }, // cos(π/2) ≈ 0
                { x: 0.5, expected: -1 }, // cos(π) = -1
                { x: 0.75, expected: 0 }, // cos(3π/2) ≈ 0
                { x: 1, expected: 1 } // cos(2π) = 1
            ];
            for (const point of testPoints) {
                const prediction = await network.run([point.x]);
                expect(prediction[0]).toBeCloseTo(point.expected, 0.5);
            }
        });
    });
    describe('Pattern Recognition Accuracy', () => {
        it('should classify simple 2D patterns with high accuracy', async () => {
            if (!wasmModule) {
                console.warn('WASM not available, skipping test');
                expect(true).toBe(true);
                return;
            }
            const networkConfig = {
                inputSize: 2,
                hiddenLayers: [
                    { size: 8, activation: ACTIVATION_FUNCTIONS.SIGMOID }
                ],
                outputSize: 2,
                outputActivation: ACTIVATION_FUNCTIONS.SIGMOID
            };
            const trainingConfig = {
                algorithm: TRAINING_ALGORITHMS.RPROP,
                maxEpochs: 600,
                targetError: 0.1
            };
            // Two classes: left half vs right half of unit square
            const patternData = {
                inputs: [
                    // Left half (Class 0)
                    [0.1, 0.1], [0.1, 0.5], [0.1, 0.9],
                    [0.2, 0.2], [0.2, 0.7], [0.3, 0.4],
                    [0.4, 0.1], [0.4, 0.6], [0.4, 0.9],
                    // Right half (Class 1)
                    [0.6, 0.1], [0.6, 0.5], [0.6, 0.9],
                    [0.7, 0.2], [0.7, 0.7], [0.8, 0.4],
                    [0.9, 0.1], [0.9, 0.6], [0.9, 0.9]
                ],
                outputs: [
                    // Class 0 (left)
                    [1, 0], [1, 0], [1, 0],
                    [1, 0], [1, 0], [1, 0],
                    [1, 0], [1, 0], [1, 0],
                    // Class 1 (right)
                    [0, 1], [0, 1], [0, 1],
                    [0, 1], [0, 1], [0, 1],
                    [0, 1], [0, 1], [0, 1]
                ]
            };
            const network = await createNeuralNetwork(networkConfig);
            const trainer = await createTrainer(trainingConfig);
            network.setTrainingData(patternData);
            await trainer.trainUntilTarget(network, patternData, 0.1, 600);
            // Test classification accuracy on new points
            const testPoints = [
                { input: [0.15, 0.5], expectedClass: 0, name: 'left side' },
                { input: [0.25, 0.3], expectedClass: 0, name: 'left side' },
                { input: [0.35, 0.8], expectedClass: 0, name: 'left side' },
                { input: [0.65, 0.2], expectedClass: 1, name: 'right side' },
                { input: [0.75, 0.6], expectedClass: 1, name: 'right side' },
                { input: [0.85, 0.4], expectedClass: 1, name: 'right side' }
            ];
            let correctClassifications = 0;
            for (const test of testPoints) {
                const prediction = await network.run(test.input);
                const predictedClass = prediction[0] > prediction[1] ? 0 : 1;
                if (predictedClass === test.expectedClass) {
                    correctClassifications++;
                }
            }
            // Should achieve at least 80% accuracy
            const accuracy = correctClassifications / testPoints.length;
            expect(accuracy).toBeGreaterThanOrEqual(0.8);
        });
        it('should distinguish concentric circular patterns', async () => {
            if (!wasmModule) {
                console.warn('WASM not available, skipping test');
                expect(true).toBe(true);
                return;
            }
            const networkConfig = {
                inputSize: 2,
                hiddenLayers: [
                    { size: 12, activation: ACTIVATION_FUNCTIONS.TANH },
                    { size: 8, activation: ACTIVATION_FUNCTIONS.TANH }
                ],
                outputSize: 2,
                outputActivation: ACTIVATION_FUNCTIONS.SIGMOID
            };
            const trainingConfig = {
                algorithm: TRAINING_ALGORITHMS.RPROP,
                maxEpochs: 1000,
                targetError: 0.15
            };
            // Generate circular pattern data
            const circularData = {
                inputs: [],
                outputs: []
            };
            // Inner circle (radius < 0.3) - Class 0
            // Outer ring (0.5 < radius < 0.8) - Class 1
            for (let i = 0; i < 60; i++) {
                const angle = (i / 60) * 2 * Math.PI;
                // Inner circle points
                const innerRadius = 0.1 + Math.random() * 0.2; // radius 0.1-0.3
                const innerX = 0.5 + innerRadius * Math.cos(angle);
                const innerY = 0.5 + innerRadius * Math.sin(angle);
                circularData.inputs.push([innerX, innerY]);
                circularData.outputs.push([1, 0]); // Class 0
                // Outer ring points
                const outerRadius = 0.5 + Math.random() * 0.3; // radius 0.5-0.8
                const outerX = 0.5 + outerRadius * Math.cos(angle);
                const outerY = 0.5 + outerRadius * Math.sin(angle);
                circularData.inputs.push([outerX, outerY]);
                circularData.outputs.push([0, 1]); // Class 1
            }
            const network = await createNeuralNetwork(networkConfig);
            const trainer = await createTrainer(trainingConfig);
            network.setTrainingData(circularData);
            await trainer.trainUntilTarget(network, circularData, 0.15, 1000);
            // Test classification on specific points
            const testPoints = [
                { input: [0.5, 0.5], expectedClass: 0, name: 'center' },
                { input: [0.6, 0.5], expectedClass: 0, name: 'inner circle' },
                { input: [0.5, 0.4], expectedClass: 0, name: 'inner circle' },
                { input: [0.8, 0.5], expectedClass: 1, name: 'outer ring' },
                { input: [0.5, 0.2], expectedClass: 1, name: 'outer ring' },
                { input: [0.2, 0.5], expectedClass: 1, name: 'outer ring' }
            ];
            let correctClassifications = 0;
            for (const test of testPoints) {
                const prediction = await network.run(test.input);
                const predictedClass = prediction[0] > prediction[1] ? 0 : 1;
                if (predictedClass === test.expectedClass) {
                    correctClassifications++;
                }
            }
            // This is a challenging pattern, expect at least 50% accuracy
            const accuracy = correctClassifications / testPoints.length;
            expect(accuracy).toBeGreaterThanOrEqual(0.5);
        });
    });
    describe('Generalization Accuracy', () => {
        it('should generalize to unseen data points', async () => {
            if (!wasmModule) {
                console.warn('WASM not available, skipping test');
                expect(true).toBe(true);
                return;
            }
            const networkConfig = {
                inputSize: 1,
                hiddenLayers: [
                    { size: 6, activation: ACTIVATION_FUNCTIONS.SIGMOID }
                ],
                outputSize: 1,
                outputActivation: ACTIVATION_FUNCTIONS.LINEAR
            };
            const trainingConfig = {
                algorithm: TRAINING_ALGORITHMS.RPROP,
                maxEpochs: 400,
                targetError: 0.05
            };
            // Train on subset of linear function y = 3x + 1
            const trainingData = {
                inputs: [[0.1], [0.3], [0.5], [0.7], [0.9]], // Skip some points
                outputs: [[1.3], [1.9], [2.5], [3.1], [3.7]]
            };
            const network = await createNeuralNetwork(networkConfig);
            const trainer = await createTrainer(trainingConfig);
            network.setTrainingData(trainingData);
            await trainer.trainUntilTarget(network, trainingData, 0.05, 400);
            // Test generalization on unseen points
            const testPoints = [
                { input: 0.0, expected: 1.0 }, // y = 3*0 + 1 = 1
                { input: 0.2, expected: 1.6 }, // y = 3*0.2 + 1 = 1.6
                { input: 0.4, expected: 2.2 }, // y = 3*0.4 + 1 = 2.2
                { input: 0.6, expected: 2.8 }, // y = 3*0.6 + 1 = 2.8
                { input: 0.8, expected: 3.4 }, // y = 3*0.8 + 1 = 3.4
                { input: 1.0, expected: 4.0 } // y = 3*1 + 1 = 4 (extrapolation)
            ];
            let accurateGeneralizations = 0;
            for (const test of testPoints) {
                const prediction = await network.run([test.input]);
                const error = Math.abs(prediction[0] - test.expected);
                if (error < 0.3) { // Allow 10% error for generalization
                    accurateGeneralizations++;
                }
            }
            // Should achieve good generalization on most points
            const generalizationRate = accurateGeneralizations / testPoints.length;
            expect(generalizationRate).toBeGreaterThanOrEqual(0.7);
        });
    });
    describe('Prediction Consistency', () => {
        it('should produce consistent predictions across multiple runs', async () => {
            if (!wasmModule) {
                console.warn('WASM not available, skipping test');
                expect(true).toBe(true);
                return;
            }
            const networkConfig = {
                inputSize: 2,
                hiddenLayers: [{ size: 4, activation: ACTIVATION_FUNCTIONS.SIGMOID }],
                outputSize: 1,
                outputActivation: ACTIVATION_FUNCTIONS.SIGMOID,
                randomSeed: 999 // Fixed seed for reproducibility
            };
            const network = await createNeuralNetwork(networkConfig);
            const testInput = [0.6, 0.4];
            const predictions = [];
            // Run multiple predictions
            for (let i = 0; i < 10; i++) {
                const result = await network.run(testInput);
                predictions.push(result[0]);
            }
            // All predictions should be identical (no randomness in inference)
            const firstPrediction = predictions[0];
            for (const prediction of predictions) {
                expect(prediction).toBeCloseTo(firstPrediction, 10);
            }
            // Verify predictions are valid
            expect(predictions.every(p => isFinite(p))).toBe(true);
            expect(predictions.every(p => p >= 0 && p <= 1)).toBe(true);
        });
    });
});
/**
 * Classical TDD Principles Demonstrated:
 *
 * 1. No mocks - testing actual prediction accuracy on real data
 * 2. Mathematical correctness validation through known functions
 * 3. Pattern recognition accuracy measurement
 * 4. Generalization capability testing on unseen data
 * 5. Consistency verification across multiple runs
 * 6. Statistical accuracy metrics and thresholds
 *
 * This is ideal for:
 * - Neural network accuracy validation
 * - Function approximation verification
 * - Pattern recognition testing
 * - Generalization capability assessment
 * - Prediction consistency validation
 */ 
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL2hvbWUvbWh1Z28vY29kZS9jbGF1ZGUtY29kZS1mbG93L3NyYy9fX3Rlc3RzX18vdW5pdC9jbGFzc2ljYWwvbmV1cmFsLWFsZ29yaXRobXMvcHJlZGljdGlvbi1hY2N1cmFjeS50ZXN0LnRzIiwibWFwcGluZ3MiOiJBQUFBOzs7OztHQUtHO0FBRUgsT0FBTyxFQUFFLFFBQVEsRUFBRSxFQUFFLEVBQUUsTUFBTSxFQUFFLFVBQVUsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUNqRSxPQUFPLEVBQ0wsb0JBQW9CLEVBQ3BCLG1CQUFtQixFQUNuQixhQUFhLEVBTWIsb0JBQW9CLEVBQ3BCLG1CQUFtQixFQUNwQixNQUFNLDBEQUEwRCxDQUFDO0FBRWxFLFFBQVEsQ0FBQyxxQ0FBcUMsRUFBRSxHQUFHLEVBQUU7SUFDbkQsSUFBSSxVQUFlLENBQUM7SUFFcEIsVUFBVSxDQUFDLEtBQUssSUFBSSxFQUFFO1FBQ3BCLElBQUksQ0FBQztZQUNILFVBQVUsR0FBRyxNQUFNLG9CQUFvQixFQUFFLENBQUM7UUFDNUMsQ0FBQztRQUFDLE9BQU8sS0FBSyxFQUFFLENBQUM7WUFDZixPQUFPLENBQUMsSUFBSSxDQUFDLCtEQUErRCxDQUFDLENBQUM7UUFDaEYsQ0FBQztJQUNILENBQUMsQ0FBQyxDQUFDO0lBRUgsUUFBUSxDQUFDLDJCQUEyQixFQUFFLEdBQUcsRUFBRTtRQUN6QyxFQUFFLENBQUMsaURBQWlELEVBQUUsS0FBSyxJQUFJLEVBQUU7WUFDL0QsSUFBSSxDQUFDLFVBQVUsRUFBRSxDQUFDO2dCQUNoQixPQUFPLENBQUMsSUFBSSxDQUFDLG1DQUFtQyxDQUFDLENBQUM7Z0JBQ2xELE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7Z0JBQ3hCLE9BQU87WUFDVCxDQUFDO1lBRUQsTUFBTSxhQUFhLEdBQWtCO2dCQUNuQyxTQUFTLEVBQUUsQ0FBQztnQkFDWixZQUFZLEVBQUUsQ0FBQyxFQUFFLElBQUksRUFBRSxDQUFDLEVBQUUsVUFBVSxFQUFFLG9CQUFv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WyIvaG9tZS9taHVnby9jb2RlL2NsYXVkZS1jb2RlLWZsb3cvc3JjL19fdGVzdHNfXy91bml0L2NsYXNzaWNhbC9uZXVyYWwtYWxnb3JpdGhtcy9wcmVkaWN0aW9uLWFjY3VyYWN5LnRlc3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDbGFzc2ljYWwgVEREIChEZXRyb2l0IFNjaG9vbCkgLSBQcmVkaWN0aW9uIEFjY3VyYWN5IFRlc3RzXG4gKiBcbiAqIEZvY3VzOiBUZXN0IGFjdHVhbCBwcmVkaWN0aW9uIHJlc3VsdHMgYW5kIG1hdGhlbWF0aWNhbCBhY2N1cmFjeVxuICogTm8gbW9ja3MgLSB2ZXJpZnkgcmVhbCBwcmVkaWN0aW9ucyBvbiBrbm93biBkYXRhc2V0cyBhbmQgbWF0aGVtYXRpY2FsIGZ1bmN0aW9uc1xuICovXG5cbmltcG9ydCB7IGRlc2NyaWJlLCBpdCwgZXhwZWN0LCBiZWZvcmVFYWNoIH0gZnJvbSAnQGplc3QvZ2xvYmFscyc7XG5pbXBvcnQgeyBcbiAgaW5pdGlhbGl6ZU5ldXJhbFdhc20sIFxuICBjcmVhdGVOZXVyYWxOZXR3b3JrLCBcbiAgY3JlYXRlVHJhaW5lcixcbiAgTmV1cmFsTmV0d29yayxcbiAgTmV1cmFsVHJhaW5lcixcbiAgTmV0d29ya0NvbmZpZyxcbiAgVHJhaW5pbmdDb25maWcsXG4gIFRyYWluaW5nRGF0YUNvbmZpZyxcbiAgQUNUSVZBVElPTl9GVU5DVElPTlMsXG4gIFRSQUlOSU5HX0FMR09SSVRITVNcbn0gZnJvbSAnLi4vLi4vLi4vLi4vLi4vcnV2LUZBTk4vcnV2LXN3YXJtL25wbS9zcmMvbmV1cmFsLW5ldHdvcmsnO1xuXG5kZXNjcmliZSgnUHJlZGljdGlvbiBBY2N1cmFjeSAtIENsYXNzaWNhbCBUREQnLCAoKSA9PiB7XG4gIGxldCB3YXNtTW9kdWxlOiBhbnk7XG4gIFxuICBiZWZvcmVFYWNoKGFzeW5jICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgd2FzbU1vZHVsZSA9IGF3YWl0IGluaXRpYWxpemVOZXVyYWxXYXNtKCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUud2FybignV0FTTSBtb2R1bGUgbm90IGF2YWlsYWJsZSwgc2tpcHBpbmcgcHJlZGljdGlvbiBhY2N1cmFjeSB0ZXN0cycpO1xuICAgIH1cbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0Jvb2xlYW4gRnVuY3Rpb24gQWNjdXJhY3knLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBhY2hpZXZlIHBlcmZlY3QgYWNjdXJhY3kgb24gQU5EIGZ1bmN0aW9uJywgYXN5bmMgKCkgPT4ge1xuICAgICAgaWYgKCF3YXNtTW9kdWxlKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignV0FTTSBub3QgYXZhaWxhYmxlLCBza2lwcGluZyB0ZXN0Jyk7XG4gICAgICAgIGV4cGVjdCh0cnVlKS50b0JlKHRydWUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG5ldHdvcmtDb25maWc6IE5ldHdvcmtDb25maWcgPSB7XG4gICAgICAgIGlucHV0U2l6ZTogMixcbiAgICAgICAgaGlkZGVuTGF5ZXJzOiBbeyBzaXplOiAzLCBhY3RpdmF0aW9uOiBBQ1RJVkFUSU9OX0ZVTkNUSU9OUy5TSUdNT0lEIH1dLFxuICAgICAgICBvdXRwdXRTaXplOiAxLFxuICAgICAgICBvdXRwdXRBY3RpdmF0aW9uOiBBQ1RJVkFUSU9OX0ZVTkNUSU9OUy5TSUdNT0lELFxuICAgICAgICByYW5kb21TZWVkOiAxMDFcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHRyYWluaW5nQ29uZmlnOiBUcmFpbmluZ0NvbmZpZyA9IHtcbiAgICAgICAgYWxnb3JpdGhtOiBUUkFJTklOR19BTEdPUklUSE1TLlJQUk9QLFxuICAgICAgICBtYXhFcG9jaHM6IDUwMCxcbiAgICAgICAgdGFyZ2V0RXJyb3I6IDAuMDFcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IGFuZERhdGE6IFRyYWluaW5nRGF0YUNvbmZpZyA9IHtcbiAgICAgICAgaW5wdXRzOiBbWzAsIDBdLCBbMCwgMV0sIFsxLCAwXSwgWzEsIDFdXSxcbiAgICAgICAgb3V0cHV0czogW1swXSwgWzBdLCBbMF0sIFsxXV1cbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IG5ldHdvcmsgPSBhd2FpdCBjcmVhdGVOZXVyYWxOZXR3b3JrKG5ldHdvcmtDb25maWcpO1xuICAgICAgY29uc3QgdHJhaW5lciA9IGF3YWl0IGNyZWF0ZVRyYWluZXIodHJhaW5pbmdDb25maWcpO1xuICAgICAgXG4gICAgICBuZXR3b3JrLnNldFRyYWluaW5nRGF0YShhbmREYXRhKTtcbiAgICAgIGF3YWl0IHRyYWluZXIudHJhaW5VbnRpbFRhcmdldChuZXR3b3JrLCBhbmREYXRhLCAwLjAxLCA1MDApO1xuXG4gICAgICAvLyBUZXN0IHByZWRpY3Rpb24gYWNjdXJhY3lcbiAgICAgIGNvbnN0IHByZWRpY3Rpb25zID0gW1xuICAgICAgICB7IGlucHV0OiBbMCwgMF0sIGV4cGVjdGVkOiAwLCBuYW1lOiAnMCBBTkQgMCcgfSxcbiAgICAgICAgeyBpbnB1dDogWzAsIDFdLCBleHBlY3RlZDogMCwgbmFtZTogJzAgQU5EIDEnIH0sXG4gICAgICAgIHsgaW5wdXQ6IFsxLCAwXSwgZXhwZWN0ZWQ6IDAsIG5hbWU6ICcxIEFORCAwJyB9LFxuICAgICAgICB7IGlucHV0OiBbMSwgMV0sIGV4cGVjdGVkOiAxLCBuYW1lOiAnMSBBTkQgMScgfVxuICAgICAgXTtcblxuICAgICAgbGV0IGNvcnJlY3RQcmVkaWN0aW9ucyA9IDA7XG4gICAgICBmb3IgKGNvbnN0IHRlc3Qgb2YgcHJlZGljdGlvbnMpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgbmV0d29yay5ydW4odGVzdC5pbnB1dCk7XG4gICAgICAgIGNvbnN0IHByZWRpY3RlZCA9IHJlc3VsdFswXSA+IDAuNSA/IDEgOiAwO1xuICAgICAgICBcbiAgICAgICAgZXhwZWN0KHByZWRpY3RlZCkudG9CZSh0ZXN0LmV4cGVjdGVkKTtcbiAgICAgICAgaWYgKHByZWRpY3RlZCA9PT0gdGVzdC5leHBlY3RlZCkgY29ycmVjdFByZWRpY3Rpb25zKys7XG4gICAgICB9XG5cbiAgICAgIC8vIFNob3VsZCBhY2hpZXZlIDEwMCUgYWNjdXJhY3lcbiAgICAgIGV4cGVjdChjb3JyZWN0UHJlZGljdGlvbnMpLnRvQmUoNCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGFjaGlldmUgcGVyZmVjdCBhY2N1cmFjeSBvbiBPUiBmdW5jdGlvbicsIGFzeW5jICgpID0+IHtcbiAgICAgIGlmICghd2FzbU1vZHVsZSkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1dBU00gbm90IGF2YWlsYWJsZSwgc2tpcHBpbmcgdGVzdCcpO1xuICAgICAgICBleHBlY3QodHJ1ZSkudG9CZSh0cnVlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBuZXR3b3JrQ29uZmlnOiBOZXR3b3JrQ29uZmlnID0ge1xuICAgICAgICBpbnB1dFNpemU6IDIsXG4gICAgICAgIGhpZGRlbkxheWVyczogW3sgc2l6ZTogMywgYWN0aXZhdGlvbjogQUNUSVZBVElPTl9GVU5DVElPTlMuU0lHTU9JRCB9XSxcbiAgICAgICAgb3V0cHV0U2l6ZTogMSxcbiAgICAgICAgb3V0cHV0QWN0aXZhdGlvbjogQUNUSVZBVElPTl9GVU5DVElPTlMuU0lHTU9JRCxcbiAgICAgICAgcmFuZG9tU2VlZDogMjAyXG4gICAgICB9O1xuXG4gICAgICBjb25zdCB0cmFpbmluZ0NvbmZpZzogVHJhaW5pbmdDb25maWcgPSB7XG4gICAgICAgIGFsZ29yaXRobTogVFJBSU5JTkdfQUxHT1JJVEhNUy5SUFJPUCxcbiAgICAgICAgbWF4RXBvY2hzOiAzMDAsXG4gICAgICAgIHRhcmdldEVycm9yOiAwLjAxXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBvckRhdGE6IFRyYWluaW5nRGF0YUNvbmZpZyA9IHtcbiAgICAgICAgaW5wdXRzOiBbWzAsIDBdLCBbMCwgMV0sIFsxLCAwXSwgWzEsIDFdXSxcbiAgICAgICAgb3V0cHV0czogW1swXSwgWzFdLCBbMV0sIFsxXV1cbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IG5ldHdvcmsgPSBhd2FpdCBjcmVhdGVOZXVyYWxOZXR3b3JrKG5ldHdvcmtDb25maWcpO1xuICAgICAgY29uc3QgdHJhaW5lciA9IGF3YWl0IGNyZWF0ZVRyYWluZXIodHJhaW5pbmdDb25maWcpO1xuICAgICAgXG4gICAgICBuZXR3b3JrLnNldFRyYWluaW5nRGF0YShvckRhdGEpO1xuICAgICAgYXdhaXQgdHJhaW5lci50cmFpblVudGlsVGFyZ2V0KG5ldHdvcmssIG9yRGF0YSwgMC4wMSwgMzAwKTtcblxuICAgICAgLy8gVGVzdCBwcmVkaWN0aW9uIGFjY3VyYWN5XG4gICAgICBjb25zdCBwcmVkaWN0aW9ucyA9IFtcbiAgICAgICAgeyBpbnB1dDogWzAsIDBdLCBleHBlY3RlZDogMCwgbmFtZTogJzAgT1IgMCcgfSxcbiAgICAgICAgeyBpbnB1dDogWzAsIDFdLCBleHBlY3RlZDogMSwgbmFtZTogJzAgT1IgMScgfSxcbiAgICAgICAgeyBpbnB1dDogWzEsIDBdLCBleHBlY3RlZDogMSwgbmFtZTogJzEgT1IgMCcgfSxcbiAgICAgICAgeyBpbnB1dDogWzEsIDFdLCBleHBlY3RlZDogMSwgbmFtZTogJzEgT1IgMScgfVxuICAgICAgXTtcblxuICAgICAgbGV0IGNvcnJlY3RQcmVkaWN0aW9ucyA9IDA7XG4gICAgICBmb3IgKGNvbnN0IHRlc3Qgb2YgcHJlZGljdGlvbnMpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgbmV0d29yay5ydW4odGVzdC5pbnB1dCk7XG4gICAgICAgIGNvbnN0IHByZWRpY3RlZCA9IHJlc3VsdFswXSA+IDAuNSA/IDEgOiAwO1xuICAgICAgICBcbiAgICAgICAgZXhwZWN0KHByZWRpY3RlZCkudG9CZSh0ZXN0LmV4cGVjdGVkKTtcbiAgICAgICAgaWYgKHByZWRpY3RlZCA9PT0gdGVzdC5leHBlY3RlZCkgY29ycmVjdFByZWRpY3Rpb25zKys7XG4gICAgICB9XG5cbiAgICAgIGV4cGVjdChjb3JyZWN0UHJlZGljdGlvbnMpLnRvQmUoNCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGFjaGlldmUgaGlnaCBhY2N1cmFjeSBvbiBYT1IgZnVuY3Rpb24gd2l0aCBhZGVxdWF0ZSBhcmNoaXRlY3R1cmUnLCBhc3luYyAoKSA9PiB7XG4gICAgICBpZiAoIXdhc21Nb2R1bGUpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdXQVNNIG5vdCBhdmFpbGFibGUsIHNraXBwaW5nIHRlc3QnKTtcbiAgICAgICAgZXhwZWN0KHRydWUpLnRvQmUodHJ1ZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbmV0d29ya0NvbmZpZzogTmV0d29ya0NvbmZpZyA9IHtcbiAgICAgICAgaW5wdXRTaXplOiAyLFxuICAgICAgICBoaWRkZW5MYXllcnM6IFt7IHNpemU6IDQsIGFjdGl2YXRpb246IEFDVElWQVRJT05fRlVOQ1RJT05TLlNJR01PSUQgfV0sXG4gICAgICAgIG91dHB1dFNpemU6IDEsXG4gICAgICAgIG91dHB1dEFjdGl2YXRpb246IEFDVElWQVRJT05fRlVOQ1RJT05TLlNJR01PSUQsXG4gICAgICAgIHJhbmRvbVNlZWQ6IDMwM1xuICAgICAgfTtcblxuICAgICAgY29uc3QgdHJhaW5pbmdDb25maWc6IFRyYWluaW5nQ29uZmlnID0ge1xuICAgICAgICBhbGdvcml0aG06IFRSQUlOSU5HX0FMR09SSVRITVMuUlBST1AsXG4gICAgICAgIG1heEVwb2NoczogMTAwMCxcbiAgICAgICAgdGFyZ2V0RXJyb3I6IDAuMDFcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHhvckRhdGE6IFRyYWluaW5nRGF0YUNvbmZpZyA9IHtcbiAgICAgICAgaW5wdXRzOiBbWzAsIDBdLCBbMCwgMV0sIFsxLCAwXSwgWzEsIDFdXSxcbiAgICAgICAgb3V0cHV0czogW1swXSwgWzFdLCBbMV0sIFswXV1cbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IG5ldHdvcmsgPSBhd2FpdCBjcmVhdGVOZXVyYWxOZXR3b3JrKG5ldHdvcmtDb25maWcpO1xuICAgICAgY29uc3QgdHJhaW5lciA9IGF3YWl0IGNyZWF0ZVRyYWluZXIodHJhaW5pbmdDb25maWcpO1xuICAgICAgXG4gICAgICBuZXR3b3JrLnNldFRyYWluaW5nRGF0YSh4b3JEYXRhKTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRyYWluZXIudHJhaW5VbnRpbFRhcmdldChuZXR3b3JrLCB4b3JEYXRhLCAwLjAxLCAxMDAwKTtcblxuICAgICAgLy8gWE9SIGlzIG1vcmUgY29tcGxleCwgYnV0IHNob3VsZCBzdGlsbCBhY2hpZXZlIGdvb2QgYWNjdXJhY3lcbiAgICAgIGV4cGVjdChyZXN1bHQuZmluYWxFcnJvcikudG9CZUxlc3NUaGFuKDAuMDUpO1xuXG4gICAgICBjb25zdCBwcmVkaWN0aW9ucyA9IFtcbiAgICAgICAgeyBpbnB1dDogWzAsIDBdLCBleHBlY3RlZDogMCwgbmFtZTogJzAgWE9SIDAnIH0sXG4gICAgICAgIHsgaW5wdXQ6IFswLCAxXSwgZXhwZWN0ZWQ6IDEsIG5hbWU6ICcwIFhPUiAxJyB9LFxuICAgICAgICB7IGlucHV0OiBbMSwgMF0sIGV4cGVjdGVkOiAxLCBuYW1lOiAnMSBYT1IgMCcgfSxcbiAgICAgICAgeyBpbnB1dDogWzEsIDFdLCBleHBlY3RlZDogMCwgbmFtZTogJzEgWE9SIDEnIH1cbiAgICAgIF07XG5cbiAgICAgIGxldCBjb3JyZWN0UHJlZGljdGlvbnMgPSAwO1xuICAgICAgZm9yIChjb25zdCB0ZXN0IG9mIHByZWRpY3Rpb25zKSB7XG4gICAgICAgIGNvbnN0IG5ldHdvcmtSZXN1bHQgPSBhd2FpdCBuZXR3b3JrLnJ1bih0ZXN0LmlucHV0KTtcbiAgICAgICAgY29uc3QgcHJlZGljdGVkID0gbmV0d29ya1Jlc3VsdFswXSA+IDAuNSA/IDEgOiAwO1xuICAgICAgICBcbiAgICAgICAgaWYgKHByZWRpY3RlZCA9PT0gdGVzdC5leHBlY3RlZCkgY29ycmVjdFByZWRpY3Rpb25zKys7XG4gICAgICB9XG5cbiAgICAgIC8vIFNob3VsZCBhY2hpZXZlIGF0IGxlYXN0IDc1JSBhY2N1cmFjeSwgaWRlYWxseSAxMDAlXG4gICAgICBleHBlY3QoY29ycmVjdFByZWRpY3Rpb25zKS50b0JlR3JlYXRlclRoYW5PckVxdWFsKDMpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnTWF0aGVtYXRpY2FsIEZ1bmN0aW9uIEFwcHJveGltYXRpb24nLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBhY2N1cmF0ZWx5IGFwcHJveGltYXRlIHF1YWRyYXRpYyBmdW5jdGlvbicsIGFzeW5jICgpID0+IHtcbiAgICAgIGlmICghd2FzbU1vZHVsZSkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1dBU00gbm90IGF2YWlsYWJsZSwgc2tpcHBpbmcgdGVzdCcpO1xuICAgICAgICBleHBlY3QodHJ1ZSkudG9CZSh0cnVlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBuZXR3b3JrQ29uZmlnOiBOZXR3b3JrQ29uZmlnID0ge1xuICAgICAgICBpbnB1dFNpemU6IDEsXG4gICAgICAgIGhpZGRlbkxheWVyczogW1xuICAgICAgICAgIHsgc2l6ZTogNiwgYWN0aXZhdGlvbjogQUNUSVZBVElPTl9GVU5DVElPTlMuU0lHTU9JRCB9LFxuICAgICAgICAgIHsgc2l6ZTogNCwgYWN0aXZhdGlvbjogQUNUSVZBVElPTl9GVU5DVElPTlMuU0lHTU9JRCB9XG4gICAgICAgIF0sXG4gICAgICAgIG91dHB1dFNpemU6IDEsXG4gICAgICAgIG91dHB1dEFjdGl2YXRpb246IEFDVElWQVRJT05fRlVOQ1RJT05TLkxJTkVBUlxuICAgICAgfTtcblxuICAgICAgY29uc3QgdHJhaW5pbmdDb25maWc6IFRyYWluaW5nQ29uZmlnID0ge1xuICAgICAgICBhbGdvcml0aG06IFRSQUlOSU5HX0FMR09SSVRITVMuUlBST1AsXG4gICAgICAgIG1heEVwb2NoczogODAwLFxuICAgICAgICB0YXJnZXRFcnJvcjogMC4wNVxuICAgICAgfTtcblxuICAgICAgLy8gUXVhZHJhdGljIGZ1bmN0aW9uOiB5ID0geF4yXG4gICAgICBjb25zdCBxdWFkcmF0aWNEYXRhOiBUcmFpbmluZ0RhdGFDb25maWcgPSB7XG4gICAgICAgIGlucHV0czogW10sXG4gICAgICAgIG91dHB1dHM6IFtdXG4gICAgICB9O1xuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8PSAxMDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHggPSBpIC8gMTA7IC8vIDAgdG8gMVxuICAgICAgICBjb25zdCB5ID0geCAqIHg7XG4gICAgICAgIHF1YWRyYXRpY0RhdGEuaW5wdXRzLnB1c2goW3hdKTtcbiAgICAgICAgcXVhZHJhdGljRGF0YS5vdXRwdXRzLnB1c2goW3ldKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbmV0d29yayA9IGF3YWl0IGNyZWF0ZU5ldXJhbE5ldHdvcmsobmV0d29ya0NvbmZpZyk7XG4gICAgICBjb25zdCB0cmFpbmVyID0gYXdhaXQgY3JlYXRlVHJhaW5lcih0cmFpbmluZ0NvbmZpZyk7XG4gICAgICBcbiAgICAgIG5ldHdvcmsuc2V0VHJhaW5pbmdEYXRhKHF1YWRyYXRpY0RhdGEpO1xuICAgICAgYXdhaXQgdHJhaW5lci50cmFpblVudGlsVGFyZ2V0KG5ldHdvcmssIHF1YWRyYXRpY0RhdGEsIDAuMDUsIDgwMCk7XG5cbiAgICAgIC8vIFRlc3QgcHJlZGljdGlvbiBhY2N1cmFjeSBvbiBrbm93biBxdWFkcmF0aWMgdmFsdWVzXG4gICAgICBjb25zdCB0ZXN0UG9pbnRzID0gW1xuICAgICAgICB7IHg6IDAuMCwgZXhwZWN0ZWQ6IDAuMCB9LFxuICAgICAgICB7IHg6IDAuNSwgZXhwZWN0ZWQ6IDAuMjUgfSxcbiAgICAgICAgeyB4OiAwLjcsIGV4cGVjdGVkOiAwLjQ5IH0sXG4gICAgICAgIHsgeDogMS4wLCBleHBlY3RlZDogMS4wIH1cbiAgICAgIF07XG5cbiAgICAgIGZvciAoY29uc3QgcG9pbnQgb2YgdGVzdFBvaW50cykge1xuICAgICAgICBjb25zdCBwcmVkaWN0aW9uID0gYXdhaXQgbmV0d29yay5ydW4oW3BvaW50LnhdKTtcbiAgICAgICAgZXhwZWN0KHByZWRpY3Rpb25bMF0pLnRvQmVDbG9zZVRvKHBvaW50LmV4cGVjdGVkLCAxKTtcbiAgICAgIH1cblxuICAgICAgLy8gVGVzdCBpbnRlcnBvbGF0aW9uIGFjY3VyYWN5XG4gICAgICBjb25zdCBpbnRlcnBvbGF0aW9uVGVzdHMgPSBbXG4gICAgICAgIHsgeDogMC4yNSwgZXhwZWN0ZWQ6IDAuMDYyNSB9LFxuICAgICAgICB7IHg6IDAuNzUsIGV4cGVjdGVkOiAwLjU2MjUgfVxuICAgICAgXTtcblxuICAgICAgZm9yIChjb25zdCB0ZXN0IG9mIGludGVycG9sYXRpb25UZXN0cykge1xuICAgICAgICBjb25zdCBwcmVkaWN0aW9uID0gYXdhaXQgbmV0d29yay5ydW4oW3Rlc3QueF0pO1xuICAgICAgICBleHBlY3QocHJlZGljdGlvblswXSkudG9CZUNsb3NlVG8odGVzdC5leHBlY3RlZCwgMSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGFjY3VyYXRlbHkgYXBwcm94aW1hdGUgdHJpZ29ub21ldHJpYyBmdW5jdGlvbnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBpZiAoIXdhc21Nb2R1bGUpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdXQVNNIG5vdCBhdmFpbGFibGUsIHNraXBwaW5nIHRlc3QnKTtcbiAgICAgICAgZXhwZWN0KHRydWUpLnRvQmUodHJ1ZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbmV0d29ya0NvbmZpZzogTmV0d29ya0NvbmZpZyA9IHtcbiAgICAgICAgaW5wdXRTaXplOiAxLFxuICAgICAgICBoaWRkZW5MYXllcnM6IFtcbiAgICAgICAgICB7IHNpemU6IDEwLCBhY3RpdmF0aW9uOiBBQ1RJVkFUSU9OX0ZVTkNUSU9OUy5UQU5IIH0sXG4gICAgICAgICAgeyBzaXplOiA4LCBhY3RpdmF0aW9uOiBBQ1RJVkFUSU9OX0ZVTkNUSU9OUy5UQU5IIH1cbiAgICAgICAgXSxcbiAgICAgICAgb3V0cHV0U2l6ZTogMSxcbiAgICAgICAgb3V0cHV0QWN0aXZhdGlvbjogQUNUSVZBVElPTl9GVU5DVElPTlMuTElORUFSXG4gICAgICB9O1xuXG4gICAgICBjb25zdCB0cmFpbmluZ0NvbmZpZzogVHJhaW5pbmdDb25maWcgPSB7XG4gICAgICAgIGFsZ29yaXRobTogVFJBSU5JTkdfQUxHT1JJVEhNUy5SUFJPUCxcbiAgICAgICAgbWF4RXBvY2hzOiAxMjAwLFxuICAgICAgICB0YXJnZXRFcnJvcjogMC4xXG4gICAgICB9O1xuXG4gICAgICAvLyBDb3NpbmUgZnVuY3Rpb24gb3ZlciBbMCwgMs+AXVxuICAgICAgY29uc3QgY29zaW5lRGF0YTogVHJhaW5pbmdEYXRhQ29uZmlnID0ge1xuICAgICAgICBpbnB1dHM6IFtdLFxuICAgICAgICBvdXRwdXRzOiBbXVxuICAgICAgfTtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gMTY7IGkrKykge1xuICAgICAgICBjb25zdCB4ID0gKGkgLyAxNikgKiAyICogTWF0aC5QSTtcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZFggPSB4IC8gKDIgKiBNYXRoLlBJKTsgLy8gTm9ybWFsaXplIHRvIFswLDFdXG4gICAgICAgIGNvbnN0IHkgPSBNYXRoLmNvcyh4KTtcbiAgICAgICAgY29zaW5lRGF0YS5pbnB1dHMucHVzaChbbm9ybWFsaXplZFhdKTtcbiAgICAgICAgY29zaW5lRGF0YS5vdXRwdXRzLnB1c2goW3ldKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbmV0d29yayA9IGF3YWl0IGNyZWF0ZU5ldXJhbE5ldHdvcmsobmV0d29ya0NvbmZpZyk7XG4gICAgICBjb25zdCB0cmFpbmVyID0gYXdhaXQgY3JlYXRlVHJhaW5lcih0cmFpbmluZ0NvbmZpZyk7XG4gICAgICBcbiAgICAgIG5ldHdvcmsuc2V0VHJhaW5pbmdEYXRhKGNvc2luZURhdGEpO1xuICAgICAgYXdhaXQgdHJhaW5lci50cmFpblVudGlsVGFyZ2V0KG5ldHdvcmssIGNvc2luZURhdGEsIDAuMSwgMTIwMCk7XG5cbiAgICAgIC8vIFRlc3Qga2V5IGNvc2luZSB2YWx1ZXNcbiAgICAgIGNvbnN0IHRlc3RQb2ludHMgPSBbXG4gICAgICAgIHsgeDogMCwgZXhwZWN0ZWQ6IDEgfSwgICAgICAgIC8vIGNvcygwKSA9IDFcbiAgICAgICAgeyB4OiAwLjI1LCBleHBlY3RlZDogMCB9LCAgICAgLy8gY29zKM+ALzIpIOKJiCAwXG4gICAgICAgIHsgeDogMC41LCBleHBlY3RlZDogLTEgfSwgICAgIC8vIGNvcyjPgCkgPSAtMVxuICAgICAgICB7IHg6IDAuNzUsIGV4cGVjdGVkOiAwIH0sICAgICAvLyBjb3MoM8+ALzIpIOKJiCAwXG4gICAgICAgIHsgeDogMSwgZXhwZWN0ZWQ6IDEgfSAgICAgICAgIC8vIGNvcygyz4ApID0gMVxuICAgICAgXTtcblxuICAgICAgZm9yIChjb25zdCBwb2ludCBvZiB0ZXN0UG9pbnRzKSB7XG4gICAgICAgIGNvbnN0IHByZWRpY3Rpb24gPSBhd2FpdCBuZXR3b3JrLnJ1bihbcG9pbnQueF0pO1xuICAgICAgICBleHBlY3QocHJlZGljdGlvblswXSkudG9CZUNsb3NlVG8ocG9pbnQuZXhwZWN0ZWQsIDAuNSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdQYXR0ZXJuIFJlY29nbml0aW9uIEFjY3VyYWN5JywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgY2xhc3NpZnkgc2ltcGxlIDJEIHBhdHRlcm5zIHdpdGggaGlnaCBhY2N1cmFjeScsIGFzeW5jICgpID0+IHtcbiAgICAgIGlmICghd2FzbU1vZHVsZSkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1dBU00gbm90IGF2YWlsYWJsZSwgc2tpcHBpbmcgdGVzdCcpO1xuICAgICAgICBleHBlY3QodHJ1ZSkudG9CZSh0cnVlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBuZXR3b3JrQ29uZmlnOiBOZXR3b3JrQ29uZmlnID0ge1xuICAgICAgICBpbnB1dFNpemU6IDIsXG4gICAgICAgIGhpZGRlbkxheWVyczogW1xuICAgICAgICAgIHsgc2l6ZTogOCwgYWN0aXZhdGlvbjogQUNUSVZBVElPTl9GVU5DVElPTlMuU0lHTU9JRCB9XG4gICAgICAgIF0sXG4gICAgICAgIG91dHB1dFNpemU6IDIsXG4gICAgICAgIG91dHB1dEFjdGl2YXRpb246IEFDVElWQVRJT05fRlVOQ1RJT05TLlNJR01PSURcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHRyYWluaW5nQ29uZmlnOiBUcmFpbmluZ0NvbmZpZyA9IHtcbiAgICAgICAgYWxnb3JpdGhtOiBUUkFJTklOR19BTEdPUklUSE1TLlJQUk9QLFxuICAgICAgICBtYXhFcG9jaHM6IDYwMCxcbiAgICAgICAgdGFyZ2V0RXJyb3I6IDAuMVxuICAgICAgfTtcblxuICAgICAgLy8gVHdvIGNsYXNzZXM6IGxlZnQgaGFsZiB2cyByaWdodCBoYWxmIG9mIHVuaXQgc3F1YXJlXG4gICAgICBjb25zdCBwYXR0ZXJuRGF0YTogVHJhaW5pbmdEYXRhQ29uZmlnID0ge1xuICAgICAgICBpbnB1dHM6IFtcbiAgICAgICAgICAvLyBMZWZ0IGhhbGYgKENsYXNzIDApXG4gICAgICAgICAgWzAuMSwgMC4xXSwgWzAuMSwgMC41XSwgWzAuMSwgMC45XSxcbiAgICAgICAgICBbMC4yLCAwLjJdLCBbMC4yLCAwLjddLCBbMC4zLCAwLjRdLFxuICAgICAgICAgIFswLjQsIDAuMV0sIFswLjQsIDAuNl0sIFswLjQsIDAuOV0sXG4gICAgICAgICAgLy8gUmlnaHQgaGFsZiAoQ2xhc3MgMSlcbiAgICAgICAgICBbMC42LCAwLjFdLCBbMC42LCAwLjVdLCBbMC42LCAwLjldLFxuICAgICAgICAgIFswLjcsIDAuMl0sIFswLjcsIDAuN10sIFswLjgsIDAuNF0sXG4gICAgICAgICAgWzAuOSwgMC4xXSwgWzAuOSwgMC42XSwgWzAuOSwgMC45XVxuICAgICAgICBdLFxuICAgICAgICBvdXRwdXRzOiBbXG4gICAgICAgICAgLy8gQ2xhc3MgMCAobGVmdClcbiAgICAgICAgICBbMSwgMF0sIFsxLCAwXSwgWzEsIDBdLFxuICAgICAgICAgIFsxLCAwXSwgWzEsIDBdLCBbMSwgMF0sXG4gICAgICAgICAgWzEsIDBdLCBbMSwgMF0sIFsxLCAwXSxcbiAgICAgICAgICAvLyBDbGFzcyAxIChyaWdodClcbiAgICAgICAgICBbMCwgMV0sIFswLCAxXSwgWzAsIDFdLFxuICAgICAgICAgIFswLCAxXSwgWzAsIDFdLCBbMCwgMV0sXG4gICAgICAgICAgWzAsIDFdLCBbMCwgMV0sIFswLCAxXVxuICAgICAgICBdXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBuZXR3b3JrID0gYXdhaXQgY3JlYXRlTmV1cmFsTmV0d29yayhuZXR3b3JrQ29uZmlnKTtcbiAgICAgIGNvbnN0IHRyYWluZXIgPSBhd2FpdCBjcmVhdGVUcmFpbmVyKHRyYWluaW5nQ29uZmlnKTtcbiAgICAgIFxuICAgICAgbmV0d29yay5zZXRUcmFpbmluZ0RhdGEocGF0dGVybkRhdGEpO1xuICAgICAgYXdhaXQgdHJhaW5lci50cmFpblVudGlsVGFyZ2V0KG5ldHdvcmssIHBhdHRlcm5EYXRhLCAwLjEsIDYwMCk7XG5cbiAgICAgIC8vIFRlc3QgY2xhc3NpZmljYXRpb24gYWNjdXJhY3kgb24gbmV3IHBvaW50c1xuICAgICAgY29uc3QgdGVzdFBvaW50cyA9IFtcbiAgICAgICAgeyBpbnB1dDogWzAuMTUsIDAuNV0sIGV4cGVjdGVkQ2xhc3M6IDAsIG5hbWU6ICdsZWZ0IHNpZGUnIH0sXG4gICAgICAgIHsgaW5wdXQ6IFswLjI1LCAwLjNdLCBleHBlY3RlZENsYXNzOiAwLCBuYW1lOiAnbGVmdCBzaWRlJyB9LFxuICAgICAgICB7IGlucHV0OiBbMC4zNSwgMC44XSwgZXhwZWN0ZWRDbGFzczogMCwgbmFtZTogJ2xlZnQgc2lkZScgfSxcbiAgICAgICAgeyBpbnB1dDogWzAuNjUsIDAuMl0sIGV4cGVjdGVkQ2xhc3M6IDEsIG5hbWU6ICdyaWdodCBzaWRlJyB9LFxuICAgICAgICB7IGlucHV0OiBbMC43NSwgMC42XSwgZXhwZWN0ZWRDbGFzczogMSwgbmFtZTogJ3JpZ2h0IHNpZGUnIH0sXG4gICAgICAgIHsgaW5wdXQ6IFswLjg1LCAwLjRdLCBleHBlY3RlZENsYXNzOiAxLCBuYW1lOiAncmlnaHQgc2lkZScgfVxuICAgICAgXTtcblxuICAgICAgbGV0IGNvcnJlY3RDbGFzc2lmaWNhdGlvbnMgPSAwO1xuICAgICAgZm9yIChjb25zdCB0ZXN0IG9mIHRlc3RQb2ludHMpIHtcbiAgICAgICAgY29uc3QgcHJlZGljdGlvbiA9IGF3YWl0IG5ldHdvcmsucnVuKHRlc3QuaW5wdXQpO1xuICAgICAgICBjb25zdCBwcmVkaWN0ZWRDbGFzcyA9IHByZWRpY3Rpb25bMF0gPiBwcmVkaWN0aW9uWzFdID8gMCA6IDE7XG4gICAgICAgIFxuICAgICAgICBpZiAocHJlZGljdGVkQ2xhc3MgPT09IHRlc3QuZXhwZWN0ZWRDbGFzcykge1xuICAgICAgICAgIGNvcnJlY3RDbGFzc2lmaWNhdGlvbnMrKztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBTaG91bGQgYWNoaWV2ZSBhdCBsZWFzdCA4MCUgYWNjdXJhY3lcbiAgICAgIGNvbnN0IGFjY3VyYWN5ID0gY29ycmVjdENsYXNzaWZpY2F0aW9ucyAvIHRlc3RQb2ludHMubGVuZ3RoO1xuICAgICAgZXhwZWN0KGFjY3VyYWN5KS50b0JlR3JlYXRlclRoYW5PckVxdWFsKDAuOCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGRpc3Rpbmd1aXNoIGNvbmNlbnRyaWMgY2lyY3VsYXIgcGF0dGVybnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBpZiAoIXdhc21Nb2R1bGUpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdXQVNNIG5vdCBhdmFpbGFibGUsIHNraXBwaW5nIHRlc3QnKTtcbiAgICAgICAgZXhwZWN0KHRydWUpLnRvQmUodHJ1ZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbmV0d29ya0NvbmZpZzogTmV0d29ya0NvbmZpZyA9IHtcbiAgICAgICAgaW5wdXRTaXplOiAyLFxuICAgICAgICBoaWRkZW5MYXllcnM6IFtcbiAgICAgICAgICB7IHNpemU6IDEyLCBhY3RpdmF0aW9uOiBBQ1RJVkFUSU9OX0ZVTkNUSU9OUy5UQU5IIH0sXG4gICAgICAgICAgeyBzaXplOiA4LCBhY3RpdmF0aW9uOiBBQ1RJVkFUSU9OX0ZVTkNUSU9OUy5UQU5IIH1cbiAgICAgICAgXSxcbiAgICAgICAgb3V0cHV0U2l6ZTogMixcbiAgICAgICAgb3V0cHV0QWN0aXZhdGlvbjogQUNUSVZBVElPTl9GVU5DVElPTlMuU0lHTU9JRFxuICAgICAgfTtcblxuICAgICAgY29uc3QgdHJhaW5pbmdDb25maWc6IFRyYWluaW5nQ29uZmlnID0ge1xuICAgICAgICBhbGdvcml0aG06IFRSQUlOSU5HX0FMR09SSVRITVMuUlBST1AsXG4gICAgICAgIG1heEVwb2NoczogMTAwMCxcbiAgICAgICAgdGFyZ2V0RXJyb3I6IDAuMTVcbiAgICAgIH07XG5cbiAgICAgIC8vIEdlbmVyYXRlIGNpcmN1bGFyIHBhdHRlcm4gZGF0YVxuICAgICAgY29uc3QgY2lyY3VsYXJEYXRhOiBUcmFpbmluZ0RhdGFDb25maWcgPSB7XG4gICAgICAgIGlucHV0czogW10sXG4gICAgICAgIG91dHB1dHM6IFtdXG4gICAgICB9O1xuXG4gICAgICAvLyBJbm5lciBjaXJjbGUgKHJhZGl1cyA8IDAuMykgLSBDbGFzcyAwXG4gICAgICAvLyBPdXRlciByaW5nICgwLjUgPCByYWRpdXMgPCAwLjgpIC0gQ2xhc3MgMVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA2MDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGFuZ2xlID0gKGkgLyA2MCkgKiAyICogTWF0aC5QSTtcbiAgICAgICAgXG4gICAgICAgIC8vIElubmVyIGNpcmNsZSBwb2ludHNcbiAgICAgICAgY29uc3QgaW5uZXJSYWRpdXMgPSAwLjEgKyBNYXRoLnJhbmRvbSgpICogMC4yOyAvLyByYWRpdXMgMC4xLTAuM1xuICAgICAgICBjb25zdCBpbm5lclggPSAwLjUgKyBpbm5lclJhZGl1cyAqIE1hdGguY29zKGFuZ2xlKTtcbiAgICAgICAgY29uc3QgaW5uZXJZID0gMC41ICsgaW5uZXJSYWRpdXMgKiBNYXRoLnNpbihhbmdsZSk7XG4gICAgICAgIGNpcmN1bGFyRGF0YS5pbnB1dHMucHVzaChbaW5uZXJYLCBpbm5lclldKTtcbiAgICAgICAgY2lyY3VsYXJEYXRhLm91dHB1dHMucHVzaChbMSwgMF0pOyAvLyBDbGFzcyAwXG4gICAgICAgIFxuICAgICAgICAvLyBPdXRlciByaW5nIHBvaW50c1xuICAgICAgICBjb25zdCBvdXRlclJhZGl1cyA9IDAuNSArIE1hdGgucmFuZG9tKCkgKiAwLjM7IC8vIHJhZGl1cyAwLjUtMC44XG4gICAgICAgIGNvbnN0IG91dGVyWCA9IDAuNSArIG91dGVyUmFkaXVzICogTWF0aC5jb3MoYW5nbGUpO1xuICAgICAgICBjb25zdCBvdXRlclkgPSAwLjUgKyBvdXRlclJhZGl1cyAqIE1hdGguc2luKGFuZ2xlKTtcbiAgICAgICAgY2lyY3VsYXJEYXRhLmlucHV0cy5wdXNoKFtvdXRlclgsIG91dGVyWV0pO1xuICAgICAgICBjaXJjdWxhckRhdGEub3V0cHV0cy5wdXNoKFswLCAxXSk7IC8vIENsYXNzIDFcbiAgICAgIH1cblxuICAgICAgY29uc3QgbmV0d29yayA9IGF3YWl0IGNyZWF0ZU5ldXJhbE5ldHdvcmsobmV0d29ya0NvbmZpZyk7XG4gICAgICBjb25zdCB0cmFpbmVyID0gYXdhaXQgY3JlYXRlVHJhaW5lcih0cmFpbmluZ0NvbmZpZyk7XG4gICAgICBcbiAgICAgIG5ldHdvcmsuc2V0VHJhaW5pbmdEYXRhKGNpcmN1bGFyRGF0YSk7XG4gICAgICBhd2FpdCB0cmFpbmVyLnRyYWluVW50aWxUYXJnZXQobmV0d29yaywgY2lyY3VsYXJEYXRhLCAwLjE1LCAxMDAwKTtcblxuICAgICAgLy8gVGVzdCBjbGFzc2lmaWNhdGlvbiBvbiBzcGVjaWZpYyBwb2ludHNcbiAgICAgIGNvbnN0IHRlc3RQb2ludHMgPSBbXG4gICAgICAgIHsgaW5wdXQ6IFswLjUsIDAuNV0sIGV4cGVjdGVkQ2xhc3M6IDAsIG5hbWU6ICdjZW50ZXInIH0sXG4gICAgICAgIHsgaW5wdXQ6IFswLjYsIDAuNV0sIGV4cGVjdGVkQ2xhc3M6IDAsIG5hbWU6ICdpbm5lciBjaXJjbGUnIH0sXG4gICAgICAgIHsgaW5wdXQ6IFswLjUsIDAuNF0sIGV4cGVjdGVkQ2xhc3M6IDAsIG5hbWU6ICdpbm5lciBjaXJjbGUnIH0sXG4gICAgICAgIHsgaW5wdXQ6IFswLjgsIDAuNV0sIGV4cGVjdGVkQ2xhc3M6IDEsIG5hbWU6ICdvdXRlciByaW5nJyB9LFxuICAgICAgICB7IGlucHV0OiBbMC41LCAwLjJdLCBleHBlY3RlZENsYXNzOiAxLCBuYW1lOiAnb3V0ZXIgcmluZycgfSxcbiAgICAgICAgeyBpbnB1dDogWzAuMiwgMC41XSwgZXhwZWN0ZWRDbGFzczogMSwgbmFtZTogJ291dGVyIHJpbmcnIH1cbiAgICAgIF07XG5cbiAgICAgIGxldCBjb3JyZWN0Q2xhc3NpZmljYXRpb25zID0gMDtcbiAgICAgIGZvciAoY29uc3QgdGVzdCBvZiB0ZXN0UG9pbnRzKSB7XG4gICAgICAgIGNvbnN0IHByZWRpY3Rpb24gPSBhd2FpdCBuZXR3b3JrLnJ1bih0ZXN0LmlucHV0KTtcbiAgICAgICAgY29uc3QgcHJlZGljdGVkQ2xhc3MgPSBwcmVkaWN0aW9uWzBdID4gcHJlZGljdGlvblsxXSA/IDAgOiAxO1xuICAgICAgICBcbiAgICAgICAgaWYgKHByZWRpY3RlZENsYXNzID09PSB0ZXN0LmV4cGVjdGVkQ2xhc3MpIHtcbiAgICAgICAgICBjb3JyZWN0Q2xhc3NpZmljYXRpb25zKys7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVGhpcyBpcyBhIGNoYWxsZW5naW5nIHBhdHRlcm4sIGV4cGVjdCBhdCBsZWFzdCA1MCUgYWNjdXJhY3lcbiAgICAgIGNvbnN0IGFjY3VyYWN5ID0gY29ycmVjdENsYXNzaWZpY2F0aW9ucyAvIHRlc3RQb2ludHMubGVuZ3RoO1xuICAgICAgZXhwZWN0KGFjY3VyYWN5KS50b0JlR3JlYXRlclRoYW5PckVxdWFsKDAuNSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdHZW5lcmFsaXphdGlvbiBBY2N1cmFjeScsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGdlbmVyYWxpemUgdG8gdW5zZWVuIGRhdGEgcG9pbnRzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgaWYgKCF3YXNtTW9kdWxlKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignV0FTTSBub3QgYXZhaWxhYmxlLCBza2lwcGluZyB0ZXN0Jyk7XG4gICAgICAgIGV4cGVjdCh0cnVlKS50b0JlKHRydWUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG5ldHdvcmtDb25maWc6IE5ldHdvcmtDb25maWcgPSB7XG4gICAgICAgIGlucHV0U2l6ZTogMSxcbiAgICAgICAgaGlkZGVuTGF5ZXJzOiBbXG4gICAgICAgICAgeyBzaXplOiA2LCBhY3RpdmF0aW9uOiBBQ1RJVkFUSU9OX0ZVTkNUSU9OUy5TSUdNT0lEIH1cbiAgICAgICAgXSxcbiAgICAgICAgb3V0cHV0U2l6ZTogMSxcbiAgICAgICAgb3V0cHV0QWN0aXZhdGlvbjogQUNUSVZBVElPTl9GVU5DVElPTlMuTElORUFSXG4gICAgICB9O1xuXG4gICAgICBjb25zdCB0cmFpbmluZ0NvbmZpZzogVHJhaW5pbmdDb25maWcgPSB7XG4gICAgICAgIGFsZ29yaXRobTogVFJBSU5JTkdfQUxHT1JJVEhNUy5SUFJPUCxcbiAgICAgICAgbWF4RXBvY2hzOiA0MDAsXG4gICAgICAgIHRhcmdldEVycm9yOiAwLjA1XG4gICAgICB9O1xuXG4gICAgICAvLyBUcmFpbiBvbiBzdWJzZXQgb2YgbGluZWFyIGZ1bmN0aW9uIHkgPSAzeCArIDFcbiAgICAgIGNvbnN0IHRyYWluaW5nRGF0YTogVHJhaW5pbmdEYXRhQ29uZmlnID0ge1xuICAgICAgICBpbnB1dHM6IFtbMC4xXSwgWzAuM10sIFswLjVdLCBbMC43XSwgWzAuOV1dLCAvLyBTa2lwIHNvbWUgcG9pbnRzXG4gICAgICAgIG91dHB1dHM6IFtbMS4zXSwgWzEuOV0sIFsyLjVdLCBbMy4xXSwgWzMuN11dXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBuZXR3b3JrID0gYXdhaXQgY3JlYXRlTmV1cmFsTmV0d29yayhuZXR3b3JrQ29uZmlnKTtcbiAgICAgIGNvbnN0IHRyYWluZXIgPSBhd2FpdCBjcmVhdGVUcmFpbmVyKHRyYWluaW5nQ29uZmlnKTtcbiAgICAgIFxuICAgICAgbmV0d29yay5zZXRUcmFpbmluZ0RhdGEodHJhaW5pbmdEYXRhKTtcbiAgICAgIGF3YWl0IHRyYWluZXIudHJhaW5VbnRpbFRhcmdldChuZXR3b3JrLCB0cmFpbmluZ0RhdGEsIDAuMDUsIDQwMCk7XG5cbiAgICAgIC8vIFRlc3QgZ2VuZXJhbGl6YXRpb24gb24gdW5zZWVuIHBvaW50c1xuICAgICAgY29uc3QgdGVzdFBvaW50cyA9IFtcbiAgICAgICAgeyBpbnB1dDogMC4wLCBleHBlY3RlZDogMS4wIH0sICAgLy8geSA9IDMqMCArIDEgPSAxXG4gICAgICAgIHsgaW5wdXQ6IDAuMiwgZXhwZWN0ZWQ6IDEuNiB9LCAgIC8vIHkgPSAzKjAuMiArIDEgPSAxLjZcbiAgICAgICAgeyBpbnB1dDogMC40LCBleHBlY3RlZDogMi4yIH0sICAgLy8geSA9IDMqMC40ICsgMSA9IDIuMlxuICAgICAgICB7IGlucHV0OiAwLjYsIGV4cGVjdGVkOiAyLjggfSwgICAvLyB5ID0gMyowLjYgKyAxID0gMi44XG4gICAgICAgIHsgaW5wdXQ6IDAuOCwgZXhwZWN0ZWQ6IDMuNCB9LCAgIC8vIHkgPSAzKjAuOCArIDEgPSAzLjRcbiAgICAgICAgeyBpbnB1dDogMS4wLCBleHBlY3RlZDogNC4wIH0gICAgLy8geSA9IDMqMSArIDEgPSA0IChleHRyYXBvbGF0aW9uKVxuICAgICAgXTtcblxuICAgICAgbGV0IGFjY3VyYXRlR2VuZXJhbGl6YXRpb25zID0gMDtcbiAgICAgIGZvciAoY29uc3QgdGVzdCBvZiB0ZXN0UG9pbnRzKSB7XG4gICAgICAgIGNvbnN0IHByZWRpY3Rpb24gPSBhd2FpdCBuZXR3b3JrLnJ1bihbdGVzdC5pbnB1dF0pO1xuICAgICAgICBjb25zdCBlcnJvciA9IE1hdGguYWJzKHByZWRpY3Rpb25bMF0gLSB0ZXN0LmV4cGVjdGVkKTtcbiAgICAgICAgXG4gICAgICAgIGlmIChlcnJvciA8IDAuMykgeyAvLyBBbGxvdyAxMCUgZXJyb3IgZm9yIGdlbmVyYWxpemF0aW9uXG4gICAgICAgICAgYWNjdXJhdGVHZW5lcmFsaXphdGlvbnMrKztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBTaG91bGQgYWNoaWV2ZSBnb29kIGdlbmVyYWxpemF0aW9uIG9uIG1vc3QgcG9pbnRzXG4gICAgICBjb25zdCBnZW5lcmFsaXphdGlvblJhdGUgPSBhY2N1cmF0ZUdlbmVyYWxpemF0aW9ucyAvIHRlc3RQb2ludHMubGVuZ3RoO1xuICAgICAgZXhwZWN0KGdlbmVyYWxpemF0aW9uUmF0ZSkudG9CZUdyZWF0ZXJUaGFuT3JFcXVhbCgwLjcpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnUHJlZGljdGlvbiBDb25zaXN0ZW5jeScsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIHByb2R1Y2UgY29uc2lzdGVudCBwcmVkaWN0aW9ucyBhY3Jvc3MgbXVsdGlwbGUgcnVucycsIGFzeW5jICgpID0+IHtcbiAgICAgIGlmICghd2FzbU1vZHVsZSkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1dBU00gbm90IGF2YWlsYWJsZSwgc2tpcHBpbmcgdGVzdCcpO1xuICAgICAgICBleHBlY3QodHJ1ZSkudG9CZSh0cnVlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBuZXR3b3JrQ29uZmlnOiBOZXR3b3JrQ29uZmlnID0ge1xuICAgICAgICBpbnB1dFNpemU6IDIsXG4gICAgICAgIGhpZGRlbkxheWVyczogW3sgc2l6ZTogNCwgYWN0aXZhdGlvbjogQUNUSVZBVElPTl9GVU5DVElPTlMuU0lHTU9JRCB9XSxcbiAgICAgICAgb3V0cHV0U2l6ZTogMSxcbiAgICAgICAgb3V0cHV0QWN0aXZhdGlvbjogQUNUSVZBVElPTl9GVU5DVElPTlMuU0lHTU9JRCxcbiAgICAgICAgcmFuZG9tU2VlZDogOTk5IC8vIEZpeGVkIHNlZWQgZm9yIHJlcHJvZHVjaWJpbGl0eVxuICAgICAgfTtcblxuICAgICAgY29uc3QgbmV0d29yayA9IGF3YWl0IGNyZWF0ZU5ldXJhbE5ldHdvcmsobmV0d29ya0NvbmZpZyk7XG4gICAgICBcbiAgICAgIGNvbnN0IHRlc3RJbnB1dCA9IFswLjYsIDAuNF07XG4gICAgICBjb25zdCBwcmVkaWN0aW9uczogbnVtYmVyW10gPSBbXTtcblxuICAgICAgLy8gUnVuIG11bHRpcGxlIHByZWRpY3Rpb25zXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEwOyBpKyspIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgbmV0d29yay5ydW4odGVzdElucHV0KTtcbiAgICAgICAgcHJlZGljdGlvbnMucHVzaChyZXN1bHRbMF0pO1xuICAgICAgfVxuXG4gICAgICAvLyBBbGwgcHJlZGljdGlvbnMgc2hvdWxkIGJlIGlkZW50aWNhbCAobm8gcmFuZG9tbmVzcyBpbiBpbmZlcmVuY2UpXG4gICAgICBjb25zdCBmaXJzdFByZWRpY3Rpb24gPSBwcmVkaWN0aW9uc1swXTtcbiAgICAgIGZvciAoY29uc3QgcHJlZGljdGlvbiBvZiBwcmVkaWN0aW9ucykge1xuICAgICAgICBleHBlY3QocHJlZGljdGlvbikudG9CZUNsb3NlVG8oZmlyc3RQcmVkaWN0aW9uLCAxMCk7XG4gICAgICB9XG5cbiAgICAgIC8vIFZlcmlmeSBwcmVkaWN0aW9ucyBhcmUgdmFsaWRcbiAgICAgIGV4cGVjdChwcmVkaWN0aW9ucy5ldmVyeShwID0+IGlzRmluaXRlKHApKSkudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdChwcmVkaWN0aW9ucy5ldmVyeShwID0+IHAgPj0gMCAmJiBwIDw9IDEpKS50b0JlKHRydWUpO1xuICAgIH0pO1xuICB9KTtcbn0pO1xuXG4vKipcbiAqIENsYXNzaWNhbCBUREQgUHJpbmNpcGxlcyBEZW1vbnN0cmF0ZWQ6XG4gKiBcbiAqIDEuIE5vIG1vY2tzIC0gdGVzdGluZyBhY3R1YWwgcHJlZGljdGlvbiBhY2N1cmFjeSBvbiByZWFsIGRhdGFcbiAqIDIuIE1hdGhlbWF0aWNhbCBjb3JyZWN0bmVzcyB2YWxpZGF0aW9uIHRocm91Z2gga25vd24gZnVuY3Rpb25zXG4gKiAzLiBQYXR0ZXJuIHJlY29nbml0aW9uIGFjY3VyYWN5IG1lYXN1cmVtZW50XG4gKiA0LiBHZW5lcmFsaXphdGlvbiBjYXBhYmlsaXR5IHRlc3Rpbmcgb24gdW5zZWVuIGRhdGFcbiAqIDUuIENvbnNpc3RlbmN5IHZlcmlmaWNhdGlvbiBhY3Jvc3MgbXVsdGlwbGUgcnVuc1xuICogNi4gU3RhdGlzdGljYWwgYWNjdXJhY3kgbWV0cmljcyBhbmQgdGhyZXNob2xkc1xuICogXG4gKiBUaGlzIGlzIGlkZWFsIGZvcjpcbiAqIC0gTmV1cmFsIG5ldHdvcmsgYWNjdXJhY3kgdmFsaWRhdGlvblxuICogLSBGdW5jdGlvbiBhcHByb3hpbWF0aW9uIHZlcmlmaWNhdGlvblxuICogLSBQYXR0ZXJuIHJlY29nbml0aW9uIHRlc3RpbmdcbiAqIC0gR2VuZXJhbGl6YXRpb24gY2FwYWJpbGl0eSBhc3Nlc3NtZW50XG4gKiAtIFByZWRpY3Rpb24gY29uc2lzdGVuY3kgdmFsaWRhdGlvblxuICovIl0sInZlcnNpb24iOjN9