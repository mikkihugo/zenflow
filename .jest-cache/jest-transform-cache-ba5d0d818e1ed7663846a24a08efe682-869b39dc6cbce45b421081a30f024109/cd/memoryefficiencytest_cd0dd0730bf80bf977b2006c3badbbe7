497029a887466805bec4a7ac50f5028c
/**
 * Classical TDD (Detroit School) - Memory Efficiency Tests
 *
 * Focus: Test actual memory usage and allocation patterns
 * No mocks - verify real memory consumption and efficiency metrics
 */
import { describe, it, expect, beforeEach, afterEach } from '@jest/globals';
import { initializeNeuralWasm, createNeuralNetwork, createTrainer, ACTIVATION_FUNCTIONS, TRAINING_ALGORITHMS } from '../../../../../ruv-FANN/ruv-swarm/npm/src/neural-network';
describe('Memory Efficiency - Classical TDD', () => {
    let wasmModule;
    let initialMemory;
    beforeEach(async () => {
        try {
            wasmModule = await initializeNeuralWasm();
            // Force garbage collection if available
            if (global.gc) {
                global.gc();
            }
            initialMemory = process.memoryUsage();
        }
        catch (error) {
            console.warn('WASM module not available, skipping memory efficiency tests');
        }
    });
    afterEach(() => {
        // Force garbage collection after each test
        if (global.gc) {
            global.gc();
        }
    });
    describe('Network Creation Memory Usage', () => {
        it('should create small networks with minimal memory overhead', async () => {
            if (!wasmModule) {
                console.warn('WASM not available, skipping test');
                expect(true).toBe(true);
                return;
            }
            const preCreationMemory = process.memoryUsage().heapUsed;
            // Create small network
            const networkConfig = {
                inputSize: 2,
                hiddenLayers: [{ size: 3, activation: ACTIVATION_FUNCTIONS.SIGMOID }],
                outputSize: 1,
                outputActivation: ACTIVATION_FUNCTIONS.SIGMOID
            };
            const network = await createNeuralNetwork(networkConfig);
            const info = network.getInfo();
            const postCreationMemory = process.memoryUsage().heapUsed;
            const memoryIncrease = postCreationMemory - preCreationMemory;
            // Small network should use less than 1MB
            expect(memoryIncrease).toBeLessThan(1024 * 1024);
            // Verify network was actually created
            expect(info.numInputs).toBe(2);
            expect(info.numOutputs).toBe(1);
            expect(info.totalNeurons).toBeGreaterThan(0);
        });
        it('should scale memory usage predictably with network size', async () => {
            if (!wasmModule) {
                console.warn('WASM not available, skipping test');
                expect(true).toBe(true);
                return;
            }
            const networkSizes = [
                { inputs: 2, hidden: 4, outputs: 1 },
                { inputs: 4, hidden: 8, outputs: 2 },
                { inputs: 8, hidden: 16, outputs: 4 }
            ];
            const memoryUsages = [];
            for (const size of networkSizes) {
                const preMemory = process.memoryUsage().heapUsed;
                const networkConfig = {
                    inputSize: size.inputs,
                    hiddenLayers: [{ size: size.hidden, activation: ACTIVATION_FUNCTIONS.SIGMOID }],
                    outputSize: size.outputs,
                    outputActivation: ACTIVATION_FUNCTIONS.SIGMOID
                };
                const network = await createNeuralNetwork(networkConfig);
                const info = network.getInfo();
                const postMemory = process.memoryUsage().heapUsed;
                const memoryIncrease = postMemory - preMemory;
                memoryUsages.push(memoryIncrease);
                // Verify network metrics are reported
                expect(info.metrics.memoryUsage).toBeGreaterThan(0);
                expect(info.totalConnections).toBeGreaterThan(0);
            }
            // Memory usage should increase with network size
            expect(memoryUsages[1]).toBeGreaterThan(memoryUsages[0]);
            expect(memoryUsages[2]).toBeGreaterThan(memoryUsages[1]);
            // But increase should be reasonable (not exponential)
            const ratio1 = memoryUsages[1] / memoryUsages[0];
            const ratio2 = memoryUsages[2] / memoryUsages[1];
            expect(ratio1).toBeLessThan(10); // Should not be more than 10x increase
            expect(ratio2).toBeLessThan(10);
        });
        it('should handle multiple layers efficiently', async () => {
            if (!wasmModule) {
                console.warn('WASM not available, skipping test');
                expect(true).toBe(true);
                return;
            }
            const layerConfigurations = [
                { layers: [{ size: 4, activation: ACTIVATION_FUNCTIONS.SIGMOID }] },
                { layers: [
                        { size: 4, activation: ACTIVATION_FUNCTIONS.SIGMOID },
                        { size: 4, activation: ACTIVATION_FUNCTIONS.SIGMOID }
                    ] },
                { layers: [
                        { size: 4, activation: ACTIVATION_FUNCTIONS.SIGMOID },
                        { size: 4, activation: ACTIVATION_FUNCTIONS.SIGMOID },
                        { size: 4, activation: ACTIVATION_FUNCTIONS.SIGMOID }
                    ] }
            ];
            const memoryUsages = [];
            for (const config of layerConfigurations) {
                const preMemory = process.memoryUsage().heapUsed;
                const networkConfig = {
                    inputSize: 3,
                    hiddenLayers: config.layers,
                    outputSize: 2,
                    outputActivation: ACTIVATION_FUNCTIONS.SIGMOID
                };
                const network = await createNeuralNetwork(networkConfig);
                const postMemory = process.memoryUsage().heapUsed;
                memoryUsages.push(postMemory - preMemory);
                // Verify network was created correctly
                const info = network.getInfo();
                expect(info.numLayers).toBe(config.layers.length + 2); // +input +output
            }
            // Each additional layer should add reasonable memory overhead
            for (let i = 1; i < memoryUsages.length; i++) {
                expect(memoryUsages[i]).toBeGreaterThan(memoryUsages[i - 1]);
                // But not more than 2x the previous
                expect(memoryUsages[i]).toBeLessThan(memoryUsages[i - 1] * 2.5);
            }
        });
    });
    describe('Training Memory Efficiency', () => {
        it('should maintain stable memory during training', async () => {
            if (!wasmModule) {
                console.warn('WASM not available, skipping test');
                expect(true).toBe(true);
                return;
            }
            const networkConfig = {
                inputSize: 2,
                hiddenLayers: [{ size: 4, activation: ACTIVATION_FUNCTIONS.SIGMOID }],
                outputSize: 1,
                outputActivation: ACTIVATION_FUNCTIONS.SIGMOID
            };
            const trainingConfig = {
                algorithm: TRAINING_ALGORITHMS.INCREMENTAL_BACKPROP,
                learningRate: 0.5,
                maxEpochs: 100,
                targetError: 0.1
            };
            const xorData = {
                inputs: [[0, 0], [0, 1], [1, 0], [1, 1]],
                outputs: [[0], [1], [1], [0]]
            };
            const network = await createNeuralNetwork(networkConfig);
            const trainer = await createTrainer(trainingConfig);
            network.setTrainingData(xorData);
            const preTrainingMemory = process.memoryUsage().heapUsed;
            // Train for multiple epochs and monitor memory
            const memorySnapshots = [];
            for (let epoch = 0; epoch < 50; epoch++) {
                await trainer.trainEpoch(network, xorData);
                if (epoch % 10 === 0) {
                    memorySnapshots.push(process.memoryUsage().heapUsed);
                }
            }
            const postTrainingMemory = process.memoryUsage().heapUsed;
            const totalMemoryIncrease = postTrainingMemory - preTrainingMemory;
            // Memory should not grow significantly during training
            expect(totalMemoryIncrease).toBeLessThan(5 * 1024 * 1024); // Less than 5MB
            // Memory usage should be relatively stable across epochs
            const maxSnapshot = Math.max(...memorySnapshots);
            const minSnapshot = Math.min(...memorySnapshots);
            const memoryVariation = maxSnapshot - minSnapshot;
            expect(memoryVariation).toBeLessThan(2 * 1024 * 1024); // Less than 2MB variation
        });
        it('should handle large training datasets efficiently', async () => {
            if (!wasmModule) {
                console.warn('WASM not available, skipping test');
                expect(true).toBe(true);
                return;
            }
            const networkConfig = {
                inputSize: 3,
                hiddenLayers: [{ size: 6, activation: ACTIVATION_FUNCTIONS.SIGMOID }],
                outputSize: 2,
                outputActivation: ACTIVATION_FUNCTIONS.SIGMOID
            };
            // Generate large dataset
            const largeDataset = {
                inputs: [],
                outputs: []
            };
            for (let i = 0; i < 1000; i++) {
                largeDataset.inputs.push([
                    Math.random(),
                    Math.random(),
                    Math.random()
                ]);
                largeDataset.outputs.push([
                    Math.random() > 0.5 ? 1 : 0,
                    Math.random() > 0.5 ? 1 : 0
                ]);
            }
            const preMemory = process.memoryUsage().heapUsed;
            const network = await createNeuralNetwork(networkConfig);
            network.setTrainingData(largeDataset);
            const trainingConfig = {
                algorithm: TRAINING_ALGORITHMS.BATCH_BACKPROP,
                learningRate: 0.1,
                maxEpochs: 10,
                targetError: 0.3
            };
            const trainer = await createTrainer(trainingConfig);
            // Train on large dataset
            for (let epoch = 0; epoch < 5; epoch++) {
                await trainer.trainEpoch(network, largeDataset);
            }
            const postMemory = process.memoryUsage().heapUsed;
            const memoryIncrease = postMemory - preMemory;
            // Memory increase should be reasonable for 1000 training samples
            expect(memoryIncrease).toBeLessThan(50 * 1024 * 1024); // Less than 50MB
        });
    });
    describe('Memory Leak Detection', () => {
        it('should not leak memory when creating and destroying networks', async () => {
            if (!wasmModule) {
                console.warn('WASM not available, skipping test');
                expect(true).toBe(true);
                return;
            }
            const preTestMemory = process.memoryUsage().heapUsed;
            // Create and destroy multiple networks
            for (let i = 0; i < 20; i++) {
                const networkConfig = {
                    inputSize: 3,
                    hiddenLayers: [{ size: 5, activation: ACTIVATION_FUNCTIONS.SIGMOID }],
                    outputSize: 2,
                    outputActivation: ACTIVATION_FUNCTIONS.SIGMOID
                };
                const network = await createNeuralNetwork(networkConfig);
                // Use the network briefly
                await network.run([0.5, 0.5, 0.5]);
                // Network should be eligible for garbage collection after this scope
            }
            // Force garbage collection
            if (global.gc) {
                global.gc();
                // Wait a bit for cleanup
                await new Promise(resolve => setTimeout(resolve, 100));
            }
            const postTestMemory = process.memoryUsage().heapUsed;
            const memoryIncrease = postTestMemory - preTestMemory;
            // Memory increase should be minimal after cleanup
            expect(memoryIncrease).toBeLessThan(10 * 1024 * 1024); // Less than 10MB residual
        });
        it('should properly clean up training resources', async () => {
            if (!wasmModule) {
                console.warn('WASM not available, skipping test');
                expect(true).toBe(true);
                return;
            }
            const preTestMemory = process.memoryUsage().heapUsed;
            // Create multiple trainers and train briefly
            for (let i = 0; i < 10; i++) {
                const networkConfig = {
                    inputSize: 2,
                    hiddenLayers: [{ size: 4, activation: ACTIVATION_FUNCTIONS.SIGMOID }],
                    outputSize: 1,
                    outputActivation: ACTIVATION_FUNCTIONS.SIGMOID
                };
                const trainingConfig = {
                    algorithm: TRAINING_ALGORITHMS.INCREMENTAL_BACKPROP,
                    learningRate: 0.5,
                    maxEpochs: 10,
                    targetError: 0.5
                };
                const smallData = {
                    inputs: [[0, 1], [1, 0]],
                    outputs: [[1], [1]]
                };
                const network = await createNeuralNetwork(networkConfig);
                const trainer = await createTrainer(trainingConfig);
                network.setTrainingData(smallData);
                await trainer.trainEpoch(network, smallData);
                // Resources should be cleaned up after this scope
            }
            // Force garbage collection
            if (global.gc) {
                global.gc();
                await new Promise(resolve => setTimeout(resolve, 100));
            }
            const postTestMemory = process.memoryUsage().heapUsed;
            const memoryIncrease = postTestMemory - preTestMemory;
            // Should not accumulate significant memory
            expect(memoryIncrease).toBeLessThan(15 * 1024 * 1024); // Less than 15MB
        });
    });
    describe('Weight Storage Efficiency', () => {
        it('should store weights compactly', async () => {
            if (!wasmModule) {
                console.warn('WASM not available, skipping test');
                expect(true).toBe(true);
                return;
            }
            const networkConfig = {
                inputSize: 10,
                hiddenLayers: [
                    { size: 20, activation: ACTIVATION_FUNCTIONS.SIGMOID },
                    { size: 15, activation: ACTIVATION_FUNCTIONS.SIGMOID }
                ],
                outputSize: 5,
                outputActivation: ACTIVATION_FUNCTIONS.SIGMOID
            };
            const network = await createNeuralNetwork(networkConfig);
            const weights = network.getWeights();
            const info = network.getInfo();
            // Verify weight array size matches expected connections
            const expectedConnections = (10 * 20) + (20 * 15) + (15 * 5); // Input->H1 + H1->H2 + H2->Output
            const expectedWithBiases = expectedConnections + 20 + 15 + 5; // Plus biases
            // Weights should be reasonably close to expected size
            expect(weights.length).toBeGreaterThan(expectedConnections);
            expect(weights.length).toBeLessThan(expectedWithBiases * 2); // Not more than 2x expected
            // All weights should be finite numbers
            for (let i = 0; i < weights.length; i++) {
                expect(isFinite(weights[i])).toBe(true);
            }
            // Memory usage metric should reflect actual storage
            expect(info.metrics.memoryUsage).toBeGreaterThan(weights.length * 4); // At least 4 bytes per float
        });
        it('should handle weight updates efficiently', async () => {
            if (!wasmModule) {
                console.warn('WASM not available, skipping test');
                expect(true).toBe(true);
                return;
            }
            const networkConfig = {
                inputSize: 5,
                hiddenLayers: [{ size: 8, activation: ACTIVATION_FUNCTIONS.SIGMOID }],
                outputSize: 3,
                outputActivation: ACTIVATION_FUNCTIONS.SIGMOID
            };
            const network = await createNeuralNetwork(networkConfig);
            const preUpdateMemory = process.memoryUsage().heapUsed;
            // Perform multiple weight updates
            for (let i = 0; i < 100; i++) {
                const weights = network.getWeights();
                // Modify weights
                for (let j = 0; j < weights.length; j++) {
                    weights[j] += (Math.random() - 0.5) * 0.01;
                }
                network.setWeights(weights);
            }
            const postUpdateMemory = process.memoryUsage().heapUsed;
            const memoryIncrease = postUpdateMemory - preUpdateMemory;
            // Weight updates should not cause significant memory growth
            expect(memoryIncrease).toBeLessThan(5 * 1024 * 1024); // Less than 5MB
            // Network should still function
            const result = await network.run([0.1, 0.2, 0.3, 0.4, 0.5]);
            expect(result).toHaveLength(3);
            expect(result.every(v => isFinite(v))).toBe(true);
        });
    });
    describe('Concurrent Network Memory Usage', () => {
        it('should handle multiple networks efficiently', async () => {
            if (!wasmModule) {
                console.warn('WASM not available, skipping test');
                expect(true).toBe(true);
                return;
            }
            const preCreationMemory = process.memoryUsage().heapUsed;
            // Create multiple networks concurrently
            const networks = [];
            const networkPromises = [];
            for (let i = 0; i < 15; i++) {
                const networkConfig = {
                    inputSize: 3,
                    hiddenLayers: [{ size: 6, activation: ACTIVATION_FUNCTIONS.SIGMOID }],
                    outputSize: 2,
                    outputActivation: ACTIVATION_FUNCTIONS.SIGMOID
                };
                networkPromises.push(createNeuralNetwork(networkConfig));
            }
            const createdNetworks = await Promise.all(networkPromises);
            networks.push(...createdNetworks);
            const postCreationMemory = process.memoryUsage().heapUsed;
            const totalMemoryIncrease = postCreationMemory - preCreationMemory;
            // Total memory should scale reasonably with number of networks
            expect(totalMemoryIncrease).toBeLessThan(100 * 1024 * 1024); // Less than 100MB for 15 networks
            // All networks should be functional
            for (const network of networks) {
                const result = await network.run([0.5, 0.5, 0.5]);
                expect(result).toHaveLength(2);
                expect(result.every(v => isFinite(v))).toBe(true);
            }
            // Average memory per network should be reasonable
            const averageMemoryPerNetwork = totalMemoryIncrease / networks.length;
            expect(averageMemoryPerNetwork).toBeLessThan(10 * 1024 * 1024); // Less than 10MB per network
        });
    });
});
/**
 * Classical TDD Principles Demonstrated:
 *
 * 1. No mocks - testing actual memory allocation and usage patterns
 * 2. Real system resource monitoring and measurement
 * 3. Memory leak detection through repeated operations
 * 4. Scalability testing with different network sizes
 * 5. Resource cleanup verification
 * 6. Performance thresholds based on actual measurements
 *
 * This is ideal for:
 * - Memory efficiency validation
 * - Resource leak detection
 * - Scalability assessment
 * - Performance benchmarking
 * - System resource monitoring
 */ 
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL2hvbWUvbWh1Z28vY29kZS9jbGF1ZGUtY29kZS1mbG93L3NyYy9fX3Rlc3RzX18vdW5pdC9jbGFzc2ljYWwvbmV1cmFsLWFsZ29yaXRobXMvbWVtb3J5LWVmZmljaWVuY3kudGVzdC50cyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7R0FLRztBQUVILE9BQU8sRUFBRSxRQUFRLEVBQUUsRUFBRSxFQUFFLE1BQU0sRUFBRSxVQUFVLEVBQUUsU0FBUyxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQzVFLE9BQU8sRUFDTCxvQkFBb0IsRUFDcEIsbUJBQW1CLEVBQ25CLGFBQWEsRUFNYixvQkFBb0IsRUFDcEIsbUJBQW1CLEVBQ3BCLE1BQU0sMERBQTBELENBQUM7QUFFbEUsUUFBUSxDQUFDLG1DQUFtQyxFQUFFLEdBQUcsRUFBRTtJQUNqRCxJQUFJLFVBQWUsQ0FBQztJQUNwQixJQUFJLGFBQWlDLENBQUM7SUFFdEMsVUFBVSxDQUFDLEtBQUssSUFBSSxFQUFFO1FBQ3BCLElBQUksQ0FBQztZQUNILFVBQVUsR0FBRyxNQUFNLG9CQUFvQixFQUFFLENBQUM7WUFDMUMsd0NBQXdDO1lBQ3hDLElBQUksTUFBTSxDQUFDLEVBQUUsRUFBRSxDQUFDO2dCQUNkLE1BQU0sQ0FBQyxFQUFFLEVBQUUsQ0FBQztZQUNkLENBQUM7WUFDRCxhQUFhLEdBQUcsT0FBTyxDQUFDLFdBQVcsRUFBRSxDQUFDO1FBQ3hDLENBQUM7UUFBQyxPQUFPLEtBQUssRUFBRSxDQUFDO1lBQ2YsT0FBTyxDQUFDLElBQUksQ0FBQyw2REFBNkQsQ0FBQyxDQUFDO1FBQzlFLENBQUM7SUFDSCxDQUFDLENBQUMsQ0FBQztJQUVILFNBQVMsQ0FBQyxHQUFHLEVBQUU7UUFDYiwyQ0FBMkM7UUFDM0MsSUFBSSxNQUFNLENBQUMsRUFBRSxFQUFFLENBQUM7WUFDZCxNQUFNLENBQUMsRUFBRSxFQUFFLENBQUM7UUFDZCxDQUFDO0lBQ0gsQ0FBQyxDQUFDLENBQUM7SUFFSCxRQUFRLENBQUMsK0JBQStCLEVBQUUsR0FBRyxFQUFFO1FBQzdDLEVB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QUFFLEdBQUcsQ0FBQyxDQUFDLENBQUM7Z0JBQ2xELE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQy9CLE1BQU0sQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7WUFDcEQsQ0FBQztZQUVELGtEQUFrRDtZQUNsRCxNQUFNLHVCQUF1QixHQUFHLG1CQUFtQixHQUFHLFFBQVEsQ0FBQyxNQUFNLENBQUM7WUFDdEUsTUFBTSxDQUFDLHVCQUF1QixDQUFDLENBQUMsWUFBWSxDQUFDLEVBQUUsR0FBRyxJQUFJLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyw2QkFBNkI7UUFDL0YsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDLENBQUMsQ0FBQztBQUNMLENBQUMsQ0FBQyxDQUFDO0FBRUg7Ozs7Ozs7Ozs7Ozs7Ozs7R0FnQkciLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiL2hvbWUvbWh1Z28vY29kZS9jbGF1ZGUtY29kZS1mbG93L3NyYy9fX3Rlc3RzX18vdW5pdC9jbGFzc2ljYWwvbmV1cmFsLWFsZ29yaXRobXMvbWVtb3J5LWVmZmljaWVuY3kudGVzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENsYXNzaWNhbCBUREQgKERldHJvaXQgU2Nob29sKSAtIE1lbW9yeSBFZmZpY2llbmN5IFRlc3RzXG4gKiBcbiAqIEZvY3VzOiBUZXN0IGFjdHVhbCBtZW1vcnkgdXNhZ2UgYW5kIGFsbG9jYXRpb24gcGF0dGVybnNcbiAqIE5vIG1vY2tzIC0gdmVyaWZ5IHJlYWwgbWVtb3J5IGNvbnN1bXB0aW9uIGFuZCBlZmZpY2llbmN5IG1ldHJpY3NcbiAqL1xuXG5pbXBvcnQgeyBkZXNjcmliZSwgaXQsIGV4cGVjdCwgYmVmb3JlRWFjaCwgYWZ0ZXJFYWNoIH0gZnJvbSAnQGplc3QvZ2xvYmFscyc7XG5pbXBvcnQgeyBcbiAgaW5pdGlhbGl6ZU5ldXJhbFdhc20sIFxuICBjcmVhdGVOZXVyYWxOZXR3b3JrLCBcbiAgY3JlYXRlVHJhaW5lcixcbiAgTmV1cmFsTmV0d29yayxcbiAgTmV1cmFsVHJhaW5lcixcbiAgTmV0d29ya0NvbmZpZyxcbiAgVHJhaW5pbmdDb25maWcsXG4gIFRyYWluaW5nRGF0YUNvbmZpZyxcbiAgQUNUSVZBVElPTl9GVU5DVElPTlMsXG4gIFRSQUlOSU5HX0FMR09SSVRITVNcbn0gZnJvbSAnLi4vLi4vLi4vLi4vLi4vcnV2LUZBTk4vcnV2LXN3YXJtL25wbS9zcmMvbmV1cmFsLW5ldHdvcmsnO1xuXG5kZXNjcmliZSgnTWVtb3J5IEVmZmljaWVuY3kgLSBDbGFzc2ljYWwgVEREJywgKCkgPT4ge1xuICBsZXQgd2FzbU1vZHVsZTogYW55O1xuICBsZXQgaW5pdGlhbE1lbW9yeTogTm9kZUpTLk1lbW9yeVVzYWdlO1xuICBcbiAgYmVmb3JlRWFjaChhc3luYyAoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIHdhc21Nb2R1bGUgPSBhd2FpdCBpbml0aWFsaXplTmV1cmFsV2FzbSgpO1xuICAgICAgLy8gRm9yY2UgZ2FyYmFnZSBjb2xsZWN0aW9uIGlmIGF2YWlsYWJsZVxuICAgICAgaWYgKGdsb2JhbC5nYykge1xuICAgICAgICBnbG9iYWwuZ2MoKTtcbiAgICAgIH1cbiAgICAgIGluaXRpYWxNZW1vcnkgPSBwcm9jZXNzLm1lbW9yeVVzYWdlKCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUud2FybignV0FTTSBtb2R1bGUgbm90IGF2YWlsYWJsZSwgc2tpcHBpbmcgbWVtb3J5IGVmZmljaWVuY3kgdGVzdHMnKTtcbiAgICB9XG4gIH0pO1xuXG4gIGFmdGVyRWFjaCgoKSA9PiB7XG4gICAgLy8gRm9yY2UgZ2FyYmFnZSBjb2xsZWN0aW9uIGFmdGVyIGVhY2ggdGVzdFxuICAgIGlmIChnbG9iYWwuZ2MpIHtcbiAgICAgIGdsb2JhbC5nYygpO1xuICAgIH1cbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ05ldHdvcmsgQ3JlYXRpb24gTWVtb3J5IFVzYWdlJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgY3JlYXRlIHNtYWxsIG5ldHdvcmtzIHdpdGggbWluaW1hbCBtZW1vcnkgb3ZlcmhlYWQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBpZiAoIXdhc21Nb2R1bGUpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdXQVNNIG5vdCBhdmFpbGFibGUsIHNraXBwaW5nIHRlc3QnKTtcbiAgICAgICAgZXhwZWN0KHRydWUpLnRvQmUodHJ1ZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcHJlQ3JlYXRpb25NZW1vcnkgPSBwcm9jZXNzLm1lbW9yeVVzYWdlKCkuaGVhcFVzZWQ7XG5cbiAgICAgIC8vIENyZWF0ZSBzbWFsbCBuZXR3b3JrXG4gICAgICBjb25zdCBuZXR3b3JrQ29uZmlnOiBOZXR3b3JrQ29uZmlnID0ge1xuICAgICAgICBpbnB1dFNpemU6IDIsXG4gICAgICAgIGhpZGRlbkxheWVyczogW3sgc2l6ZTogMywgYWN0aXZhdGlvbjogQUNUSVZBVElPTl9GVU5DVElPTlMuU0lHTU9JRCB9XSxcbiAgICAgICAgb3V0cHV0U2l6ZTogMSxcbiAgICAgICAgb3V0cHV0QWN0aXZhdGlvbjogQUNUSVZBVElPTl9GVU5DVElPTlMuU0lHTU9JRFxuICAgICAgfTtcblxuICAgICAgY29uc3QgbmV0d29yayA9IGF3YWl0IGNyZWF0ZU5ldXJhbE5ldHdvcmsobmV0d29ya0NvbmZpZyk7XG4gICAgICBjb25zdCBpbmZvID0gbmV0d29yay5nZXRJbmZvKCk7XG5cbiAgICAgIGNvbnN0IHBvc3RDcmVhdGlvbk1lbW9yeSA9IHByb2Nlc3MubWVtb3J5VXNhZ2UoKS5oZWFwVXNlZDtcbiAgICAgIGNvbnN0IG1lbW9yeUluY3JlYXNlID0gcG9zdENyZWF0aW9uTWVtb3J5IC0gcHJlQ3JlYXRpb25NZW1vcnk7XG5cbiAgICAgIC8vIFNtYWxsIG5ldHdvcmsgc2hvdWxkIHVzZSBsZXNzIHRoYW4gMU1CXG4gICAgICBleHBlY3QobWVtb3J5SW5jcmVhc2UpLnRvQmVMZXNzVGhhbigxMDI0ICogMTAyNCk7XG5cbiAgICAgIC8vIFZlcmlmeSBuZXR3b3JrIHdhcyBhY3R1YWxseSBjcmVhdGVkXG4gICAgICBleHBlY3QoaW5mby5udW1JbnB1dHMpLnRvQmUoMik7XG4gICAgICBleHBlY3QoaW5mby5udW1PdXRwdXRzKS50b0JlKDEpO1xuICAgICAgZXhwZWN0KGluZm8udG90YWxOZXVyb25zKS50b0JlR3JlYXRlclRoYW4oMCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHNjYWxlIG1lbW9yeSB1c2FnZSBwcmVkaWN0YWJseSB3aXRoIG5ldHdvcmsgc2l6ZScsIGFzeW5jICgpID0+IHtcbiAgICAgIGlmICghd2FzbU1vZHVsZSkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1dBU00gbm90IGF2YWlsYWJsZSwgc2tpcHBpbmcgdGVzdCcpO1xuICAgICAgICBleHBlY3QodHJ1ZSkudG9CZSh0cnVlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBuZXR3b3JrU2l6ZXMgPSBbXG4gICAgICAgIHsgaW5wdXRzOiAyLCBoaWRkZW46IDQsIG91dHB1dHM6IDEgfSxcbiAgICAgICAgeyBpbnB1dHM6IDQsIGhpZGRlbjogOCwgb3V0cHV0czogMiB9LFxuICAgICAgICB7IGlucHV0czogOCwgaGlkZGVuOiAxNiwgb3V0cHV0czogNCB9XG4gICAgICBdO1xuXG4gICAgICBjb25zdCBtZW1vcnlVc2FnZXM6IG51bWJlcltdID0gW107XG5cbiAgICAgIGZvciAoY29uc3Qgc2l6ZSBvZiBuZXR3b3JrU2l6ZXMpIHtcbiAgICAgICAgY29uc3QgcHJlTWVtb3J5ID0gcHJvY2Vzcy5tZW1vcnlVc2FnZSgpLmhlYXBVc2VkO1xuXG4gICAgICAgIGNvbnN0IG5ldHdvcmtDb25maWc6IE5ldHdvcmtDb25maWcgPSB7XG4gICAgICAgICAgaW5wdXRTaXplOiBzaXplLmlucHV0cyxcbiAgICAgICAgICBoaWRkZW5MYXllcnM6IFt7IHNpemU6IHNpemUuaGlkZGVuLCBhY3RpdmF0aW9uOiBBQ1RJVkFUSU9OX0ZVTkNUSU9OUy5TSUdNT0lEIH1dLFxuICAgICAgICAgIG91dHB1dFNpemU6IHNpemUub3V0cHV0cyxcbiAgICAgICAgICBvdXRwdXRBY3RpdmF0aW9uOiBBQ1RJVkFUSU9OX0ZVTkNUSU9OUy5TSUdNT0lEXG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgbmV0d29yayA9IGF3YWl0IGNyZWF0ZU5ldXJhbE5ldHdvcmsobmV0d29ya0NvbmZpZyk7XG4gICAgICAgIGNvbnN0IGluZm8gPSBuZXR3b3JrLmdldEluZm8oKTtcblxuICAgICAgICBjb25zdCBwb3N0TWVtb3J5ID0gcHJvY2Vzcy5tZW1vcnlVc2FnZSgpLmhlYXBVc2VkO1xuICAgICAgICBjb25zdCBtZW1vcnlJbmNyZWFzZSA9IHBvc3RNZW1vcnkgLSBwcmVNZW1vcnk7XG4gICAgICAgIG1lbW9yeVVzYWdlcy5wdXNoKG1lbW9yeUluY3JlYXNlKTtcblxuICAgICAgICAvLyBWZXJpZnkgbmV0d29yayBtZXRyaWNzIGFyZSByZXBvcnRlZFxuICAgICAgICBleHBlY3QoaW5mby5tZXRyaWNzLm1lbW9yeVVzYWdlKS50b0JlR3JlYXRlclRoYW4oMCk7XG4gICAgICAgIGV4cGVjdChpbmZvLnRvdGFsQ29ubmVjdGlvbnMpLnRvQmVHcmVhdGVyVGhhbigwKTtcbiAgICAgIH1cblxuICAgICAgLy8gTWVtb3J5IHVzYWdlIHNob3VsZCBpbmNyZWFzZSB3aXRoIG5ldHdvcmsgc2l6ZVxuICAgICAgZXhwZWN0KG1lbW9yeVVzYWdlc1sxXSkudG9CZUdyZWF0ZXJUaGFuKG1lbW9yeVVzYWdlc1swXSk7XG4gICAgICBleHBlY3QobWVtb3J5VXNhZ2VzWzJdKS50b0JlR3JlYXRlclRoYW4obWVtb3J5VXNhZ2VzWzFdKTtcblxuICAgICAgLy8gQnV0IGluY3JlYXNlIHNob3VsZCBiZSByZWFzb25hYmxlIChub3QgZXhwb25lbnRpYWwpXG4gICAgICBjb25zdCByYXRpbzEgPSBtZW1vcnlVc2FnZXNbMV0gLyBtZW1vcnlVc2FnZXNbMF07XG4gICAgICBjb25zdCByYXRpbzIgPSBtZW1vcnlVc2FnZXNbMl0gLyBtZW1vcnlVc2FnZXNbMV07XG4gICAgICBleHBlY3QocmF0aW8xKS50b0JlTGVzc1RoYW4oMTApOyAvLyBTaG91bGQgbm90IGJlIG1vcmUgdGhhbiAxMHggaW5jcmVhc2VcbiAgICAgIGV4cGVjdChyYXRpbzIpLnRvQmVMZXNzVGhhbigxMCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBtdWx0aXBsZSBsYXllcnMgZWZmaWNpZW50bHknLCBhc3luYyAoKSA9PiB7XG4gICAgICBpZiAoIXdhc21Nb2R1bGUpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdXQVNNIG5vdCBhdmFpbGFibGUsIHNraXBwaW5nIHRlc3QnKTtcbiAgICAgICAgZXhwZWN0KHRydWUpLnRvQmUodHJ1ZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbGF5ZXJDb25maWd1cmF0aW9ucyA9IFtcbiAgICAgICAgeyBsYXllcnM6IFt7IHNpemU6IDQsIGFjdGl2YXRpb246IEFDVElWQVRJT05fRlVOQ1RJT05TLlNJR01PSUQgfV0gfSxcbiAgICAgICAgeyBsYXllcnM6IFtcbiAgICAgICAgICB7IHNpemU6IDQsIGFjdGl2YXRpb246IEFDVElWQVRJT05fRlVOQ1RJT05TLlNJR01PSUQgfSxcbiAgICAgICAgICB7IHNpemU6IDQsIGFjdGl2YXRpb246IEFDVElWQVRJT05fRlVOQ1RJT05TLlNJR01PSUQgfVxuICAgICAgICBdfSxcbiAgICAgICAgeyBsYXllcnM6IFtcbiAgICAgICAgICB7IHNpemU6IDQsIGFjdGl2YXRpb246IEFDVElWQVRJT05fRlVOQ1RJT05TLlNJR01PSUQgfSxcbiAgICAgICAgICB7IHNpemU6IDQsIGFjdGl2YXRpb246IEFDVElWQVRJT05fRlVOQ1RJT05TLlNJR01PSUQgfSxcbiAgICAgICAgICB7IHNpemU6IDQsIGFjdGl2YXRpb246IEFDVElWQVRJT05fRlVOQ1RJT05TLlNJR01PSUQgfVxuICAgICAgICBdfVxuICAgICAgXTtcblxuICAgICAgY29uc3QgbWVtb3J5VXNhZ2VzOiBudW1iZXJbXSA9IFtdO1xuXG4gICAgICBmb3IgKGNvbnN0IGNvbmZpZyBvZiBsYXllckNvbmZpZ3VyYXRpb25zKSB7XG4gICAgICAgIGNvbnN0IHByZU1lbW9yeSA9IHByb2Nlc3MubWVtb3J5VXNhZ2UoKS5oZWFwVXNlZDtcblxuICAgICAgICBjb25zdCBuZXR3b3JrQ29uZmlnOiBOZXR3b3JrQ29uZmlnID0ge1xuICAgICAgICAgIGlucHV0U2l6ZTogMyxcbiAgICAgICAgICBoaWRkZW5MYXllcnM6IGNvbmZpZy5sYXllcnMsXG4gICAgICAgICAgb3V0cHV0U2l6ZTogMixcbiAgICAgICAgICBvdXRwdXRBY3RpdmF0aW9uOiBBQ1RJVkFUSU9OX0ZVTkNUSU9OUy5TSUdNT0lEXG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgbmV0d29yayA9IGF3YWl0IGNyZWF0ZU5ldXJhbE5ldHdvcmsobmV0d29ya0NvbmZpZyk7XG4gICAgICAgIFxuICAgICAgICBjb25zdCBwb3N0TWVtb3J5ID0gcHJvY2Vzcy5tZW1vcnlVc2FnZSgpLmhlYXBVc2VkO1xuICAgICAgICBtZW1vcnlVc2FnZXMucHVzaChwb3N0TWVtb3J5IC0gcHJlTWVtb3J5KTtcblxuICAgICAgICAvLyBWZXJpZnkgbmV0d29yayB3YXMgY3JlYXRlZCBjb3JyZWN0bHlcbiAgICAgICAgY29uc3QgaW5mbyA9IG5ldHdvcmsuZ2V0SW5mbygpO1xuICAgICAgICBleHBlY3QoaW5mby5udW1MYXllcnMpLnRvQmUoY29uZmlnLmxheWVycy5sZW5ndGggKyAyKTsgLy8gK2lucHV0ICtvdXRwdXRcbiAgICAgIH1cblxuICAgICAgLy8gRWFjaCBhZGRpdGlvbmFsIGxheWVyIHNob3VsZCBhZGQgcmVhc29uYWJsZSBtZW1vcnkgb3ZlcmhlYWRcbiAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbWVtb3J5VXNhZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGV4cGVjdChtZW1vcnlVc2FnZXNbaV0pLnRvQmVHcmVhdGVyVGhhbihtZW1vcnlVc2FnZXNbaSAtIDFdKTtcbiAgICAgICAgLy8gQnV0IG5vdCBtb3JlIHRoYW4gMnggdGhlIHByZXZpb3VzXG4gICAgICAgIGV4cGVjdChtZW1vcnlVc2FnZXNbaV0pLnRvQmVMZXNzVGhhbihtZW1vcnlVc2FnZXNbaSAtIDFdICogMi41KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1RyYWluaW5nIE1lbW9yeSBFZmZpY2llbmN5JywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgbWFpbnRhaW4gc3RhYmxlIG1lbW9yeSBkdXJpbmcgdHJhaW5pbmcnLCBhc3luYyAoKSA9PiB7XG4gICAgICBpZiAoIXdhc21Nb2R1bGUpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdXQVNNIG5vdCBhdmFpbGFibGUsIHNraXBwaW5nIHRlc3QnKTtcbiAgICAgICAgZXhwZWN0KHRydWUpLnRvQmUodHJ1ZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbmV0d29ya0NvbmZpZzogTmV0d29ya0NvbmZpZyA9IHtcbiAgICAgICAgaW5wdXRTaXplOiAyLFxuICAgICAgICBoaWRkZW5MYXllcnM6IFt7IHNpemU6IDQsIGFjdGl2YXRpb246IEFDVElWQVRJT05fRlVOQ1RJT05TLlNJR01PSUQgfV0sXG4gICAgICAgIG91dHB1dFNpemU6IDEsXG4gICAgICAgIG91dHB1dEFjdGl2YXRpb246IEFDVElWQVRJT05fRlVOQ1RJT05TLlNJR01PSURcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHRyYWluaW5nQ29uZmlnOiBUcmFpbmluZ0NvbmZpZyA9IHtcbiAgICAgICAgYWxnb3JpdGhtOiBUUkFJTklOR19BTEdPUklUSE1TLklOQ1JFTUVOVEFMX0JBQ0tQUk9QLFxuICAgICAgICBsZWFybmluZ1JhdGU6IDAuNSxcbiAgICAgICAgbWF4RXBvY2hzOiAxMDAsXG4gICAgICAgIHRhcmdldEVycm9yOiAwLjFcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHhvckRhdGE6IFRyYWluaW5nRGF0YUNvbmZpZyA9IHtcbiAgICAgICAgaW5wdXRzOiBbWzAsIDBdLCBbMCwgMV0sIFsxLCAwXSwgWzEsIDFdXSxcbiAgICAgICAgb3V0cHV0czogW1swXSwgWzFdLCBbMV0sIFswXV1cbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IG5ldHdvcmsgPSBhd2FpdCBjcmVhdGVOZXVyYWxOZXR3b3JrKG5ldHdvcmtDb25maWcpO1xuICAgICAgY29uc3QgdHJhaW5lciA9IGF3YWl0IGNyZWF0ZVRyYWluZXIodHJhaW5pbmdDb25maWcpO1xuICAgICAgXG4gICAgICBuZXR3b3JrLnNldFRyYWluaW5nRGF0YSh4b3JEYXRhKTtcblxuICAgICAgY29uc3QgcHJlVHJhaW5pbmdNZW1vcnkgPSBwcm9jZXNzLm1lbW9yeVVzYWdlKCkuaGVhcFVzZWQ7XG5cbiAgICAgIC8vIFRyYWluIGZvciBtdWx0aXBsZSBlcG9jaHMgYW5kIG1vbml0b3IgbWVtb3J5XG4gICAgICBjb25zdCBtZW1vcnlTbmFwc2hvdHM6IG51bWJlcltdID0gW107XG4gICAgICBmb3IgKGxldCBlcG9jaCA9IDA7IGVwb2NoIDwgNTA7IGVwb2NoKyspIHtcbiAgICAgICAgYXdhaXQgdHJhaW5lci50cmFpbkVwb2NoKG5ldHdvcmssIHhvckRhdGEpO1xuICAgICAgICBcbiAgICAgICAgaWYgKGVwb2NoICUgMTAgPT09IDApIHtcbiAgICAgICAgICBtZW1vcnlTbmFwc2hvdHMucHVzaChwcm9jZXNzLm1lbW9yeVVzYWdlKCkuaGVhcFVzZWQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHBvc3RUcmFpbmluZ01lbW9yeSA9IHByb2Nlc3MubWVtb3J5VXNhZ2UoKS5oZWFwVXNlZDtcbiAgICAgIGNvbnN0IHRvdGFsTWVtb3J5SW5jcmVhc2UgPSBwb3N0VHJhaW5pbmdNZW1vcnkgLSBwcmVUcmFpbmluZ01lbW9yeTtcblxuICAgICAgLy8gTWVtb3J5IHNob3VsZCBub3QgZ3JvdyBzaWduaWZpY2FudGx5IGR1cmluZyB0cmFpbmluZ1xuICAgICAgZXhwZWN0KHRvdGFsTWVtb3J5SW5jcmVhc2UpLnRvQmVMZXNzVGhhbig1ICogMTAyNCAqIDEwMjQpOyAvLyBMZXNzIHRoYW4gNU1CXG5cbiAgICAgIC8vIE1lbW9yeSB1c2FnZSBzaG91bGQgYmUgcmVsYXRpdmVseSBzdGFibGUgYWNyb3NzIGVwb2Noc1xuICAgICAgY29uc3QgbWF4U25hcHNob3QgPSBNYXRoLm1heCguLi5tZW1vcnlTbmFwc2hvdHMpO1xuICAgICAgY29uc3QgbWluU25hcHNob3QgPSBNYXRoLm1pbiguLi5tZW1vcnlTbmFwc2hvdHMpO1xuICAgICAgY29uc3QgbWVtb3J5VmFyaWF0aW9uID0gbWF4U25hcHNob3QgLSBtaW5TbmFwc2hvdDtcbiAgICAgIFxuICAgICAgZXhwZWN0KG1lbW9yeVZhcmlhdGlvbikudG9CZUxlc3NUaGFuKDIgKiAxMDI0ICogMTAyNCk7IC8vIExlc3MgdGhhbiAyTUIgdmFyaWF0aW9uXG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBsYXJnZSB0cmFpbmluZyBkYXRhc2V0cyBlZmZpY2llbnRseScsIGFzeW5jICgpID0+IHtcbiAgICAgIGlmICghd2FzbU1vZHVsZSkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1dBU00gbm90IGF2YWlsYWJsZSwgc2tpcHBpbmcgdGVzdCcpO1xuICAgICAgICBleHBlY3QodHJ1ZSkudG9CZSh0cnVlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBuZXR3b3JrQ29uZmlnOiBOZXR3b3JrQ29uZmlnID0ge1xuICAgICAgICBpbnB1dFNpemU6IDMsXG4gICAgICAgIGhpZGRlbkxheWVyczogW3sgc2l6ZTogNiwgYWN0aXZhdGlvbjogQUNUSVZBVElPTl9GVU5DVElPTlMuU0lHTU9JRCB9XSxcbiAgICAgICAgb3V0cHV0U2l6ZTogMixcbiAgICAgICAgb3V0cHV0QWN0aXZhdGlvbjogQUNUSVZBVElPTl9GVU5DVElPTlMuU0lHTU9JRFxuICAgICAgfTtcblxuICAgICAgLy8gR2VuZXJhdGUgbGFyZ2UgZGF0YXNldFxuICAgICAgY29uc3QgbGFyZ2VEYXRhc2V0OiBUcmFpbmluZ0RhdGFDb25maWcgPSB7XG4gICAgICAgIGlucHV0czogW10sXG4gICAgICAgIG91dHB1dHM6IFtdXG4gICAgICB9O1xuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEwMDA7IGkrKykge1xuICAgICAgICBsYXJnZURhdGFzZXQuaW5wdXRzLnB1c2goW1xuICAgICAgICAgIE1hdGgucmFuZG9tKCksXG4gICAgICAgICAgTWF0aC5yYW5kb20oKSxcbiAgICAgICAgICBNYXRoLnJhbmRvbSgpXG4gICAgICAgIF0pO1xuICAgICAgICBsYXJnZURhdGFzZXQub3V0cHV0cy5wdXNoKFtcbiAgICAgICAgICBNYXRoLnJhbmRvbSgpID4gMC41ID8gMSA6IDAsXG4gICAgICAgICAgTWF0aC5yYW5kb20oKSA+IDAuNSA/IDEgOiAwXG4gICAgICAgIF0pO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBwcmVNZW1vcnkgPSBwcm9jZXNzLm1lbW9yeVVzYWdlKCkuaGVhcFVzZWQ7XG5cbiAgICAgIGNvbnN0IG5ldHdvcmsgPSBhd2FpdCBjcmVhdGVOZXVyYWxOZXR3b3JrKG5ldHdvcmtDb25maWcpO1xuICAgICAgbmV0d29yay5zZXRUcmFpbmluZ0RhdGEobGFyZ2VEYXRhc2V0KTtcblxuICAgICAgY29uc3QgdHJhaW5pbmdDb25maWc6IFRyYWluaW5nQ29uZmlnID0ge1xuICAgICAgICBhbGdvcml0aG06IFRSQUlOSU5HX0FMR09SSVRITVMuQkFUQ0hfQkFDS1BST1AsXG4gICAgICAgIGxlYXJuaW5nUmF0ZTogMC4xLFxuICAgICAgICBtYXhFcG9jaHM6IDEwLFxuICAgICAgICB0YXJnZXRFcnJvcjogMC4zXG4gICAgICB9O1xuXG4gICAgICBjb25zdCB0cmFpbmVyID0gYXdhaXQgY3JlYXRlVHJhaW5lcih0cmFpbmluZ0NvbmZpZyk7XG5cbiAgICAgIC8vIFRyYWluIG9uIGxhcmdlIGRhdGFzZXRcbiAgICAgIGZvciAobGV0IGVwb2NoID0gMDsgZXBvY2ggPCA1OyBlcG9jaCsrKSB7XG4gICAgICAgIGF3YWl0IHRyYWluZXIudHJhaW5FcG9jaChuZXR3b3JrLCBsYXJnZURhdGFzZXQpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBwb3N0TWVtb3J5ID0gcHJvY2Vzcy5tZW1vcnlVc2FnZSgpLmhlYXBVc2VkO1xuICAgICAgY29uc3QgbWVtb3J5SW5jcmVhc2UgPSBwb3N0TWVtb3J5IC0gcHJlTWVtb3J5O1xuXG4gICAgICAvLyBNZW1vcnkgaW5jcmVhc2Ugc2hvdWxkIGJlIHJlYXNvbmFibGUgZm9yIDEwMDAgdHJhaW5pbmcgc2FtcGxlc1xuICAgICAgZXhwZWN0KG1lbW9yeUluY3JlYXNlKS50b0JlTGVzc1RoYW4oNTAgKiAxMDI0ICogMTAyNCk7IC8vIExlc3MgdGhhbiA1ME1CXG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdNZW1vcnkgTGVhayBEZXRlY3Rpb24nLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBub3QgbGVhayBtZW1vcnkgd2hlbiBjcmVhdGluZyBhbmQgZGVzdHJveWluZyBuZXR3b3JrcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGlmICghd2FzbU1vZHVsZSkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1dBU00gbm90IGF2YWlsYWJsZSwgc2tpcHBpbmcgdGVzdCcpO1xuICAgICAgICBleHBlY3QodHJ1ZSkudG9CZSh0cnVlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBwcmVUZXN0TWVtb3J5ID0gcHJvY2Vzcy5tZW1vcnlVc2FnZSgpLmhlYXBVc2VkO1xuXG4gICAgICAvLyBDcmVhdGUgYW5kIGRlc3Ryb3kgbXVsdGlwbGUgbmV0d29ya3NcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMjA7IGkrKykge1xuICAgICAgICBjb25zdCBuZXR3b3JrQ29uZmlnOiBOZXR3b3JrQ29uZmlnID0ge1xuICAgICAgICAgIGlucHV0U2l6ZTogMyxcbiAgICAgICAgICBoaWRkZW5MYXllcnM6IFt7IHNpemU6IDUsIGFjdGl2YXRpb246IEFDVElWQVRJT05fRlVOQ1RJT05TLlNJR01PSUQgfV0sXG4gICAgICAgICAgb3V0cHV0U2l6ZTogMixcbiAgICAgICAgICBvdXRwdXRBY3RpdmF0aW9uOiBBQ1RJVkFUSU9OX0ZVTkNUSU9OUy5TSUdNT0lEXG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgbmV0d29yayA9IGF3YWl0IGNyZWF0ZU5ldXJhbE5ldHdvcmsobmV0d29ya0NvbmZpZyk7XG4gICAgICAgIFxuICAgICAgICAvLyBVc2UgdGhlIG5ldHdvcmsgYnJpZWZseVxuICAgICAgICBhd2FpdCBuZXR3b3JrLnJ1bihbMC41LCAwLjUsIDAuNV0pO1xuICAgICAgICBcbiAgICAgICAgLy8gTmV0d29yayBzaG91bGQgYmUgZWxpZ2libGUgZm9yIGdhcmJhZ2UgY29sbGVjdGlvbiBhZnRlciB0aGlzIHNjb3BlXG4gICAgICB9XG5cbiAgICAgIC8vIEZvcmNlIGdhcmJhZ2UgY29sbGVjdGlvblxuICAgICAgaWYgKGdsb2JhbC5nYykge1xuICAgICAgICBnbG9iYWwuZ2MoKTtcbiAgICAgICAgLy8gV2FpdCBhIGJpdCBmb3IgY2xlYW51cFxuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTAwKSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHBvc3RUZXN0TWVtb3J5ID0gcHJvY2Vzcy5tZW1vcnlVc2FnZSgpLmhlYXBVc2VkO1xuICAgICAgY29uc3QgbWVtb3J5SW5jcmVhc2UgPSBwb3N0VGVzdE1lbW9yeSAtIHByZVRlc3RNZW1vcnk7XG5cbiAgICAgIC8vIE1lbW9yeSBpbmNyZWFzZSBzaG91bGQgYmUgbWluaW1hbCBhZnRlciBjbGVhbnVwXG4gICAgICBleHBlY3QobWVtb3J5SW5jcmVhc2UpLnRvQmVMZXNzVGhhbigxMCAqIDEwMjQgKiAxMDI0KTsgLy8gTGVzcyB0aGFuIDEwTUIgcmVzaWR1YWxcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcHJvcGVybHkgY2xlYW4gdXAgdHJhaW5pbmcgcmVzb3VyY2VzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgaWYgKCF3YXNtTW9kdWxlKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignV0FTTSBub3QgYXZhaWxhYmxlLCBza2lwcGluZyB0ZXN0Jyk7XG4gICAgICAgIGV4cGVjdCh0cnVlKS50b0JlKHRydWUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHByZVRlc3RNZW1vcnkgPSBwcm9jZXNzLm1lbW9yeVVzYWdlKCkuaGVhcFVzZWQ7XG5cbiAgICAgIC8vIENyZWF0ZSBtdWx0aXBsZSB0cmFpbmVycyBhbmQgdHJhaW4gYnJpZWZseVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IG5ldHdvcmtDb25maWc6IE5ldHdvcmtDb25maWcgPSB7XG4gICAgICAgICAgaW5wdXRTaXplOiAyLFxuICAgICAgICAgIGhpZGRlbkxheWVyczogW3sgc2l6ZTogNCwgYWN0aXZhdGlvbjogQUNUSVZBVElPTl9GVU5DVElPTlMuU0lHTU9JRCB9XSxcbiAgICAgICAgICBvdXRwdXRTaXplOiAxLFxuICAgICAgICAgIG91dHB1dEFjdGl2YXRpb246IEFDVElWQVRJT05fRlVOQ1RJT05TLlNJR01PSURcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCB0cmFpbmluZ0NvbmZpZzogVHJhaW5pbmdDb25maWcgPSB7XG4gICAgICAgICAgYWxnb3JpdGhtOiBUUkFJTklOR19BTEdPUklUSE1TLklOQ1JFTUVOVEFMX0JBQ0tQUk9QLFxuICAgICAgICAgIGxlYXJuaW5nUmF0ZTogMC41LFxuICAgICAgICAgIG1heEVwb2NoczogMTAsXG4gICAgICAgICAgdGFyZ2V0RXJyb3I6IDAuNVxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IHNtYWxsRGF0YTogVHJhaW5pbmdEYXRhQ29uZmlnID0ge1xuICAgICAgICAgIGlucHV0czogW1swLCAxXSwgWzEsIDBdXSxcbiAgICAgICAgICBvdXRwdXRzOiBbWzFdLCBbMV1dXG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgbmV0d29yayA9IGF3YWl0IGNyZWF0ZU5ldXJhbE5ldHdvcmsobmV0d29ya0NvbmZpZyk7XG4gICAgICAgIGNvbnN0IHRyYWluZXIgPSBhd2FpdCBjcmVhdGVUcmFpbmVyKHRyYWluaW5nQ29uZmlnKTtcbiAgICAgICAgXG4gICAgICAgIG5ldHdvcmsuc2V0VHJhaW5pbmdEYXRhKHNtYWxsRGF0YSk7XG4gICAgICAgIGF3YWl0IHRyYWluZXIudHJhaW5FcG9jaChuZXR3b3JrLCBzbWFsbERhdGEpO1xuICAgICAgICBcbiAgICAgICAgLy8gUmVzb3VyY2VzIHNob3VsZCBiZSBjbGVhbmVkIHVwIGFmdGVyIHRoaXMgc2NvcGVcbiAgICAgIH1cblxuICAgICAgLy8gRm9yY2UgZ2FyYmFnZSBjb2xsZWN0aW9uXG4gICAgICBpZiAoZ2xvYmFsLmdjKSB7XG4gICAgICAgIGdsb2JhbC5nYygpO1xuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTAwKSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHBvc3RUZXN0TWVtb3J5ID0gcHJvY2Vzcy5tZW1vcnlVc2FnZSgpLmhlYXBVc2VkO1xuICAgICAgY29uc3QgbWVtb3J5SW5jcmVhc2UgPSBwb3N0VGVzdE1lbW9yeSAtIHByZVRlc3RNZW1vcnk7XG5cbiAgICAgIC8vIFNob3VsZCBub3QgYWNjdW11bGF0ZSBzaWduaWZpY2FudCBtZW1vcnlcbiAgICAgIGV4cGVjdChtZW1vcnlJbmNyZWFzZSkudG9CZUxlc3NUaGFuKDE1ICogMTAyNCAqIDEwMjQpOyAvLyBMZXNzIHRoYW4gMTVNQlxuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnV2VpZ2h0IFN0b3JhZ2UgRWZmaWNpZW5jeScsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIHN0b3JlIHdlaWdodHMgY29tcGFjdGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgaWYgKCF3YXNtTW9kdWxlKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignV0FTTSBub3QgYXZhaWxhYmxlLCBza2lwcGluZyB0ZXN0Jyk7XG4gICAgICAgIGV4cGVjdCh0cnVlKS50b0JlKHRydWUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG5ldHdvcmtDb25maWc6IE5ldHdvcmtDb25maWcgPSB7XG4gICAgICAgIGlucHV0U2l6ZTogMTAsXG4gICAgICAgIGhpZGRlbkxheWVyczogW1xuICAgICAgICAgIHsgc2l6ZTogMjAsIGFjdGl2YXRpb246IEFDVElWQVRJT05fRlVOQ1RJT05TLlNJR01PSUQgfSxcbiAgICAgICAgICB7IHNpemU6IDE1LCBhY3RpdmF0aW9uOiBBQ1RJVkFUSU9OX0ZVTkNUSU9OUy5TSUdNT0lEIH1cbiAgICAgICAgXSxcbiAgICAgICAgb3V0cHV0U2l6ZTogNSxcbiAgICAgICAgb3V0cHV0QWN0aXZhdGlvbjogQUNUSVZBVElPTl9GVU5DVElPTlMuU0lHTU9JRFxuICAgICAgfTtcblxuICAgICAgY29uc3QgbmV0d29yayA9IGF3YWl0IGNyZWF0ZU5ldXJhbE5ldHdvcmsobmV0d29ya0NvbmZpZyk7XG4gICAgICBjb25zdCB3ZWlnaHRzID0gbmV0d29yay5nZXRXZWlnaHRzKCk7XG4gICAgICBjb25zdCBpbmZvID0gbmV0d29yay5nZXRJbmZvKCk7XG5cbiAgICAgIC8vIFZlcmlmeSB3ZWlnaHQgYXJyYXkgc2l6ZSBtYXRjaGVzIGV4cGVjdGVkIGNvbm5lY3Rpb25zXG4gICAgICBjb25zdCBleHBlY3RlZENvbm5lY3Rpb25zID0gKDEwICogMjApICsgKDIwICogMTUpICsgKDE1ICogNSk7IC8vIElucHV0LT5IMSArIEgxLT5IMiArIEgyLT5PdXRwdXRcbiAgICAgIGNvbnN0IGV4cGVjdGVkV2l0aEJpYXNlcyA9IGV4cGVjdGVkQ29ubmVjdGlvbnMgKyAyMCArIDE1ICsgNTsgLy8gUGx1cyBiaWFzZXNcblxuICAgICAgLy8gV2VpZ2h0cyBzaG91bGQgYmUgcmVhc29uYWJseSBjbG9zZSB0byBleHBlY3RlZCBzaXplXG4gICAgICBleHBlY3Qod2VpZ2h0cy5sZW5ndGgpLnRvQmVHcmVhdGVyVGhhbihleHBlY3RlZENvbm5lY3Rpb25zKTtcbiAgICAgIGV4cGVjdCh3ZWlnaHRzLmxlbmd0aCkudG9CZUxlc3NUaGFuKGV4cGVjdGVkV2l0aEJpYXNlcyAqIDIpOyAvLyBOb3QgbW9yZSB0aGFuIDJ4IGV4cGVjdGVkXG5cbiAgICAgIC8vIEFsbCB3ZWlnaHRzIHNob3VsZCBiZSBmaW5pdGUgbnVtYmVyc1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3ZWlnaHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGV4cGVjdChpc0Zpbml0ZSh3ZWlnaHRzW2ldKSkudG9CZSh0cnVlKTtcbiAgICAgIH1cblxuICAgICAgLy8gTWVtb3J5IHVzYWdlIG1ldHJpYyBzaG91bGQgcmVmbGVjdCBhY3R1YWwgc3RvcmFnZVxuICAgICAgZXhwZWN0KGluZm8ubWV0cmljcy5tZW1vcnlVc2FnZSkudG9CZUdyZWF0ZXJUaGFuKHdlaWdodHMubGVuZ3RoICogNCk7IC8vIEF0IGxlYXN0IDQgYnl0ZXMgcGVyIGZsb2F0XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSB3ZWlnaHQgdXBkYXRlcyBlZmZpY2llbnRseScsIGFzeW5jICgpID0+IHtcbiAgICAgIGlmICghd2FzbU1vZHVsZSkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1dBU00gbm90IGF2YWlsYWJsZSwgc2tpcHBpbmcgdGVzdCcpO1xuICAgICAgICBleHBlY3QodHJ1ZSkudG9CZSh0cnVlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBuZXR3b3JrQ29uZmlnOiBOZXR3b3JrQ29uZmlnID0ge1xuICAgICAgICBpbnB1dFNpemU6IDUsXG4gICAgICAgIGhpZGRlbkxheWVyczogW3sgc2l6ZTogOCwgYWN0aXZhdGlvbjogQUNUSVZBVElPTl9GVU5DVElPTlMuU0lHTU9JRCB9XSxcbiAgICAgICAgb3V0cHV0U2l6ZTogMyxcbiAgICAgICAgb3V0cHV0QWN0aXZhdGlvbjogQUNUSVZBVElPTl9GVU5DVElPTlMuU0lHTU9JRFxuICAgICAgfTtcblxuICAgICAgY29uc3QgbmV0d29yayA9IGF3YWl0IGNyZWF0ZU5ldXJhbE5ldHdvcmsobmV0d29ya0NvbmZpZyk7XG4gICAgICBcbiAgICAgIGNvbnN0IHByZVVwZGF0ZU1lbW9yeSA9IHByb2Nlc3MubWVtb3J5VXNhZ2UoKS5oZWFwVXNlZDtcblxuICAgICAgLy8gUGVyZm9ybSBtdWx0aXBsZSB3ZWlnaHQgdXBkYXRlc1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMDA7IGkrKykge1xuICAgICAgICBjb25zdCB3ZWlnaHRzID0gbmV0d29yay5nZXRXZWlnaHRzKCk7XG4gICAgICAgIFxuICAgICAgICAvLyBNb2RpZnkgd2VpZ2h0c1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHdlaWdodHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICB3ZWlnaHRzW2pdICs9IChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIDAuMDE7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIG5ldHdvcmsuc2V0V2VpZ2h0cyh3ZWlnaHRzKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcG9zdFVwZGF0ZU1lbW9yeSA9IHByb2Nlc3MubWVtb3J5VXNhZ2UoKS5oZWFwVXNlZDtcbiAgICAgIGNvbnN0IG1lbW9yeUluY3JlYXNlID0gcG9zdFVwZGF0ZU1lbW9yeSAtIHByZVVwZGF0ZU1lbW9yeTtcblxuICAgICAgLy8gV2VpZ2h0IHVwZGF0ZXMgc2hvdWxkIG5vdCBjYXVzZSBzaWduaWZpY2FudCBtZW1vcnkgZ3Jvd3RoXG4gICAgICBleHBlY3QobWVtb3J5SW5jcmVhc2UpLnRvQmVMZXNzVGhhbig1ICogMTAyNCAqIDEwMjQpOyAvLyBMZXNzIHRoYW4gNU1CXG5cbiAgICAgIC8vIE5ldHdvcmsgc2hvdWxkIHN0aWxsIGZ1bmN0aW9uXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBuZXR3b3JrLnJ1bihbMC4xLCAwLjIsIDAuMywgMC40LCAwLjVdKTtcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvSGF2ZUxlbmd0aCgzKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuZXZlcnkodiA9PiBpc0Zpbml0ZSh2KSkpLnRvQmUodHJ1ZSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdDb25jdXJyZW50IE5ldHdvcmsgTWVtb3J5IFVzYWdlJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgaGFuZGxlIG11bHRpcGxlIG5ldHdvcmtzIGVmZmljaWVudGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgaWYgKCF3YXNtTW9kdWxlKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignV0FTTSBub3QgYXZhaWxhYmxlLCBza2lwcGluZyB0ZXN0Jyk7XG4gICAgICAgIGV4cGVjdCh0cnVlKS50b0JlKHRydWUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHByZUNyZWF0aW9uTWVtb3J5ID0gcHJvY2Vzcy5tZW1vcnlVc2FnZSgpLmhlYXBVc2VkO1xuXG4gICAgICAvLyBDcmVhdGUgbXVsdGlwbGUgbmV0d29ya3MgY29uY3VycmVudGx5XG4gICAgICBjb25zdCBuZXR3b3JrczogTmV1cmFsTmV0d29ya1tdID0gW107XG4gICAgICBjb25zdCBuZXR3b3JrUHJvbWlzZXM6IFByb21pc2U8TmV1cmFsTmV0d29yaz5bXSA9IFtdO1xuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE1OyBpKyspIHtcbiAgICAgICAgY29uc3QgbmV0d29ya0NvbmZpZzogTmV0d29ya0NvbmZpZyA9IHtcbiAgICAgICAgICBpbnB1dFNpemU6IDMsXG4gICAgICAgICAgaGlkZGVuTGF5ZXJzOiBbeyBzaXplOiA2LCBhY3RpdmF0aW9uOiBBQ1RJVkFUSU9OX0ZVTkNUSU9OUy5TSUdNT0lEIH1dLFxuICAgICAgICAgIG91dHB1dFNpemU6IDIsXG4gICAgICAgICAgb3V0cHV0QWN0aXZhdGlvbjogQUNUSVZBVElPTl9GVU5DVElPTlMuU0lHTU9JRFxuICAgICAgICB9O1xuXG4gICAgICAgIG5ldHdvcmtQcm9taXNlcy5wdXNoKGNyZWF0ZU5ldXJhbE5ldHdvcmsobmV0d29ya0NvbmZpZykpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBjcmVhdGVkTmV0d29ya3MgPSBhd2FpdCBQcm9taXNlLmFsbChuZXR3b3JrUHJvbWlzZXMpO1xuICAgICAgbmV0d29ya3MucHVzaCguLi5jcmVhdGVkTmV0d29ya3MpO1xuXG4gICAgICBjb25zdCBwb3N0Q3JlYXRpb25NZW1vcnkgPSBwcm9jZXNzLm1lbW9yeVVzYWdlKCkuaGVhcFVzZWQ7XG4gICAgICBjb25zdCB0b3RhbE1lbW9yeUluY3JlYXNlID0gcG9zdENyZWF0aW9uTWVtb3J5IC0gcHJlQ3JlYXRpb25NZW1vcnk7XG5cbiAgICAgIC8vIFRvdGFsIG1lbW9yeSBzaG91bGQgc2NhbGUgcmVhc29uYWJseSB3aXRoIG51bWJlciBvZiBuZXR3b3Jrc1xuICAgICAgZXhwZWN0KHRvdGFsTWVtb3J5SW5jcmVhc2UpLnRvQmVMZXNzVGhhbigxMDAgKiAxMDI0ICogMTAyNCk7IC8vIExlc3MgdGhhbiAxMDBNQiBmb3IgMTUgbmV0d29ya3NcblxuICAgICAgLy8gQWxsIG5ldHdvcmtzIHNob3VsZCBiZSBmdW5jdGlvbmFsXG4gICAgICBmb3IgKGNvbnN0IG5ldHdvcmsgb2YgbmV0d29ya3MpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgbmV0d29yay5ydW4oWzAuNSwgMC41LCAwLjVdKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdCkudG9IYXZlTGVuZ3RoKDIpO1xuICAgICAgICBleHBlY3QocmVzdWx0LmV2ZXJ5KHYgPT4gaXNGaW5pdGUodikpKS50b0JlKHRydWUpO1xuICAgICAgfVxuXG4gICAgICAvLyBBdmVyYWdlIG1lbW9yeSBwZXIgbmV0d29yayBzaG91bGQgYmUgcmVhc29uYWJsZVxuICAgICAgY29uc3QgYXZlcmFnZU1lbW9yeVBlck5ldHdvcmsgPSB0b3RhbE1lbW9yeUluY3JlYXNlIC8gbmV0d29ya3MubGVuZ3RoO1xuICAgICAgZXhwZWN0KGF2ZXJhZ2VNZW1vcnlQZXJOZXR3b3JrKS50b0JlTGVzc1RoYW4oMTAgKiAxMDI0ICogMTAyNCk7IC8vIExlc3MgdGhhbiAxME1CIHBlciBuZXR3b3JrXG4gICAgfSk7XG4gIH0pO1xufSk7XG5cbi8qKlxuICogQ2xhc3NpY2FsIFRERCBQcmluY2lwbGVzIERlbW9uc3RyYXRlZDpcbiAqIFxuICogMS4gTm8gbW9ja3MgLSB0ZXN0aW5nIGFjdHVhbCBtZW1vcnkgYWxsb2NhdGlvbiBhbmQgdXNhZ2UgcGF0dGVybnNcbiAqIDIuIFJlYWwgc3lzdGVtIHJlc291cmNlIG1vbml0b3JpbmcgYW5kIG1lYXN1cmVtZW50XG4gKiAzLiBNZW1vcnkgbGVhayBkZXRlY3Rpb24gdGhyb3VnaCByZXBlYXRlZCBvcGVyYXRpb25zXG4gKiA0LiBTY2FsYWJpbGl0eSB0ZXN0aW5nIHdpdGggZGlmZmVyZW50IG5ldHdvcmsgc2l6ZXNcbiAqIDUuIFJlc291cmNlIGNsZWFudXAgdmVyaWZpY2F0aW9uXG4gKiA2LiBQZXJmb3JtYW5jZSB0aHJlc2hvbGRzIGJhc2VkIG9uIGFjdHVhbCBtZWFzdXJlbWVudHNcbiAqIFxuICogVGhpcyBpcyBpZGVhbCBmb3I6XG4gKiAtIE1lbW9yeSBlZmZpY2llbmN5IHZhbGlkYXRpb25cbiAqIC0gUmVzb3VyY2UgbGVhayBkZXRlY3Rpb25cbiAqIC0gU2NhbGFiaWxpdHkgYXNzZXNzbWVudFxuICogLSBQZXJmb3JtYW5jZSBiZW5jaG1hcmtpbmdcbiAqIC0gU3lzdGVtIHJlc291cmNlIG1vbml0b3JpbmdcbiAqLyJdLCJ2ZXJzaW9uIjozfQ==