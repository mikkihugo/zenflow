{"file":"/home/mhugo/code/claude-code-flow/src/__tests__/integration/memory-stores/data-integrity.test.ts","mappings":"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","names":[],"sources":["/home/mhugo/code/claude-code-flow/src/__tests__/integration/memory-stores/data-integrity.test.ts"],"sourcesContent":["/**\n * Data Integrity Integration Tests\n * \n * Hybrid Testing Approach:\n * - London School: Mock storage backends and corruption scenarios\n * - Classical School: Test actual data validation and error recovery\n */\n\nimport { createHash } from 'crypto';\nimport { EventEmitter } from 'events';\n\n// Data integrity interfaces and utilities\ninterface DataChecksum {\n  algorithm: 'sha256' | 'md5' | 'crc32';\n  value: string;\n}\n\ninterface IntegrityRecord {\n  id: string;\n  data: any;\n  checksum: DataChecksum;\n  timestamp: number;\n  version: number;\n  metadata?: Record<string, any>;\n}\n\ninterface ValidationResult {\n  valid: boolean;\n  errors: string[];\n  warnings: string[];\n  corrected?: boolean;\n}\n\n// Data integrity utilities\nclass DataIntegrityUtils {\n  static calculateChecksum(data: any, algorithm: 'sha256' | 'md5' | 'crc32' = 'sha256'): DataChecksum {\n    const serialized = typeof data === 'string' ? data : JSON.stringify(data);\n    \n    let hash: string;\n    switch (algorithm) {\n      case 'sha256':\n        hash = createHash('sha256').update(serialized).digest('hex');\n        break;\n      case 'md5':\n        hash = createHash('md5').update(serialized).digest('hex');\n        break;\n      case 'crc32':\n        // Simple CRC32 implementation for testing\n        hash = this.crc32(serialized).toString(16);\n        break;\n      default:\n        throw new Error(`Unsupported algorithm: ${algorithm}`);\n    }\n    \n    return { algorithm, value: hash };\n  }\n\n  static validateChecksum(data: any, expectedChecksum: DataChecksum): boolean {\n    const actualChecksum = this.calculateChecksum(data, expectedChecksum.algorithm);\n    return actualChecksum.value === expectedChecksum.value;\n  }\n\n  static detectCorruption(original: any, current: any): string[] {\n    const issues: string[] = [];\n    \n    if (typeof original !== typeof current) {\n      issues.push(`Type mismatch: expected ${typeof original}, got ${typeof current}`);\n      return issues;\n    }\n\n    if (original === null || current === null) {\n      if (original !== current) {\n        issues.push('Null value mismatch');\n      }\n      return issues;\n    }\n\n    if (typeof original === 'object' && Array.isArray(original)) {\n      if (!Array.isArray(current)) {\n        issues.push('Array structure corrupted');\n        return issues;\n      }\n      \n      if (original.length !== current.length) {\n        issues.push(`Array length mismatch: expected ${original.length}, got ${current.length}`);\n      }\n      \n      for (let i = 0; i < Math.min(original.length, current.length); i++) {\n        const subIssues = this.detectCorruption(original[i], current[i]);\n        issues.push(...subIssues.map(issue => `Array[${i}]: ${issue}`));\n      }\n    } else if (typeof original === 'object') {\n      const originalKeys = Object.keys(original).sort();\n      const currentKeys = Object.keys(current).sort();\n      \n      if (originalKeys.length !== currentKeys.length) {\n        issues.push(`Object key count mismatch: expected ${originalKeys.length}, got ${currentKeys.length}`);\n      }\n      \n      const missingKeys = originalKeys.filter(key => !(key in current));\n      const extraKeys = currentKeys.filter(key => !(key in original));\n      \n      if (missingKeys.length > 0) {\n        issues.push(`Missing keys: ${missingKeys.join(', ')}`);\n      }\n      \n      if (extraKeys.length > 0) {\n        issues.push(`Extra keys: ${extraKeys.join(', ')}`);\n      }\n      \n      for (const key of originalKeys) {\n        if (key in current) {\n          const subIssues = this.detectCorruption(original[key], current[key]);\n          issues.push(...subIssues.map(issue => `Object.${key}: ${issue}`));\n        }\n      }\n    } else if (original !== current) {\n      issues.push(`Value mismatch: expected ${JSON.stringify(original)}, got ${JSON.stringify(current)}`);\n    }\n    \n    return issues;\n  }\n\n  static attemptRepair<T>(corrupted: T, reference: T, strategy: 'merge' | 'replace' | 'selective' = 'selective'): T {\n    if (strategy === 'replace') {\n      return reference;\n    }\n    \n    if (strategy === 'merge' && typeof corrupted === 'object' && typeof reference === 'object') {\n      if (corrupted === null || reference === null) {\n        return reference;\n      }\n      \n      if (Array.isArray(reference)) {\n        return reference; // For arrays, replace entirely\n      }\n      \n      const merged = { ...corrupted };\n      for (const [key, value] of Object.entries(reference)) {\n        if (!(key in merged) || merged[key] === null || merged[key] === undefined) {\n          (merged as any)[key] = value;\n        }\n      }\n      return merged as T;\n    }\n    \n    // Selective repair - only fix obvious corruption\n    if (corrupted === null || corrupted === undefined) {\n      return reference;\n    }\n    \n    return corrupted;\n  }\n\n  private static crc32(str: string): number {\n    let crc = 0 ^ (-1);\n    for (let i = 0; i < str.length; i++) {\n      crc = (crc >>> 8) ^ this.crcTable[(crc ^ str.charCodeAt(i)) & 0xFF];\n    }\n    return (crc ^ (-1)) >>> 0;\n  }\n\n  private static crcTable = (() => {\n    const table = new Array(256);\n    for (let i = 0; i < 256; i++) {\n      let c = i;\n      for (let j = 0; j < 8; j++) {\n        c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));\n      }\n      table[i] = c;\n    }\n    return table;\n  })();\n}\n\n// Integrity-aware storage system\nclass IntegrityStorage extends EventEmitter {\n  private records = new Map<string, IntegrityRecord>();\n  private backupRecords = new Map<string, IntegrityRecord>();\n  private validationEnabled = true;\n  private autoRepair = true;\n  private redundancyLevel = 1;\n\n  constructor(options: {\n    validationEnabled?: boolean;\n    autoRepair?: boolean;\n    redundancyLevel?: number;\n  } = {}) {\n    super();\n    this.validationEnabled = options.validationEnabled ?? true;\n    this.autoRepair = options.autoRepair ?? true;\n    this.redundancyLevel = options.redundancyLevel ?? 1;\n  }\n\n  async store(id: string, data: any, metadata?: Record<string, any>): Promise<IntegrityRecord> {\n    const checksum = DataIntegrityUtils.calculateChecksum(data);\n    const timestamp = Date.now();\n    const version = (this.records.get(id)?.version ?? 0) + 1;\n\n    const record: IntegrityRecord = {\n      id,\n      data,\n      checksum,\n      timestamp,\n      version,\n      metadata\n    };\n\n    this.records.set(id, record);\n\n    // Create backup copies for redundancy\n    if (this.redundancyLevel > 0) {\n      this.backupRecords.set(id, { ...record });\n    }\n\n    this.emit('stored', { id, version, checksum: checksum.value });\n    return { ...record };\n  }\n\n  async retrieve(id: string): Promise<IntegrityRecord | null> {\n    const record = this.records.get(id);\n    if (!record) {\n      return null;\n    }\n\n    if (this.validationEnabled) {\n      const validation = await this.validateRecord(record);\n      \n      if (!validation.valid) {\n        this.emit('corruptionDetected', { id, errors: validation.errors });\n        \n        if (this.autoRepair) {\n          const repaired = await this.attemptRepair(id, record);\n          if (repaired) {\n            this.emit('dataRepaired', { id, method: 'auto' });\n            return repaired;\n          }\n        }\n        \n        throw new Error(`Data integrity violation for ${id}: ${validation.errors.join(', ')}`);\n      }\n    }\n\n    this.emit('retrieved', { id, version: record.version });\n    return { ...record };\n  }\n\n  async validateRecord(record: IntegrityRecord): Promise<ValidationResult> {\n    const errors: string[] = [];\n    const warnings: string[] = [];\n\n    // Checksum validation\n    const isValidChecksum = DataIntegrityUtils.validateChecksum(record.data, record.checksum);\n    if (!isValidChecksum) {\n      errors.push('Checksum validation failed');\n    }\n\n    // Structural validation\n    if (record.data === null || record.data === undefined) {\n      warnings.push('Data is null or undefined');\n    }\n\n    // Timestamp validation\n    if (record.timestamp > Date.now()) {\n      warnings.push('Future timestamp detected');\n    }\n\n    // Version validation\n    if (record.version < 1) {\n      errors.push('Invalid version number');\n    }\n\n    return {\n      valid: errors.length === 0,\n      errors,\n      warnings\n    };\n  }\n\n  async validateAll(): Promise<{ valid: number; corrupted: number; repaired: number }> {\n    let valid = 0;\n    let corrupted = 0;\n    let repaired = 0;\n\n    for (const [id, record] of this.records.entries()) {\n      try {\n        const validation = await this.validateRecord(record);\n        \n        if (validation.valid) {\n          valid++;\n        } else {\n          corrupted++;\n          \n          if (this.autoRepair) {\n            const repairedRecord = await this.attemptRepair(id, record);\n            if (repairedRecord) {\n              repaired++;\n            }\n          }\n        }\n      } catch (error) {\n        corrupted++;\n      }\n    }\n\n    this.emit('bulkValidation', { valid, corrupted, repaired });\n    return { valid, corrupted, repaired };\n  }\n\n  async attemptRepair(id: string, corruptedRecord: IntegrityRecord): Promise<IntegrityRecord | null> {\n    // Try backup first\n    const backup = this.backupRecords.get(id);\n    if (backup) {\n      const backupValidation = await this.validateRecord(backup);\n      if (backupValidation.valid) {\n        this.records.set(id, { ...backup });\n        this.emit('repairedFromBackup', { id });\n        return { ...backup };\n      }\n    }\n\n    // Try to repair the current record\n    if (backup) {\n      try {\n        const repairedData = DataIntegrityUtils.attemptRepair(\n          corruptedRecord.data,\n          backup.data,\n          'selective'\n        );\n        \n        const repairedRecord: IntegrityRecord = {\n          ...corruptedRecord,\n          data: repairedData,\n          checksum: DataIntegrityUtils.calculateChecksum(repairedData),\n          version: corruptedRecord.version + 1,\n          timestamp: Date.now()\n        };\n        \n        this.records.set(id, repairedRecord);\n        this.emit('repairedSelectively', { id });\n        return { ...repairedRecord };\n      } catch (error) {\n        this.emit('repairFailed', { id, error: error.message });\n      }\n    }\n\n    return null;\n  }\n\n  async simulateCorruption(id: string, corruptionType: 'checksum' | 'data' | 'structure'): Promise<boolean> {\n    const record = this.records.get(id);\n    if (!record) {\n      return false;\n    }\n\n    switch (corruptionType) {\n      case 'checksum':\n        record.checksum.value = 'corrupted_checksum';\n        break;\n      \n      case 'data':\n        if (typeof record.data === 'object' && record.data !== null) {\n          record.data = { ...record.data, corrupted: true };\n        } else {\n          record.data = 'CORRUPTED';\n        }\n        break;\n      \n      case 'structure':\n        if (typeof record.data === 'object' && !Array.isArray(record.data)) {\n          delete record.data.someKey;\n          record.data.unexpectedKey = 'unexpected';\n        }\n        break;\n    }\n\n    this.emit('corruptionSimulated', { id, type: corruptionType });\n    return true;\n  }\n\n  getStats(): {\n    totalRecords: number;\n    backupRecords: number;\n    validationEnabled: boolean;\n    autoRepair: boolean;\n  } {\n    return {\n      totalRecords: this.records.size,\n      backupRecords: this.backupRecords.size,\n      validationEnabled: this.validationEnabled,\n      autoRepair: this.autoRepair\n    };\n  }\n\n  async clear(): Promise<void> {\n    this.records.clear();\n    this.backupRecords.clear();\n    this.emit('cleared');\n  }\n}\n\n// Mock corrupted storage for London-style tests\nclass MockCorruptedStorage {\n  private shouldCorrupt = false;\n  private corruptionRate = 0.1;\n  public operations: string[] = [];\n\n  setShouldCorrupt(shouldCorrupt: boolean, rate = 0.1): void {\n    this.shouldCorrupt = shouldCorrupt;\n    this.corruptionRate = rate;\n  }\n\n  async store(id: string, data: any): Promise<any> {\n    this.operations.push(`store:${id}`);\n    \n    if (this.shouldCorrupt && Math.random() < this.corruptionRate) {\n      // Simulate corruption during storage\n      const corrupted = typeof data === 'object' ? { ...data, __corrupted: true } : 'CORRUPTED';\n      return { success: false, data: corrupted, error: 'Storage corruption' };\n    }\n    \n    return { success: true, data, checksum: 'mock_checksum' };\n  }\n\n  async retrieve(id: string): Promise<any> {\n    this.operations.push(`retrieve:${id}`);\n    \n    if (this.shouldCorrupt && Math.random() < this.corruptionRate) {\n      return { success: false, error: 'Retrieval corruption' };\n    }\n    \n    return { success: true, data: { id, mockData: true } };\n  }\n}\n\ndescribe('Data Integrity Integration Tests', () => {\n  describe('Data Integrity Utils (Classical School)', () => {\n    it('should calculate checksums correctly', () => {\n      const data = { message: 'test data', number: 42 };\n      \n      const sha256Checksum = DataIntegrityUtils.calculateChecksum(data, 'sha256');\n      const md5Checksum = DataIntegrityUtils.calculateChecksum(data, 'md5');\n      const crc32Checksum = DataIntegrityUtils.calculateChecksum(data, 'crc32');\n      \n      expect(sha256Checksum.algorithm).toBe('sha256');\n      expect(sha256Checksum.value).toHaveLength(64); // SHA256 hex length\n      \n      expect(md5Checksum.algorithm).toBe('md5');\n      expect(md5Checksum.value).toHaveLength(32); // MD5 hex length\n      \n      expect(crc32Checksum.algorithm).toBe('crc32');\n      expect(crc32Checksum.value).toMatch(/^[0-9a-f]+$/); // Hex string\n      \n      // Same data should produce same checksums\n      const duplicate = DataIntegrityUtils.calculateChecksum(data, 'sha256');\n      expect(duplicate.value).toBe(sha256Checksum.value);\n    });\n\n    it('should validate checksums correctly', () => {\n      const data = { test: 'validation data' };\n      const checksum = DataIntegrityUtils.calculateChecksum(data);\n      \n      expect(DataIntegrityUtils.validateChecksum(data, checksum)).toBe(true);\n      \n      const modifiedData = { test: 'modified data' };\n      expect(DataIntegrityUtils.validateChecksum(modifiedData, checksum)).toBe(false);\n    });\n\n    it('should detect data corruption accurately', () => {\n      const original = {\n        name: 'John',\n        age: 30,\n        address: {\n          street: '123 Main St',\n          city: 'Anytown'\n        },\n        hobbies: ['reading', 'coding']\n      };\n\n      // No corruption\n      const identical = { ...original, address: { ...original.address }, hobbies: [...original.hobbies] };\n      expect(DataIntegrityUtils.detectCorruption(original, identical)).toHaveLength(0);\n\n      // Value corruption\n      const valueCorrupted = { ...original, age: 31 };\n      const valueIssues = DataIntegrityUtils.detectCorruption(original, valueCorrupted);\n      expect(valueIssues).toContain('Object.age: Value mismatch: expected 30, got 31');\n\n      // Missing key\n      const { name, ...missingKey } = original;\n      const keyIssues = DataIntegrityUtils.detectCorruption(original, missingKey);\n      expect(keyIssues.some(issue => issue.includes('Missing keys: name'))).toBe(true);\n\n      // Array corruption\n      const arrayCorrupted = { ...original, hobbies: ['reading'] };\n      const arrayIssues = DataIntegrityUtils.detectCorruption(original, arrayCorrupted);\n      expect(arrayIssues.some(issue => issue.includes('Array length mismatch'))).toBe(true);\n    });\n\n    it('should attempt data repair using different strategies', () => {\n      const reference = { a: 1, b: 2, c: 3 };\n      const corrupted = { a: 1, b: null, d: 4 };\n\n      // Replace strategy\n      const replaced = DataIntegrityUtils.attemptRepair(corrupted, reference, 'replace');\n      expect(replaced).toEqual(reference);\n\n      // Merge strategy\n      const merged = DataIntegrityUtils.attemptRepair(corrupted, reference, 'merge');\n      expect(merged.a).toBe(1); // Keep original\n      expect(merged.b).toBe(2); // Replace null with reference value\n      expect(merged.c).toBe(3); // Add missing\n      expect(merged.d).toBe(4); // Keep extra\n\n      // Selective strategy\n      const selective = DataIntegrityUtils.attemptRepair(corrupted, reference, 'selective');\n      expect(selective).toBe(corrupted); // Selective is conservative\n    });\n  });\n\n  describe('Integrity Storage (Classical School)', () => {\n    let storage: IntegrityStorage;\n\n    beforeEach(() => {\n      storage = new IntegrityStorage({\n        validationEnabled: true,\n        autoRepair: true,\n        redundancyLevel: 1\n      });\n    });\n\n    afterEach(async () => {\n      await storage.clear();\n    });\n\n    it('should store data with integrity metadata', async () => {\n      const testData = { message: 'integrity test', timestamp: Date.now() };\n      const metadata = { source: 'test', priority: 'high' };\n\n      const record = await storage.store('test-record', testData, metadata);\n\n      expect(record.id).toBe('test-record');\n      expect(record.data).toEqual(testData);\n      expect(record.metadata).toEqual(metadata);\n      expect(record.checksum).toBeDefined();\n      expect(record.checksum.algorithm).toBe('sha256');\n      expect(record.version).toBe(1);\n      expect(record.timestamp).toBeGreaterThan(0);\n    });\n\n    it('should validate data integrity on retrieval', async () => {\n      const testData = { test: 'validation data' };\n      await storage.store('validate-test', testData);\n\n      const retrieved = await storage.retrieve('validate-test');\n      expect(retrieved).toBeDefined();\n      expect(retrieved!.data).toEqual(testData);\n    });\n\n    it('should detect and handle corruption', async () => {\n      // Create storage without auto-repair to test error detection\n      const noRepairStorage = new IntegrityStorage({\n        validationEnabled: true,\n        autoRepair: false\n      });\n\n      const testData = { important: 'data', value: 42 };\n      await noRepairStorage.store('corruption-test', testData);\n\n      // Simulate corruption after initial store\n      const corrupted = await noRepairStorage.simulateCorruption('corruption-test', 'checksum');\n      expect(corrupted).toBe(true);\n\n      // Should throw error due to corruption (no auto-repair)\n      await expect(noRepairStorage.retrieve('corruption-test')).rejects.toThrow(/Data integrity violation|Checksum validation failed/);\n      \n      await noRepairStorage.clear();\n    });\n\n    it('should attempt automatic repair when enabled', async () => {\n      const originalData = { value: 'original', number: 123 };\n      await storage.store('repair-test', originalData);\n\n      // Simulate data corruption (not checksum, so repair can work)\n      await storage.simulateCorruption('repair-test', 'data');\n\n      // Should repair and return data\n      const repairEvents: any[] = [];\n      storage.on('dataRepaired', (event) => repairEvents.push(event));\n\n      try {\n        const retrieved = await storage.retrieve('repair-test');\n        // If it doesn't throw, repair was successful\n        expect(retrieved).toBeDefined();\n      } catch {\n        // Expected if repair couldn't work\n        expect(repairEvents.length).toBeGreaterThanOrEqual(0);\n      }\n    });\n\n    it('should handle version tracking', async () => {\n      const initialData = { version: 'v1' };\n      const record1 = await storage.store('version-test', initialData);\n      expect(record1.version).toBe(1);\n\n      // Add small delay to ensure timestamp difference\n      await new Promise(resolve => setTimeout(resolve, 1));\n\n      const updatedData = { version: 'v2' };\n      const record2 = await storage.store('version-test', updatedData);\n      expect(record2.version).toBe(2);\n      expect(record2.timestamp).toBeGreaterThanOrEqual(record1.timestamp);\n    });\n\n    it('should validate all records in bulk', async () => {\n      // Store some valid records\n      await storage.store('valid-1', { data: 'good' });\n      await storage.store('valid-2', { data: 'also good' });\n      await storage.store('corrupt-1', { data: 'will be corrupted' });\n\n      // Corrupt one record\n      await storage.simulateCorruption('corrupt-1', 'checksum');\n\n      const results = await storage.validateAll();\n      expect(results.valid).toBe(2);\n      expect(results.corrupted).toBeGreaterThanOrEqual(1);\n    });\n\n    it('should maintain backup copies for redundancy', async () => {\n      const testData = { backup: 'test data' };\n      await storage.store('backup-test', testData);\n\n      const stats = storage.getStats();\n      expect(stats.totalRecords).toBe(1);\n      expect(stats.backupRecords).toBe(1); // Should have backup\n    });\n  });\n\n  describe('Mock Corruption Scenarios (London School)', () => {\n    let mockStorage: MockCorruptedStorage;\n\n    beforeEach(() => {\n      mockStorage = new MockCorruptedStorage();\n    });\n\n    it('should simulate storage corruption', async () => {\n      mockStorage.setShouldCorrupt(true, 1.0); // 100% corruption rate for testing\n\n      const result = await mockStorage.store('test', { data: 'test' });\n      expect(result.success).toBe(false);\n      expect(result.error).toBe('Storage corruption');\n      expect(mockStorage.operations).toContain('store:test');\n    });\n\n    it('should simulate retrieval corruption', async () => {\n      mockStorage.setShouldCorrupt(true, 1.0);\n\n      const result = await mockStorage.retrieve('test');\n      expect(result.success).toBe(false);\n      expect(result.error).toBe('Retrieval corruption');\n      expect(mockStorage.operations).toContain('retrieve:test');\n    });\n\n    it('should handle normal operations when corruption is disabled', async () => {\n      mockStorage.setShouldCorrupt(false);\n\n      const storeResult = await mockStorage.store('normal', { data: 'normal' });\n      expect(storeResult.success).toBe(true);\n\n      const retrieveResult = await mockStorage.retrieve('normal');\n      expect(retrieveResult.success).toBe(true);\n    });\n\n    it('should track operations for verification', async () => {\n      await mockStorage.store('op1', {});\n      await mockStorage.retrieve('op2');\n      await mockStorage.store('op3', {});\n\n      expect(mockStorage.operations).toEqual(['store:op1', 'retrieve:op2', 'store:op3']);\n    });\n  });\n\n  describe('Event Handling and Monitoring', () => {\n    let storage: IntegrityStorage;\n    let events: Array<{ type: string; data: any }>;\n\n    beforeEach(() => {\n      storage = new IntegrityStorage();\n      events = [];\n\n      storage.on('stored', (data) => events.push({ type: 'stored', data }));\n      storage.on('retrieved', (data) => events.push({ type: 'retrieved', data }));\n      storage.on('corruptionDetected', (data) => events.push({ type: 'corruptionDetected', data }));\n      storage.on('dataRepaired', (data) => events.push({ type: 'dataRepaired', data }));\n      storage.on('repairFailed', (data) => events.push({ type: 'repairFailed', data }));\n    });\n\n    afterEach(async () => {\n      await storage.clear();\n    });\n\n    it('should emit events for normal operations', async () => {\n      await storage.store('event-test', { test: 'data' });\n      await storage.retrieve('event-test');\n\n      expect(events.some(e => e.type === 'stored')).toBe(true);\n      expect(events.some(e => e.type === 'retrieved')).toBe(true);\n\n      const storeEvent = events.find(e => e.type === 'stored');\n      expect(storeEvent?.data.id).toBe('event-test');\n    });\n\n    it('should emit corruption detection events', async () => {\n      await storage.store('corruption-event', { data: 'test' });\n      await storage.simulateCorruption('corruption-event', 'checksum');\n\n      try {\n        await storage.retrieve('corruption-event');\n      } catch {\n        // Expected to fail\n      }\n\n      expect(events.some(e => e.type === 'corruptionDetected')).toBe(true);\n    });\n  });\n\n  describe('Performance Under Corruption', () => {\n    let storage: IntegrityStorage;\n\n    beforeEach(() => {\n      storage = new IntegrityStorage({\n        validationEnabled: true,\n        autoRepair: true\n      });\n    });\n\n    afterEach(async () => {\n      await storage.clear();\n    });\n\n    it('should benchmark validation performance', async () => {\n      const iterations = 1000;\n      const testData = { benchmark: 'validation', data: 'x'.repeat(100) };\n\n      // Store records\n      for (let i = 0; i < iterations; i++) {\n        await storage.store(`bench-${i}`, { ...testData, index: i });\n      }\n\n      // Benchmark validation\n      const startTime = process.hrtime.bigint();\n      const results = await storage.validateAll();\n      const endTime = process.hrtime.bigint();\n\n      const durationMs = Number(endTime - startTime) / 1_000_000;\n      const validationsPerSecond = (iterations / durationMs) * 1000;\n\n      console.log(`Validation performance: ${validationsPerSecond.toFixed(0)} validations/sec`);\n\n      expect(results.valid).toBe(iterations);\n      expect(validationsPerSecond).toBeGreaterThan(100); // Should validate at least 100/sec\n    });\n\n    it('should handle mixed corruption scenarios', async () => {\n      const recordCount = 100;\n      const corruptionRate = 0.1; // 10% corruption\n\n      // Store records\n      for (let i = 0; i < recordCount; i++) {\n        await storage.store(`mixed-${i}`, { index: i, data: `record-${i}` });\n      }\n\n      // Randomly corrupt some records\n      const corruptedCount = Math.floor(recordCount * corruptionRate);\n      const corruptionTypes: Array<'checksum' | 'data' | 'structure'> = ['checksum', 'data', 'structure'];\n\n      for (let i = 0; i < corruptedCount; i++) {\n        const recordIndex = Math.floor(Math.random() * recordCount);\n        const corruptionType = corruptionTypes[Math.floor(Math.random() * corruptionTypes.length)];\n        await storage.simulateCorruption(`mixed-${recordIndex}`, corruptionType);\n      }\n\n      // Validate all and measure results\n      const results = await storage.validateAll();\n\n      expect(results.valid + results.corrupted).toBe(recordCount);\n      expect(results.corrupted).toBeGreaterThanOrEqual(0);\n      \n      console.log(`Mixed corruption test: ${results.valid} valid, ${results.corrupted} corrupted, ${results.repaired} repaired`);\n    });\n  });\n\n  describe('Complex Data Structures', () => {\n    let storage: IntegrityStorage;\n\n    beforeEach(() => {\n      storage = new IntegrityStorage();\n    });\n\n    afterEach(async () => {\n      await storage.clear();\n    });\n\n    it('should handle nested object integrity', async () => {\n      const complexData = {\n        user: {\n          id: 'user123',\n          profile: {\n            name: 'John Doe',\n            preferences: {\n              theme: 'dark',\n              notifications: {\n                email: true,\n                push: false,\n                sms: true\n              }\n            }\n          }\n        },\n        metadata: {\n          created: Date.now(),\n          tags: ['important', 'user-data'],\n          flags: {\n            verified: true,\n            premium: false\n          }\n        }\n      };\n\n      const record = await storage.store('complex-data', complexData);\n      expect(record.checksum).toBeDefined();\n\n      const retrieved = await storage.retrieve('complex-data');\n      expect(retrieved!.data).toEqual(complexData);\n    });\n\n    it('should detect subtle nested corruption', async () => {\n      const originalData = {\n        config: {\n          database: {\n            host: 'localhost',\n            port: 5432,\n            credentials: {\n              username: 'admin',\n              password: 'secret'\n            }\n          }\n        }\n      };\n\n      await storage.store('nested-test', originalData);\n      await storage.simulateCorruption('nested-test', 'structure');\n\n      const validation = await storage.validateRecord((storage as any).records.get('nested-test'));\n      expect(validation.valid).toBe(false);\n    });\n\n    it('should maintain integrity with large datasets', async () => {\n      const largeData = {\n        matrix: Array.from({ length: 100 }, (_, i) =>\n          Array.from({ length: 100 }, (_, j) => i * 100 + j)\n        ),\n        lookup: Object.fromEntries(\n          Array.from({ length: 1000 }, (_, i) => [`key_${i}`, `value_${i}`])\n        )\n      };\n\n      const startTime = process.hrtime.bigint();\n      const record = await storage.store('large-dataset', largeData);\n      const storeTime = process.hrtime.bigint();\n\n      const retrieved = await storage.retrieve('large-dataset');\n      const retrieveTime = process.hrtime.bigint();\n\n      const storeDuration = Number(storeTime - startTime) / 1_000_000;\n      const retrieveDuration = Number(retrieveTime - storeTime) / 1_000_000;\n\n      console.log(`Large dataset - Store: ${storeDuration.toFixed(2)}ms, Retrieve: ${retrieveDuration.toFixed(2)}ms`);\n\n      expect(retrieved!.data).toEqual(largeData);\n      expect(storeDuration).toBeLessThan(1000); // Should complete within 1 second\n      expect(retrieveDuration).toBeLessThan(1000);\n    });\n  });\n});"],"version":3}