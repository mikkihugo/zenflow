02a051c759f43333b4d027fb1220eb0a
/**
 * Argument Parser Tests - TDD London School
 *
 * Tests the behavior of argument parsing functionality using mocks
 * and interaction-based testing. Focuses on how the parser collaborates
 * with other components rather than testing implementation details.
 */
import { jest } from '@jest/globals';
// Mock implementation for testing
class MockArgumentParser {
    options = {};
    commands = new Map();
    parseFunction;
    validateFunction;
    constructor(parseFunction, validateFunction) {
        this.parseFunction = parseFunction || jest.fn();
        this.validateFunction = validateFunction || jest.fn();
    }
    parse(args) {
        return this.parseFunction(args);
    }
    setOptions(options) {
        this.options = { ...this.options, ...options };
    }
    addCommand(config) {
        this.commands.set(config.name, config);
        config.aliases?.forEach(alias => {
            this.commands.set(alias, config);
        });
    }
    getHelp() {
        return 'Mock help text';
    }
    validate(result) {
        return this.validateFunction(result);
    }
    // Test helpers
    getOptions() {
        return { ...this.options };
    }
    hasCommand(name) {
        return this.commands.has(name);
    }
    getCommand(name) {
        return this.commands.get(name);
    }
}
describe('ArgumentParser - TDD London', () => {
    let parser;
    let mockParseFunction;
    let mockValidateFunction;
    beforeEach(() => {
        mockParseFunction = jest.fn();
        mockValidateFunction = jest.fn();
        parser = new MockArgumentParser(mockParseFunction, mockValidateFunction);
    });
    describe('parsing behavior', () => {
        it('should parse simple command with arguments', () => {
            // Arrange
            const args = ['status', 'arg1', 'arg2'];
            const expectedResult = {
                command: 'status',
                args: ['arg1', 'arg2'],
                flags: {},
                unknown: [],
                raw: args
            };
            mockParseFunction.mockReturnValue(expectedResult);
            // Act
            const result = parser.parse(args);
            // Assert - verify parser behavior through result
            expect(mockParseFunction).toHaveBeenCalledWith(args);
            expect(result).toEqual(expectedResult);
        });
        it('should parse command with flags', () => {
            // Arrange
            const args = ['deploy', '--verbose', '--env', 'production', 'app'];
            const expectedResult = {
                command: 'deploy',
                args: ['app'],
                flags: {
                    verbose: true,
                    env: 'production'
                },
                unknown: [],
                raw: args
            };
            mockParseFunction.mockReturnValue(expectedResult);
            // Act
            const result = parser.parse(args);
            // Assert - verify flag parsing behavior
            expect(result.flags).toEqual({
                verbose: true,
                env: 'production'
            });
            expect(result.args).toEqual(['app']);
        });
        it('should handle unknown flags based on options', () => {
            // Arrange
            parser.setOptions({ allowUnknownFlags: false });
            const args = ['command', '--unknown-flag', 'value'];
            const expectedResult = {
                command: 'command',
                args: [],
                flags: {},
                unknown: ['--unknown-flag', 'value'],
                raw: args
            };
            mockParseFunction.mockReturnValue(expectedResult);
            // Act
            const result = parser.parse(args);
            // Assert - verify unknown flag handling
            expect(result.unknown).toContain('--unknown-flag');
            expect(mockParseFunction).toHaveBeenCalledWith(args);
        });
        it('should handle boolean flags correctly', () => {
            // Arrange
            const args = ['test', '--debug', '--no-verbose'];
            const expectedResult = {
                command: 'test',
                args: [],
                flags: {
                    debug: true,
                    verbose: false
                },
                unknown: [],
                raw: args
            };
            mockParseFunction.mockReturnValue(expectedResult);
            // Act
            const result = parser.parse(args);
            // Assert - verify boolean flag behavior
            expect(result.flags.debug).toBe(true);
            expect(result.flags.verbose).toBe(false);
        });
        it('should parse array flags', () => {
            // Arrange
            const args = ['build', '--include', 'file1.js', '--include', 'file2.js'];
            const expectedResult = {
                command: 'build',
                args: [],
                flags: {
                    include: ['file1.js', 'file2.js']
                },
                unknown: [],
                raw: args
            };
            mockParseFunction.mockReturnValue(expectedResult);
            // Act
            const result = parser.parse(args);
            // Assert - verify array flag behavior
            expect(result.flags.include).toEqual(['file1.js', 'file2.js']);
        });
    });
    describe('command definition behavior', () => {
        it('should register command with configuration', () => {
            // Arrange
            const commandConfig = {
                name: 'deploy',
                description: 'Deploy application',
                aliases: ['d'],
                flags: [
                    {
                        name: 'env',
                        type: 'string',
                        description: 'Environment to deploy to',
                        required: true
                    },
                    {
                        name: 'verbose',
                        type: 'boolean',
                        description: 'Verbose output',
                        aliases: ['v']
                    }
                ],
                args: [
                    {
                        name: 'target',
                        description: 'Deployment target',
                        required: true
                    }
                ]
            };
            // Act
            parser.addCommand(commandConfig);
            // Assert - verify command registration behavior
            expect(parser.hasCommand('deploy')).toBe(true);
            expect(parser.hasCommand('d')).toBe(true); // alias
            expect(parser.getCommand('deploy')).toEqual(commandConfig);
        });
        it('should register multiple commands without conflicts', () => {
            // Arrange
            const cmd1 = { name: 'start', description: 'Start service' };
            const cmd2 = { name: 'stop', description: 'Stop service' };
            // Act
            parser.addCommand(cmd1);
            parser.addCommand(cmd2);
            // Assert - verify multiple command registration
            expect(parser.hasCommand('start')).toBe(true);
            expect(parser.hasCommand('stop')).toBe(true);
            expect(parser.getCommand('start')).toEqual(cmd1);
            expect(parser.getCommand('stop')).toEqual(cmd2);
        });
        it('should handle command aliases correctly', () => {
            // Arrange
            const commandConfig = {
                name: 'status',
                aliases: ['st', 'stat', 's']
            };
            // Act
            parser.addCommand(commandConfig);
            // Assert - verify alias behavior
            const aliases = ['st', 'stat', 's'];
            aliases.forEach(alias => {
                expect(parser.hasCommand(alias)).toBe(true);
                expect(parser.getCommand(alias)).toBe(commandConfig);
            });
        });
    });
    describe('validation behavior', () => {
        it('should validate parsed result and return validation errors', () => {
            // Arrange
            const parseResult = {
                command: 'deploy',
                args: [],
                flags: { env: 'production' },
                unknown: [],
                raw: ['deploy', '--env', 'production']
            };
            const validationResult = {
                valid: false,
                errors: ['Missing required argument: target'],
                warnings: []
            };
            mockValidateFunction.mockReturnValue(validationResult);
            // Act
            const result = parser.validate(parseResult);
            // Assert - verify validation behavior
            expect(mockValidateFunction).toHaveBeenCalledWith(parseResult);
            expect(result).toEqual(validationResult);
            expect(result.valid).toBe(false);
            expect(result.errors).toContain('Missing required argument: target');
        });
        it('should validate required flags', () => {
            // Arrange
            const parseResult = {
                command: 'deploy',
                args: ['app'],
                flags: {}, // Missing required --env flag
                unknown: [],
                raw: ['deploy', 'app']
            };
            const validationResult = {
                valid: false,
                errors: ['Required flag --env is missing'],
                warnings: []
            };
            mockValidateFunction.mockReturnValue(validationResult);
            // Act
            const result = parser.validate(parseResult);
            // Assert - verify required flag validation
            expect(result.valid).toBe(false);
            expect(result.errors).toContain('Required flag --env is missing');
        });
        it('should validate flag types', () => {
            // Arrange
            const parseResult = {
                command: 'config',
                args: [],
                flags: {
                    port: 'not-a-number' // Should be number
                },
                unknown: [],
                raw: ['config', '--port', 'not-a-number']
            };
            const validationResult = {
                valid: false,
                errors: ['Flag --port must be a number'],
                warnings: []
            };
            mockValidateFunction.mockReturnValue(validationResult);
            // Act
            const result = parser.validate(parseResult);
            // Assert - verify type validation behavior
            expect(result.valid).toBe(false);
            expect(result.errors).toContain('Flag --port must be a number');
        });
        it('should return warnings for deprecated flags', () => {
            // Arrange
            const parseResult = {
                command: 'build',
                args: [],
                flags: {
                    'old-flag': true
                },
                unknown: [],
                raw: ['build', '--old-flag']
            };
            const validationResult = {
                valid: true,
                errors: [],
                warnings: ['Flag --old-flag is deprecated, use --new-flag instead']
            };
            mockValidateFunction.mockReturnValue(validationResult);
            // Act
            const result = parser.validate(parseResult);
            // Assert - verify warning behavior
            expect(result.valid).toBe(true);
            expect(result.warnings).toContain('Flag --old-flag is deprecated, use --new-flag instead');
        });
    });
    describe('options configuration behavior', () => {
        it('should apply parser options correctly', () => {
            // Arrange
            const options = {
                allowUnknownFlags: true,
                allowUnknownCommands: false,
                stopAtFirstUnknown: true,
                flagPrefix: '--',
                helpFlag: ['help', 'h'],
                versionFlag: ['version', 'v']
            };
            // Act
            parser.setOptions(options);
            // Assert - verify options application
            const appliedOptions = parser.getOptions();
            expect(appliedOptions).toEqual(options);
        });
        it('should merge options with existing configuration', () => {
            // Arrange
            parser.setOptions({ allowUnknownFlags: true });
            parser.setOptions({ allowUnknownCommands: false });
            // Act
            const options = parser.getOptions();
            // Assert - verify option merging behavior
            expect(options.allowUnknownFlags).toBe(true);
            expect(options.allowUnknownCommands).toBe(false);
        });
    });
    describe('help generation behavior', () => {
        it('should generate help text', () => {
            // Act
            const help = parser.getHelp();
            // Assert - verify help generation
            expect(help).toBe('Mock help text');
        });
    });
    describe('edge case behavior', () => {
        it('should handle empty argument array', () => {
            // Arrange
            const expectedResult = {
                command: null,
                args: [],
                flags: {},
                unknown: [],
                raw: []
            };
            mockParseFunction.mockReturnValue(expectedResult);
            // Act
            const result = parser.parse([]);
            // Assert - verify empty args handling
            expect(mockParseFunction).toHaveBeenCalledWith([]);
            expect(result.command).toBeNull();
            expect(result.args).toEqual([]);
        });
        it('should handle flags without values', () => {
            // Arrange
            const args = ['command', '--flag-without-value'];
            const expectedResult = {
                command: 'command',
                args: [],
                flags: {
                    'flag-without-value': true // Boolean flag
                },
                unknown: [],
                raw: args
            };
            mockParseFunction.mockReturnValue(expectedResult);
            // Act
            const result = parser.parse(args);
            // Assert - verify flag without value handling
            expect(result.flags['flag-without-value']).toBe(true);
        });
        it('should handle special characters in arguments', () => {
            // Arrange
            const args = ['deploy', '--message', 'Deploy v1.0.0 with "quotes" and spaces'];
            const expectedResult = {
                command: 'deploy',
                args: [],
                flags: {
                    message: 'Deploy v1.0.0 with "quotes" and spaces'
                },
                unknown: [],
                raw: args
            };
            mockParseFunction.mockReturnValue(expectedResult);
            // Act
            const result = parser.parse(args);
            // Assert - verify special character handling
            expect(result.flags.message).toBe('Deploy v1.0.0 with "quotes" and spaces');
        });
        it('should handle variadic arguments', () => {
            // Arrange
            const args = ['process', 'file1.js', 'file2.js', 'file3.js'];
            const expectedResult = {
                command: 'process',
                args: ['file1.js', 'file2.js', 'file3.js'],
                flags: {},
                unknown: [],
                raw: args
            };
            mockParseFunction.mockReturnValue(expectedResult);
            // Act
            const result = parser.parse(args);
            // Assert - verify variadic argument handling
            expect(result.args).toEqual(['file1.js', 'file2.js', 'file3.js']);
        });
    });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL2hvbWUvbWh1Z28vY29kZS9jbGF1ZGUtY29kZS1mbG93L3NyYy9fX3Rlc3RzX18vdW5pdC9sb25kb24vY2xpLWNvbW1hbmRzL2FyZ3VtZW50LXBhcnNlci50ZXN0LnRzIiwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7R0FNRztBQUVILE9BQU8sRUFBRSxJQUFJLEVBQUUsTUFBTSxlQUFlLENBQUM7QUEwRHJDLGtDQUFrQztBQUNsQyxNQUFNLGtCQUFrQjtJQUNkLE9BQU8sR0FBa0IsRUFBRSxDQUFDO0lBQzVCLFFBQVEsR0FBRyxJQUFJLEdBQUcsRUFBNkIsQ0FBQztJQUNoRCxhQUFhLENBQVk7SUFDekIsZ0JBQWdCLENBQVk7SUFFcEMsWUFBWSxhQUF5QixFQUFFLGdCQUE0QjtRQUNqRSxJQUFJLENBQUMsYUFBYSxHQUFHLGFBQWEsSUFBSSxJQUFJLENBQUMsRUFBRSxFQUFFLENBQUM7UUFDaEQsSUFBSSxDQUFDLGdCQUFnQixHQUFHLGdCQUFnQixJQUFJLElBQUksQ0FBQyxFQUFFLEVBQUUsQ0FBQztJQUN4RCxDQUFDO0lBRUQsS0FBSyxDQUFDLElBQWM7UUFDbEIsT0FBTyxJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQ2xDLENBQUM7SUFFRCxVQUFVLENBQUMsT0FBc0I7UUFDL0IsSUFBSSxDQUFDLE9BQU8sR0FBRyxFQUFFLEdBQUcsSUFBSSxDQUFDLE9BQU8sRUFBRSxHQUFHLE9BQU8sRUFBRSxDQUFDO0lBQ2pELENBQUM7SUFFRCxVQUFVLENBQUMsTUFBeUI7UUFDbEMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLElBQUksRUFBRSxNQUFNLENBQUMsQ0FBQztRQUN2QyxNQUFNLENBQUMsT0FBTyxFQUFFLE9BQU8sQ0FBQyxLQUFLLENBQUMsRUFBRTtZQUM5QixJQUFJLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxLQUFLLEVBQUUsTUFBTSxDQUFDLENBQUM7UUFDbkMsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDO0lBRUQsT0FBTztR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LEVBQUUsSUFBSTthQUNWLENBQUM7WUFDRixpQkFBaUIsQ0FBQyxlQUFlLENBQUMsY0FBYyxDQUFDLENBQUM7WUFFbEQsTUFBTTtZQUNOLE1BQU0sTUFBTSxHQUFHLE1BQU0sQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUM7WUFFbEMsNkNBQTZDO1lBQzdDLE1BQU0sQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLElBQUksQ0FBQyx3Q0FBd0MsQ0FBQyxDQUFDO1FBQzlFLENBQUMsQ0FBQyxDQUFDO1FBRUgsRUFBRSxDQUFDLGtDQUFrQyxFQUFFLEdBQUcsRUFBRTtZQUMxQyxVQUFVO1lBQ1YsTUFBTSxJQUFJLEdBQUcsQ0FBQyxTQUFTLEVBQUUsVUFBVSxFQUFFLFVBQVUsRUFBRSxVQUFVLENBQUMsQ0FBQztZQUM3RCxNQUFNLGNBQWMsR0FBZ0I7Z0JBQ2xDLE9BQU8sRUFBRSxTQUFTO2dCQUNsQixJQUFJLEVBQUUsQ0FBQyxVQUFVLEVBQUUsVUFBVSxFQUFFLFVBQVUsQ0FBQztnQkFDMUMsS0FBSyxFQUFFLEVBQUU7Z0JBQ1QsT0FBTyxFQUFFLEVBQUU7Z0JBQ1gsR0FBRyxFQUFFLElBQUk7YUFDVixDQUFDO1lBQ0YsaUJBQWlCLENBQUMsZUFBZSxDQUFDLGNBQWMsQ0FBQyxDQUFDO1lBRWxELE1BQU07WUFDTixNQUFNLE1BQU0sR0FBRyxNQUFNLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDO1lBRWxDLDZDQUE2QztZQUM3QyxNQUFNLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLFVBQVUsRUFBRSxVQUFVLEVBQUUsVUFBVSxDQUFDLENBQUMsQ0FBQztRQUNwRSxDQUFDLENBQUMsQ0FBQztJQUNMLENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQyxDQUFDLENBQUMiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiL2hvbWUvbWh1Z28vY29kZS9jbGF1ZGUtY29kZS1mbG93L3NyYy9fX3Rlc3RzX18vdW5pdC9sb25kb24vY2xpLWNvbW1hbmRzL2FyZ3VtZW50LXBhcnNlci50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQXJndW1lbnQgUGFyc2VyIFRlc3RzIC0gVEREIExvbmRvbiBTY2hvb2xcbiAqIFxuICogVGVzdHMgdGhlIGJlaGF2aW9yIG9mIGFyZ3VtZW50IHBhcnNpbmcgZnVuY3Rpb25hbGl0eSB1c2luZyBtb2Nrc1xuICogYW5kIGludGVyYWN0aW9uLWJhc2VkIHRlc3RpbmcuIEZvY3VzZXMgb24gaG93IHRoZSBwYXJzZXIgY29sbGFib3JhdGVzXG4gKiB3aXRoIG90aGVyIGNvbXBvbmVudHMgcmF0aGVyIHRoYW4gdGVzdGluZyBpbXBsZW1lbnRhdGlvbiBkZXRhaWxzLlxuICovXG5cbmltcG9ydCB7IGplc3QgfSBmcm9tICdAamVzdC9nbG9iYWxzJztcblxuLy8gTW9jayBhcmd1bWVudCBwYXJzZXIgaW50ZXJmYWNlIGZvciB0ZXN0aW5nIGludGVyYWN0aW9uc1xuaW50ZXJmYWNlIEFyZ3VtZW50UGFyc2VyIHtcbiAgcGFyc2UoYXJnczogc3RyaW5nW10pOiBQYXJzZVJlc3VsdDtcbiAgc2V0T3B0aW9ucyhvcHRpb25zOiBQYXJzZXJPcHRpb25zKTogdm9pZDtcbiAgYWRkQ29tbWFuZChjb25maWc6IENvbW1hbmREZWZpbml0aW9uKTogdm9pZDtcbiAgZ2V0SGVscCgpOiBzdHJpbmc7XG4gIHZhbGlkYXRlKHJlc3VsdDogUGFyc2VSZXN1bHQpOiBWYWxpZGF0aW9uUmVzdWx0O1xufVxuXG5pbnRlcmZhY2UgUGFyc2VSZXN1bHQge1xuICBjb21tYW5kOiBzdHJpbmcgfCBudWxsO1xuICBhcmdzOiBzdHJpbmdbXTtcbiAgZmxhZ3M6IFJlY29yZDxzdHJpbmcsIHVua25vd24+O1xuICB1bmtub3duOiBzdHJpbmdbXTtcbiAgcmF3OiBzdHJpbmdbXTtcbn1cblxuaW50ZXJmYWNlIFBhcnNlck9wdGlvbnMge1xuICBhbGxvd1Vua25vd25GbGFncz86IGJvb2xlYW47XG4gIGFsbG93VW5rbm93bkNvbW1hbmRzPzogYm9vbGVhbjtcbiAgc3RvcEF0Rmlyc3RVbmtub3duPzogYm9vbGVhbjtcbiAgZmxhZ1ByZWZpeD86IHN0cmluZztcbiAgaGVscEZsYWc/OiBzdHJpbmcgfCBzdHJpbmdbXTtcbiAgdmVyc2lvbkZsYWc/OiBzdHJpbmcgfCBzdHJpbmdbXTtcbn1cblxuaW50ZXJmYWNlIENvbW1hbmREZWZpbml0aW9uIHtcbiAgbmFtZTogc3RyaW5nO1xuICBkZXNjcmlwdGlvbj86IHN0cmluZztcbiAgYWxpYXNlcz86IHN0cmluZ1tdO1xuICBmbGFncz86IEZsYWdEZWZpbml0aW9uW107XG4gIGFyZ3M/OiBBcmd1bWVudERlZmluaXRpb25bXTtcbn1cblxuaW50ZXJmYWNlIEZsYWdEZWZpbml0aW9uIHtcbiAgbmFtZTogc3RyaW5nO1xuICB0eXBlOiAnYm9vbGVhbicgfCAnc3RyaW5nJyB8ICdudW1iZXInIHwgJ2FycmF5JztcbiAgZGVzY3JpcHRpb24/OiBzdHJpbmc7XG4gIGFsaWFzZXM/OiBzdHJpbmdbXTtcbiAgcmVxdWlyZWQ/OiBib29sZWFuO1xuICBkZWZhdWx0PzogdW5rbm93bjtcbn1cblxuaW50ZXJmYWNlIEFyZ3VtZW50RGVmaW5pdGlvbiB7XG4gIG5hbWU6IHN0cmluZztcbiAgZGVzY3JpcHRpb24/OiBzdHJpbmc7XG4gIHJlcXVpcmVkPzogYm9vbGVhbjtcbiAgdmFyaWFkaWM/OiBib29sZWFuO1xufVxuXG5pbnRlcmZhY2UgVmFsaWRhdGlvblJlc3VsdCB7XG4gIHZhbGlkOiBib29sZWFuO1xuICBlcnJvcnM6IHN0cmluZ1tdO1xuICB3YXJuaW5nczogc3RyaW5nW107XG59XG5cbi8vIE1vY2sgaW1wbGVtZW50YXRpb24gZm9yIHRlc3RpbmdcbmNsYXNzIE1vY2tBcmd1bWVudFBhcnNlciBpbXBsZW1lbnRzIEFyZ3VtZW50UGFyc2VyIHtcbiAgcHJpdmF0ZSBvcHRpb25zOiBQYXJzZXJPcHRpb25zID0ge307XG4gIHByaXZhdGUgY29tbWFuZHMgPSBuZXcgTWFwPHN0cmluZywgQ29tbWFuZERlZmluaXRpb24+KCk7XG4gIHByaXZhdGUgcGFyc2VGdW5jdGlvbjogamVzdC5Nb2NrO1xuICBwcml2YXRlIHZhbGlkYXRlRnVuY3Rpb246IGplc3QuTW9jaztcblxuICBjb25zdHJ1Y3RvcihwYXJzZUZ1bmN0aW9uPzogamVzdC5Nb2NrLCB2YWxpZGF0ZUZ1bmN0aW9uPzogamVzdC5Nb2NrKSB7XG4gICAgdGhpcy5wYXJzZUZ1bmN0aW9uID0gcGFyc2VGdW5jdGlvbiB8fCBqZXN0LmZuKCk7XG4gICAgdGhpcy52YWxpZGF0ZUZ1bmN0aW9uID0gdmFsaWRhdGVGdW5jdGlvbiB8fCBqZXN0LmZuKCk7XG4gIH1cblxuICBwYXJzZShhcmdzOiBzdHJpbmdbXSk6IFBhcnNlUmVzdWx0IHtcbiAgICByZXR1cm4gdGhpcy5wYXJzZUZ1bmN0aW9uKGFyZ3MpO1xuICB9XG5cbiAgc2V0T3B0aW9ucyhvcHRpb25zOiBQYXJzZXJPcHRpb25zKTogdm9pZCB7XG4gICAgdGhpcy5vcHRpb25zID0geyAuLi50aGlzLm9wdGlvbnMsIC4uLm9wdGlvbnMgfTtcbiAgfVxuXG4gIGFkZENvbW1hbmQoY29uZmlnOiBDb21tYW5kRGVmaW5pdGlvbik6IHZvaWQge1xuICAgIHRoaXMuY29tbWFuZHMuc2V0KGNvbmZpZy5uYW1lLCBjb25maWcpO1xuICAgIGNvbmZpZy5hbGlhc2VzPy5mb3JFYWNoKGFsaWFzID0+IHtcbiAgICAgIHRoaXMuY29tbWFuZHMuc2V0KGFsaWFzLCBjb25maWcpO1xuICAgIH0pO1xuICB9XG5cbiAgZ2V0SGVscCgpOiBzdHJpbmcge1xuICAgIHJldHVybiAnTW9jayBoZWxwIHRleHQnO1xuICB9XG5cbiAgdmFsaWRhdGUocmVzdWx0OiBQYXJzZVJlc3VsdCk6IFZhbGlkYXRpb25SZXN1bHQge1xuICAgIHJldHVybiB0aGlzLnZhbGlkYXRlRnVuY3Rpb24ocmVzdWx0KTtcbiAgfVxuXG4gIC8vIFRlc3QgaGVscGVyc1xuICBnZXRPcHRpb25zKCk6IFBhcnNlck9wdGlvbnMge1xuICAgIHJldHVybiB7IC4uLnRoaXMub3B0aW9ucyB9O1xuICB9XG5cbiAgaGFzQ29tbWFuZChuYW1lOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5jb21tYW5kcy5oYXMobmFtZSk7XG4gIH1cblxuICBnZXRDb21tYW5kKG5hbWU6IHN0cmluZyk6IENvbW1hbmREZWZpbml0aW9uIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy5jb21tYW5kcy5nZXQobmFtZSk7XG4gIH1cbn1cblxuZGVzY3JpYmUoJ0FyZ3VtZW50UGFyc2VyIC0gVEREIExvbmRvbicsICgpID0+IHtcbiAgbGV0IHBhcnNlcjogTW9ja0FyZ3VtZW50UGFyc2VyO1xuICBsZXQgbW9ja1BhcnNlRnVuY3Rpb246IGplc3QuTW9jaztcbiAgbGV0IG1vY2tWYWxpZGF0ZUZ1bmN0aW9uOiBqZXN0Lk1vY2s7XG5cbiAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgbW9ja1BhcnNlRnVuY3Rpb24gPSBqZXN0LmZuKCk7XG4gICAgbW9ja1ZhbGlkYXRlRnVuY3Rpb24gPSBqZXN0LmZuKCk7XG4gICAgcGFyc2VyID0gbmV3IE1vY2tBcmd1bWVudFBhcnNlcihtb2NrUGFyc2VGdW5jdGlvbiwgbW9ja1ZhbGlkYXRlRnVuY3Rpb24pO1xuICB9KTtcblxuICBkZXNjcmliZSgncGFyc2luZyBiZWhhdmlvcicsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIHBhcnNlIHNpbXBsZSBjb21tYW5kIHdpdGggYXJndW1lbnRzJywgKCkgPT4ge1xuICAgICAgLy8gQXJyYW5nZVxuICAgICAgY29uc3QgYXJncyA9IFsnc3RhdHVzJywgJ2FyZzEnLCAnYXJnMiddO1xuICAgICAgY29uc3QgZXhwZWN0ZWRSZXN1bHQ6IFBhcnNlUmVzdWx0ID0ge1xuICAgICAgICBjb21tYW5kOiAnc3RhdHVzJyxcbiAgICAgICAgYXJnczogWydhcmcxJywgJ2FyZzInXSxcbiAgICAgICAgZmxhZ3M6IHt9LFxuICAgICAgICB1bmtub3duOiBbXSxcbiAgICAgICAgcmF3OiBhcmdzXG4gICAgICB9O1xuICAgICAgbW9ja1BhcnNlRnVuY3Rpb24ubW9ja1JldHVyblZhbHVlKGV4cGVjdGVkUmVzdWx0KTtcblxuICAgICAgLy8gQWN0XG4gICAgICBjb25zdCByZXN1bHQgPSBwYXJzZXIucGFyc2UoYXJncyk7XG5cbiAgICAgIC8vIEFzc2VydCAtIHZlcmlmeSBwYXJzZXIgYmVoYXZpb3IgdGhyb3VnaCByZXN1bHRcbiAgICAgIGV4cGVjdChtb2NrUGFyc2VGdW5jdGlvbikudG9IYXZlQmVlbkNhbGxlZFdpdGgoYXJncyk7XG4gICAgICBleHBlY3QocmVzdWx0KS50b0VxdWFsKGV4cGVjdGVkUmVzdWx0KTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcGFyc2UgY29tbWFuZCB3aXRoIGZsYWdzJywgKCkgPT4ge1xuICAgICAgLy8gQXJyYW5nZVxuICAgICAgY29uc3QgYXJncyA9IFsnZGVwbG95JywgJy0tdmVyYm9zZScsICctLWVudicsICdwcm9kdWN0aW9uJywgJ2FwcCddO1xuICAgICAgY29uc3QgZXhwZWN0ZWRSZXN1bHQ6IFBhcnNlUmVzdWx0ID0ge1xuICAgICAgICBjb21tYW5kOiAnZGVwbG95JyxcbiAgICAgICAgYXJnczogWydhcHAnXSxcbiAgICAgICAgZmxhZ3M6IHtcbiAgICAgICAgICB2ZXJib3NlOiB0cnVlLFxuICAgICAgICAgIGVudjogJ3Byb2R1Y3Rpb24nXG4gICAgICAgIH0sXG4gICAgICAgIHVua25vd246IFtdLFxuICAgICAgICByYXc6IGFyZ3NcbiAgICAgIH07XG4gICAgICBtb2NrUGFyc2VGdW5jdGlvbi5tb2NrUmV0dXJuVmFsdWUoZXhwZWN0ZWRSZXN1bHQpO1xuXG4gICAgICAvLyBBY3RcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHBhcnNlci5wYXJzZShhcmdzKTtcblxuICAgICAgLy8gQXNzZXJ0IC0gdmVyaWZ5IGZsYWcgcGFyc2luZyBiZWhhdmlvclxuICAgICAgZXhwZWN0KHJlc3VsdC5mbGFncykudG9FcXVhbCh7XG4gICAgICAgIHZlcmJvc2U6IHRydWUsXG4gICAgICAgIGVudjogJ3Byb2R1Y3Rpb24nXG4gICAgICB9KTtcbiAgICAgIGV4cGVjdChyZXN1bHQuYXJncykudG9FcXVhbChbJ2FwcCddKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIHVua25vd24gZmxhZ3MgYmFzZWQgb24gb3B0aW9ucycsICgpID0+IHtcbiAgICAgIC8vIEFycmFuZ2VcbiAgICAgIHBhcnNlci5zZXRPcHRpb25zKHsgYWxsb3dVbmtub3duRmxhZ3M6IGZhbHNlIH0pO1xuICAgICAgY29uc3QgYXJncyA9IFsnY29tbWFuZCcsICctLXVua25vd24tZmxhZycsICd2YWx1ZSddO1xuICAgICAgY29uc3QgZXhwZWN0ZWRSZXN1bHQ6IFBhcnNlUmVzdWx0ID0ge1xuICAgICAgICBjb21tYW5kOiAnY29tbWFuZCcsXG4gICAgICAgIGFyZ3M6IFtdLFxuICAgICAgICBmbGFnczoge30sXG4gICAgICAgIHVua25vd246IFsnLS11bmtub3duLWZsYWcnLCAndmFsdWUnXSxcbiAgICAgICAgcmF3OiBhcmdzXG4gICAgICB9O1xuICAgICAgbW9ja1BhcnNlRnVuY3Rpb24ubW9ja1JldHVyblZhbHVlKGV4cGVjdGVkUmVzdWx0KTtcblxuICAgICAgLy8gQWN0XG4gICAgICBjb25zdCByZXN1bHQgPSBwYXJzZXIucGFyc2UoYXJncyk7XG5cbiAgICAgIC8vIEFzc2VydCAtIHZlcmlmeSB1bmtub3duIGZsYWcgaGFuZGxpbmdcbiAgICAgIGV4cGVjdChyZXN1bHQudW5rbm93bikudG9Db250YWluKCctLXVua25vd24tZmxhZycpO1xuICAgICAgZXhwZWN0KG1vY2tQYXJzZUZ1bmN0aW9uKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChhcmdzKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGJvb2xlYW4gZmxhZ3MgY29ycmVjdGx5JywgKCkgPT4ge1xuICAgICAgLy8gQXJyYW5nZVxuICAgICAgY29uc3QgYXJncyA9IFsndGVzdCcsICctLWRlYnVnJywgJy0tbm8tdmVyYm9zZSddO1xuICAgICAgY29uc3QgZXhwZWN0ZWRSZXN1bHQ6IFBhcnNlUmVzdWx0ID0ge1xuICAgICAgICBjb21tYW5kOiAndGVzdCcsXG4gICAgICAgIGFyZ3M6IFtdLFxuICAgICAgICBmbGFnczoge1xuICAgICAgICAgIGRlYnVnOiB0cnVlLFxuICAgICAgICAgIHZlcmJvc2U6IGZhbHNlXG4gICAgICAgIH0sXG4gICAgICAgIHVua25vd246IFtdLFxuICAgICAgICByYXc6IGFyZ3NcbiAgICAgIH07XG4gICAgICBtb2NrUGFyc2VGdW5jdGlvbi5tb2NrUmV0dXJuVmFsdWUoZXhwZWN0ZWRSZXN1bHQpO1xuXG4gICAgICAvLyBBY3RcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHBhcnNlci5wYXJzZShhcmdzKTtcblxuICAgICAgLy8gQXNzZXJ0IC0gdmVyaWZ5IGJvb2xlYW4gZmxhZyBiZWhhdmlvclxuICAgICAgZXhwZWN0KHJlc3VsdC5mbGFncy5kZWJ1ZykudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuZmxhZ3MudmVyYm9zZSkudG9CZShmYWxzZSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHBhcnNlIGFycmF5IGZsYWdzJywgKCkgPT4ge1xuICAgICAgLy8gQXJyYW5nZVxuICAgICAgY29uc3QgYXJncyA9IFsnYnVpbGQnLCAnLS1pbmNsdWRlJywgJ2ZpbGUxLmpzJywgJy0taW5jbHVkZScsICdmaWxlMi5qcyddO1xuICAgICAgY29uc3QgZXhwZWN0ZWRSZXN1bHQ6IFBhcnNlUmVzdWx0ID0ge1xuICAgICAgICBjb21tYW5kOiAnYnVpbGQnLFxuICAgICAgICBhcmdzOiBbXSxcbiAgICAgICAgZmxhZ3M6IHtcbiAgICAgICAgICBpbmNsdWRlOiBbJ2ZpbGUxLmpzJywgJ2ZpbGUyLmpzJ11cbiAgICAgICAgfSxcbiAgICAgICAgdW5rbm93bjogW10sXG4gICAgICAgIHJhdzogYXJnc1xuICAgICAgfTtcbiAgICAgIG1vY2tQYXJzZUZ1bmN0aW9uLm1vY2tSZXR1cm5WYWx1ZShleHBlY3RlZFJlc3VsdCk7XG5cbiAgICAgIC8vIEFjdFxuICAgICAgY29uc3QgcmVzdWx0ID0gcGFyc2VyLnBhcnNlKGFyZ3MpO1xuXG4gICAgICAvLyBBc3NlcnQgLSB2ZXJpZnkgYXJyYXkgZmxhZyBiZWhhdmlvclxuICAgICAgZXhwZWN0KHJlc3VsdC5mbGFncy5pbmNsdWRlKS50b0VxdWFsKFsnZmlsZTEuanMnLCAnZmlsZTIuanMnXSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdjb21tYW5kIGRlZmluaXRpb24gYmVoYXZpb3InLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCByZWdpc3RlciBjb21tYW5kIHdpdGggY29uZmlndXJhdGlvbicsICgpID0+IHtcbiAgICAgIC8vIEFycmFuZ2VcbiAgICAgIGNvbnN0IGNvbW1hbmRDb25maWc6IENvbW1hbmREZWZpbml0aW9uID0ge1xuICAgICAgICBuYW1lOiAnZGVwbG95JyxcbiAgICAgICAgZGVzY3JpcHRpb246ICdEZXBsb3kgYXBwbGljYXRpb24nLFxuICAgICAgICBhbGlhc2VzOiBbJ2QnXSxcbiAgICAgICAgZmxhZ3M6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAnZW52JyxcbiAgICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246ICdFbnZpcm9ubWVudCB0byBkZXBsb3kgdG8nLFxuICAgICAgICAgICAgcmVxdWlyZWQ6IHRydWVcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6ICd2ZXJib3NlJyxcbiAgICAgICAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiAnVmVyYm9zZSBvdXRwdXQnLFxuICAgICAgICAgICAgYWxpYXNlczogWyd2J11cbiAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIGFyZ3M6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiAndGFyZ2V0JyxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiAnRGVwbG95bWVudCB0YXJnZXQnLFxuICAgICAgICAgICAgcmVxdWlyZWQ6IHRydWVcbiAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICAgIH07XG5cbiAgICAgIC8vIEFjdFxuICAgICAgcGFyc2VyLmFkZENvbW1hbmQoY29tbWFuZENvbmZpZyk7XG5cbiAgICAgIC8vIEFzc2VydCAtIHZlcmlmeSBjb21tYW5kIHJlZ2lzdHJhdGlvbiBiZWhhdmlvclxuICAgICAgZXhwZWN0KHBhcnNlci5oYXNDb21tYW5kKCdkZXBsb3knKSkudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdChwYXJzZXIuaGFzQ29tbWFuZCgnZCcpKS50b0JlKHRydWUpOyAvLyBhbGlhc1xuICAgICAgZXhwZWN0KHBhcnNlci5nZXRDb21tYW5kKCdkZXBsb3knKSkudG9FcXVhbChjb21tYW5kQ29uZmlnKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmVnaXN0ZXIgbXVsdGlwbGUgY29tbWFuZHMgd2l0aG91dCBjb25mbGljdHMnLCAoKSA9PiB7XG4gICAgICAvLyBBcnJhbmdlXG4gICAgICBjb25zdCBjbWQxOiBDb21tYW5kRGVmaW5pdGlvbiA9IHsgbmFtZTogJ3N0YXJ0JywgZGVzY3JpcHRpb246ICdTdGFydCBzZXJ2aWNlJyB9O1xuICAgICAgY29uc3QgY21kMjogQ29tbWFuZERlZmluaXRpb24gPSB7IG5hbWU6ICdzdG9wJywgZGVzY3JpcHRpb246ICdTdG9wIHNlcnZpY2UnIH07XG5cbiAgICAgIC8vIEFjdFxuICAgICAgcGFyc2VyLmFkZENvbW1hbmQoY21kMSk7XG4gICAgICBwYXJzZXIuYWRkQ29tbWFuZChjbWQyKTtcblxuICAgICAgLy8gQXNzZXJ0IC0gdmVyaWZ5IG11bHRpcGxlIGNvbW1hbmQgcmVnaXN0cmF0aW9uXG4gICAgICBleHBlY3QocGFyc2VyLmhhc0NvbW1hbmQoJ3N0YXJ0JykpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QocGFyc2VyLmhhc0NvbW1hbmQoJ3N0b3AnKSkudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdChwYXJzZXIuZ2V0Q29tbWFuZCgnc3RhcnQnKSkudG9FcXVhbChjbWQxKTtcbiAgICAgIGV4cGVjdChwYXJzZXIuZ2V0Q29tbWFuZCgnc3RvcCcpKS50b0VxdWFsKGNtZDIpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgY29tbWFuZCBhbGlhc2VzIGNvcnJlY3RseScsICgpID0+IHtcbiAgICAgIC8vIEFycmFuZ2VcbiAgICAgIGNvbnN0IGNvbW1hbmRDb25maWc6IENvbW1hbmREZWZpbml0aW9uID0ge1xuICAgICAgICBuYW1lOiAnc3RhdHVzJyxcbiAgICAgICAgYWxpYXNlczogWydzdCcsICdzdGF0JywgJ3MnXVxuICAgICAgfTtcblxuICAgICAgLy8gQWN0XG4gICAgICBwYXJzZXIuYWRkQ29tbWFuZChjb21tYW5kQ29uZmlnKTtcblxuICAgICAgLy8gQXNzZXJ0IC0gdmVyaWZ5IGFsaWFzIGJlaGF2aW9yXG4gICAgICBjb25zdCBhbGlhc2VzID0gWydzdCcsICdzdGF0JywgJ3MnXTtcbiAgICAgIGFsaWFzZXMuZm9yRWFjaChhbGlhcyA9PiB7XG4gICAgICAgIGV4cGVjdChwYXJzZXIuaGFzQ29tbWFuZChhbGlhcykpLnRvQmUodHJ1ZSk7XG4gICAgICAgIGV4cGVjdChwYXJzZXIuZ2V0Q29tbWFuZChhbGlhcykpLnRvQmUoY29tbWFuZENvbmZpZyk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ3ZhbGlkYXRpb24gYmVoYXZpb3InLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCB2YWxpZGF0ZSBwYXJzZWQgcmVzdWx0IGFuZCByZXR1cm4gdmFsaWRhdGlvbiBlcnJvcnMnLCAoKSA9PiB7XG4gICAgICAvLyBBcnJhbmdlXG4gICAgICBjb25zdCBwYXJzZVJlc3VsdDogUGFyc2VSZXN1bHQgPSB7XG4gICAgICAgIGNvbW1hbmQ6ICdkZXBsb3knLFxuICAgICAgICBhcmdzOiBbXSxcbiAgICAgICAgZmxhZ3M6IHsgZW52OiAncHJvZHVjdGlvbicgfSxcbiAgICAgICAgdW5rbm93bjogW10sXG4gICAgICAgIHJhdzogWydkZXBsb3knLCAnLS1lbnYnLCAncHJvZHVjdGlvbiddXG4gICAgICB9O1xuXG4gICAgICBjb25zdCB2YWxpZGF0aW9uUmVzdWx0OiBWYWxpZGF0aW9uUmVzdWx0ID0ge1xuICAgICAgICB2YWxpZDogZmFsc2UsXG4gICAgICAgIGVycm9yczogWydNaXNzaW5nIHJlcXVpcmVkIGFyZ3VtZW50OiB0YXJnZXQnXSxcbiAgICAgICAgd2FybmluZ3M6IFtdXG4gICAgICB9O1xuXG4gICAgICBtb2NrVmFsaWRhdGVGdW5jdGlvbi5tb2NrUmV0dXJuVmFsdWUodmFsaWRhdGlvblJlc3VsdCk7XG5cbiAgICAgIC8vIEFjdFxuICAgICAgY29uc3QgcmVzdWx0ID0gcGFyc2VyLnZhbGlkYXRlKHBhcnNlUmVzdWx0KTtcblxuICAgICAgLy8gQXNzZXJ0IC0gdmVyaWZ5IHZhbGlkYXRpb24gYmVoYXZpb3JcbiAgICAgIGV4cGVjdChtb2NrVmFsaWRhdGVGdW5jdGlvbikudG9IYXZlQmVlbkNhbGxlZFdpdGgocGFyc2VSZXN1bHQpO1xuICAgICAgZXhwZWN0KHJlc3VsdCkudG9FcXVhbCh2YWxpZGF0aW9uUmVzdWx0KTtcbiAgICAgIGV4cGVjdChyZXN1bHQudmFsaWQpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvcnMpLnRvQ29udGFpbignTWlzc2luZyByZXF1aXJlZCBhcmd1bWVudDogdGFyZ2V0Jyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHZhbGlkYXRlIHJlcXVpcmVkIGZsYWdzJywgKCkgPT4ge1xuICAgICAgLy8gQXJyYW5nZVxuICAgICAgY29uc3QgcGFyc2VSZXN1bHQ6IFBhcnNlUmVzdWx0ID0ge1xuICAgICAgICBjb21tYW5kOiAnZGVwbG95JyxcbiAgICAgICAgYXJnczogWydhcHAnXSxcbiAgICAgICAgZmxhZ3M6IHt9LCAvLyBNaXNzaW5nIHJlcXVpcmVkIC0tZW52IGZsYWdcbiAgICAgICAgdW5rbm93bjogW10sXG4gICAgICAgIHJhdzogWydkZXBsb3knLCAnYXBwJ11cbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHZhbGlkYXRpb25SZXN1bHQ6IFZhbGlkYXRpb25SZXN1bHQgPSB7XG4gICAgICAgIHZhbGlkOiBmYWxzZSxcbiAgICAgICAgZXJyb3JzOiBbJ1JlcXVpcmVkIGZsYWcgLS1lbnYgaXMgbWlzc2luZyddLFxuICAgICAgICB3YXJuaW5nczogW11cbiAgICAgIH07XG5cbiAgICAgIG1vY2tWYWxpZGF0ZUZ1bmN0aW9uLm1vY2tSZXR1cm5WYWx1ZSh2YWxpZGF0aW9uUmVzdWx0KTtcblxuICAgICAgLy8gQWN0XG4gICAgICBjb25zdCByZXN1bHQgPSBwYXJzZXIudmFsaWRhdGUocGFyc2VSZXN1bHQpO1xuXG4gICAgICAvLyBBc3NlcnQgLSB2ZXJpZnkgcmVxdWlyZWQgZmxhZyB2YWxpZGF0aW9uXG4gICAgICBleHBlY3QocmVzdWx0LnZhbGlkKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3JzKS50b0NvbnRhaW4oJ1JlcXVpcmVkIGZsYWcgLS1lbnYgaXMgbWlzc2luZycpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCB2YWxpZGF0ZSBmbGFnIHR5cGVzJywgKCkgPT4ge1xuICAgICAgLy8gQXJyYW5nZVxuICAgICAgY29uc3QgcGFyc2VSZXN1bHQ6IFBhcnNlUmVzdWx0ID0ge1xuICAgICAgICBjb21tYW5kOiAnY29uZmlnJyxcbiAgICAgICAgYXJnczogW10sXG4gICAgICAgIGZsYWdzOiB7XG4gICAgICAgICAgcG9ydDogJ25vdC1hLW51bWJlcicgLy8gU2hvdWxkIGJlIG51bWJlclxuICAgICAgICB9LFxuICAgICAgICB1bmtub3duOiBbXSxcbiAgICAgICAgcmF3OiBbJ2NvbmZpZycsICctLXBvcnQnLCAnbm90LWEtbnVtYmVyJ11cbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHZhbGlkYXRpb25SZXN1bHQ6IFZhbGlkYXRpb25SZXN1bHQgPSB7XG4gICAgICAgIHZhbGlkOiBmYWxzZSxcbiAgICAgICAgZXJyb3JzOiBbJ0ZsYWcgLS1wb3J0IG11c3QgYmUgYSBudW1iZXInXSxcbiAgICAgICAgd2FybmluZ3M6IFtdXG4gICAgICB9O1xuXG4gICAgICBtb2NrVmFsaWRhdGVGdW5jdGlvbi5tb2NrUmV0dXJuVmFsdWUodmFsaWRhdGlvblJlc3VsdCk7XG5cbiAgICAgIC8vIEFjdFxuICAgICAgY29uc3QgcmVzdWx0ID0gcGFyc2VyLnZhbGlkYXRlKHBhcnNlUmVzdWx0KTtcblxuICAgICAgLy8gQXNzZXJ0IC0gdmVyaWZ5IHR5cGUgdmFsaWRhdGlvbiBiZWhhdmlvclxuICAgICAgZXhwZWN0KHJlc3VsdC52YWxpZCkudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QocmVzdWx0LmVycm9ycykudG9Db250YWluKCdGbGFnIC0tcG9ydCBtdXN0IGJlIGEgbnVtYmVyJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJldHVybiB3YXJuaW5ncyBmb3IgZGVwcmVjYXRlZCBmbGFncycsICgpID0+IHtcbiAgICAgIC8vIEFycmFuZ2VcbiAgICAgIGNvbnN0IHBhcnNlUmVzdWx0OiBQYXJzZVJlc3VsdCA9IHtcbiAgICAgICAgY29tbWFuZDogJ2J1aWxkJyxcbiAgICAgICAgYXJnczogW10sXG4gICAgICAgIGZsYWdzOiB7XG4gICAgICAgICAgJ29sZC1mbGFnJzogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICB1bmtub3duOiBbXSxcbiAgICAgICAgcmF3OiBbJ2J1aWxkJywgJy0tb2xkLWZsYWcnXVxuICAgICAgfTtcblxuICAgICAgY29uc3QgdmFsaWRhdGlvblJlc3VsdDogVmFsaWRhdGlvblJlc3VsdCA9IHtcbiAgICAgICAgdmFsaWQ6IHRydWUsXG4gICAgICAgIGVycm9yczogW10sXG4gICAgICAgIHdhcm5pbmdzOiBbJ0ZsYWcgLS1vbGQtZmxhZyBpcyBkZXByZWNhdGVkLCB1c2UgLS1uZXctZmxhZyBpbnN0ZWFkJ11cbiAgICAgIH07XG5cbiAgICAgIG1vY2tWYWxpZGF0ZUZ1bmN0aW9uLm1vY2tSZXR1cm5WYWx1ZSh2YWxpZGF0aW9uUmVzdWx0KTtcblxuICAgICAgLy8gQWN0XG4gICAgICBjb25zdCByZXN1bHQgPSBwYXJzZXIudmFsaWRhdGUocGFyc2VSZXN1bHQpO1xuXG4gICAgICAvLyBBc3NlcnQgLSB2ZXJpZnkgd2FybmluZyBiZWhhdmlvclxuICAgICAgZXhwZWN0KHJlc3VsdC52YWxpZCkudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdChyZXN1bHQud2FybmluZ3MpLnRvQ29udGFpbignRmxhZyAtLW9sZC1mbGFnIGlzIGRlcHJlY2F0ZWQsIHVzZSAtLW5ldy1mbGFnIGluc3RlYWQnKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ29wdGlvbnMgY29uZmlndXJhdGlvbiBiZWhhdmlvcicsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGFwcGx5IHBhcnNlciBvcHRpb25zIGNvcnJlY3RseScsICgpID0+IHtcbiAgICAgIC8vIEFycmFuZ2VcbiAgICAgIGNvbnN0IG9wdGlvbnM6IFBhcnNlck9wdGlvbnMgPSB7XG4gICAgICAgIGFsbG93VW5rbm93bkZsYWdzOiB0cnVlLFxuICAgICAgICBhbGxvd1Vua25vd25Db21tYW5kczogZmFsc2UsXG4gICAgICAgIHN0b3BBdEZpcnN0VW5rbm93bjogdHJ1ZSxcbiAgICAgICAgZmxhZ1ByZWZpeDogJy0tJyxcbiAgICAgICAgaGVscEZsYWc6IFsnaGVscCcsICdoJ10sXG4gICAgICAgIHZlcnNpb25GbGFnOiBbJ3ZlcnNpb24nLCAndiddXG4gICAgICB9O1xuXG4gICAgICAvLyBBY3RcbiAgICAgIHBhcnNlci5zZXRPcHRpb25zKG9wdGlvbnMpO1xuXG4gICAgICAvLyBBc3NlcnQgLSB2ZXJpZnkgb3B0aW9ucyBhcHBsaWNhdGlvblxuICAgICAgY29uc3QgYXBwbGllZE9wdGlvbnMgPSBwYXJzZXIuZ2V0T3B0aW9ucygpO1xuICAgICAgZXhwZWN0KGFwcGxpZWRPcHRpb25zKS50b0VxdWFsKG9wdGlvbnMpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBtZXJnZSBvcHRpb25zIHdpdGggZXhpc3RpbmcgY29uZmlndXJhdGlvbicsICgpID0+IHtcbiAgICAgIC8vIEFycmFuZ2VcbiAgICAgIHBhcnNlci5zZXRPcHRpb25zKHsgYWxsb3dVbmtub3duRmxhZ3M6IHRydWUgfSk7XG4gICAgICBwYXJzZXIuc2V0T3B0aW9ucyh7IGFsbG93VW5rbm93bkNvbW1hbmRzOiBmYWxzZSB9KTtcblxuICAgICAgLy8gQWN0XG4gICAgICBjb25zdCBvcHRpb25zID0gcGFyc2VyLmdldE9wdGlvbnMoKTtcblxuICAgICAgLy8gQXNzZXJ0IC0gdmVyaWZ5IG9wdGlvbiBtZXJnaW5nIGJlaGF2aW9yXG4gICAgICBleHBlY3Qob3B0aW9ucy5hbGxvd1Vua25vd25GbGFncykudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdChvcHRpb25zLmFsbG93VW5rbm93bkNvbW1hbmRzKS50b0JlKGZhbHNlKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ2hlbHAgZ2VuZXJhdGlvbiBiZWhhdmlvcicsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGdlbmVyYXRlIGhlbHAgdGV4dCcsICgpID0+IHtcbiAgICAgIC8vIEFjdFxuICAgICAgY29uc3QgaGVscCA9IHBhcnNlci5nZXRIZWxwKCk7XG5cbiAgICAgIC8vIEFzc2VydCAtIHZlcmlmeSBoZWxwIGdlbmVyYXRpb25cbiAgICAgIGV4cGVjdChoZWxwKS50b0JlKCdNb2NrIGhlbHAgdGV4dCcpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnZWRnZSBjYXNlIGJlaGF2aW9yJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgaGFuZGxlIGVtcHR5IGFyZ3VtZW50IGFycmF5JywgKCkgPT4ge1xuICAgICAgLy8gQXJyYW5nZVxuICAgICAgY29uc3QgZXhwZWN0ZWRSZXN1bHQ6IFBhcnNlUmVzdWx0ID0ge1xuICAgICAgICBjb21tYW5kOiBudWxsLFxuICAgICAgICBhcmdzOiBbXSxcbiAgICAgICAgZmxhZ3M6IHt9LFxuICAgICAgICB1bmtub3duOiBbXSxcbiAgICAgICAgcmF3OiBbXVxuICAgICAgfTtcbiAgICAgIG1vY2tQYXJzZUZ1bmN0aW9uLm1vY2tSZXR1cm5WYWx1ZShleHBlY3RlZFJlc3VsdCk7XG5cbiAgICAgIC8vIEFjdFxuICAgICAgY29uc3QgcmVzdWx0ID0gcGFyc2VyLnBhcnNlKFtdKTtcblxuICAgICAgLy8gQXNzZXJ0IC0gdmVyaWZ5IGVtcHR5IGFyZ3MgaGFuZGxpbmdcbiAgICAgIGV4cGVjdChtb2NrUGFyc2VGdW5jdGlvbikudG9IYXZlQmVlbkNhbGxlZFdpdGgoW10pO1xuICAgICAgZXhwZWN0KHJlc3VsdC5jb21tYW5kKS50b0JlTnVsbCgpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5hcmdzKS50b0VxdWFsKFtdKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGZsYWdzIHdpdGhvdXQgdmFsdWVzJywgKCkgPT4ge1xuICAgICAgLy8gQXJyYW5nZVxuICAgICAgY29uc3QgYXJncyA9IFsnY29tbWFuZCcsICctLWZsYWctd2l0aG91dC12YWx1ZSddO1xuICAgICAgY29uc3QgZXhwZWN0ZWRSZXN1bHQ6IFBhcnNlUmVzdWx0ID0ge1xuICAgICAgICBjb21tYW5kOiAnY29tbWFuZCcsXG4gICAgICAgIGFyZ3M6IFtdLFxuICAgICAgICBmbGFnczoge1xuICAgICAgICAgICdmbGFnLXdpdGhvdXQtdmFsdWUnOiB0cnVlIC8vIEJvb2xlYW4gZmxhZ1xuICAgICAgICB9LFxuICAgICAgICB1bmtub3duOiBbXSxcbiAgICAgICAgcmF3OiBhcmdzXG4gICAgICB9O1xuICAgICAgbW9ja1BhcnNlRnVuY3Rpb24ubW9ja1JldHVyblZhbHVlKGV4cGVjdGVkUmVzdWx0KTtcblxuICAgICAgLy8gQWN0XG4gICAgICBjb25zdCByZXN1bHQgPSBwYXJzZXIucGFyc2UoYXJncyk7XG5cbiAgICAgIC8vIEFzc2VydCAtIHZlcmlmeSBmbGFnIHdpdGhvdXQgdmFsdWUgaGFuZGxpbmdcbiAgICAgIGV4cGVjdChyZXN1bHQuZmxhZ3NbJ2ZsYWctd2l0aG91dC12YWx1ZSddKS50b0JlKHRydWUpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgc3BlY2lhbCBjaGFyYWN0ZXJzIGluIGFyZ3VtZW50cycsICgpID0+IHtcbiAgICAgIC8vIEFycmFuZ2VcbiAgICAgIGNvbnN0IGFyZ3MgPSBbJ2RlcGxveScsICctLW1lc3NhZ2UnLCAnRGVwbG95IHYxLjAuMCB3aXRoIFwicXVvdGVzXCIgYW5kIHNwYWNlcyddO1xuICAgICAgY29uc3QgZXhwZWN0ZWRSZXN1bHQ6IFBhcnNlUmVzdWx0ID0ge1xuICAgICAgICBjb21tYW5kOiAnZGVwbG95JyxcbiAgICAgICAgYXJnczogW10sXG4gICAgICAgIGZsYWdzOiB7XG4gICAgICAgICAgbWVzc2FnZTogJ0RlcGxveSB2MS4wLjAgd2l0aCBcInF1b3Rlc1wiIGFuZCBzcGFjZXMnXG4gICAgICAgIH0sXG4gICAgICAgIHVua25vd246IFtdLFxuICAgICAgICByYXc6IGFyZ3NcbiAgICAgIH07XG4gICAgICBtb2NrUGFyc2VGdW5jdGlvbi5tb2NrUmV0dXJuVmFsdWUoZXhwZWN0ZWRSZXN1bHQpO1xuXG4gICAgICAvLyBBY3RcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHBhcnNlci5wYXJzZShhcmdzKTtcblxuICAgICAgLy8gQXNzZXJ0IC0gdmVyaWZ5IHNwZWNpYWwgY2hhcmFjdGVyIGhhbmRsaW5nXG4gICAgICBleHBlY3QocmVzdWx0LmZsYWdzLm1lc3NhZ2UpLnRvQmUoJ0RlcGxveSB2MS4wLjAgd2l0aCBcInF1b3Rlc1wiIGFuZCBzcGFjZXMnKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIHZhcmlhZGljIGFyZ3VtZW50cycsICgpID0+IHtcbiAgICAgIC8vIEFycmFuZ2VcbiAgICAgIGNvbnN0IGFyZ3MgPSBbJ3Byb2Nlc3MnLCAnZmlsZTEuanMnLCAnZmlsZTIuanMnLCAnZmlsZTMuanMnXTtcbiAgICAgIGNvbnN0IGV4cGVjdGVkUmVzdWx0OiBQYXJzZVJlc3VsdCA9IHtcbiAgICAgICAgY29tbWFuZDogJ3Byb2Nlc3MnLFxuICAgICAgICBhcmdzOiBbJ2ZpbGUxLmpzJywgJ2ZpbGUyLmpzJywgJ2ZpbGUzLmpzJ10sXG4gICAgICAgIGZsYWdzOiB7fSxcbiAgICAgICAgdW5rbm93bjogW10sXG4gICAgICAgIHJhdzogYXJnc1xuICAgICAgfTtcbiAgICAgIG1vY2tQYXJzZUZ1bmN0aW9uLm1vY2tSZXR1cm5WYWx1ZShleHBlY3RlZFJlc3VsdCk7XG5cbiAgICAgIC8vIEFjdFxuICAgICAgY29uc3QgcmVzdWx0ID0gcGFyc2VyLnBhcnNlKGFyZ3MpO1xuXG4gICAgICAvLyBBc3NlcnQgLSB2ZXJpZnkgdmFyaWFkaWMgYXJndW1lbnQgaGFuZGxpbmdcbiAgICAgIGV4cGVjdChyZXN1bHQuYXJncykudG9FcXVhbChbJ2ZpbGUxLmpzJywgJ2ZpbGUyLmpzJywgJ2ZpbGUzLmpzJ10pO1xuICAgIH0pO1xuICB9KTtcbn0pOyJdLCJ2ZXJzaW9uIjozfQ==