39b1cd9574879731134f95450fcf57bd
/**
 * Data Integrity Integration Tests
 *
 * Hybrid Testing Approach:
 * - London School: Mock storage backends and corruption scenarios
 * - Classical School: Test actual data validation and error recovery
 */
import { createHash } from 'crypto';
import { EventEmitter } from 'events';
// Data integrity utilities
class DataIntegrityUtils {
    static calculateChecksum(data, algorithm = 'sha256') {
        const serialized = typeof data === 'string' ? data : JSON.stringify(data);
        let hash;
        switch (algorithm) {
            case 'sha256':
                hash = createHash('sha256').update(serialized).digest('hex');
                break;
            case 'md5':
                hash = createHash('md5').update(serialized).digest('hex');
                break;
            case 'crc32':
                // Simple CRC32 implementation for testing
                hash = this.crc32(serialized).toString(16);
                break;
            default:
                throw new Error(`Unsupported algorithm: ${algorithm}`);
        }
        return { algorithm, value: hash };
    }
    static validateChecksum(data, expectedChecksum) {
        const actualChecksum = this.calculateChecksum(data, expectedChecksum.algorithm);
        return actualChecksum.value === expectedChecksum.value;
    }
    static detectCorruption(original, current) {
        const issues = [];
        if (typeof original !== typeof current) {
            issues.push(`Type mismatch: expected ${typeof original}, got ${typeof current}`);
            return issues;
        }
        if (original === null || current === null) {
            if (original !== current) {
                issues.push('Null value mismatch');
            }
            return issues;
        }
        if (typeof original === 'object' && Array.isArray(original)) {
            if (!Array.isArray(current)) {
                issues.push('Array structure corrupted');
                return issues;
            }
            if (original.length !== current.length) {
                issues.push(`Array length mismatch: expected ${original.length}, got ${current.length}`);
            }
            for (let i = 0; i < Math.min(original.length, current.length); i++) {
                const subIssues = this.detectCorruption(original[i], current[i]);
                issues.push(...subIssues.map(issue => `Array[${i}]: ${issue}`));
            }
        }
        else if (typeof original === 'object') {
            const originalKeys = Object.keys(original).sort();
            const currentKeys = Object.keys(current).sort();
            if (originalKeys.length !== currentKeys.length) {
                issues.push(`Object key count mismatch: expected ${originalKeys.length}, got ${currentKeys.length}`);
            }
            const missingKeys = originalKeys.filter(key => !(key in current));
            const extraKeys = currentKeys.filter(key => !(key in original));
            if (missingKeys.length > 0) {
                issues.push(`Missing keys: ${missingKeys.join(', ')}`);
            }
            if (extraKeys.length > 0) {
                issues.push(`Extra keys: ${extraKeys.join(', ')}`);
            }
            for (const key of originalKeys) {
                if (key in current) {
                    const subIssues = this.detectCorruption(original[key], current[key]);
                    issues.push(...subIssues.map(issue => `Object.${key}: ${issue}`));
                }
            }
        }
        else if (original !== current) {
            issues.push(`Value mismatch: expected ${JSON.stringify(original)}, got ${JSON.stringify(current)}`);
        }
        return issues;
    }
    static attemptRepair(corrupted, reference, strategy = 'selective') {
        if (strategy === 'replace') {
            return reference;
        }
        if (strategy === 'merge' && typeof corrupted === 'object' && typeof reference === 'object') {
            if (corrupted === null || reference === null) {
                return reference;
            }
            if (Array.isArray(reference)) {
                return reference; // For arrays, replace entirely
            }
            const merged = { ...corrupted };
            for (const [key, value] of Object.entries(reference)) {
                if (!(key in merged) || merged[key] === null || merged[key] === undefined) {
                    merged[key] = value;
                }
            }
            return merged;
        }
        // Selective repair - only fix obvious corruption
        if (corrupted === null || corrupted === undefined) {
            return reference;
        }
        return corrupted;
    }
    static crc32(str) {
        let crc = 0 ^ (-1);
        for (let i = 0; i < str.length; i++) {
            crc = (crc >>> 8) ^ this.crcTable[(crc ^ str.charCodeAt(i)) & 0xFF];
        }
        return (crc ^ (-1)) >>> 0;
    }
    static crcTable = (() => {
        const table = new Array(256);
        for (let i = 0; i < 256; i++) {
            let c = i;
            for (let j = 0; j < 8; j++) {
                c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
            }
            table[i] = c;
        }
        return table;
    })();
}
// Integrity-aware storage system
class IntegrityStorage extends EventEmitter {
    records = new Map();
    backupRecords = new Map();
    validationEnabled = true;
    autoRepair = true;
    redundancyLevel = 1;
    constructor(options = {}) {
        super();
        this.validationEnabled = options.validationEnabled ?? true;
        this.autoRepair = options.autoRepair ?? true;
        this.redundancyLevel = options.redundancyLevel ?? 1;
    }
    async store(id, data, metadata) {
        const checksum = DataIntegrityUtils.calculateChecksum(data);
        const timestamp = Date.now();
        const version = (this.records.get(id)?.version ?? 0) + 1;
        const record = {
            id,
            data,
            checksum,
            timestamp,
            version,
            metadata
        };
        this.records.set(id, record);
        // Create backup copies for redundancy
        if (this.redundancyLevel > 0) {
            this.backupRecords.set(id, { ...record });
        }
        this.emit('stored', { id, version, checksum: checksum.value });
        return { ...record };
    }
    async retrieve(id) {
        const record = this.records.get(id);
        if (!record) {
            return null;
        }
        if (this.validationEnabled) {
            const validation = await this.validateRecord(record);
            if (!validation.valid) {
                this.emit('corruptionDetected', { id, errors: validation.errors });
                if (this.autoRepair) {
                    const repaired = await this.attemptRepair(id, record);
                    if (repaired) {
                        this.emit('dataRepaired', { id, method: 'auto' });
                        return repaired;
                    }
                }
                throw new Error(`Data integrity violation for ${id}: ${validation.errors.join(', ')}`);
            }
        }
        this.emit('retrieved', { id, version: record.version });
        return { ...record };
    }
    async validateRecord(record) {
        const errors = [];
        const warnings = [];
        // Checksum validation
        const isValidChecksum = DataIntegrityUtils.validateChecksum(record.data, record.checksum);
        if (!isValidChecksum) {
            errors.push('Checksum validation failed');
        }
        // Structural validation
        if (record.data === null || record.data === undefined) {
            warnings.push('Data is null or undefined');
        }
        // Timestamp validation
        if (record.timestamp > Date.now()) {
            warnings.push('Future timestamp detected');
        }
        // Version validation
        if (record.version < 1) {
            errors.push('Invalid version number');
        }
        return {
            valid: errors.length === 0,
            errors,
            warnings
        };
    }
    async validateAll() {
        let valid = 0;
        let corrupted = 0;
        let repaired = 0;
        for (const [id, record] of this.records.entries()) {
            try {
                const validation = await this.validateRecord(record);
                if (validation.valid) {
                    valid++;
                }
                else {
                    corrupted++;
                    if (this.autoRepair) {
                        const repairedRecord = await this.attemptRepair(id, record);
                        if (repairedRecord) {
                            repaired++;
                        }
                    }
                }
            }
            catch (error) {
                corrupted++;
            }
        }
        this.emit('bulkValidation', { valid, corrupted, repaired });
        return { valid, corrupted, repaired };
    }
    async attemptRepair(id, corruptedRecord) {
        // Try backup first
        const backup = this.backupRecords.get(id);
        if (backup) {
            const backupValidation = await this.validateRecord(backup);
            if (backupValidation.valid) {
                this.records.set(id, { ...backup });
                this.emit('repairedFromBackup', { id });
                return { ...backup };
            }
        }
        // Try to repair the current record
        if (backup) {
            try {
                const repairedData = DataIntegrityUtils.attemptRepair(corruptedRecord.data, backup.data, 'selective');
                const repairedRecord = {
                    ...corruptedRecord,
                    data: repairedData,
                    checksum: DataIntegrityUtils.calculateChecksum(repairedData),
                    version: corruptedRecord.version + 1,
                    timestamp: Date.now()
                };
                this.records.set(id, repairedRecord);
                this.emit('repairedSelectively', { id });
                return { ...repairedRecord };
            }
            catch (error) {
                this.emit('repairFailed', { id, error: error.message });
            }
        }
        return null;
    }
    async simulateCorruption(id, corruptionType) {
        const record = this.records.get(id);
        if (!record) {
            return false;
        }
        switch (corruptionType) {
            case 'checksum':
                record.checksum.value = 'corrupted_checksum';
                break;
            case 'data':
                if (typeof record.data === 'object' && record.data !== null) {
                    record.data = { ...record.data, corrupted: true };
                }
                else {
                    record.data = 'CORRUPTED';
                }
                break;
            case 'structure':
                if (typeof record.data === 'object' && !Array.isArray(record.data)) {
                    delete record.data.someKey;
                    record.data.unexpectedKey = 'unexpected';
                }
                break;
        }
        this.emit('corruptionSimulated', { id, type: corruptionType });
        return true;
    }
    getStats() {
        return {
            totalRecords: this.records.size,
            backupRecords: this.backupRecords.size,
            validationEnabled: this.validationEnabled,
            autoRepair: this.autoRepair
        };
    }
    async clear() {
        this.records.clear();
        this.backupRecords.clear();
        this.emit('cleared');
    }
}
// Mock corrupted storage for London-style tests
class MockCorruptedStorage {
    shouldCorrupt = false;
    corruptionRate = 0.1;
    operations = [];
    setShouldCorrupt(shouldCorrupt, rate = 0.1) {
        this.shouldCorrupt = shouldCorrupt;
        this.corruptionRate = rate;
    }
    async store(id, data) {
        this.operations.push(`store:${id}`);
        if (this.shouldCorrupt && Math.random() < this.corruptionRate) {
            // Simulate corruption during storage
            const corrupted = typeof data === 'object' ? { ...data, __corrupted: true } : 'CORRUPTED';
            return { success: false, data: corrupted, error: 'Storage corruption' };
        }
        return { success: true, data, checksum: 'mock_checksum' };
    }
    async retrieve(id) {
        this.operations.push(`retrieve:${id}`);
        if (this.shouldCorrupt && Math.random() < this.corruptionRate) {
            return { success: false, error: 'Retrieval corruption' };
        }
        return { success: true, data: { id, mockData: true } };
    }
}
describe('Data Integrity Integration Tests', () => {
    describe('Data Integrity Utils (Classical School)', () => {
        it('should calculate checksums correctly', () => {
            const data = { message: 'test data', number: 42 };
            const sha256Checksum = DataIntegrityUtils.calculateChecksum(data, 'sha256');
            const md5Checksum = DataIntegrityUtils.calculateChecksum(data, 'md5');
            const crc32Checksum = DataIntegrityUtils.calculateChecksum(data, 'crc32');
            expect(sha256Checksum.algorithm).toBe('sha256');
            expect(sha256Checksum.value).toHaveLength(64); // SHA256 hex length
            expect(md5Checksum.algorithm).toBe('md5');
            expect(md5Checksum.value).toHaveLength(32); // MD5 hex length
            expect(crc32Checksum.algorithm).toBe('crc32');
            expect(crc32Checksum.value).toMatch(/^[0-9a-f]+$/); // Hex string
            // Same data should produce same checksums
            const duplicate = DataIntegrityUtils.calculateChecksum(data, 'sha256');
            expect(duplicate.value).toBe(sha256Checksum.value);
        });
        it('should validate checksums correctly', () => {
            const data = { test: 'validation data' };
            const checksum = DataIntegrityUtils.calculateChecksum(data);
            expect(DataIntegrityUtils.validateChecksum(data, checksum)).toBe(true);
            const modifiedData = { test: 'modified data' };
            expect(DataIntegrityUtils.validateChecksum(modifiedData, checksum)).toBe(false);
        });
        it('should detect data corruption accurately', () => {
            const original = {
                name: 'John',
                age: 30,
                address: {
                    street: '123 Main St',
                    city: 'Anytown'
                },
                hobbies: ['reading', 'coding']
            };
            // No corruption
            const identical = { ...original, address: { ...original.address }, hobbies: [...original.hobbies] };
            expect(DataIntegrityUtils.detectCorruption(original, identical)).toHaveLength(0);
            // Value corruption
            const valueCorrupted = { ...original, age: 31 };
            const valueIssues = DataIntegrityUtils.detectCorruption(original, valueCorrupted);
            expect(valueIssues).toContain('Object.age: Value mismatch: expected 30, got 31');
            // Missing key
            const { name, ...missingKey } = original;
            const keyIssues = DataIntegrityUtils.detectCorruption(original, missingKey);
            expect(keyIssues.some(issue => issue.includes('Missing keys: name'))).toBe(true);
            // Array corruption
            const arrayCorrupted = { ...original, hobbies: ['reading'] };
            const arrayIssues = DataIntegrityUtils.detectCorruption(original, arrayCorrupted);
            expect(arrayIssues.some(issue => issue.includes('Array length mismatch'))).toBe(true);
        });
        it('should attempt data repair using different strategies', () => {
            const reference = { a: 1, b: 2, c: 3 };
            const corrupted = { a: 1, b: null, d: 4 };
            // Replace strategy
            const replaced = DataIntegrityUtils.attemptRepair(corrupted, reference, 'replace');
            expect(replaced).toEqual(reference);
            // Merge strategy
            const merged = DataIntegrityUtils.attemptRepair(corrupted, reference, 'merge');
            expect(merged.a).toBe(1); // Keep original
            expect(merged.b).toBe(2); // Replace null with reference value
            expect(merged.c).toBe(3); // Add missing
            expect(merged.d).toBe(4); // Keep extra
            // Selective strategy
            const selective = DataIntegrityUtils.attemptRepair(corrupted, reference, 'selective');
            expect(selective).toBe(corrupted); // Selective is conservative
        });
    });
    describe('Integrity Storage (Classical School)', () => {
        let storage;
        beforeEach(() => {
            storage = new IntegrityStorage({
                validationEnabled: true,
                autoRepair: true,
                redundancyLevel: 1
            });
        });
        afterEach(async () => {
            await storage.clear();
        });
        it('should store data with integrity metadata', async () => {
            const testData = { message: 'integrity test', timestamp: Date.now() };
            const metadata = { source: 'test', priority: 'high' };
            const record = await storage.store('test-record', testData, metadata);
            expect(record.id).toBe('test-record');
            expect(record.data).toEqual(testData);
            expect(record.metadata).toEqual(metadata);
            expect(record.checksum).toBeDefined();
            expect(record.checksum.algorithm).toBe('sha256');
            expect(record.version).toBe(1);
            expect(record.timestamp).toBeGreaterThan(0);
        });
        it('should validate data integrity on retrieval', async () => {
            const testData = { test: 'validation data' };
            await storage.store('validate-test', testData);
            const retrieved = await storage.retrieve('validate-test');
            expect(retrieved).toBeDefined();
            expect(retrieved.data).toEqual(testData);
        });
        it('should detect and handle corruption', async () => {
            const testData = { important: 'data', value: 42 };
            await storage.store('corruption-test', testData);
            // Simulate corruption
            const corrupted = await storage.simulateCorruption('corruption-test', 'checksum');
            expect(corrupted).toBe(true);
            // Should throw error due to corruption
            await expect(storage.retrieve('corruption-test')).rejects.toThrow(/Data integrity violation|Checksum validation failed/);
        });
        it('should attempt automatic repair when enabled', async () => {
            const originalData = { value: 'original', number: 123 };
            await storage.store('repair-test', originalData);
            // Simulate data corruption (not checksum, so repair can work)
            await storage.simulateCorruption('repair-test', 'data');
            // Should repair and return data
            const repairEvents = [];
            storage.on('dataRepaired', (event) => repairEvents.push(event));
            try {
                const retrieved = await storage.retrieve('repair-test');
                // If it doesn't throw, repair was successful
                expect(retrieved).toBeDefined();
            }
            catch {
                // Expected if repair couldn't work
                expect(repairEvents.length).toBeGreaterThanOrEqual(0);
            }
        });
        it('should handle version tracking', async () => {
            const initialData = { version: 'v1' };
            const record1 = await storage.store('version-test', initialData);
            expect(record1.version).toBe(1);
            // Add small delay to ensure timestamp difference
            await new Promise(resolve => setTimeout(resolve, 1));
            const updatedData = { version: 'v2' };
            const record2 = await storage.store('version-test', updatedData);
            expect(record2.version).toBe(2);
            expect(record2.timestamp).toBeGreaterThanOrEqual(record1.timestamp);
        });
        it('should validate all records in bulk', async () => {
            // Store some valid records
            await storage.store('valid-1', { data: 'good' });
            await storage.store('valid-2', { data: 'also good' });
            await storage.store('corrupt-1', { data: 'will be corrupted' });
            // Corrupt one record
            await storage.simulateCorruption('corrupt-1', 'checksum');
            const results = await storage.validateAll();
            expect(results.valid).toBe(2);
            expect(results.corrupted).toBeGreaterThanOrEqual(1);
        });
        it('should maintain backup copies for redundancy', async () => {
            const testData = { backup: 'test data' };
            await storage.store('backup-test', testData);
            const stats = storage.getStats();
            expect(stats.totalRecords).toBe(1);
            expect(stats.backupRecords).toBe(1); // Should have backup
        });
    });
    describe('Mock Corruption Scenarios (London School)', () => {
        let mockStorage;
        beforeEach(() => {
            mockStorage = new MockCorruptedStorage();
        });
        it('should simulate storage corruption', async () => {
            mockStorage.setShouldCorrupt(true, 1.0); // 100% corruption rate for testing
            const result = await mockStorage.store('test', { data: 'test' });
            expect(result.success).toBe(false);
            expect(result.error).toBe('Storage corruption');
            expect(mockStorage.operations).toContain('store:test');
        });
        it('should simulate retrieval corruption', async () => {
            mockStorage.setShouldCorrupt(true, 1.0);
            const result = await mockStorage.retrieve('test');
            expect(result.success).toBe(false);
            expect(result.error).toBe('Retrieval corruption');
            expect(mockStorage.operations).toContain('retrieve:test');
        });
        it('should handle normal operations when corruption is disabled', async () => {
            mockStorage.setShouldCorrupt(false);
            const storeResult = await mockStorage.store('normal', { data: 'normal' });
            expect(storeResult.success).toBe(true);
            const retrieveResult = await mockStorage.retrieve('normal');
            expect(retrieveResult.success).toBe(true);
        });
        it('should track operations for verification', async () => {
            await mockStorage.store('op1', {});
            await mockStorage.retrieve('op2');
            await mockStorage.store('op3', {});
            expect(mockStorage.operations).toEqual(['store:op1', 'retrieve:op2', 'store:op3']);
        });
    });
    describe('Event Handling and Monitoring', () => {
        let storage;
        let events;
        beforeEach(() => {
            storage = new IntegrityStorage();
            events = [];
            storage.on('stored', (data) => events.push({ type: 'stored', data }));
            storage.on('retrieved', (data) => events.push({ type: 'retrieved', data }));
            storage.on('corruptionDetected', (data) => events.push({ type: 'corruptionDetected', data }));
            storage.on('dataRepaired', (data) => events.push({ type: 'dataRepaired', data }));
            storage.on('repairFailed', (data) => events.push({ type: 'repairFailed', data }));
        });
        afterEach(async () => {
            await storage.clear();
        });
        it('should emit events for normal operations', async () => {
            await storage.store('event-test', { test: 'data' });
            await storage.retrieve('event-test');
            expect(events.some(e => e.type === 'stored')).toBe(true);
            expect(events.some(e => e.type === 'retrieved')).toBe(true);
            const storeEvent = events.find(e => e.type === 'stored');
            expect(storeEvent?.data.id).toBe('event-test');
        });
        it('should emit corruption detection events', async () => {
            await storage.store('corruption-event', { data: 'test' });
            await storage.simulateCorruption('corruption-event', 'checksum');
            try {
                await storage.retrieve('corruption-event');
            }
            catch {
                // Expected to fail
            }
            expect(events.some(e => e.type === 'corruptionDetected')).toBe(true);
        });
    });
    describe('Performance Under Corruption', () => {
        let storage;
        beforeEach(() => {
            storage = new IntegrityStorage({
                validationEnabled: true,
                autoRepair: true
            });
        });
        afterEach(async () => {
            await storage.clear();
        });
        it('should benchmark validation performance', async () => {
            const iterations = 1000;
            const testData = { benchmark: 'validation', data: 'x'.repeat(100) };
            // Store records
            for (let i = 0; i < iterations; i++) {
                await storage.store(`bench-${i}`, { ...testData, index: i });
            }
            // Benchmark validation
            const startTime = process.hrtime.bigint();
            const results = await storage.validateAll();
            const endTime = process.hrtime.bigint();
            const durationMs = Number(endTime - startTime) / 1_000_000;
            const validationsPerSecond = (iterations / durationMs) * 1000;
            console.log(`Validation performance: ${validationsPerSecond.toFixed(0)} validations/sec`);
            expect(results.valid).toBe(iterations);
            expect(validationsPerSecond).toBeGreaterThan(100); // Should validate at least 100/sec
        });
        it('should handle mixed corruption scenarios', async () => {
            const recordCount = 100;
            const corruptionRate = 0.1; // 10% corruption
            // Store records
            for (let i = 0; i < recordCount; i++) {
                await storage.store(`mixed-${i}`, { index: i, data: `record-${i}` });
            }
            // Randomly corrupt some records
            const corruptedCount = Math.floor(recordCount * corruptionRate);
            const corruptionTypes = ['checksum', 'data', 'structure'];
            for (let i = 0; i < corruptedCount; i++) {
                const recordIndex = Math.floor(Math.random() * recordCount);
                const corruptionType = corruptionTypes[Math.floor(Math.random() * corruptionTypes.length)];
                await storage.simulateCorruption(`mixed-${recordIndex}`, corruptionType);
            }
            // Validate all and measure results
            const results = await storage.validateAll();
            expect(results.valid + results.corrupted).toBe(recordCount);
            expect(results.corrupted).toBeGreaterThanOrEqual(0);
            console.log(`Mixed corruption test: ${results.valid} valid, ${results.corrupted} corrupted, ${results.repaired} repaired`);
        });
    });
    describe('Complex Data Structures', () => {
        let storage;
        beforeEach(() => {
            storage = new IntegrityStorage();
        });
        afterEach(async () => {
            await storage.clear();
        });
        it('should handle nested object integrity', async () => {
            const complexData = {
                user: {
                    id: 'user123',
                    profile: {
                        name: 'John Doe',
                        preferences: {
                            theme: 'dark',
                            notifications: {
                                email: true,
                                push: false,
                                sms: true
                            }
                        }
                    }
                },
                metadata: {
                    created: Date.now(),
                    tags: ['important', 'user-data'],
                    flags: {
                        verified: true,
                        premium: false
                    }
                }
            };
            const record = await storage.store('complex-data', complexData);
            expect(record.checksum).toBeDefined();
            const retrieved = await storage.retrieve('complex-data');
            expect(retrieved.data).toEqual(complexData);
        });
        it('should detect subtle nested corruption', async () => {
            const originalData = {
                config: {
                    database: {
                        host: 'localhost',
                        port: 5432,
                        credentials: {
                            username: 'admin',
                            password: 'secret'
                        }
                    }
                }
            };
            await storage.store('nested-test', originalData);
            await storage.simulateCorruption('nested-test', 'structure');
            const validation = await storage.validateRecord(storage.records.get('nested-test'));
            expect(validation.valid).toBe(false);
        });
        it('should maintain integrity with large datasets', async () => {
            const largeData = {
                matrix: Array.from({ length: 100 }, (_, i) => Array.from({ length: 100 }, (_, j) => i * 100 + j)),
                lookup: Object.fromEntries(Array.from({ length: 1000 }, (_, i) => [`key_${i}`, `value_${i}`]))
            };
            const startTime = process.hrtime.bigint();
            const record = await storage.store('large-dataset', largeData);
            const storeTime = process.hrtime.bigint();
            const retrieved = await storage.retrieve('large-dataset');
            const retrieveTime = process.hrtime.bigint();
            const storeDuration = Number(storeTime - startTime) / 1_000_000;
            const retrieveDuration = Number(retrieveTime - storeTime) / 1_000_000;
            console.log(`Large dataset - Store: ${storeDuration.toFixed(2)}ms, Retrieve: ${retrieveDuration.toFixed(2)}ms`);
            expect(retrieved.data).toEqual(largeData);
            expect(storeDuration).toBeLessThan(1000); // Should complete within 1 second
            expect(retrieveDuration).toBeLessThan(1000);
        });
    });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL2hvbWUvbWh1Z28vY29kZS9jbGF1ZGUtY29kZS1mbG93L3NyYy9fX3Rlc3RzX18vaW50ZWdyYXRpb24vbWVtb3J5LXN0b3Jlcy9kYXRhLWludGVncml0eS50ZXN0LnRzIiwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7R0FNRztBQUVILE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxRQUFRLENBQUM7QUFDcEMsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLFFBQVEsQ0FBQztBQXdCdEMsMkJBQTJCO0FBQzNCLE1BQU0sa0JBQWtCO0lBQ3RCLE1BQU0sQ0FBQyxpQkFBaUIsQ0FBQyxJQUFTLEVBQUUsWUFBd0MsUUFBUTtRQUNsRixNQUFNLFVBQVUsR0FBRyxPQUFPLElBQUksS0FBSyxRQUFRLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUUxRSxJQUFJLElBQVksQ0FBQztRQUNqQixRQUFRLFNBQVMsRUFBRSxDQUFDO1lBQ2xCLEtBQUssUUFBUTtnQkFDWCxJQUFJLEdBQUcsVUFBVSxDQUFDLFFBQVEsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxVQUFVLENBQUMsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUM7Z0JBQzdELE1BQU07WUFDUixLQUFLLEtBQUs7Z0JBQ1IsSUFBSSxHQUFHLFVBQVUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDO2dCQUMxRCxNQUFNO1lBQ1IsS0FBSyxPQUFPO2dCQUNWLDBDQUEwQztnQkFDMUMsSUFBSSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsVUFBVSxDQUFDLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxDQUFDO2dCQUMzQyxNQUFNO1lBQ1I7Z0JBQ0UsTUFBTSxJQUFJLEtBQUssQ0FBQywwQkFBMEIsU0FBUyxFQUFFLENBQUMsQ0FBQztRQUMzRCxDQUFDO1FBRUQsT0FBTyxFQUFFLFNBQVMsRUFB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QyxZQUFZLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDOUMsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDLENBQUMsQ0FBQztBQUNMLENBQUMsQ0FBQyxDQUFDIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIi9ob21lL21odWdvL2NvZGUvY2xhdWRlLWNvZGUtZmxvdy9zcmMvX190ZXN0c19fL2ludGVncmF0aW9uL21lbW9yeS1zdG9yZXMvZGF0YS1pbnRlZ3JpdHkudGVzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIERhdGEgSW50ZWdyaXR5IEludGVncmF0aW9uIFRlc3RzXG4gKiBcbiAqIEh5YnJpZCBUZXN0aW5nIEFwcHJvYWNoOlxuICogLSBMb25kb24gU2Nob29sOiBNb2NrIHN0b3JhZ2UgYmFja2VuZHMgYW5kIGNvcnJ1cHRpb24gc2NlbmFyaW9zXG4gKiAtIENsYXNzaWNhbCBTY2hvb2w6IFRlc3QgYWN0dWFsIGRhdGEgdmFsaWRhdGlvbiBhbmQgZXJyb3IgcmVjb3ZlcnlcbiAqL1xuXG5pbXBvcnQgeyBjcmVhdGVIYXNoIH0gZnJvbSAnY3J5cHRvJztcbmltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gJ2V2ZW50cyc7XG5cbi8vIERhdGEgaW50ZWdyaXR5IGludGVyZmFjZXMgYW5kIHV0aWxpdGllc1xuaW50ZXJmYWNlIERhdGFDaGVja3N1bSB7XG4gIGFsZ29yaXRobTogJ3NoYTI1NicgfCAnbWQ1JyB8ICdjcmMzMic7XG4gIHZhbHVlOiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBJbnRlZ3JpdHlSZWNvcmQge1xuICBpZDogc3RyaW5nO1xuICBkYXRhOiBhbnk7XG4gIGNoZWNrc3VtOiBEYXRhQ2hlY2tzdW07XG4gIHRpbWVzdGFtcDogbnVtYmVyO1xuICB2ZXJzaW9uOiBudW1iZXI7XG4gIG1ldGFkYXRhPzogUmVjb3JkPHN0cmluZywgYW55Pjtcbn1cblxuaW50ZXJmYWNlIFZhbGlkYXRpb25SZXN1bHQge1xuICB2YWxpZDogYm9vbGVhbjtcbiAgZXJyb3JzOiBzdHJpbmdbXTtcbiAgd2FybmluZ3M6IHN0cmluZ1tdO1xuICBjb3JyZWN0ZWQ/OiBib29sZWFuO1xufVxuXG4vLyBEYXRhIGludGVncml0eSB1dGlsaXRpZXNcbmNsYXNzIERhdGFJbnRlZ3JpdHlVdGlscyB7XG4gIHN0YXRpYyBjYWxjdWxhdGVDaGVja3N1bShkYXRhOiBhbnksIGFsZ29yaXRobTogJ3NoYTI1NicgfCAnbWQ1JyB8ICdjcmMzMicgPSAnc2hhMjU2Jyk6IERhdGFDaGVja3N1bSB7XG4gICAgY29uc3Qgc2VyaWFsaXplZCA9IHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJyA/IGRhdGEgOiBKU09OLnN0cmluZ2lmeShkYXRhKTtcbiAgICBcbiAgICBsZXQgaGFzaDogc3RyaW5nO1xuICAgIHN3aXRjaCAoYWxnb3JpdGhtKSB7XG4gICAgICBjYXNlICdzaGEyNTYnOlxuICAgICAgICBoYXNoID0gY3JlYXRlSGFzaCgnc2hhMjU2JykudXBkYXRlKHNlcmlhbGl6ZWQpLmRpZ2VzdCgnaGV4Jyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbWQ1JzpcbiAgICAgICAgaGFzaCA9IGNyZWF0ZUhhc2goJ21kNScpLnVwZGF0ZShzZXJpYWxpemVkKS5kaWdlc3QoJ2hleCcpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2NyYzMyJzpcbiAgICAgICAgLy8gU2ltcGxlIENSQzMyIGltcGxlbWVudGF0aW9uIGZvciB0ZXN0aW5nXG4gICAgICAgIGhhc2ggPSB0aGlzLmNyYzMyKHNlcmlhbGl6ZWQpLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGFsZ29yaXRobTogJHthbGdvcml0aG19YCk7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiB7IGFsZ29yaXRobSwgdmFsdWU6IGhhc2ggfTtcbiAgfVxuXG4gIHN0YXRpYyB2YWxpZGF0ZUNoZWNrc3VtKGRhdGE6IGFueSwgZXhwZWN0ZWRDaGVja3N1bTogRGF0YUNoZWNrc3VtKTogYm9vbGVhbiB7XG4gICAgY29uc3QgYWN0dWFsQ2hlY2tzdW0gPSB0aGlzLmNhbGN1bGF0ZUNoZWNrc3VtKGRhdGEsIGV4cGVjdGVkQ2hlY2tzdW0uYWxnb3JpdGhtKTtcbiAgICByZXR1cm4gYWN0dWFsQ2hlY2tzdW0udmFsdWUgPT09IGV4cGVjdGVkQ2hlY2tzdW0udmFsdWU7XG4gIH1cblxuICBzdGF0aWMgZGV0ZWN0Q29ycnVwdGlvbihvcmlnaW5hbDogYW55LCBjdXJyZW50OiBhbnkpOiBzdHJpbmdbXSB7XG4gICAgY29uc3QgaXNzdWVzOiBzdHJpbmdbXSA9IFtdO1xuICAgIFxuICAgIGlmICh0eXBlb2Ygb3JpZ2luYWwgIT09IHR5cGVvZiBjdXJyZW50KSB7XG4gICAgICBpc3N1ZXMucHVzaChgVHlwZSBtaXNtYXRjaDogZXhwZWN0ZWQgJHt0eXBlb2Ygb3JpZ2luYWx9LCBnb3QgJHt0eXBlb2YgY3VycmVudH1gKTtcbiAgICAgIHJldHVybiBpc3N1ZXM7XG4gICAgfVxuXG4gICAgaWYgKG9yaWdpbmFsID09PSBudWxsIHx8IGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgIGlmIChvcmlnaW5hbCAhPT0gY3VycmVudCkge1xuICAgICAgICBpc3N1ZXMucHVzaCgnTnVsbCB2YWx1ZSBtaXNtYXRjaCcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlzc3VlcztcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG9yaWdpbmFsID09PSAnb2JqZWN0JyAmJiBBcnJheS5pc0FycmF5KG9yaWdpbmFsKSkge1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGN1cnJlbnQpKSB7XG4gICAgICAgIGlzc3Vlcy5wdXNoKCdBcnJheSBzdHJ1Y3R1cmUgY29ycnVwdGVkJyk7XG4gICAgICAgIHJldHVybiBpc3N1ZXM7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmIChvcmlnaW5hbC5sZW5ndGggIT09IGN1cnJlbnQubGVuZ3RoKSB7XG4gICAgICAgIGlzc3Vlcy5wdXNoKGBBcnJheSBsZW5ndGggbWlzbWF0Y2g6IGV4cGVjdGVkICR7b3JpZ2luYWwubGVuZ3RofSwgZ290ICR7Y3VycmVudC5sZW5ndGh9YCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTWF0aC5taW4ob3JpZ2luYWwubGVuZ3RoLCBjdXJyZW50Lmxlbmd0aCk7IGkrKykge1xuICAgICAgICBjb25zdCBzdWJJc3N1ZXMgPSB0aGlzLmRldGVjdENvcnJ1cHRpb24ob3JpZ2luYWxbaV0sIGN1cnJlbnRbaV0pO1xuICAgICAgICBpc3N1ZXMucHVzaCguLi5zdWJJc3N1ZXMubWFwKGlzc3VlID0+IGBBcnJheVske2l9XTogJHtpc3N1ZX1gKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygb3JpZ2luYWwgPT09ICdvYmplY3QnKSB7XG4gICAgICBjb25zdCBvcmlnaW5hbEtleXMgPSBPYmplY3Qua2V5cyhvcmlnaW5hbCkuc29ydCgpO1xuICAgICAgY29uc3QgY3VycmVudEtleXMgPSBPYmplY3Qua2V5cyhjdXJyZW50KS5zb3J0KCk7XG4gICAgICBcbiAgICAgIGlmIChvcmlnaW5hbEtleXMubGVuZ3RoICE9PSBjdXJyZW50S2V5cy5sZW5ndGgpIHtcbiAgICAgICAgaXNzdWVzLnB1c2goYE9iamVjdCBrZXkgY291bnQgbWlzbWF0Y2g6IGV4cGVjdGVkICR7b3JpZ2luYWxLZXlzLmxlbmd0aH0sIGdvdCAke2N1cnJlbnRLZXlzLmxlbmd0aH1gKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3QgbWlzc2luZ0tleXMgPSBvcmlnaW5hbEtleXMuZmlsdGVyKGtleSA9PiAhKGtleSBpbiBjdXJyZW50KSk7XG4gICAgICBjb25zdCBleHRyYUtleXMgPSBjdXJyZW50S2V5cy5maWx0ZXIoa2V5ID0+ICEoa2V5IGluIG9yaWdpbmFsKSk7XG4gICAgICBcbiAgICAgIGlmIChtaXNzaW5nS2V5cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGlzc3Vlcy5wdXNoKGBNaXNzaW5nIGtleXM6ICR7bWlzc2luZ0tleXMuam9pbignLCAnKX1gKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgaWYgKGV4dHJhS2V5cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGlzc3Vlcy5wdXNoKGBFeHRyYSBrZXlzOiAke2V4dHJhS2V5cy5qb2luKCcsICcpfWApO1xuICAgICAgfVxuICAgICAgXG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiBvcmlnaW5hbEtleXMpIHtcbiAgICAgICAgaWYgKGtleSBpbiBjdXJyZW50KSB7XG4gICAgICAgICAgY29uc3Qgc3ViSXNzdWVzID0gdGhpcy5kZXRlY3RDb3JydXB0aW9uKG9yaWdpbmFsW2tleV0sIGN1cnJlbnRba2V5XSk7XG4gICAgICAgICAgaXNzdWVzLnB1c2goLi4uc3ViSXNzdWVzLm1hcChpc3N1ZSA9PiBgT2JqZWN0LiR7a2V5fTogJHtpc3N1ZX1gKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9yaWdpbmFsICE9PSBjdXJyZW50KSB7XG4gICAgICBpc3N1ZXMucHVzaChgVmFsdWUgbWlzbWF0Y2g6IGV4cGVjdGVkICR7SlNPTi5zdHJpbmdpZnkob3JpZ2luYWwpfSwgZ290ICR7SlNPTi5zdHJpbmdpZnkoY3VycmVudCl9YCk7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBpc3N1ZXM7XG4gIH1cblxuICBzdGF0aWMgYXR0ZW1wdFJlcGFpcjxUPihjb3JydXB0ZWQ6IFQsIHJlZmVyZW5jZTogVCwgc3RyYXRlZ3k6ICdtZXJnZScgfCAncmVwbGFjZScgfCAnc2VsZWN0aXZlJyA9ICdzZWxlY3RpdmUnKTogVCB7XG4gICAgaWYgKHN0cmF0ZWd5ID09PSAncmVwbGFjZScpIHtcbiAgICAgIHJldHVybiByZWZlcmVuY2U7XG4gICAgfVxuICAgIFxuICAgIGlmIChzdHJhdGVneSA9PT0gJ21lcmdlJyAmJiB0eXBlb2YgY29ycnVwdGVkID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgcmVmZXJlbmNlID09PSAnb2JqZWN0Jykge1xuICAgICAgaWYgKGNvcnJ1cHRlZCA9PT0gbnVsbCB8fCByZWZlcmVuY2UgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHJlZmVyZW5jZTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVmZXJlbmNlKSkge1xuICAgICAgICByZXR1cm4gcmVmZXJlbmNlOyAvLyBGb3IgYXJyYXlzLCByZXBsYWNlIGVudGlyZWx5XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IG1lcmdlZCA9IHsgLi4uY29ycnVwdGVkIH07XG4gICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhyZWZlcmVuY2UpKSB7XG4gICAgICAgIGlmICghKGtleSBpbiBtZXJnZWQpIHx8IG1lcmdlZFtrZXldID09PSBudWxsIHx8IG1lcmdlZFtrZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAobWVyZ2VkIGFzIGFueSlba2V5XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbWVyZ2VkIGFzIFQ7XG4gICAgfVxuICAgIFxuICAgIC8vIFNlbGVjdGl2ZSByZXBhaXIgLSBvbmx5IGZpeCBvYnZpb3VzIGNvcnJ1cHRpb25cbiAgICBpZiAoY29ycnVwdGVkID09PSBudWxsIHx8IGNvcnJ1cHRlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gcmVmZXJlbmNlO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gY29ycnVwdGVkO1xuICB9XG5cbiAgcHJpdmF0ZSBzdGF0aWMgY3JjMzIoc3RyOiBzdHJpbmcpOiBudW1iZXIge1xuICAgIGxldCBjcmMgPSAwIF4gKC0xKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgY3JjID0gKGNyYyA+Pj4gOCkgXiB0aGlzLmNyY1RhYmxlWyhjcmMgXiBzdHIuY2hhckNvZGVBdChpKSkgJiAweEZGXTtcbiAgICB9XG4gICAgcmV0dXJuIChjcmMgXiAoLTEpKSA+Pj4gMDtcbiAgfVxuXG4gIHByaXZhdGUgc3RhdGljIGNyY1RhYmxlID0gKCgpID0+IHtcbiAgICBjb25zdCB0YWJsZSA9IG5ldyBBcnJheSgyNTYpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcbiAgICAgIGxldCBjID0gaTtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgODsgaisrKSB7XG4gICAgICAgIGMgPSAoKGMgJiAxKSA/ICgweEVEQjg4MzIwIF4gKGMgPj4+IDEpKSA6IChjID4+PiAxKSk7XG4gICAgICB9XG4gICAgICB0YWJsZVtpXSA9IGM7XG4gICAgfVxuICAgIHJldHVybiB0YWJsZTtcbiAgfSkoKTtcbn1cblxuLy8gSW50ZWdyaXR5LWF3YXJlIHN0b3JhZ2Ugc3lzdGVtXG5jbGFzcyBJbnRlZ3JpdHlTdG9yYWdlIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgcHJpdmF0ZSByZWNvcmRzID0gbmV3IE1hcDxzdHJpbmcsIEludGVncml0eVJlY29yZD4oKTtcbiAgcHJpdmF0ZSBiYWNrdXBSZWNvcmRzID0gbmV3IE1hcDxzdHJpbmcsIEludGVncml0eVJlY29yZD4oKTtcbiAgcHJpdmF0ZSB2YWxpZGF0aW9uRW5hYmxlZCA9IHRydWU7XG4gIHByaXZhdGUgYXV0b1JlcGFpciA9IHRydWU7XG4gIHByaXZhdGUgcmVkdW5kYW5jeUxldmVsID0gMTtcblxuICBjb25zdHJ1Y3RvcihvcHRpb25zOiB7XG4gICAgdmFsaWRhdGlvbkVuYWJsZWQ/OiBib29sZWFuO1xuICAgIGF1dG9SZXBhaXI/OiBib29sZWFuO1xuICAgIHJlZHVuZGFuY3lMZXZlbD86IG51bWJlcjtcbiAgfSA9IHt9KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnZhbGlkYXRpb25FbmFibGVkID0gb3B0aW9ucy52YWxpZGF0aW9uRW5hYmxlZCA/PyB0cnVlO1xuICAgIHRoaXMuYXV0b1JlcGFpciA9IG9wdGlvbnMuYXV0b1JlcGFpciA/PyB0cnVlO1xuICAgIHRoaXMucmVkdW5kYW5jeUxldmVsID0gb3B0aW9ucy5yZWR1bmRhbmN5TGV2ZWwgPz8gMTtcbiAgfVxuXG4gIGFzeW5jIHN0b3JlKGlkOiBzdHJpbmcsIGRhdGE6IGFueSwgbWV0YWRhdGE/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogUHJvbWlzZTxJbnRlZ3JpdHlSZWNvcmQ+IHtcbiAgICBjb25zdCBjaGVja3N1bSA9IERhdGFJbnRlZ3JpdHlVdGlscy5jYWxjdWxhdGVDaGVja3N1bShkYXRhKTtcbiAgICBjb25zdCB0aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuICAgIGNvbnN0IHZlcnNpb24gPSAodGhpcy5yZWNvcmRzLmdldChpZCk/LnZlcnNpb24gPz8gMCkgKyAxO1xuXG4gICAgY29uc3QgcmVjb3JkOiBJbnRlZ3JpdHlSZWNvcmQgPSB7XG4gICAgICBpZCxcbiAgICAgIGRhdGEsXG4gICAgICBjaGVja3N1bSxcbiAgICAgIHRpbWVzdGFtcCxcbiAgICAgIHZlcnNpb24sXG4gICAgICBtZXRhZGF0YVxuICAgIH07XG5cbiAgICB0aGlzLnJlY29yZHMuc2V0KGlkLCByZWNvcmQpO1xuXG4gICAgLy8gQ3JlYXRlIGJhY2t1cCBjb3BpZXMgZm9yIHJlZHVuZGFuY3lcbiAgICBpZiAodGhpcy5yZWR1bmRhbmN5TGV2ZWwgPiAwKSB7XG4gICAgICB0aGlzLmJhY2t1cFJlY29yZHMuc2V0KGlkLCB7IC4uLnJlY29yZCB9KTtcbiAgICB9XG5cbiAgICB0aGlzLmVtaXQoJ3N0b3JlZCcsIHsgaWQsIHZlcnNpb24sIGNoZWNrc3VtOiBjaGVja3N1bS52YWx1ZSB9KTtcbiAgICByZXR1cm4geyAuLi5yZWNvcmQgfTtcbiAgfVxuXG4gIGFzeW5jIHJldHJpZXZlKGlkOiBzdHJpbmcpOiBQcm9taXNlPEludGVncml0eVJlY29yZCB8IG51bGw+IHtcbiAgICBjb25zdCByZWNvcmQgPSB0aGlzLnJlY29yZHMuZ2V0KGlkKTtcbiAgICBpZiAoIXJlY29yZCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMudmFsaWRhdGlvbkVuYWJsZWQpIHtcbiAgICAgIGNvbnN0IHZhbGlkYXRpb24gPSBhd2FpdCB0aGlzLnZhbGlkYXRlUmVjb3JkKHJlY29yZCk7XG4gICAgICBcbiAgICAgIGlmICghdmFsaWRhdGlvbi52YWxpZCkge1xuICAgICAgICB0aGlzLmVtaXQoJ2NvcnJ1cHRpb25EZXRlY3RlZCcsIHsgaWQsIGVycm9yczogdmFsaWRhdGlvbi5lcnJvcnMgfSk7XG4gICAgICAgIFxuICAgICAgICBpZiAodGhpcy5hdXRvUmVwYWlyKSB7XG4gICAgICAgICAgY29uc3QgcmVwYWlyZWQgPSBhd2FpdCB0aGlzLmF0dGVtcHRSZXBhaXIoaWQsIHJlY29yZCk7XG4gICAgICAgICAgaWYgKHJlcGFpcmVkKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2RhdGFSZXBhaXJlZCcsIHsgaWQsIG1ldGhvZDogJ2F1dG8nIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlcGFpcmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEYXRhIGludGVncml0eSB2aW9sYXRpb24gZm9yICR7aWR9OiAke3ZhbGlkYXRpb24uZXJyb3JzLmpvaW4oJywgJyl9YCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5lbWl0KCdyZXRyaWV2ZWQnLCB7IGlkLCB2ZXJzaW9uOiByZWNvcmQudmVyc2lvbiB9KTtcbiAgICByZXR1cm4geyAuLi5yZWNvcmQgfTtcbiAgfVxuXG4gIGFzeW5jIHZhbGlkYXRlUmVjb3JkKHJlY29yZDogSW50ZWdyaXR5UmVjb3JkKTogUHJvbWlzZTxWYWxpZGF0aW9uUmVzdWx0PiB7XG4gICAgY29uc3QgZXJyb3JzOiBzdHJpbmdbXSA9IFtdO1xuICAgIGNvbnN0IHdhcm5pbmdzOiBzdHJpbmdbXSA9IFtdO1xuXG4gICAgLy8gQ2hlY2tzdW0gdmFsaWRhdGlvblxuICAgIGNvbnN0IGlzVmFsaWRDaGVja3N1bSA9IERhdGFJbnRlZ3JpdHlVdGlscy52YWxpZGF0ZUNoZWNrc3VtKHJlY29yZC5kYXRhLCByZWNvcmQuY2hlY2tzdW0pO1xuICAgIGlmICghaXNWYWxpZENoZWNrc3VtKSB7XG4gICAgICBlcnJvcnMucHVzaCgnQ2hlY2tzdW0gdmFsaWRhdGlvbiBmYWlsZWQnKTtcbiAgICB9XG5cbiAgICAvLyBTdHJ1Y3R1cmFsIHZhbGlkYXRpb25cbiAgICBpZiAocmVjb3JkLmRhdGEgPT09IG51bGwgfHwgcmVjb3JkLmRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgd2FybmluZ3MucHVzaCgnRGF0YSBpcyBudWxsIG9yIHVuZGVmaW5lZCcpO1xuICAgIH1cblxuICAgIC8vIFRpbWVzdGFtcCB2YWxpZGF0aW9uXG4gICAgaWYgKHJlY29yZC50aW1lc3RhbXAgPiBEYXRlLm5vdygpKSB7XG4gICAgICB3YXJuaW5ncy5wdXNoKCdGdXR1cmUgdGltZXN0YW1wIGRldGVjdGVkJyk7XG4gICAgfVxuXG4gICAgLy8gVmVyc2lvbiB2YWxpZGF0aW9uXG4gICAgaWYgKHJlY29yZC52ZXJzaW9uIDwgMSkge1xuICAgICAgZXJyb3JzLnB1c2goJ0ludmFsaWQgdmVyc2lvbiBudW1iZXInKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdmFsaWQ6IGVycm9ycy5sZW5ndGggPT09IDAsXG4gICAgICBlcnJvcnMsXG4gICAgICB3YXJuaW5nc1xuICAgIH07XG4gIH1cblxuICBhc3luYyB2YWxpZGF0ZUFsbCgpOiBQcm9taXNlPHsgdmFsaWQ6IG51bWJlcjsgY29ycnVwdGVkOiBudW1iZXI7IHJlcGFpcmVkOiBudW1iZXIgfT4ge1xuICAgIGxldCB2YWxpZCA9IDA7XG4gICAgbGV0IGNvcnJ1cHRlZCA9IDA7XG4gICAgbGV0IHJlcGFpcmVkID0gMDtcblxuICAgIGZvciAoY29uc3QgW2lkLCByZWNvcmRdIG9mIHRoaXMucmVjb3Jkcy5lbnRyaWVzKCkpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHZhbGlkYXRpb24gPSBhd2FpdCB0aGlzLnZhbGlkYXRlUmVjb3JkKHJlY29yZCk7XG4gICAgICAgIFxuICAgICAgICBpZiAodmFsaWRhdGlvbi52YWxpZCkge1xuICAgICAgICAgIHZhbGlkKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29ycnVwdGVkKys7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKHRoaXMuYXV0b1JlcGFpcikge1xuICAgICAgICAgICAgY29uc3QgcmVwYWlyZWRSZWNvcmQgPSBhd2FpdCB0aGlzLmF0dGVtcHRSZXBhaXIoaWQsIHJlY29yZCk7XG4gICAgICAgICAgICBpZiAocmVwYWlyZWRSZWNvcmQpIHtcbiAgICAgICAgICAgICAgcmVwYWlyZWQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvcnJ1cHRlZCsrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuZW1pdCgnYnVsa1ZhbGlkYXRpb24nLCB7IHZhbGlkLCBjb3JydXB0ZWQsIHJlcGFpcmVkIH0pO1xuICAgIHJldHVybiB7IHZhbGlkLCBjb3JydXB0ZWQsIHJlcGFpcmVkIH07XG4gIH1cblxuICBhc3luYyBhdHRlbXB0UmVwYWlyKGlkOiBzdHJpbmcsIGNvcnJ1cHRlZFJlY29yZDogSW50ZWdyaXR5UmVjb3JkKTogUHJvbWlzZTxJbnRlZ3JpdHlSZWNvcmQgfCBudWxsPiB7XG4gICAgLy8gVHJ5IGJhY2t1cCBmaXJzdFxuICAgIGNvbnN0IGJhY2t1cCA9IHRoaXMuYmFja3VwUmVjb3Jkcy5nZXQoaWQpO1xuICAgIGlmIChiYWNrdXApIHtcbiAgICAgIGNvbnN0IGJhY2t1cFZhbGlkYXRpb24gPSBhd2FpdCB0aGlzLnZhbGlkYXRlUmVjb3JkKGJhY2t1cCk7XG4gICAgICBpZiAoYmFja3VwVmFsaWRhdGlvbi52YWxpZCkge1xuICAgICAgICB0aGlzLnJlY29yZHMuc2V0KGlkLCB7IC4uLmJhY2t1cCB9KTtcbiAgICAgICAgdGhpcy5lbWl0KCdyZXBhaXJlZEZyb21CYWNrdXAnLCB7IGlkIH0pO1xuICAgICAgICByZXR1cm4geyAuLi5iYWNrdXAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUcnkgdG8gcmVwYWlyIHRoZSBjdXJyZW50IHJlY29yZFxuICAgIGlmIChiYWNrdXApIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlcGFpcmVkRGF0YSA9IERhdGFJbnRlZ3JpdHlVdGlscy5hdHRlbXB0UmVwYWlyKFxuICAgICAgICAgIGNvcnJ1cHRlZFJlY29yZC5kYXRhLFxuICAgICAgICAgIGJhY2t1cC5kYXRhLFxuICAgICAgICAgICdzZWxlY3RpdmUnXG4gICAgICAgICk7XG4gICAgICAgIFxuICAgICAgICBjb25zdCByZXBhaXJlZFJlY29yZDogSW50ZWdyaXR5UmVjb3JkID0ge1xuICAgICAgICAgIC4uLmNvcnJ1cHRlZFJlY29yZCxcbiAgICAgICAgICBkYXRhOiByZXBhaXJlZERhdGEsXG4gICAgICAgICAgY2hlY2tzdW06IERhdGFJbnRlZ3JpdHlVdGlscy5jYWxjdWxhdGVDaGVja3N1bShyZXBhaXJlZERhdGEpLFxuICAgICAgICAgIHZlcnNpb246IGNvcnJ1cHRlZFJlY29yZC52ZXJzaW9uICsgMSxcbiAgICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KClcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMucmVjb3Jkcy5zZXQoaWQsIHJlcGFpcmVkUmVjb3JkKTtcbiAgICAgICAgdGhpcy5lbWl0KCdyZXBhaXJlZFNlbGVjdGl2ZWx5JywgeyBpZCB9KTtcbiAgICAgICAgcmV0dXJuIHsgLi4ucmVwYWlyZWRSZWNvcmQgfTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHRoaXMuZW1pdCgncmVwYWlyRmFpbGVkJywgeyBpZCwgZXJyb3I6IGVycm9yLm1lc3NhZ2UgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBhc3luYyBzaW11bGF0ZUNvcnJ1cHRpb24oaWQ6IHN0cmluZywgY29ycnVwdGlvblR5cGU6ICdjaGVja3N1bScgfCAnZGF0YScgfCAnc3RydWN0dXJlJyk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIGNvbnN0IHJlY29yZCA9IHRoaXMucmVjb3Jkcy5nZXQoaWQpO1xuICAgIGlmICghcmVjb3JkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgc3dpdGNoIChjb3JydXB0aW9uVHlwZSkge1xuICAgICAgY2FzZSAnY2hlY2tzdW0nOlxuICAgICAgICByZWNvcmQuY2hlY2tzdW0udmFsdWUgPSAnY29ycnVwdGVkX2NoZWNrc3VtJztcbiAgICAgICAgYnJlYWs7XG4gICAgICBcbiAgICAgIGNhc2UgJ2RhdGEnOlxuICAgICAgICBpZiAodHlwZW9mIHJlY29yZC5kYXRhID09PSAnb2JqZWN0JyAmJiByZWNvcmQuZGF0YSAhPT0gbnVsbCkge1xuICAgICAgICAgIHJlY29yZC5kYXRhID0geyAuLi5yZWNvcmQuZGF0YSwgY29ycnVwdGVkOiB0cnVlIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVjb3JkLmRhdGEgPSAnQ09SUlVQVEVEJztcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIFxuICAgICAgY2FzZSAnc3RydWN0dXJlJzpcbiAgICAgICAgaWYgKHR5cGVvZiByZWNvcmQuZGF0YSA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocmVjb3JkLmRhdGEpKSB7XG4gICAgICAgICAgZGVsZXRlIHJlY29yZC5kYXRhLnNvbWVLZXk7XG4gICAgICAgICAgcmVjb3JkLmRhdGEudW5leHBlY3RlZEtleSA9ICd1bmV4cGVjdGVkJztcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICB0aGlzLmVtaXQoJ2NvcnJ1cHRpb25TaW11bGF0ZWQnLCB7IGlkLCB0eXBlOiBjb3JydXB0aW9uVHlwZSB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGdldFN0YXRzKCk6IHtcbiAgICB0b3RhbFJlY29yZHM6IG51bWJlcjtcbiAgICBiYWNrdXBSZWNvcmRzOiBudW1iZXI7XG4gICAgdmFsaWRhdGlvbkVuYWJsZWQ6IGJvb2xlYW47XG4gICAgYXV0b1JlcGFpcjogYm9vbGVhbjtcbiAgfSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRvdGFsUmVjb3JkczogdGhpcy5yZWNvcmRzLnNpemUsXG4gICAgICBiYWNrdXBSZWNvcmRzOiB0aGlzLmJhY2t1cFJlY29yZHMuc2l6ZSxcbiAgICAgIHZhbGlkYXRpb25FbmFibGVkOiB0aGlzLnZhbGlkYXRpb25FbmFibGVkLFxuICAgICAgYXV0b1JlcGFpcjogdGhpcy5hdXRvUmVwYWlyXG4gICAgfTtcbiAgfVxuXG4gIGFzeW5jIGNsZWFyKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRoaXMucmVjb3Jkcy5jbGVhcigpO1xuICAgIHRoaXMuYmFja3VwUmVjb3Jkcy5jbGVhcigpO1xuICAgIHRoaXMuZW1pdCgnY2xlYXJlZCcpO1xuICB9XG59XG5cbi8vIE1vY2sgY29ycnVwdGVkIHN0b3JhZ2UgZm9yIExvbmRvbi1zdHlsZSB0ZXN0c1xuY2xhc3MgTW9ja0NvcnJ1cHRlZFN0b3JhZ2Uge1xuICBwcml2YXRlIHNob3VsZENvcnJ1cHQgPSBmYWxzZTtcbiAgcHJpdmF0ZSBjb3JydXB0aW9uUmF0ZSA9IDAuMTtcbiAgcHVibGljIG9wZXJhdGlvbnM6IHN0cmluZ1tdID0gW107XG5cbiAgc2V0U2hvdWxkQ29ycnVwdChzaG91bGRDb3JydXB0OiBib29sZWFuLCByYXRlID0gMC4xKTogdm9pZCB7XG4gICAgdGhpcy5zaG91bGRDb3JydXB0ID0gc2hvdWxkQ29ycnVwdDtcbiAgICB0aGlzLmNvcnJ1cHRpb25SYXRlID0gcmF0ZTtcbiAgfVxuXG4gIGFzeW5jIHN0b3JlKGlkOiBzdHJpbmcsIGRhdGE6IGFueSk6IFByb21pc2U8YW55PiB7XG4gICAgdGhpcy5vcGVyYXRpb25zLnB1c2goYHN0b3JlOiR7aWR9YCk7XG4gICAgXG4gICAgaWYgKHRoaXMuc2hvdWxkQ29ycnVwdCAmJiBNYXRoLnJhbmRvbSgpIDwgdGhpcy5jb3JydXB0aW9uUmF0ZSkge1xuICAgICAgLy8gU2ltdWxhdGUgY29ycnVwdGlvbiBkdXJpbmcgc3RvcmFnZVxuICAgICAgY29uc3QgY29ycnVwdGVkID0gdHlwZW9mIGRhdGEgPT09ICdvYmplY3QnID8geyAuLi5kYXRhLCBfX2NvcnJ1cHRlZDogdHJ1ZSB9IDogJ0NPUlJVUFRFRCc7XG4gICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZGF0YTogY29ycnVwdGVkLCBlcnJvcjogJ1N0b3JhZ2UgY29ycnVwdGlvbicgfTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSwgZGF0YSwgY2hlY2tzdW06ICdtb2NrX2NoZWNrc3VtJyB9O1xuICB9XG5cbiAgYXN5bmMgcmV0cmlldmUoaWQ6IHN0cmluZyk6IFByb21pc2U8YW55PiB7XG4gICAgdGhpcy5vcGVyYXRpb25zLnB1c2goYHJldHJpZXZlOiR7aWR9YCk7XG4gICAgXG4gICAgaWYgKHRoaXMuc2hvdWxkQ29ycnVwdCAmJiBNYXRoLnJhbmRvbSgpIDwgdGhpcy5jb3JydXB0aW9uUmF0ZSkge1xuICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiAnUmV0cmlldmFsIGNvcnJ1cHRpb24nIH07XG4gICAgfVxuICAgIFxuICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUsIGRhdGE6IHsgaWQsIG1vY2tEYXRhOiB0cnVlIH0gfTtcbiAgfVxufVxuXG5kZXNjcmliZSgnRGF0YSBJbnRlZ3JpdHkgSW50ZWdyYXRpb24gVGVzdHMnLCAoKSA9PiB7XG4gIGRlc2NyaWJlKCdEYXRhIEludGVncml0eSBVdGlscyAoQ2xhc3NpY2FsIFNjaG9vbCknLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBjYWxjdWxhdGUgY2hlY2tzdW1zIGNvcnJlY3RseScsICgpID0+IHtcbiAgICAgIGNvbnN0IGRhdGEgPSB7IG1lc3NhZ2U6ICd0ZXN0IGRhdGEnLCBudW1iZXI6IDQyIH07XG4gICAgICBcbiAgICAgIGNvbnN0IHNoYTI1NkNoZWNrc3VtID0gRGF0YUludGVncml0eVV0aWxzLmNhbGN1bGF0ZUNoZWNrc3VtKGRhdGEsICdzaGEyNTYnKTtcbiAgICAgIGNvbnN0IG1kNUNoZWNrc3VtID0gRGF0YUludGVncml0eVV0aWxzLmNhbGN1bGF0ZUNoZWNrc3VtKGRhdGEsICdtZDUnKTtcbiAgICAgIGNvbnN0IGNyYzMyQ2hlY2tzdW0gPSBEYXRhSW50ZWdyaXR5VXRpbHMuY2FsY3VsYXRlQ2hlY2tzdW0oZGF0YSwgJ2NyYzMyJyk7XG4gICAgICBcbiAgICAgIGV4cGVjdChzaGEyNTZDaGVja3N1bS5hbGdvcml0aG0pLnRvQmUoJ3NoYTI1NicpO1xuICAgICAgZXhwZWN0KHNoYTI1NkNoZWNrc3VtLnZhbHVlKS50b0hhdmVMZW5ndGgoNjQpOyAvLyBTSEEyNTYgaGV4IGxlbmd0aFxuICAgICAgXG4gICAgICBleHBlY3QobWQ1Q2hlY2tzdW0uYWxnb3JpdGhtKS50b0JlKCdtZDUnKTtcbiAgICAgIGV4cGVjdChtZDVDaGVja3N1bS52YWx1ZSkudG9IYXZlTGVuZ3RoKDMyKTsgLy8gTUQ1IGhleCBsZW5ndGhcbiAgICAgIFxuICAgICAgZXhwZWN0KGNyYzMyQ2hlY2tzdW0uYWxnb3JpdGhtKS50b0JlKCdjcmMzMicpO1xuICAgICAgZXhwZWN0KGNyYzMyQ2hlY2tzdW0udmFsdWUpLnRvTWF0Y2goL15bMC05YS1mXSskLyk7IC8vIEhleCBzdHJpbmdcbiAgICAgIFxuICAgICAgLy8gU2FtZSBkYXRhIHNob3VsZCBwcm9kdWNlIHNhbWUgY2hlY2tzdW1zXG4gICAgICBjb25zdCBkdXBsaWNhdGUgPSBEYXRhSW50ZWdyaXR5VXRpbHMuY2FsY3VsYXRlQ2hlY2tzdW0oZGF0YSwgJ3NoYTI1NicpO1xuICAgICAgZXhwZWN0KGR1cGxpY2F0ZS52YWx1ZSkudG9CZShzaGEyNTZDaGVja3N1bS52YWx1ZSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHZhbGlkYXRlIGNoZWNrc3VtcyBjb3JyZWN0bHknLCAoKSA9PiB7XG4gICAgICBjb25zdCBkYXRhID0geyB0ZXN0OiAndmFsaWRhdGlvbiBkYXRhJyB9O1xuICAgICAgY29uc3QgY2hlY2tzdW0gPSBEYXRhSW50ZWdyaXR5VXRpbHMuY2FsY3VsYXRlQ2hlY2tzdW0oZGF0YSk7XG4gICAgICBcbiAgICAgIGV4cGVjdChEYXRhSW50ZWdyaXR5VXRpbHMudmFsaWRhdGVDaGVja3N1bShkYXRhLCBjaGVja3N1bSkpLnRvQmUodHJ1ZSk7XG4gICAgICBcbiAgICAgIGNvbnN0IG1vZGlmaWVkRGF0YSA9IHsgdGVzdDogJ21vZGlmaWVkIGRhdGEnIH07XG4gICAgICBleHBlY3QoRGF0YUludGVncml0eVV0aWxzLnZhbGlkYXRlQ2hlY2tzdW0obW9kaWZpZWREYXRhLCBjaGVja3N1bSkpLnRvQmUoZmFsc2UpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBkZXRlY3QgZGF0YSBjb3JydXB0aW9uIGFjY3VyYXRlbHknLCAoKSA9PiB7XG4gICAgICBjb25zdCBvcmlnaW5hbCA9IHtcbiAgICAgICAgbmFtZTogJ0pvaG4nLFxuICAgICAgICBhZ2U6IDMwLFxuICAgICAgICBhZGRyZXNzOiB7XG4gICAgICAgICAgc3RyZWV0OiAnMTIzIE1haW4gU3QnLFxuICAgICAgICAgIGNpdHk6ICdBbnl0b3duJ1xuICAgICAgICB9LFxuICAgICAgICBob2JiaWVzOiBbJ3JlYWRpbmcnLCAnY29kaW5nJ11cbiAgICAgIH07XG5cbiAgICAgIC8vIE5vIGNvcnJ1cHRpb25cbiAgICAgIGNvbnN0IGlkZW50aWNhbCA9IHsgLi4ub3JpZ2luYWwsIGFkZHJlc3M6IHsgLi4ub3JpZ2luYWwuYWRkcmVzcyB9LCBob2JiaWVzOiBbLi4ub3JpZ2luYWwuaG9iYmllc10gfTtcbiAgICAgIGV4cGVjdChEYXRhSW50ZWdyaXR5VXRpbHMuZGV0ZWN0Q29ycnVwdGlvbihvcmlnaW5hbCwgaWRlbnRpY2FsKSkudG9IYXZlTGVuZ3RoKDApO1xuXG4gICAgICAvLyBWYWx1ZSBjb3JydXB0aW9uXG4gICAgICBjb25zdCB2YWx1ZUNvcnJ1cHRlZCA9IHsgLi4ub3JpZ2luYWwsIGFnZTogMzEgfTtcbiAgICAgIGNvbnN0IHZhbHVlSXNzdWVzID0gRGF0YUludGVncml0eVV0aWxzLmRldGVjdENvcnJ1cHRpb24ob3JpZ2luYWwsIHZhbHVlQ29ycnVwdGVkKTtcbiAgICAgIGV4cGVjdCh2YWx1ZUlzc3VlcykudG9Db250YWluKCdPYmplY3QuYWdlOiBWYWx1ZSBtaXNtYXRjaDogZXhwZWN0ZWQgMzAsIGdvdCAzMScpO1xuXG4gICAgICAvLyBNaXNzaW5nIGtleVxuICAgICAgY29uc3QgeyBuYW1lLCAuLi5taXNzaW5nS2V5IH0gPSBvcmlnaW5hbDtcbiAgICAgIGNvbnN0IGtleUlzc3VlcyA9IERhdGFJbnRlZ3JpdHlVdGlscy5kZXRlY3RDb3JydXB0aW9uKG9yaWdpbmFsLCBtaXNzaW5nS2V5KTtcbiAgICAgIGV4cGVjdChrZXlJc3N1ZXMuc29tZShpc3N1ZSA9PiBpc3N1ZS5pbmNsdWRlcygnTWlzc2luZyBrZXlzOiBuYW1lJykpKS50b0JlKHRydWUpO1xuXG4gICAgICAvLyBBcnJheSBjb3JydXB0aW9uXG4gICAgICBjb25zdCBhcnJheUNvcnJ1cHRlZCA9IHsgLi4ub3JpZ2luYWwsIGhvYmJpZXM6IFsncmVhZGluZyddIH07XG4gICAgICBjb25zdCBhcnJheUlzc3VlcyA9IERhdGFJbnRlZ3JpdHlVdGlscy5kZXRlY3RDb3JydXB0aW9uKG9yaWdpbmFsLCBhcnJheUNvcnJ1cHRlZCk7XG4gICAgICBleHBlY3QoYXJyYXlJc3N1ZXMuc29tZShpc3N1ZSA9PiBpc3N1ZS5pbmNsdWRlcygnQXJyYXkgbGVuZ3RoIG1pc21hdGNoJykpKS50b0JlKHRydWUpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBhdHRlbXB0IGRhdGEgcmVwYWlyIHVzaW5nIGRpZmZlcmVudCBzdHJhdGVnaWVzJywgKCkgPT4ge1xuICAgICAgY29uc3QgcmVmZXJlbmNlID0geyBhOiAxLCBiOiAyLCBjOiAzIH07XG4gICAgICBjb25zdCBjb3JydXB0ZWQgPSB7IGE6IDEsIGI6IG51bGwsIGQ6IDQgfTtcblxuICAgICAgLy8gUmVwbGFjZSBzdHJhdGVneVxuICAgICAgY29uc3QgcmVwbGFjZWQgPSBEYXRhSW50ZWdyaXR5VXRpbHMuYXR0ZW1wdFJlcGFpcihjb3JydXB0ZWQsIHJlZmVyZW5jZSwgJ3JlcGxhY2UnKTtcbiAgICAgIGV4cGVjdChyZXBsYWNlZCkudG9FcXVhbChyZWZlcmVuY2UpO1xuXG4gICAgICAvLyBNZXJnZSBzdHJhdGVneVxuICAgICAgY29uc3QgbWVyZ2VkID0gRGF0YUludGVncml0eVV0aWxzLmF0dGVtcHRSZXBhaXIoY29ycnVwdGVkLCByZWZlcmVuY2UsICdtZXJnZScpO1xuICAgICAgZXhwZWN0KG1lcmdlZC5hKS50b0JlKDEpOyAvLyBLZWVwIG9yaWdpbmFsXG4gICAgICBleHBlY3QobWVyZ2VkLmIpLnRvQmUoMik7IC8vIFJlcGxhY2UgbnVsbCB3aXRoIHJlZmVyZW5jZSB2YWx1ZVxuICAgICAgZXhwZWN0KG1lcmdlZC5jKS50b0JlKDMpOyAvLyBBZGQgbWlzc2luZ1xuICAgICAgZXhwZWN0KG1lcmdlZC5kKS50b0JlKDQpOyAvLyBLZWVwIGV4dHJhXG5cbiAgICAgIC8vIFNlbGVjdGl2ZSBzdHJhdGVneVxuICAgICAgY29uc3Qgc2VsZWN0aXZlID0gRGF0YUludGVncml0eVV0aWxzLmF0dGVtcHRSZXBhaXIoY29ycnVwdGVkLCByZWZlcmVuY2UsICdzZWxlY3RpdmUnKTtcbiAgICAgIGV4cGVjdChzZWxlY3RpdmUpLnRvQmUoY29ycnVwdGVkKTsgLy8gU2VsZWN0aXZlIGlzIGNvbnNlcnZhdGl2ZVxuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnSW50ZWdyaXR5IFN0b3JhZ2UgKENsYXNzaWNhbCBTY2hvb2wpJywgKCkgPT4ge1xuICAgIGxldCBzdG9yYWdlOiBJbnRlZ3JpdHlTdG9yYWdlO1xuXG4gICAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgICBzdG9yYWdlID0gbmV3IEludGVncml0eVN0b3JhZ2Uoe1xuICAgICAgICB2YWxpZGF0aW9uRW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgYXV0b1JlcGFpcjogdHJ1ZSxcbiAgICAgICAgcmVkdW5kYW5jeUxldmVsOiAxXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGFmdGVyRWFjaChhc3luYyAoKSA9PiB7XG4gICAgICBhd2FpdCBzdG9yYWdlLmNsZWFyKCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHN0b3JlIGRhdGEgd2l0aCBpbnRlZ3JpdHkgbWV0YWRhdGEnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB0ZXN0RGF0YSA9IHsgbWVzc2FnZTogJ2ludGVncml0eSB0ZXN0JywgdGltZXN0YW1wOiBEYXRlLm5vdygpIH07XG4gICAgICBjb25zdCBtZXRhZGF0YSA9IHsgc291cmNlOiAndGVzdCcsIHByaW9yaXR5OiAnaGlnaCcgfTtcblxuICAgICAgY29uc3QgcmVjb3JkID0gYXdhaXQgc3RvcmFnZS5zdG9yZSgndGVzdC1yZWNvcmQnLCB0ZXN0RGF0YSwgbWV0YWRhdGEpO1xuXG4gICAgICBleHBlY3QocmVjb3JkLmlkKS50b0JlKCd0ZXN0LXJlY29yZCcpO1xuICAgICAgZXhwZWN0KHJlY29yZC5kYXRhKS50b0VxdWFsKHRlc3REYXRhKTtcbiAgICAgIGV4cGVjdChyZWNvcmQubWV0YWRhdGEpLnRvRXF1YWwobWV0YWRhdGEpO1xuICAgICAgZXhwZWN0KHJlY29yZC5jaGVja3N1bSkudG9CZURlZmluZWQoKTtcbiAgICAgIGV4cGVjdChyZWNvcmQuY2hlY2tzdW0uYWxnb3JpdGhtKS50b0JlKCdzaGEyNTYnKTtcbiAgICAgIGV4cGVjdChyZWNvcmQudmVyc2lvbikudG9CZSgxKTtcbiAgICAgIGV4cGVjdChyZWNvcmQudGltZXN0YW1wKS50b0JlR3JlYXRlclRoYW4oMCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHZhbGlkYXRlIGRhdGEgaW50ZWdyaXR5IG9uIHJldHJpZXZhbCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHRlc3REYXRhID0geyB0ZXN0OiAndmFsaWRhdGlvbiBkYXRhJyB9O1xuICAgICAgYXdhaXQgc3RvcmFnZS5zdG9yZSgndmFsaWRhdGUtdGVzdCcsIHRlc3REYXRhKTtcblxuICAgICAgY29uc3QgcmV0cmlldmVkID0gYXdhaXQgc3RvcmFnZS5yZXRyaWV2ZSgndmFsaWRhdGUtdGVzdCcpO1xuICAgICAgZXhwZWN0KHJldHJpZXZlZCkudG9CZURlZmluZWQoKTtcbiAgICAgIGV4cGVjdChyZXRyaWV2ZWQhLmRhdGEpLnRvRXF1YWwodGVzdERhdGEpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBkZXRlY3QgYW5kIGhhbmRsZSBjb3JydXB0aW9uJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdGVzdERhdGEgPSB7IGltcG9ydGFudDogJ2RhdGEnLCB2YWx1ZTogNDIgfTtcbiAgICAgIGF3YWl0IHN0b3JhZ2Uuc3RvcmUoJ2NvcnJ1cHRpb24tdGVzdCcsIHRlc3REYXRhKTtcblxuICAgICAgLy8gU2ltdWxhdGUgY29ycnVwdGlvblxuICAgICAgY29uc3QgY29ycnVwdGVkID0gYXdhaXQgc3RvcmFnZS5zaW11bGF0ZUNvcnJ1cHRpb24oJ2NvcnJ1cHRpb24tdGVzdCcsICdjaGVja3N1bScpO1xuICAgICAgZXhwZWN0KGNvcnJ1cHRlZCkudG9CZSh0cnVlKTtcblxuICAgICAgLy8gU2hvdWxkIHRocm93IGVycm9yIGR1ZSB0byBjb3JydXB0aW9uXG4gICAgICBhd2FpdCBleHBlY3Qoc3RvcmFnZS5yZXRyaWV2ZSgnY29ycnVwdGlvbi10ZXN0JykpLnJlamVjdHMudG9UaHJvdygvRGF0YSBpbnRlZ3JpdHkgdmlvbGF0aW9ufENoZWNrc3VtIHZhbGlkYXRpb24gZmFpbGVkLyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGF0dGVtcHQgYXV0b21hdGljIHJlcGFpciB3aGVuIGVuYWJsZWQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBvcmlnaW5hbERhdGEgPSB7IHZhbHVlOiAnb3JpZ2luYWwnLCBudW1iZXI6IDEyMyB9O1xuICAgICAgYXdhaXQgc3RvcmFnZS5zdG9yZSgncmVwYWlyLXRlc3QnLCBvcmlnaW5hbERhdGEpO1xuXG4gICAgICAvLyBTaW11bGF0ZSBkYXRhIGNvcnJ1cHRpb24gKG5vdCBjaGVja3N1bSwgc28gcmVwYWlyIGNhbiB3b3JrKVxuICAgICAgYXdhaXQgc3RvcmFnZS5zaW11bGF0ZUNvcnJ1cHRpb24oJ3JlcGFpci10ZXN0JywgJ2RhdGEnKTtcblxuICAgICAgLy8gU2hvdWxkIHJlcGFpciBhbmQgcmV0dXJuIGRhdGFcbiAgICAgIGNvbnN0IHJlcGFpckV2ZW50czogYW55W10gPSBbXTtcbiAgICAgIHN0b3JhZ2Uub24oJ2RhdGFSZXBhaXJlZCcsIChldmVudCkgPT4gcmVwYWlyRXZlbnRzLnB1c2goZXZlbnQpKTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmV0cmlldmVkID0gYXdhaXQgc3RvcmFnZS5yZXRyaWV2ZSgncmVwYWlyLXRlc3QnKTtcbiAgICAgICAgLy8gSWYgaXQgZG9lc24ndCB0aHJvdywgcmVwYWlyIHdhcyBzdWNjZXNzZnVsXG4gICAgICAgIGV4cGVjdChyZXRyaWV2ZWQpLnRvQmVEZWZpbmVkKCk7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgLy8gRXhwZWN0ZWQgaWYgcmVwYWlyIGNvdWxkbid0IHdvcmtcbiAgICAgICAgZXhwZWN0KHJlcGFpckV2ZW50cy5sZW5ndGgpLnRvQmVHcmVhdGVyVGhhbk9yRXF1YWwoMCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSB2ZXJzaW9uIHRyYWNraW5nJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgaW5pdGlhbERhdGEgPSB7IHZlcnNpb246ICd2MScgfTtcbiAgICAgIGNvbnN0IHJlY29yZDEgPSBhd2FpdCBzdG9yYWdlLnN0b3JlKCd2ZXJzaW9uLXRlc3QnLCBpbml0aWFsRGF0YSk7XG4gICAgICBleHBlY3QocmVjb3JkMS52ZXJzaW9uKS50b0JlKDEpO1xuXG4gICAgICAvLyBBZGQgc21hbGwgZGVsYXkgdG8gZW5zdXJlIHRpbWVzdGFtcCBkaWZmZXJlbmNlXG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMSkpO1xuXG4gICAgICBjb25zdCB1cGRhdGVkRGF0YSA9IHsgdmVyc2lvbjogJ3YyJyB9O1xuICAgICAgY29uc3QgcmVjb3JkMiA9IGF3YWl0IHN0b3JhZ2Uuc3RvcmUoJ3ZlcnNpb24tdGVzdCcsIHVwZGF0ZWREYXRhKTtcbiAgICAgIGV4cGVjdChyZWNvcmQyLnZlcnNpb24pLnRvQmUoMik7XG4gICAgICBleHBlY3QocmVjb3JkMi50aW1lc3RhbXApLnRvQmVHcmVhdGVyVGhhbk9yRXF1YWwocmVjb3JkMS50aW1lc3RhbXApO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCB2YWxpZGF0ZSBhbGwgcmVjb3JkcyBpbiBidWxrJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gU3RvcmUgc29tZSB2YWxpZCByZWNvcmRzXG4gICAgICBhd2FpdCBzdG9yYWdlLnN0b3JlKCd2YWxpZC0xJywgeyBkYXRhOiAnZ29vZCcgfSk7XG4gICAgICBhd2FpdCBzdG9yYWdlLnN0b3JlKCd2YWxpZC0yJywgeyBkYXRhOiAnYWxzbyBnb29kJyB9KTtcbiAgICAgIGF3YWl0IHN0b3JhZ2Uuc3RvcmUoJ2NvcnJ1cHQtMScsIHsgZGF0YTogJ3dpbGwgYmUgY29ycnVwdGVkJyB9KTtcblxuICAgICAgLy8gQ29ycnVwdCBvbmUgcmVjb3JkXG4gICAgICBhd2FpdCBzdG9yYWdlLnNpbXVsYXRlQ29ycnVwdGlvbignY29ycnVwdC0xJywgJ2NoZWNrc3VtJyk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBzdG9yYWdlLnZhbGlkYXRlQWxsKCk7XG4gICAgICBleHBlY3QocmVzdWx0cy52YWxpZCkudG9CZSgyKTtcbiAgICAgIGV4cGVjdChyZXN1bHRzLmNvcnJ1cHRlZCkudG9CZUdyZWF0ZXJUaGFuT3JFcXVhbCgxKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgbWFpbnRhaW4gYmFja3VwIGNvcGllcyBmb3IgcmVkdW5kYW5jeScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHRlc3REYXRhID0geyBiYWNrdXA6ICd0ZXN0IGRhdGEnIH07XG4gICAgICBhd2FpdCBzdG9yYWdlLnN0b3JlKCdiYWNrdXAtdGVzdCcsIHRlc3REYXRhKTtcblxuICAgICAgY29uc3Qgc3RhdHMgPSBzdG9yYWdlLmdldFN0YXRzKCk7XG4gICAgICBleHBlY3Qoc3RhdHMudG90YWxSZWNvcmRzKS50b0JlKDEpO1xuICAgICAgZXhwZWN0KHN0YXRzLmJhY2t1cFJlY29yZHMpLnRvQmUoMSk7IC8vIFNob3VsZCBoYXZlIGJhY2t1cFxuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnTW9jayBDb3JydXB0aW9uIFNjZW5hcmlvcyAoTG9uZG9uIFNjaG9vbCknLCAoKSA9PiB7XG4gICAgbGV0IG1vY2tTdG9yYWdlOiBNb2NrQ29ycnVwdGVkU3RvcmFnZTtcblxuICAgIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgICAgbW9ja1N0b3JhZ2UgPSBuZXcgTW9ja0NvcnJ1cHRlZFN0b3JhZ2UoKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgc2ltdWxhdGUgc3RvcmFnZSBjb3JydXB0aW9uJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja1N0b3JhZ2Uuc2V0U2hvdWxkQ29ycnVwdCh0cnVlLCAxLjApOyAvLyAxMDAlIGNvcnJ1cHRpb24gcmF0ZSBmb3IgdGVzdGluZ1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBtb2NrU3RvcmFnZS5zdG9yZSgndGVzdCcsIHsgZGF0YTogJ3Rlc3QnIH0pO1xuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3IpLnRvQmUoJ1N0b3JhZ2UgY29ycnVwdGlvbicpO1xuICAgICAgZXhwZWN0KG1vY2tTdG9yYWdlLm9wZXJhdGlvbnMpLnRvQ29udGFpbignc3RvcmU6dGVzdCcpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBzaW11bGF0ZSByZXRyaWV2YWwgY29ycnVwdGlvbicsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tTdG9yYWdlLnNldFNob3VsZENvcnJ1cHQodHJ1ZSwgMS4wKTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgbW9ja1N0b3JhZ2UucmV0cmlldmUoJ3Rlc3QnKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QocmVzdWx0LmVycm9yKS50b0JlKCdSZXRyaWV2YWwgY29ycnVwdGlvbicpO1xuICAgICAgZXhwZWN0KG1vY2tTdG9yYWdlLm9wZXJhdGlvbnMpLnRvQ29udGFpbigncmV0cmlldmU6dGVzdCcpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgbm9ybWFsIG9wZXJhdGlvbnMgd2hlbiBjb3JydXB0aW9uIGlzIGRpc2FibGVkJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja1N0b3JhZ2Uuc2V0U2hvdWxkQ29ycnVwdChmYWxzZSk7XG5cbiAgICAgIGNvbnN0IHN0b3JlUmVzdWx0ID0gYXdhaXQgbW9ja1N0b3JhZ2Uuc3RvcmUoJ25vcm1hbCcsIHsgZGF0YTogJ25vcm1hbCcgfSk7XG4gICAgICBleHBlY3Qoc3RvcmVSZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcblxuICAgICAgY29uc3QgcmV0cmlldmVSZXN1bHQgPSBhd2FpdCBtb2NrU3RvcmFnZS5yZXRyaWV2ZSgnbm9ybWFsJyk7XG4gICAgICBleHBlY3QocmV0cmlldmVSZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgdHJhY2sgb3BlcmF0aW9ucyBmb3IgdmVyaWZpY2F0aW9uJywgYXN5bmMgKCkgPT4ge1xuICAgICAgYXdhaXQgbW9ja1N0b3JhZ2Uuc3RvcmUoJ29wMScsIHt9KTtcbiAgICAgIGF3YWl0IG1vY2tTdG9yYWdlLnJldHJpZXZlKCdvcDInKTtcbiAgICAgIGF3YWl0IG1vY2tTdG9yYWdlLnN0b3JlKCdvcDMnLCB7fSk7XG5cbiAgICAgIGV4cGVjdChtb2NrU3RvcmFnZS5vcGVyYXRpb25zKS50b0VxdWFsKFsnc3RvcmU6b3AxJywgJ3JldHJpZXZlOm9wMicsICdzdG9yZTpvcDMnXSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdFdmVudCBIYW5kbGluZyBhbmQgTW9uaXRvcmluZycsICgpID0+IHtcbiAgICBsZXQgc3RvcmFnZTogSW50ZWdyaXR5U3RvcmFnZTtcbiAgICBsZXQgZXZlbnRzOiBBcnJheTx7IHR5cGU6IHN0cmluZzsgZGF0YTogYW55IH0+O1xuXG4gICAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgICBzdG9yYWdlID0gbmV3IEludGVncml0eVN0b3JhZ2UoKTtcbiAgICAgIGV2ZW50cyA9IFtdO1xuXG4gICAgICBzdG9yYWdlLm9uKCdzdG9yZWQnLCAoZGF0YSkgPT4gZXZlbnRzLnB1c2goeyB0eXBlOiAnc3RvcmVkJywgZGF0YSB9KSk7XG4gICAgICBzdG9yYWdlLm9uKCdyZXRyaWV2ZWQnLCAoZGF0YSkgPT4gZXZlbnRzLnB1c2goeyB0eXBlOiAncmV0cmlldmVkJywgZGF0YSB9KSk7XG4gICAgICBzdG9yYWdlLm9uKCdjb3JydXB0aW9uRGV0ZWN0ZWQnLCAoZGF0YSkgPT4gZXZlbnRzLnB1c2goeyB0eXBlOiAnY29ycnVwdGlvbkRldGVjdGVkJywgZGF0YSB9KSk7XG4gICAgICBzdG9yYWdlLm9uKCdkYXRhUmVwYWlyZWQnLCAoZGF0YSkgPT4gZXZlbnRzLnB1c2goeyB0eXBlOiAnZGF0YVJlcGFpcmVkJywgZGF0YSB9KSk7XG4gICAgICBzdG9yYWdlLm9uKCdyZXBhaXJGYWlsZWQnLCAoZGF0YSkgPT4gZXZlbnRzLnB1c2goeyB0eXBlOiAncmVwYWlyRmFpbGVkJywgZGF0YSB9KSk7XG4gICAgfSk7XG5cbiAgICBhZnRlckVhY2goYXN5bmMgKCkgPT4ge1xuICAgICAgYXdhaXQgc3RvcmFnZS5jbGVhcigpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBlbWl0IGV2ZW50cyBmb3Igbm9ybWFsIG9wZXJhdGlvbnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBhd2FpdCBzdG9yYWdlLnN0b3JlKCdldmVudC10ZXN0JywgeyB0ZXN0OiAnZGF0YScgfSk7XG4gICAgICBhd2FpdCBzdG9yYWdlLnJldHJpZXZlKCdldmVudC10ZXN0Jyk7XG5cbiAgICAgIGV4cGVjdChldmVudHMuc29tZShlID0+IGUudHlwZSA9PT0gJ3N0b3JlZCcpKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KGV2ZW50cy5zb21lKGUgPT4gZS50eXBlID09PSAncmV0cmlldmVkJykpLnRvQmUodHJ1ZSk7XG5cbiAgICAgIGNvbnN0IHN0b3JlRXZlbnQgPSBldmVudHMuZmluZChlID0+IGUudHlwZSA9PT0gJ3N0b3JlZCcpO1xuICAgICAgZXhwZWN0KHN0b3JlRXZlbnQ/LmRhdGEuaWQpLnRvQmUoJ2V2ZW50LXRlc3QnKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgZW1pdCBjb3JydXB0aW9uIGRldGVjdGlvbiBldmVudHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBhd2FpdCBzdG9yYWdlLnN0b3JlKCdjb3JydXB0aW9uLWV2ZW50JywgeyBkYXRhOiAndGVzdCcgfSk7XG4gICAgICBhd2FpdCBzdG9yYWdlLnNpbXVsYXRlQ29ycnVwdGlvbignY29ycnVwdGlvbi1ldmVudCcsICdjaGVja3N1bScpO1xuXG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBzdG9yYWdlLnJldHJpZXZlKCdjb3JydXB0aW9uLWV2ZW50Jyk7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgLy8gRXhwZWN0ZWQgdG8gZmFpbFxuICAgICAgfVxuXG4gICAgICBleHBlY3QoZXZlbnRzLnNvbWUoZSA9PiBlLnR5cGUgPT09ICdjb3JydXB0aW9uRGV0ZWN0ZWQnKSkudG9CZSh0cnVlKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1BlcmZvcm1hbmNlIFVuZGVyIENvcnJ1cHRpb24nLCAoKSA9PiB7XG4gICAgbGV0IHN0b3JhZ2U6IEludGVncml0eVN0b3JhZ2U7XG5cbiAgICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICAgIHN0b3JhZ2UgPSBuZXcgSW50ZWdyaXR5U3RvcmFnZSh7XG4gICAgICAgIHZhbGlkYXRpb25FbmFibGVkOiB0cnVlLFxuICAgICAgICBhdXRvUmVwYWlyOiB0cnVlXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGFmdGVyRWFjaChhc3luYyAoKSA9PiB7XG4gICAgICBhd2FpdCBzdG9yYWdlLmNsZWFyKCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGJlbmNobWFyayB2YWxpZGF0aW9uIHBlcmZvcm1hbmNlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgaXRlcmF0aW9ucyA9IDEwMDA7XG4gICAgICBjb25zdCB0ZXN0RGF0YSA9IHsgYmVuY2htYXJrOiAndmFsaWRhdGlvbicsIGRhdGE6ICd4Jy5yZXBlYXQoMTAwKSB9O1xuXG4gICAgICAvLyBTdG9yZSByZWNvcmRzXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZXJhdGlvbnM7IGkrKykge1xuICAgICAgICBhd2FpdCBzdG9yYWdlLnN0b3JlKGBiZW5jaC0ke2l9YCwgeyAuLi50ZXN0RGF0YSwgaW5kZXg6IGkgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIEJlbmNobWFyayB2YWxpZGF0aW9uXG4gICAgICBjb25zdCBzdGFydFRpbWUgPSBwcm9jZXNzLmhydGltZS5iaWdpbnQoKTtcbiAgICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBzdG9yYWdlLnZhbGlkYXRlQWxsKCk7XG4gICAgICBjb25zdCBlbmRUaW1lID0gcHJvY2Vzcy5ocnRpbWUuYmlnaW50KCk7XG5cbiAgICAgIGNvbnN0IGR1cmF0aW9uTXMgPSBOdW1iZXIoZW5kVGltZSAtIHN0YXJ0VGltZSkgLyAxXzAwMF8wMDA7XG4gICAgICBjb25zdCB2YWxpZGF0aW9uc1BlclNlY29uZCA9IChpdGVyYXRpb25zIC8gZHVyYXRpb25NcykgKiAxMDAwO1xuXG4gICAgICBjb25zb2xlLmxvZyhgVmFsaWRhdGlvbiBwZXJmb3JtYW5jZTogJHt2YWxpZGF0aW9uc1BlclNlY29uZC50b0ZpeGVkKDApfSB2YWxpZGF0aW9ucy9zZWNgKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdHMudmFsaWQpLnRvQmUoaXRlcmF0aW9ucyk7XG4gICAgICBleHBlY3QodmFsaWRhdGlvbnNQZXJTZWNvbmQpLnRvQmVHcmVhdGVyVGhhbigxMDApOyAvLyBTaG91bGQgdmFsaWRhdGUgYXQgbGVhc3QgMTAwL3NlY1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgbWl4ZWQgY29ycnVwdGlvbiBzY2VuYXJpb3MnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCByZWNvcmRDb3VudCA9IDEwMDtcbiAgICAgIGNvbnN0IGNvcnJ1cHRpb25SYXRlID0gMC4xOyAvLyAxMCUgY29ycnVwdGlvblxuXG4gICAgICAvLyBTdG9yZSByZWNvcmRzXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlY29yZENvdW50OyBpKyspIHtcbiAgICAgICAgYXdhaXQgc3RvcmFnZS5zdG9yZShgbWl4ZWQtJHtpfWAsIHsgaW5kZXg6IGksIGRhdGE6IGByZWNvcmQtJHtpfWAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFJhbmRvbWx5IGNvcnJ1cHQgc29tZSByZWNvcmRzXG4gICAgICBjb25zdCBjb3JydXB0ZWRDb3VudCA9IE1hdGguZmxvb3IocmVjb3JkQ291bnQgKiBjb3JydXB0aW9uUmF0ZSk7XG4gICAgICBjb25zdCBjb3JydXB0aW9uVHlwZXM6IEFycmF5PCdjaGVja3N1bScgfCAnZGF0YScgfCAnc3RydWN0dXJlJz4gPSBbJ2NoZWNrc3VtJywgJ2RhdGEnLCAnc3RydWN0dXJlJ107XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29ycnVwdGVkQ291bnQ7IGkrKykge1xuICAgICAgICBjb25zdCByZWNvcmRJbmRleCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIHJlY29yZENvdW50KTtcbiAgICAgICAgY29uc3QgY29ycnVwdGlvblR5cGUgPSBjb3JydXB0aW9uVHlwZXNbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogY29ycnVwdGlvblR5cGVzLmxlbmd0aCldO1xuICAgICAgICBhd2FpdCBzdG9yYWdlLnNpbXVsYXRlQ29ycnVwdGlvbihgbWl4ZWQtJHtyZWNvcmRJbmRleH1gLCBjb3JydXB0aW9uVHlwZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFZhbGlkYXRlIGFsbCBhbmQgbWVhc3VyZSByZXN1bHRzXG4gICAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgc3RvcmFnZS52YWxpZGF0ZUFsbCgpO1xuXG4gICAgICBleHBlY3QocmVzdWx0cy52YWxpZCArIHJlc3VsdHMuY29ycnVwdGVkKS50b0JlKHJlY29yZENvdW50KTtcbiAgICAgIGV4cGVjdChyZXN1bHRzLmNvcnJ1cHRlZCkudG9CZUdyZWF0ZXJUaGFuT3JFcXVhbCgwKTtcbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coYE1peGVkIGNvcnJ1cHRpb24gdGVzdDogJHtyZXN1bHRzLnZhbGlkfSB2YWxpZCwgJHtyZXN1bHRzLmNvcnJ1cHRlZH0gY29ycnVwdGVkLCAke3Jlc3VsdHMucmVwYWlyZWR9IHJlcGFpcmVkYCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdDb21wbGV4IERhdGEgU3RydWN0dXJlcycsICgpID0+IHtcbiAgICBsZXQgc3RvcmFnZTogSW50ZWdyaXR5U3RvcmFnZTtcblxuICAgIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgICAgc3RvcmFnZSA9IG5ldyBJbnRlZ3JpdHlTdG9yYWdlKCk7XG4gICAgfSk7XG5cbiAgICBhZnRlckVhY2goYXN5bmMgKCkgPT4ge1xuICAgICAgYXdhaXQgc3RvcmFnZS5jbGVhcigpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgbmVzdGVkIG9iamVjdCBpbnRlZ3JpdHknLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBjb21wbGV4RGF0YSA9IHtcbiAgICAgICAgdXNlcjoge1xuICAgICAgICAgIGlkOiAndXNlcjEyMycsXG4gICAgICAgICAgcHJvZmlsZToge1xuICAgICAgICAgICAgbmFtZTogJ0pvaG4gRG9lJyxcbiAgICAgICAgICAgIHByZWZlcmVuY2VzOiB7XG4gICAgICAgICAgICAgIHRoZW1lOiAnZGFyaycsXG4gICAgICAgICAgICAgIG5vdGlmaWNhdGlvbnM6IHtcbiAgICAgICAgICAgICAgICBlbWFpbDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBwdXNoOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBzbXM6IHRydWVcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgICBjcmVhdGVkOiBEYXRlLm5vdygpLFxuICAgICAgICAgIHRhZ3M6IFsnaW1wb3J0YW50JywgJ3VzZXItZGF0YSddLFxuICAgICAgICAgIGZsYWdzOiB7XG4gICAgICAgICAgICB2ZXJpZmllZDogdHJ1ZSxcbiAgICAgICAgICAgIHByZW1pdW06IGZhbHNlXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBjb25zdCByZWNvcmQgPSBhd2FpdCBzdG9yYWdlLnN0b3JlKCdjb21wbGV4LWRhdGEnLCBjb21wbGV4RGF0YSk7XG4gICAgICBleHBlY3QocmVjb3JkLmNoZWNrc3VtKS50b0JlRGVmaW5lZCgpO1xuXG4gICAgICBjb25zdCByZXRyaWV2ZWQgPSBhd2FpdCBzdG9yYWdlLnJldHJpZXZlKCdjb21wbGV4LWRhdGEnKTtcbiAgICAgIGV4cGVjdChyZXRyaWV2ZWQhLmRhdGEpLnRvRXF1YWwoY29tcGxleERhdGEpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBkZXRlY3Qgc3VidGxlIG5lc3RlZCBjb3JydXB0aW9uJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3Qgb3JpZ2luYWxEYXRhID0ge1xuICAgICAgICBjb25maWc6IHtcbiAgICAgICAgICBkYXRhYmFzZToge1xuICAgICAgICAgICAgaG9zdDogJ2xvY2FsaG9zdCcsXG4gICAgICAgICAgICBwb3J0OiA1NDMyLFxuICAgICAgICAgICAgY3JlZGVudGlhbHM6IHtcbiAgICAgICAgICAgICAgdXNlcm5hbWU6ICdhZG1pbicsXG4gICAgICAgICAgICAgIHBhc3N3b3JkOiAnc2VjcmV0J1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgYXdhaXQgc3RvcmFnZS5zdG9yZSgnbmVzdGVkLXRlc3QnLCBvcmlnaW5hbERhdGEpO1xuICAgICAgYXdhaXQgc3RvcmFnZS5zaW11bGF0ZUNvcnJ1cHRpb24oJ25lc3RlZC10ZXN0JywgJ3N0cnVjdHVyZScpO1xuXG4gICAgICBjb25zdCB2YWxpZGF0aW9uID0gYXdhaXQgc3RvcmFnZS52YWxpZGF0ZVJlY29yZCgoc3RvcmFnZSBhcyBhbnkpLnJlY29yZHMuZ2V0KCduZXN0ZWQtdGVzdCcpKTtcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uLnZhbGlkKS50b0JlKGZhbHNlKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgbWFpbnRhaW4gaW50ZWdyaXR5IHdpdGggbGFyZ2UgZGF0YXNldHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBsYXJnZURhdGEgPSB7XG4gICAgICAgIG1hdHJpeDogQXJyYXkuZnJvbSh7IGxlbmd0aDogMTAwIH0sIChfLCBpKSA9PlxuICAgICAgICAgIEFycmF5LmZyb20oeyBsZW5ndGg6IDEwMCB9LCAoXywgaikgPT4gaSAqIDEwMCArIGopXG4gICAgICAgICksXG4gICAgICAgIGxvb2t1cDogT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgICAgIEFycmF5LmZyb20oeyBsZW5ndGg6IDEwMDAgfSwgKF8sIGkpID0+IFtga2V5XyR7aX1gLCBgdmFsdWVfJHtpfWBdKVxuICAgICAgICApXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBzdGFydFRpbWUgPSBwcm9jZXNzLmhydGltZS5iaWdpbnQoKTtcbiAgICAgIGNvbnN0IHJlY29yZCA9IGF3YWl0IHN0b3JhZ2Uuc3RvcmUoJ2xhcmdlLWRhdGFzZXQnLCBsYXJnZURhdGEpO1xuICAgICAgY29uc3Qgc3RvcmVUaW1lID0gcHJvY2Vzcy5ocnRpbWUuYmlnaW50KCk7XG5cbiAgICAgIGNvbnN0IHJldHJpZXZlZCA9IGF3YWl0IHN0b3JhZ2UucmV0cmlldmUoJ2xhcmdlLWRhdGFzZXQnKTtcbiAgICAgIGNvbnN0IHJldHJpZXZlVGltZSA9IHByb2Nlc3MuaHJ0aW1lLmJpZ2ludCgpO1xuXG4gICAgICBjb25zdCBzdG9yZUR1cmF0aW9uID0gTnVtYmVyKHN0b3JlVGltZSAtIHN0YXJ0VGltZSkgLyAxXzAwMF8wMDA7XG4gICAgICBjb25zdCByZXRyaWV2ZUR1cmF0aW9uID0gTnVtYmVyKHJldHJpZXZlVGltZSAtIHN0b3JlVGltZSkgLyAxXzAwMF8wMDA7XG5cbiAgICAgIGNvbnNvbGUubG9nKGBMYXJnZSBkYXRhc2V0IC0gU3RvcmU6ICR7c3RvcmVEdXJhdGlvbi50b0ZpeGVkKDIpfW1zLCBSZXRyaWV2ZTogJHtyZXRyaWV2ZUR1cmF0aW9uLnRvRml4ZWQoMil9bXNgKTtcblxuICAgICAgZXhwZWN0KHJldHJpZXZlZCEuZGF0YSkudG9FcXVhbChsYXJnZURhdGEpO1xuICAgICAgZXhwZWN0KHN0b3JlRHVyYXRpb24pLnRvQmVMZXNzVGhhbigxMDAwKTsgLy8gU2hvdWxkIGNvbXBsZXRlIHdpdGhpbiAxIHNlY29uZFxuICAgICAgZXhwZWN0KHJldHJpZXZlRHVyYXRpb24pLnRvQmVMZXNzVGhhbigxMDAwKTtcbiAgICB9KTtcbiAgfSk7XG59KTsiXSwidmVyc2lvbiI6M30=