03d18b7fc1088a417177629d4c5193dc
/**
 * CLI Command Processing Tests - TDD London School
 *
 * Comprehensive tests for CLI command processing behavior using London TDD approach.
 * Tests focus on interactions and behavior verification rather than state testing.
 */
import { jest, describe, it, expect, beforeEach } from '@jest/globals';
describe('CLI Command Processing - TDD London', () => {
    let mockRegistry;
    let mockParser;
    let mockFormatter;
    let mockErrorHandler;
    beforeEach(() => {
        // Setup mocks for all CLI components
        mockRegistry = {
            register: jest.fn(),
            unregister: jest.fn(),
            execute: jest.fn(),
            has: jest.fn(),
            list: jest.fn()
        };
        mockParser = {
            parse: jest.fn(),
            validate: jest.fn()
        };
        mockFormatter = {
            format: jest.fn(),
            setDefaults: jest.fn()
        };
        mockErrorHandler = {
            handle: jest.fn(),
            register: jest.fn()
        };
    });
    describe('command registration behavior', () => {
        it('should register command and verify registration call', () => {
            // Arrange
            const commandConfig = {
                name: 'test-command',
                description: 'Test command',
                handler: jest.fn()
            };
            // Act
            mockRegistry.register(commandConfig);
            // Assert - verify interaction
            expect(mockRegistry.register).toHaveBeenCalledWith(commandConfig);
            expect(mockRegistry.register).toHaveBeenCalledTimes(1);
        });
        it('should check command existence through registry', () => {
            // Arrange
            const commandName = 'status';
            mockRegistry.has.mockReturnValue(true);
            // Act
            const exists = mockRegistry.has(commandName);
            // Assert - verify behavior
            expect(mockRegistry.has).toHaveBeenCalledWith(commandName);
            expect(exists).toBe(true);
        });
        it('should list registered commands', () => {
            // Arrange
            const expectedCommands = [
                { name: 'status', description: 'Show status' },
                { name: 'init', description: 'Initialize project' }
            ];
            mockRegistry.list.mockReturnValue(expectedCommands);
            // Act
            const commands = mockRegistry.list();
            // Assert - verify interaction and result
            expect(mockRegistry.list).toHaveBeenCalled();
            expect(commands).toEqual(expectedCommands);
        });
        it('should unregister command and confirm removal', () => {
            // Arrange
            const commandName = 'old-command';
            mockRegistry.unregister.mockReturnValue(true);
            // Act
            const removed = mockRegistry.unregister(commandName);
            // Assert - verify unregistration behavior
            expect(mockRegistry.unregister).toHaveBeenCalledWith(commandName);
            expect(removed).toBe(true);
        });
    });
    describe('argument parsing behavior', () => {
        it('should parse command line arguments correctly', () => {
            // Arrange
            const args = ['deploy', 'app', '--env', 'production', '--verbose'];
            const expectedResult = {
                command: 'deploy',
                args: ['app'],
                flags: { env: 'production', verbose: true }
            };
            mockParser.parse.mockReturnValue(expectedResult);
            // Act
            const result = mockParser.parse(args);
            // Assert - verify parsing interaction
            expect(mockParser.parse).toHaveBeenCalledWith(args);
            expect(result).toEqual(expectedResult);
        });
        it('should validate parsed arguments', () => {
            // Arrange
            const parseResult = {
                command: 'deploy',
                args: ['app'],
                flags: { env: 'production' }
            };
            const validationResult = {
                valid: true,
                errors: [],
                warnings: []
            };
            mockParser.validate.mockReturnValue(validationResult);
            // Act
            const result = mockParser.validate(parseResult);
            // Assert - verify validation behavior
            expect(mockParser.validate).toHaveBeenCalledWith(parseResult);
            expect(result.valid).toBe(true);
        });
        it('should handle parsing errors gracefully', () => {
            // Arrange
            const invalidArgs = ['--invalid-flag-without-command'];
            const errorResult = {
                command: null,
                args: [],
                flags: {},
                errors: ['No command specified']
            };
            mockParser.parse.mockReturnValue(errorResult);
            // Act
            const result = mockParser.parse(invalidArgs);
            // Assert - verify error handling behavior
            expect(mockParser.parse).toHaveBeenCalledWith(invalidArgs);
            expect(result.command).toBeNull();
            expect(result.errors).toContain('No command specified');
        });
    });
    describe('command execution behavior', () => {
        it('should execute command with proper context', async () => {
            // Arrange
            const context = {
                args: ['app'],
                flags: { env: 'production', verbose: true },
                command: 'deploy'
            };
            const expectedResult = {
                success: true,
                exitCode: 0,
                message: 'Deployment successful',
                data: { deployed: true }
            };
            mockRegistry.execute.mockResolvedValue(expectedResult);
            // Act
            const result = await mockRegistry.execute('deploy', context);
            // Assert - verify execution behavior
            expect(mockRegistry.execute).toHaveBeenCalledWith('deploy', context);
            expect(result).toEqual(expectedResult);
        });
        it('should handle command execution failure', async () => {
            // Arrange
            const context = {
                args: [],
                flags: {},
                command: 'failing-command'
            };
            const errorResult = {
                success: false,
                exitCode: 1,
                message: 'Command execution failed'
            };
            mockRegistry.execute.mockResolvedValue(errorResult);
            // Act
            const result = await mockRegistry.execute('failing-command', context);
            // Assert - verify failure handling
            expect(mockRegistry.execute).toHaveBeenCalledWith('failing-command', context);
            expect(result.success).toBe(false);
            expect(result.exitCode).toBe(1);
        });
        it('should handle command not found scenario', async () => {
            // Arrange
            const context = {
                args: [],
                flags: {},
                command: 'unknown-command'
            };
            const notFoundResult = {
                success: false,
                exitCode: 127,
                message: 'Command not found'
            };
            mockRegistry.execute.mockResolvedValue(notFoundResult);
            // Act
            const result = await mockRegistry.execute('unknown-command', context);
            // Assert - verify not found behavior
            expect(result.exitCode).toBe(127);
            expect(result.message).toContain('Command not found');
        });
    });
    describe('output formatting behavior', () => {
        it('should format command output in specified format', () => {
            // Arrange
            const data = { status: 'running', agents: 3, tasks: 15 };
            const options = { format: 'json', indent: 2 };
            const expectedOutput = JSON.stringify(data, null, 2);
            mockFormatter.format.mockReturnValue(expectedOutput);
            // Act
            const result = mockFormatter.format(data, options);
            // Assert - verify formatting interaction
            expect(mockFormatter.format).toHaveBeenCalledWith(data, options);
            expect(result).toBe(expectedOutput);
        });
        it('should apply default formatting options', () => {
            // Arrange
            const defaults = { format: 'table', colors: true };
            // Act
            mockFormatter.setDefaults(defaults);
            // Assert - verify defaults application
            expect(mockFormatter.setDefaults).toHaveBeenCalledWith(defaults);
        });
        it('should handle different output formats', () => {
            // Arrange
            const testData = { message: 'test output' };
            const formats = ['json', 'yaml', 'table', 'text'];
            const expectedOutputs = {
                json: '{"message": "test output"}',
                yaml: 'message: test output',
                table: '| message      | \n| test output  |',
                text: 'message: test output'
            };
            // Act & Assert for each format
            formats.forEach(format => {
                mockFormatter.format.mockReturnValue(expectedOutputs[format]);
                const result = mockFormatter.format(testData, { format });
                expect(mockFormatter.format).toHaveBeenCalledWith(testData, { format });
                expect(result).toBe(expectedOutputs[format]);
            });
        });
    });
    describe('error handling behavior', () => {
        it('should handle errors and return error result', async () => {
            // Arrange
            const error = new Error('Test error');
            const context = { command: 'test-command', args: [], flags: {} };
            const errorResult = {
                handled: true,
                exitCode: 1,
                message: 'Test error handled',
                recovered: false
            };
            mockErrorHandler.handle.mockResolvedValue(errorResult);
            // Act
            const result = await mockErrorHandler.handle(error, context);
            // Assert - verify error handling behavior
            expect(mockErrorHandler.handle).toHaveBeenCalledWith(error, context);
            expect(result.handled).toBe(true);
            expect(result.exitCode).toBe(1);
        });
        it('should register error handlers for specific error types', () => {
            // Arrange
            const errorType = 'ValidationError';
            const handler = jest.fn();
            // Act
            mockErrorHandler.register(errorType, handler);
            // Assert - verify handler registration
            expect(mockErrorHandler.register).toHaveBeenCalledWith(errorType, handler);
        });
        it('should handle different error severity levels', async () => {
            // Arrange
            const criticalError = new Error('Critical system failure');
            const warningError = new Error('Non-critical warning');
            const criticalResult = {
                handled: true,
                exitCode: 2,
                message: 'Critical error handled',
                severity: 'critical'
            };
            const warningResult = {
                handled: true,
                exitCode: 0,
                message: 'Warning handled',
                severity: 'warning'
            };
            mockErrorHandler.handle
                .mockResolvedValueOnce(criticalResult)
                .mockResolvedValueOnce(warningResult);
            // Act
            const criticalHandling = await mockErrorHandler.handle(criticalError);
            const warningHandling = await mockErrorHandler.handle(warningError);
            // Assert - verify severity-based handling
            expect(criticalHandling.exitCode).toBe(2);
            expect(warningHandling.exitCode).toBe(0);
            expect(mockErrorHandler.handle).toHaveBeenCalledTimes(2);
        });
    });
    describe('integration behavior', () => {
        it('should coordinate between all components for successful command execution', async () => {
            // Arrange - Setup the complete flow
            const input = ['status', '--format', 'json'];
            const parseResult = {
                command: 'status',
                args: [],
                flags: { format: 'json' }
            };
            const executionResult = {
                success: true,
                exitCode: 0,
                data: { active: true, agents: 2 }
            };
            const formattedOutput = '{"active": true, "agents": 2}';
            // Setup mock interactions
            mockParser.parse.mockReturnValue(parseResult);
            mockRegistry.execute.mockResolvedValue(executionResult);
            mockFormatter.format.mockReturnValue(formattedOutput);
            // Act - Simulate the complete flow
            const parsed = mockParser.parse(input);
            const executed = await mockRegistry.execute(parsed.command, {
                args: parsed.args,
                flags: parsed.flags,
                command: parsed.command
            });
            const formatted = mockFormatter.format(executed.data, parsed.flags);
            // Assert - Verify complete interaction chain
            expect(mockParser.parse).toHaveBeenCalledWith(input);
            expect(mockRegistry.execute).toHaveBeenCalledWith('status', expect.any(Object));
            expect(mockFormatter.format).toHaveBeenCalledWith(executionResult.data, parseResult.flags);
            expect(formatted).toBe(formattedOutput);
        });
        it('should handle errors throughout the execution chain', async () => {
            // Arrange - Setup error scenario
            const input = ['invalid-command'];
            const parseResult = {
                command: 'invalid-command',
                args: [],
                flags: {}
            };
            const executionError = new Error('Command not found');
            const errorResult = {
                handled: true,
                exitCode: 127,
                message: 'Command not found'
            };
            // Setup mock interactions
            mockParser.parse.mockReturnValue(parseResult);
            mockRegistry.execute.mockRejectedValue(executionError);
            mockErrorHandler.handle.mockResolvedValue(errorResult);
            // Act - Simulate error flow
            const parsed = mockParser.parse(input);
            try {
                await mockRegistry.execute(parsed.command, {
                    args: parsed.args,
                    flags: parsed.flags,
                    command: parsed.command
                });
            }
            catch (error) {
                await mockErrorHandler.handle(error, { command: parsed.command });
            }
            // Assert - Verify error handling chain
            expect(mockParser.parse).toHaveBeenCalledWith(input);
            expect(mockRegistry.execute).toHaveBeenCalledWith('invalid-command', expect.any(Object));
            expect(mockErrorHandler.handle).toHaveBeenCalledWith(executionError, expect.any(Object));
        });
        it('should validate arguments before command execution', () => {
            // Arrange
            const parseResult = {
                command: 'deploy',
                args: [],
                flags: { env: 'production' }
            };
            const validationResult = {
                valid: false,
                errors: ['Missing required argument: target'],
                warnings: []
            };
            mockParser.validate.mockReturnValue(validationResult);
            // Act
            const validation = mockParser.validate(parseResult);
            // Assert - Verify validation step
            expect(mockParser.validate).toHaveBeenCalledWith(parseResult);
            expect(validation.valid).toBe(false);
            expect(validation.errors).toContain('Missing required argument: target');
        });
    });
    describe('command lifecycle behavior', () => {
        it('should handle command initialization and cleanup', async () => {
            // Arrange
            const initFunction = jest.fn().mockResolvedValue(undefined);
            const cleanupFunction = jest.fn().mockResolvedValue(undefined);
            // Act - Simulate lifecycle
            await initFunction();
            // ... command execution would happen here
            await cleanupFunction();
            // Assert - Verify lifecycle calls
            expect(initFunction).toHaveBeenCalled();
            expect(cleanupFunction).toHaveBeenCalled();
        });
        it('should track command execution metrics', async () => {
            // Arrange
            const metricsTracker = {
                recordExecution: jest.fn(),
                recordSuccess: jest.fn(),
                recordFailure: jest.fn()
            };
            const context = {
                args: [],
                flags: {},
                command: 'status'
            };
            // Act - Simulate execution with metrics
            metricsTracker.recordExecution('status');
            const result = await mockRegistry.execute('status', context);
            if (result && result.success) {
                metricsTracker.recordSuccess('status');
            }
            else {
                metricsTracker.recordFailure('status');
            }
            // Assert - Verify metrics tracking
            expect(metricsTracker.recordExecution).toHaveBeenCalledWith('status');
            // The success/failure call depends on the mock setup
        });
    });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL2hvbWUvbWh1Z28vY29kZS9jbGF1ZGUtY29kZS1mbG93L3NyYy9fX3Rlc3RzX18vdW5pdC9sb25kb24vY2xpLWNvbW1hbmRzL2NsaS1jb21tYW5kLXByb2Nlc3NpbmcudGVzdC50cyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7R0FLRztBQUVILE9BQU8sRUFBRSxJQUFJLEVBQUUsUUFBUSxFQUFFLEVBQUUsRUFBRSxNQUFNLEVBQUUsVUFBVSxFQUFhLE1BQU0sZUFBZSxDQUFDO0FBdUNsRixRQUFRLENBQUMscUNBQXFDLEVBQUUsR0FBRyxFQUFFO0lBQ25ELElBQUksWUFBaUMsQ0FBQztJQUN0QyxJQUFJLFVBQThCLENBQUM7SUFDbkMsSUFBSSxhQUFrQyxDQUFDO0lBQ3ZDLElBQUksZ0JBQWtDLENBQUM7SUFFdkMsVUFBVSxDQUFDLEdBQUcsRUFBRTtRQUNkLHFDQUFxQztRQUNyQyxZQUFZLEdBQUc7WUFDYixRQUFRLEVBQUUsSUFBSSxDQUFDLEVBQUUsRUFBRTtZQUNuQixVQUFVLEVBQUUsSUFBSSxDQUFDLEVBQUUsRUFBRTtZQUNyQixPQUFPLEVBQUUsSUFBSSxDQUFDLEVBQUUsRUFBRTtZQUNsQixHQUFHLEVBQUUsSUFBSSxDQUFDLEVBQUUsRUFBRTtZQUNkLElBQUksRUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFO1NBQ2hCLENBQUM7UUFFRixVQUFVLEdBQUc7WUFDWCxLQUFLLEVBQUUsSUFBSSxDQUFDLEVBQUUsRUFBRTtZQUNoQixRQUFRLEVBQUUsSUFBSSxDQUFDLEVBQUUsRUFBRTtTQUNwQixDQUFDO1FBRUYsYUFBYSxHQUFHO1lBQ2QsTUFBTSxFQUFFLElBQUksQ0FBQyxFQUFFLEVBQUU7WUFDakIsV0FBVyxFQUFFLElBQUksQ0FBQyxFQUFFLEVBQUU7U0FDdkIsQ0FBQztRQUVGLGdCQUFnQixHQUFHO1lBQ2pCLE1BQU0sRUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFO1lBQ2pCLFFBQVEsRUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFO1NBQ3BCLENBQUM7SUFDSixDQUFDLENBQUMs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YUFDbEIsQ0FBQztZQUVGLHdDQUF3QztZQUN4QyxjQUFjLENBQUMsZUFBZSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1lBRXpDLE1BQU0sTUFBTSxHQUFHLE1BQU0sWUFBWSxDQUFDLE9BQU8sQ0FBQyxRQUFRLEVBQUUsT0FBTyxDQUFDLENBQUM7WUFFN0QsSUFBSSxNQUFNLElBQUksTUFBTSxDQUFDLE9BQU8sRUFBRSxDQUFDO2dCQUM3QixjQUFjLENBQUMsYUFBYSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1lBQ3pDLENBQUM7aUJBQU0sQ0FBQztnQkFDTixjQUFjLENBQUMsYUFBYSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1lBQ3pDLENBQUM7WUFFRCxtQ0FBbUM7WUFDbkMsTUFBTSxDQUFDLGNBQWMsQ0FBQyxlQUFlLENBQUMsQ0FBQyxvQkFBb0IsQ0FBQyxRQUFRLENBQUMsQ0FBQztZQUN0RSxxREFBcUQ7UUFDdkQsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDLENBQUMsQ0FBQztBQUNMLENBQUMsQ0FBQyxDQUFDIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIi9ob21lL21odWdvL2NvZGUvY2xhdWRlLWNvZGUtZmxvdy9zcmMvX190ZXN0c19fL3VuaXQvbG9uZG9uL2NsaS1jb21tYW5kcy9jbGktY29tbWFuZC1wcm9jZXNzaW5nLnRlc3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDTEkgQ29tbWFuZCBQcm9jZXNzaW5nIFRlc3RzIC0gVEREIExvbmRvbiBTY2hvb2xcbiAqIFxuICogQ29tcHJlaGVuc2l2ZSB0ZXN0cyBmb3IgQ0xJIGNvbW1hbmQgcHJvY2Vzc2luZyBiZWhhdmlvciB1c2luZyBMb25kb24gVEREIGFwcHJvYWNoLlxuICogVGVzdHMgZm9jdXMgb24gaW50ZXJhY3Rpb25zIGFuZCBiZWhhdmlvciB2ZXJpZmljYXRpb24gcmF0aGVyIHRoYW4gc3RhdGUgdGVzdGluZy5cbiAqL1xuXG5pbXBvcnQgeyBqZXN0LCBkZXNjcmliZSwgaXQsIGV4cGVjdCwgYmVmb3JlRWFjaCwgYWZ0ZXJFYWNoIH0gZnJvbSAnQGplc3QvZ2xvYmFscyc7XG5cbi8vIE1vY2sgdHlwZXMgZm9yIHRlc3RpbmcgQ0xJIGNvbW1hbmQgcHJvY2Vzc2luZ1xuaW50ZXJmYWNlIE1vY2tDb21tYW5kUmVnaXN0cnkge1xuICByZWdpc3RlcjogamVzdC5Nb2NrO1xuICB1bnJlZ2lzdGVyOiBqZXN0Lk1vY2s7XG4gIGV4ZWN1dGU6IGplc3QuTW9jaztcbiAgaGFzOiBqZXN0Lk1vY2s7XG4gIGxpc3Q6IGplc3QuTW9jaztcbn1cblxuaW50ZXJmYWNlIE1vY2tDb21tYW5kQ29udGV4dCB7XG4gIGFyZ3M6IHN0cmluZ1tdO1xuICBmbGFnczogUmVjb3JkPHN0cmluZywgdW5rbm93bj47XG4gIGNvbW1hbmQ6IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIE1vY2tDb21tYW5kUmVzdWx0IHtcbiAgc3VjY2VzczogYm9vbGVhbjtcbiAgZXhpdENvZGU6IG51bWJlcjtcbiAgbWVzc2FnZT86IHN0cmluZztcbiAgZGF0YT86IHVua25vd247XG59XG5cbmludGVyZmFjZSBNb2NrQXJndW1lbnRQYXJzZXIge1xuICBwYXJzZTogamVzdC5Nb2NrO1xuICB2YWxpZGF0ZTogamVzdC5Nb2NrO1xufVxuXG5pbnRlcmZhY2UgTW9ja091dHB1dEZvcm1hdHRlciB7XG4gIGZvcm1hdDogamVzdC5Nb2NrO1xuICBzZXREZWZhdWx0czogamVzdC5Nb2NrO1xufVxuXG5pbnRlcmZhY2UgTW9ja0Vycm9ySGFuZGxlciB7XG4gIGhhbmRsZTogamVzdC5Nb2NrO1xuICByZWdpc3RlcjogamVzdC5Nb2NrO1xufVxuXG5kZXNjcmliZSgnQ0xJIENvbW1hbmQgUHJvY2Vzc2luZyAtIFRERCBMb25kb24nLCAoKSA9PiB7XG4gIGxldCBtb2NrUmVnaXN0cnk6IE1vY2tDb21tYW5kUmVnaXN0cnk7XG4gIGxldCBtb2NrUGFyc2VyOiBNb2NrQXJndW1lbnRQYXJzZXI7XG4gIGxldCBtb2NrRm9ybWF0dGVyOiBNb2NrT3V0cHV0Rm9ybWF0dGVyO1xuICBsZXQgbW9ja0Vycm9ySGFuZGxlcjogTW9ja0Vycm9ySGFuZGxlcjtcblxuICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICAvLyBTZXR1cCBtb2NrcyBmb3IgYWxsIENMSSBjb21wb25lbnRzXG4gICAgbW9ja1JlZ2lzdHJ5ID0ge1xuICAgICAgcmVnaXN0ZXI6IGplc3QuZm4oKSxcbiAgICAgIHVucmVnaXN0ZXI6IGplc3QuZm4oKSxcbiAgICAgIGV4ZWN1dGU6IGplc3QuZm4oKSxcbiAgICAgIGhhczogamVzdC5mbigpLFxuICAgICAgbGlzdDogamVzdC5mbigpXG4gICAgfTtcblxuICAgIG1vY2tQYXJzZXIgPSB7XG4gICAgICBwYXJzZTogamVzdC5mbigpLFxuICAgICAgdmFsaWRhdGU6IGplc3QuZm4oKVxuICAgIH07XG5cbiAgICBtb2NrRm9ybWF0dGVyID0ge1xuICAgICAgZm9ybWF0OiBqZXN0LmZuKCksXG4gICAgICBzZXREZWZhdWx0czogamVzdC5mbigpXG4gICAgfTtcblxuICAgIG1vY2tFcnJvckhhbmRsZXIgPSB7XG4gICAgICBoYW5kbGU6IGplc3QuZm4oKSxcbiAgICAgIHJlZ2lzdGVyOiBqZXN0LmZuKClcbiAgICB9O1xuICB9KTtcblxuICBkZXNjcmliZSgnY29tbWFuZCByZWdpc3RyYXRpb24gYmVoYXZpb3InLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCByZWdpc3RlciBjb21tYW5kIGFuZCB2ZXJpZnkgcmVnaXN0cmF0aW9uIGNhbGwnLCAoKSA9PiB7XG4gICAgICAvLyBBcnJhbmdlXG4gICAgICBjb25zdCBjb21tYW5kQ29uZmlnID0ge1xuICAgICAgICBuYW1lOiAndGVzdC1jb21tYW5kJyxcbiAgICAgICAgZGVzY3JpcHRpb246ICdUZXN0IGNvbW1hbmQnLFxuICAgICAgICBoYW5kbGVyOiBqZXN0LmZuKClcbiAgICAgIH07XG5cbiAgICAgIC8vIEFjdFxuICAgICAgbW9ja1JlZ2lzdHJ5LnJlZ2lzdGVyKGNvbW1hbmRDb25maWcpO1xuXG4gICAgICAvLyBBc3NlcnQgLSB2ZXJpZnkgaW50ZXJhY3Rpb25cbiAgICAgIGV4cGVjdChtb2NrUmVnaXN0cnkucmVnaXN0ZXIpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKGNvbW1hbmRDb25maWcpO1xuICAgICAgZXhwZWN0KG1vY2tSZWdpc3RyeS5yZWdpc3RlcikudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDEpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBjaGVjayBjb21tYW5kIGV4aXN0ZW5jZSB0aHJvdWdoIHJlZ2lzdHJ5JywgKCkgPT4ge1xuICAgICAgLy8gQXJyYW5nZVxuICAgICAgY29uc3QgY29tbWFuZE5hbWUgPSAnc3RhdHVzJztcbiAgICAgIG1vY2tSZWdpc3RyeS5oYXMubW9ja1JldHVyblZhbHVlKHRydWUpO1xuXG4gICAgICAvLyBBY3RcbiAgICAgIGNvbnN0IGV4aXN0cyA9IG1vY2tSZWdpc3RyeS5oYXMoY29tbWFuZE5hbWUpO1xuXG4gICAgICAvLyBBc3NlcnQgLSB2ZXJpZnkgYmVoYXZpb3JcbiAgICAgIGV4cGVjdChtb2NrUmVnaXN0cnkuaGFzKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChjb21tYW5kTmFtZSk7XG4gICAgICBleHBlY3QoZXhpc3RzKS50b0JlKHRydWUpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBsaXN0IHJlZ2lzdGVyZWQgY29tbWFuZHMnLCAoKSA9PiB7XG4gICAgICAvLyBBcnJhbmdlXG4gICAgICBjb25zdCBleHBlY3RlZENvbW1hbmRzID0gW1xuICAgICAgICB7IG5hbWU6ICdzdGF0dXMnLCBkZXNjcmlwdGlvbjogJ1Nob3cgc3RhdHVzJyB9LFxuICAgICAgICB7IG5hbWU6ICdpbml0JywgZGVzY3JpcHRpb246ICdJbml0aWFsaXplIHByb2plY3QnIH1cbiAgICAgIF07XG4gICAgICBtb2NrUmVnaXN0cnkubGlzdC5tb2NrUmV0dXJuVmFsdWUoZXhwZWN0ZWRDb21tYW5kcyk7XG5cbiAgICAgIC8vIEFjdFxuICAgICAgY29uc3QgY29tbWFuZHMgPSBtb2NrUmVnaXN0cnkubGlzdCgpO1xuXG4gICAgICAvLyBBc3NlcnQgLSB2ZXJpZnkgaW50ZXJhY3Rpb24gYW5kIHJlc3VsdFxuICAgICAgZXhwZWN0KG1vY2tSZWdpc3RyeS5saXN0KS50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgICBleHBlY3QoY29tbWFuZHMpLnRvRXF1YWwoZXhwZWN0ZWRDb21tYW5kcyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHVucmVnaXN0ZXIgY29tbWFuZCBhbmQgY29uZmlybSByZW1vdmFsJywgKCkgPT4ge1xuICAgICAgLy8gQXJyYW5nZVxuICAgICAgY29uc3QgY29tbWFuZE5hbWUgPSAnb2xkLWNvbW1hbmQnO1xuICAgICAgbW9ja1JlZ2lzdHJ5LnVucmVnaXN0ZXIubW9ja1JldHVyblZhbHVlKHRydWUpO1xuXG4gICAgICAvLyBBY3RcbiAgICAgIGNvbnN0IHJlbW92ZWQgPSBtb2NrUmVnaXN0cnkudW5yZWdpc3Rlcihjb21tYW5kTmFtZSk7XG5cbiAgICAgIC8vIEFzc2VydCAtIHZlcmlmeSB1bnJlZ2lzdHJhdGlvbiBiZWhhdmlvclxuICAgICAgZXhwZWN0KG1vY2tSZWdpc3RyeS51bnJlZ2lzdGVyKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChjb21tYW5kTmFtZSk7XG4gICAgICBleHBlY3QocmVtb3ZlZCkudG9CZSh0cnVlKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ2FyZ3VtZW50IHBhcnNpbmcgYmVoYXZpb3InLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBwYXJzZSBjb21tYW5kIGxpbmUgYXJndW1lbnRzIGNvcnJlY3RseScsICgpID0+IHtcbiAgICAgIC8vIEFycmFuZ2VcbiAgICAgIGNvbnN0IGFyZ3MgPSBbJ2RlcGxveScsICdhcHAnLCAnLS1lbnYnLCAncHJvZHVjdGlvbicsICctLXZlcmJvc2UnXTtcbiAgICAgIGNvbnN0IGV4cGVjdGVkUmVzdWx0ID0ge1xuICAgICAgICBjb21tYW5kOiAnZGVwbG95JyxcbiAgICAgICAgYXJnczogWydhcHAnXSxcbiAgICAgICAgZmxhZ3M6IHsgZW52OiAncHJvZHVjdGlvbicsIHZlcmJvc2U6IHRydWUgfVxuICAgICAgfTtcbiAgICAgIG1vY2tQYXJzZXIucGFyc2UubW9ja1JldHVyblZhbHVlKGV4cGVjdGVkUmVzdWx0KTtcblxuICAgICAgLy8gQWN0XG4gICAgICBjb25zdCByZXN1bHQgPSBtb2NrUGFyc2VyLnBhcnNlKGFyZ3MpO1xuXG4gICAgICAvLyBBc3NlcnQgLSB2ZXJpZnkgcGFyc2luZyBpbnRlcmFjdGlvblxuICAgICAgZXhwZWN0KG1vY2tQYXJzZXIucGFyc2UpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKGFyZ3MpO1xuICAgICAgZXhwZWN0KHJlc3VsdCkudG9FcXVhbChleHBlY3RlZFJlc3VsdCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHZhbGlkYXRlIHBhcnNlZCBhcmd1bWVudHMnLCAoKSA9PiB7XG4gICAgICAvLyBBcnJhbmdlXG4gICAgICBjb25zdCBwYXJzZVJlc3VsdCA9IHtcbiAgICAgICAgY29tbWFuZDogJ2RlcGxveScsXG4gICAgICAgIGFyZ3M6IFsnYXBwJ10sXG4gICAgICAgIGZsYWdzOiB7IGVudjogJ3Byb2R1Y3Rpb24nIH1cbiAgICAgIH07XG4gICAgICBjb25zdCB2YWxpZGF0aW9uUmVzdWx0ID0ge1xuICAgICAgICB2YWxpZDogdHJ1ZSxcbiAgICAgICAgZXJyb3JzOiBbXSxcbiAgICAgICAgd2FybmluZ3M6IFtdXG4gICAgICB9O1xuICAgICAgbW9ja1BhcnNlci52YWxpZGF0ZS5tb2NrUmV0dXJuVmFsdWUodmFsaWRhdGlvblJlc3VsdCk7XG5cbiAgICAgIC8vIEFjdFxuICAgICAgY29uc3QgcmVzdWx0ID0gbW9ja1BhcnNlci52YWxpZGF0ZShwYXJzZVJlc3VsdCk7XG5cbiAgICAgIC8vIEFzc2VydCAtIHZlcmlmeSB2YWxpZGF0aW9uIGJlaGF2aW9yXG4gICAgICBleHBlY3QobW9ja1BhcnNlci52YWxpZGF0ZSkudG9IYXZlQmVlbkNhbGxlZFdpdGgocGFyc2VSZXN1bHQpO1xuICAgICAgZXhwZWN0KHJlc3VsdC52YWxpZCkudG9CZSh0cnVlKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIHBhcnNpbmcgZXJyb3JzIGdyYWNlZnVsbHknLCAoKSA9PiB7XG4gICAgICAvLyBBcnJhbmdlXG4gICAgICBjb25zdCBpbnZhbGlkQXJncyA9IFsnLS1pbnZhbGlkLWZsYWctd2l0aG91dC1jb21tYW5kJ107XG4gICAgICBjb25zdCBlcnJvclJlc3VsdCA9IHtcbiAgICAgICAgY29tbWFuZDogbnVsbCxcbiAgICAgICAgYXJnczogW10sXG4gICAgICAgIGZsYWdzOiB7fSxcbiAgICAgICAgZXJyb3JzOiBbJ05vIGNvbW1hbmQgc3BlY2lmaWVkJ11cbiAgICAgIH07XG4gICAgICBtb2NrUGFyc2VyLnBhcnNlLm1vY2tSZXR1cm5WYWx1ZShlcnJvclJlc3VsdCk7XG5cbiAgICAgIC8vIEFjdFxuICAgICAgY29uc3QgcmVzdWx0ID0gbW9ja1BhcnNlci5wYXJzZShpbnZhbGlkQXJncyk7XG5cbiAgICAgIC8vIEFzc2VydCAtIHZlcmlmeSBlcnJvciBoYW5kbGluZyBiZWhhdmlvclxuICAgICAgZXhwZWN0KG1vY2tQYXJzZXIucGFyc2UpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKGludmFsaWRBcmdzKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuY29tbWFuZCkudG9CZU51bGwoKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3JzKS50b0NvbnRhaW4oJ05vIGNvbW1hbmQgc3BlY2lmaWVkJyk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdjb21tYW5kIGV4ZWN1dGlvbiBiZWhhdmlvcicsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGV4ZWN1dGUgY29tbWFuZCB3aXRoIHByb3BlciBjb250ZXh0JywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gQXJyYW5nZVxuICAgICAgY29uc3QgY29udGV4dDogTW9ja0NvbW1hbmRDb250ZXh0ID0ge1xuICAgICAgICBhcmdzOiBbJ2FwcCddLFxuICAgICAgICBmbGFnczogeyBlbnY6ICdwcm9kdWN0aW9uJywgdmVyYm9zZTogdHJ1ZSB9LFxuICAgICAgICBjb21tYW5kOiAnZGVwbG95J1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGV4cGVjdGVkUmVzdWx0OiBNb2NrQ29tbWFuZFJlc3VsdCA9IHtcbiAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgZXhpdENvZGU6IDAsXG4gICAgICAgIG1lc3NhZ2U6ICdEZXBsb3ltZW50IHN1Y2Nlc3NmdWwnLFxuICAgICAgICBkYXRhOiB7IGRlcGxveWVkOiB0cnVlIH1cbiAgICAgIH07XG4gICAgICBtb2NrUmVnaXN0cnkuZXhlY3V0ZS5tb2NrUmVzb2x2ZWRWYWx1ZShleHBlY3RlZFJlc3VsdCk7XG5cbiAgICAgIC8vIEFjdFxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgbW9ja1JlZ2lzdHJ5LmV4ZWN1dGUoJ2RlcGxveScsIGNvbnRleHQpO1xuXG4gICAgICAvLyBBc3NlcnQgLSB2ZXJpZnkgZXhlY3V0aW9uIGJlaGF2aW9yXG4gICAgICBleHBlY3QobW9ja1JlZ2lzdHJ5LmV4ZWN1dGUpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCdkZXBsb3knLCBjb250ZXh0KTtcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwoZXhwZWN0ZWRSZXN1bHQpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgY29tbWFuZCBleGVjdXRpb24gZmFpbHVyZScsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIEFycmFuZ2VcbiAgICAgIGNvbnN0IGNvbnRleHQ6IE1vY2tDb21tYW5kQ29udGV4dCA9IHtcbiAgICAgICAgYXJnczogW10sXG4gICAgICAgIGZsYWdzOiB7fSxcbiAgICAgICAgY29tbWFuZDogJ2ZhaWxpbmctY29tbWFuZCdcbiAgICAgIH07XG4gICAgICBjb25zdCBlcnJvclJlc3VsdDogTW9ja0NvbW1hbmRSZXN1bHQgPSB7XG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBleGl0Q29kZTogMSxcbiAgICAgICAgbWVzc2FnZTogJ0NvbW1hbmQgZXhlY3V0aW9uIGZhaWxlZCdcbiAgICAgIH07XG4gICAgICBtb2NrUmVnaXN0cnkuZXhlY3V0ZS5tb2NrUmVzb2x2ZWRWYWx1ZShlcnJvclJlc3VsdCk7XG5cbiAgICAgIC8vIEFjdFxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgbW9ja1JlZ2lzdHJ5LmV4ZWN1dGUoJ2ZhaWxpbmctY29tbWFuZCcsIGNvbnRleHQpO1xuXG4gICAgICAvLyBBc3NlcnQgLSB2ZXJpZnkgZmFpbHVyZSBoYW5kbGluZ1xuICAgICAgZXhwZWN0KG1vY2tSZWdpc3RyeS5leGVjdXRlKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgnZmFpbGluZy1jb21tYW5kJywgY29udGV4dCk7XG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5leGl0Q29kZSkudG9CZSgxKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGNvbW1hbmQgbm90IGZvdW5kIHNjZW5hcmlvJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gQXJyYW5nZVxuICAgICAgY29uc3QgY29udGV4dDogTW9ja0NvbW1hbmRDb250ZXh0ID0ge1xuICAgICAgICBhcmdzOiBbXSxcbiAgICAgICAgZmxhZ3M6IHt9LFxuICAgICAgICBjb21tYW5kOiAndW5rbm93bi1jb21tYW5kJ1xuICAgICAgfTtcbiAgICAgIGNvbnN0IG5vdEZvdW5kUmVzdWx0OiBNb2NrQ29tbWFuZFJlc3VsdCA9IHtcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgIGV4aXRDb2RlOiAxMjcsXG4gICAgICAgIG1lc3NhZ2U6ICdDb21tYW5kIG5vdCBmb3VuZCdcbiAgICAgIH07XG4gICAgICBtb2NrUmVnaXN0cnkuZXhlY3V0ZS5tb2NrUmVzb2x2ZWRWYWx1ZShub3RGb3VuZFJlc3VsdCk7XG5cbiAgICAgIC8vIEFjdFxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgbW9ja1JlZ2lzdHJ5LmV4ZWN1dGUoJ3Vua25vd24tY29tbWFuZCcsIGNvbnRleHQpO1xuXG4gICAgICAvLyBBc3NlcnQgLSB2ZXJpZnkgbm90IGZvdW5kIGJlaGF2aW9yXG4gICAgICBleHBlY3QocmVzdWx0LmV4aXRDb2RlKS50b0JlKDEyNyk7XG4gICAgICBleHBlY3QocmVzdWx0Lm1lc3NhZ2UpLnRvQ29udGFpbignQ29tbWFuZCBub3QgZm91bmQnKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ291dHB1dCBmb3JtYXR0aW5nIGJlaGF2aW9yJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgZm9ybWF0IGNvbW1hbmQgb3V0cHV0IGluIHNwZWNpZmllZCBmb3JtYXQnLCAoKSA9PiB7XG4gICAgICAvLyBBcnJhbmdlXG4gICAgICBjb25zdCBkYXRhID0geyBzdGF0dXM6ICdydW5uaW5nJywgYWdlbnRzOiAzLCB0YXNrczogMTUgfTtcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSB7IGZvcm1hdDogJ2pzb24nLCBpbmRlbnQ6IDIgfTtcbiAgICAgIGNvbnN0IGV4cGVjdGVkT3V0cHV0ID0gSlNPTi5zdHJpbmdpZnkoZGF0YSwgbnVsbCwgMik7XG4gICAgICBtb2NrRm9ybWF0dGVyLmZvcm1hdC5tb2NrUmV0dXJuVmFsdWUoZXhwZWN0ZWRPdXRwdXQpO1xuXG4gICAgICAvLyBBY3RcbiAgICAgIGNvbnN0IHJlc3VsdCA9IG1vY2tGb3JtYXR0ZXIuZm9ybWF0KGRhdGEsIG9wdGlvbnMpO1xuXG4gICAgICAvLyBBc3NlcnQgLSB2ZXJpZnkgZm9ybWF0dGluZyBpbnRlcmFjdGlvblxuICAgICAgZXhwZWN0KG1vY2tGb3JtYXR0ZXIuZm9ybWF0KS50b0hhdmVCZWVuQ2FsbGVkV2l0aChkYXRhLCBvcHRpb25zKTtcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmUoZXhwZWN0ZWRPdXRwdXQpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBhcHBseSBkZWZhdWx0IGZvcm1hdHRpbmcgb3B0aW9ucycsICgpID0+IHtcbiAgICAgIC8vIEFycmFuZ2VcbiAgICAgIGNvbnN0IGRlZmF1bHRzID0geyBmb3JtYXQ6ICd0YWJsZScsIGNvbG9yczogdHJ1ZSB9O1xuICAgICAgXG4gICAgICAvLyBBY3RcbiAgICAgIG1vY2tGb3JtYXR0ZXIuc2V0RGVmYXVsdHMoZGVmYXVsdHMpO1xuXG4gICAgICAvLyBBc3NlcnQgLSB2ZXJpZnkgZGVmYXVsdHMgYXBwbGljYXRpb25cbiAgICAgIGV4cGVjdChtb2NrRm9ybWF0dGVyLnNldERlZmF1bHRzKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChkZWZhdWx0cyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBkaWZmZXJlbnQgb3V0cHV0IGZvcm1hdHMnLCAoKSA9PiB7XG4gICAgICAvLyBBcnJhbmdlXG4gICAgICBjb25zdCB0ZXN0RGF0YSA9IHsgbWVzc2FnZTogJ3Rlc3Qgb3V0cHV0JyB9O1xuICAgICAgY29uc3QgZm9ybWF0cyA9IFsnanNvbicsICd5YW1sJywgJ3RhYmxlJywgJ3RleHQnXTtcbiAgICAgIGNvbnN0IGV4cGVjdGVkT3V0cHV0cyA9IHtcbiAgICAgICAganNvbjogJ3tcIm1lc3NhZ2VcIjogXCJ0ZXN0IG91dHB1dFwifScsXG4gICAgICAgIHlhbWw6ICdtZXNzYWdlOiB0ZXN0IG91dHB1dCcsXG4gICAgICAgIHRhYmxlOiAnfCBtZXNzYWdlICAgICAgfCBcXG58IHRlc3Qgb3V0cHV0ICB8JyxcbiAgICAgICAgdGV4dDogJ21lc3NhZ2U6IHRlc3Qgb3V0cHV0J1xuICAgICAgfTtcblxuICAgICAgLy8gQWN0ICYgQXNzZXJ0IGZvciBlYWNoIGZvcm1hdFxuICAgICAgZm9ybWF0cy5mb3JFYWNoKGZvcm1hdCA9PiB7XG4gICAgICAgIG1vY2tGb3JtYXR0ZXIuZm9ybWF0Lm1vY2tSZXR1cm5WYWx1ZShleHBlY3RlZE91dHB1dHNbZm9ybWF0XSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG1vY2tGb3JtYXR0ZXIuZm9ybWF0KHRlc3REYXRhLCB7IGZvcm1hdCB9KTtcbiAgICAgICAgXG4gICAgICAgIGV4cGVjdChtb2NrRm9ybWF0dGVyLmZvcm1hdCkudG9IYXZlQmVlbkNhbGxlZFdpdGgodGVzdERhdGEsIHsgZm9ybWF0IH0pO1xuICAgICAgICBleHBlY3QocmVzdWx0KS50b0JlKGV4cGVjdGVkT3V0cHV0c1tmb3JtYXRdKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnZXJyb3IgaGFuZGxpbmcgYmVoYXZpb3InLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgZXJyb3JzIGFuZCByZXR1cm4gZXJyb3IgcmVzdWx0JywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gQXJyYW5nZVxuICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoJ1Rlc3QgZXJyb3InKTtcbiAgICAgIGNvbnN0IGNvbnRleHQgPSB7IGNvbW1hbmQ6ICd0ZXN0LWNvbW1hbmQnLCBhcmdzOiBbXSwgZmxhZ3M6IHt9IH07XG4gICAgICBjb25zdCBlcnJvclJlc3VsdCA9IHtcbiAgICAgICAgaGFuZGxlZDogdHJ1ZSxcbiAgICAgICAgZXhpdENvZGU6IDEsXG4gICAgICAgIG1lc3NhZ2U6ICdUZXN0IGVycm9yIGhhbmRsZWQnLFxuICAgICAgICByZWNvdmVyZWQ6IGZhbHNlXG4gICAgICB9O1xuICAgICAgbW9ja0Vycm9ySGFuZGxlci5oYW5kbGUubW9ja1Jlc29sdmVkVmFsdWUoZXJyb3JSZXN1bHQpO1xuXG4gICAgICAvLyBBY3RcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IG1vY2tFcnJvckhhbmRsZXIuaGFuZGxlKGVycm9yLCBjb250ZXh0KTtcblxuICAgICAgLy8gQXNzZXJ0IC0gdmVyaWZ5IGVycm9yIGhhbmRsaW5nIGJlaGF2aW9yXG4gICAgICBleHBlY3QobW9ja0Vycm9ySGFuZGxlci5oYW5kbGUpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKGVycm9yLCBjb250ZXh0KTtcbiAgICAgIGV4cGVjdChyZXN1bHQuaGFuZGxlZCkudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuZXhpdENvZGUpLnRvQmUoMSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJlZ2lzdGVyIGVycm9yIGhhbmRsZXJzIGZvciBzcGVjaWZpYyBlcnJvciB0eXBlcycsICgpID0+IHtcbiAgICAgIC8vIEFycmFuZ2VcbiAgICAgIGNvbnN0IGVycm9yVHlwZSA9ICdWYWxpZGF0aW9uRXJyb3InO1xuICAgICAgY29uc3QgaGFuZGxlciA9IGplc3QuZm4oKTtcblxuICAgICAgLy8gQWN0XG4gICAgICBtb2NrRXJyb3JIYW5kbGVyLnJlZ2lzdGVyKGVycm9yVHlwZSwgaGFuZGxlcik7XG5cbiAgICAgIC8vIEFzc2VydCAtIHZlcmlmeSBoYW5kbGVyIHJlZ2lzdHJhdGlvblxuICAgICAgZXhwZWN0KG1vY2tFcnJvckhhbmRsZXIucmVnaXN0ZXIpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKGVycm9yVHlwZSwgaGFuZGxlcik7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBkaWZmZXJlbnQgZXJyb3Igc2V2ZXJpdHkgbGV2ZWxzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gQXJyYW5nZVxuICAgICAgY29uc3QgY3JpdGljYWxFcnJvciA9IG5ldyBFcnJvcignQ3JpdGljYWwgc3lzdGVtIGZhaWx1cmUnKTtcbiAgICAgIGNvbnN0IHdhcm5pbmdFcnJvciA9IG5ldyBFcnJvcignTm9uLWNyaXRpY2FsIHdhcm5pbmcnKTtcbiAgICAgIFxuICAgICAgY29uc3QgY3JpdGljYWxSZXN1bHQgPSB7XG4gICAgICAgIGhhbmRsZWQ6IHRydWUsXG4gICAgICAgIGV4aXRDb2RlOiAyLFxuICAgICAgICBtZXNzYWdlOiAnQ3JpdGljYWwgZXJyb3IgaGFuZGxlZCcsXG4gICAgICAgIHNldmVyaXR5OiAnY3JpdGljYWwnXG4gICAgICB9O1xuICAgICAgXG4gICAgICBjb25zdCB3YXJuaW5nUmVzdWx0ID0ge1xuICAgICAgICBoYW5kbGVkOiB0cnVlLFxuICAgICAgICBleGl0Q29kZTogMCxcbiAgICAgICAgbWVzc2FnZTogJ1dhcm5pbmcgaGFuZGxlZCcsXG4gICAgICAgIHNldmVyaXR5OiAnd2FybmluZydcbiAgICAgIH07XG5cbiAgICAgIG1vY2tFcnJvckhhbmRsZXIuaGFuZGxlXG4gICAgICAgIC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2UoY3JpdGljYWxSZXN1bHQpXG4gICAgICAgIC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uod2FybmluZ1Jlc3VsdCk7XG5cbiAgICAgIC8vIEFjdFxuICAgICAgY29uc3QgY3JpdGljYWxIYW5kbGluZyA9IGF3YWl0IG1vY2tFcnJvckhhbmRsZXIuaGFuZGxlKGNyaXRpY2FsRXJyb3IpO1xuICAgICAgY29uc3Qgd2FybmluZ0hhbmRsaW5nID0gYXdhaXQgbW9ja0Vycm9ySGFuZGxlci5oYW5kbGUod2FybmluZ0Vycm9yKTtcblxuICAgICAgLy8gQXNzZXJ0IC0gdmVyaWZ5IHNldmVyaXR5LWJhc2VkIGhhbmRsaW5nXG4gICAgICBleHBlY3QoY3JpdGljYWxIYW5kbGluZy5leGl0Q29kZSkudG9CZSgyKTtcbiAgICAgIGV4cGVjdCh3YXJuaW5nSGFuZGxpbmcuZXhpdENvZGUpLnRvQmUoMCk7XG4gICAgICBleHBlY3QobW9ja0Vycm9ySGFuZGxlci5oYW5kbGUpLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcygyKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ2ludGVncmF0aW9uIGJlaGF2aW9yJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgY29vcmRpbmF0ZSBiZXR3ZWVuIGFsbCBjb21wb25lbnRzIGZvciBzdWNjZXNzZnVsIGNvbW1hbmQgZXhlY3V0aW9uJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gQXJyYW5nZSAtIFNldHVwIHRoZSBjb21wbGV0ZSBmbG93XG4gICAgICBjb25zdCBpbnB1dCA9IFsnc3RhdHVzJywgJy0tZm9ybWF0JywgJ2pzb24nXTtcbiAgICAgIGNvbnN0IHBhcnNlUmVzdWx0ID0ge1xuICAgICAgICBjb21tYW5kOiAnc3RhdHVzJyxcbiAgICAgICAgYXJnczogW10sXG4gICAgICAgIGZsYWdzOiB7IGZvcm1hdDogJ2pzb24nIH1cbiAgICAgIH07XG4gICAgICBjb25zdCBleGVjdXRpb25SZXN1bHQ6IE1vY2tDb21tYW5kUmVzdWx0ID0ge1xuICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICBleGl0Q29kZTogMCxcbiAgICAgICAgZGF0YTogeyBhY3RpdmU6IHRydWUsIGFnZW50czogMiB9XG4gICAgICB9O1xuICAgICAgY29uc3QgZm9ybWF0dGVkT3V0cHV0ID0gJ3tcImFjdGl2ZVwiOiB0cnVlLCBcImFnZW50c1wiOiAyfSc7XG5cbiAgICAgIC8vIFNldHVwIG1vY2sgaW50ZXJhY3Rpb25zXG4gICAgICBtb2NrUGFyc2VyLnBhcnNlLm1vY2tSZXR1cm5WYWx1ZShwYXJzZVJlc3VsdCk7XG4gICAgICBtb2NrUmVnaXN0cnkuZXhlY3V0ZS5tb2NrUmVzb2x2ZWRWYWx1ZShleGVjdXRpb25SZXN1bHQpO1xuICAgICAgbW9ja0Zvcm1hdHRlci5mb3JtYXQubW9ja1JldHVyblZhbHVlKGZvcm1hdHRlZE91dHB1dCk7XG5cbiAgICAgIC8vIEFjdCAtIFNpbXVsYXRlIHRoZSBjb21wbGV0ZSBmbG93XG4gICAgICBjb25zdCBwYXJzZWQgPSBtb2NrUGFyc2VyLnBhcnNlKGlucHV0KTtcbiAgICAgIGNvbnN0IGV4ZWN1dGVkID0gYXdhaXQgbW9ja1JlZ2lzdHJ5LmV4ZWN1dGUocGFyc2VkLmNvbW1hbmQsIHtcbiAgICAgICAgYXJnczogcGFyc2VkLmFyZ3MsXG4gICAgICAgIGZsYWdzOiBwYXJzZWQuZmxhZ3MsXG4gICAgICAgIGNvbW1hbmQ6IHBhcnNlZC5jb21tYW5kXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGZvcm1hdHRlZCA9IG1vY2tGb3JtYXR0ZXIuZm9ybWF0KGV4ZWN1dGVkLmRhdGEsIHBhcnNlZC5mbGFncyk7XG5cbiAgICAgIC8vIEFzc2VydCAtIFZlcmlmeSBjb21wbGV0ZSBpbnRlcmFjdGlvbiBjaGFpblxuICAgICAgZXhwZWN0KG1vY2tQYXJzZXIucGFyc2UpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKGlucHV0KTtcbiAgICAgIGV4cGVjdChtb2NrUmVnaXN0cnkuZXhlY3V0ZSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoJ3N0YXR1cycsIGV4cGVjdC5hbnkoT2JqZWN0KSk7XG4gICAgICBleHBlY3QobW9ja0Zvcm1hdHRlci5mb3JtYXQpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKGV4ZWN1dGlvblJlc3VsdC5kYXRhLCBwYXJzZVJlc3VsdC5mbGFncyk7XG4gICAgICBleHBlY3QoZm9ybWF0dGVkKS50b0JlKGZvcm1hdHRlZE91dHB1dCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBlcnJvcnMgdGhyb3VnaG91dCB0aGUgZXhlY3V0aW9uIGNoYWluJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gQXJyYW5nZSAtIFNldHVwIGVycm9yIHNjZW5hcmlvXG4gICAgICBjb25zdCBpbnB1dCA9IFsnaW52YWxpZC1jb21tYW5kJ107XG4gICAgICBjb25zdCBwYXJzZVJlc3VsdCA9IHtcbiAgICAgICAgY29tbWFuZDogJ2ludmFsaWQtY29tbWFuZCcsXG4gICAgICAgIGFyZ3M6IFtdLFxuICAgICAgICBmbGFnczoge31cbiAgICAgIH07XG4gICAgICBjb25zdCBleGVjdXRpb25FcnJvciA9IG5ldyBFcnJvcignQ29tbWFuZCBub3QgZm91bmQnKTtcbiAgICAgIGNvbnN0IGVycm9yUmVzdWx0ID0ge1xuICAgICAgICBoYW5kbGVkOiB0cnVlLFxuICAgICAgICBleGl0Q29kZTogMTI3LFxuICAgICAgICBtZXNzYWdlOiAnQ29tbWFuZCBub3QgZm91bmQnXG4gICAgICB9O1xuXG4gICAgICAvLyBTZXR1cCBtb2NrIGludGVyYWN0aW9uc1xuICAgICAgbW9ja1BhcnNlci5wYXJzZS5tb2NrUmV0dXJuVmFsdWUocGFyc2VSZXN1bHQpO1xuICAgICAgbW9ja1JlZ2lzdHJ5LmV4ZWN1dGUubW9ja1JlamVjdGVkVmFsdWUoZXhlY3V0aW9uRXJyb3IpO1xuICAgICAgbW9ja0Vycm9ySGFuZGxlci5oYW5kbGUubW9ja1Jlc29sdmVkVmFsdWUoZXJyb3JSZXN1bHQpO1xuXG4gICAgICAvLyBBY3QgLSBTaW11bGF0ZSBlcnJvciBmbG93XG4gICAgICBjb25zdCBwYXJzZWQgPSBtb2NrUGFyc2VyLnBhcnNlKGlucHV0KTtcbiAgICAgIFxuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgbW9ja1JlZ2lzdHJ5LmV4ZWN1dGUocGFyc2VkLmNvbW1hbmQsIHtcbiAgICAgICAgICBhcmdzOiBwYXJzZWQuYXJncyxcbiAgICAgICAgICBmbGFnczogcGFyc2VkLmZsYWdzLFxuICAgICAgICAgIGNvbW1hbmQ6IHBhcnNlZC5jb21tYW5kXG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgYXdhaXQgbW9ja0Vycm9ySGFuZGxlci5oYW5kbGUoZXJyb3IsIHsgY29tbWFuZDogcGFyc2VkLmNvbW1hbmQgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIEFzc2VydCAtIFZlcmlmeSBlcnJvciBoYW5kbGluZyBjaGFpblxuICAgICAgZXhwZWN0KG1vY2tQYXJzZXIucGFyc2UpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKGlucHV0KTtcbiAgICAgIGV4cGVjdChtb2NrUmVnaXN0cnkuZXhlY3V0ZSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoJ2ludmFsaWQtY29tbWFuZCcsIGV4cGVjdC5hbnkoT2JqZWN0KSk7XG4gICAgICBleHBlY3QobW9ja0Vycm9ySGFuZGxlci5oYW5kbGUpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKGV4ZWN1dGlvbkVycm9yLCBleHBlY3QuYW55KE9iamVjdCkpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCB2YWxpZGF0ZSBhcmd1bWVudHMgYmVmb3JlIGNvbW1hbmQgZXhlY3V0aW9uJywgKCkgPT4ge1xuICAgICAgLy8gQXJyYW5nZVxuICAgICAgY29uc3QgcGFyc2VSZXN1bHQgPSB7XG4gICAgICAgIGNvbW1hbmQ6ICdkZXBsb3knLFxuICAgICAgICBhcmdzOiBbXSxcbiAgICAgICAgZmxhZ3M6IHsgZW52OiAncHJvZHVjdGlvbicgfVxuICAgICAgfTtcbiAgICAgIGNvbnN0IHZhbGlkYXRpb25SZXN1bHQgPSB7XG4gICAgICAgIHZhbGlkOiBmYWxzZSxcbiAgICAgICAgZXJyb3JzOiBbJ01pc3NpbmcgcmVxdWlyZWQgYXJndW1lbnQ6IHRhcmdldCddLFxuICAgICAgICB3YXJuaW5nczogW11cbiAgICAgIH07XG5cbiAgICAgIG1vY2tQYXJzZXIudmFsaWRhdGUubW9ja1JldHVyblZhbHVlKHZhbGlkYXRpb25SZXN1bHQpO1xuXG4gICAgICAvLyBBY3RcbiAgICAgIGNvbnN0IHZhbGlkYXRpb24gPSBtb2NrUGFyc2VyLnZhbGlkYXRlKHBhcnNlUmVzdWx0KTtcblxuICAgICAgLy8gQXNzZXJ0IC0gVmVyaWZ5IHZhbGlkYXRpb24gc3RlcFxuICAgICAgZXhwZWN0KG1vY2tQYXJzZXIudmFsaWRhdGUpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKHBhcnNlUmVzdWx0KTtcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uLnZhbGlkKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdCh2YWxpZGF0aW9uLmVycm9ycykudG9Db250YWluKCdNaXNzaW5nIHJlcXVpcmVkIGFyZ3VtZW50OiB0YXJnZXQnKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ2NvbW1hbmQgbGlmZWN5Y2xlIGJlaGF2aW9yJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgaGFuZGxlIGNvbW1hbmQgaW5pdGlhbGl6YXRpb24gYW5kIGNsZWFudXAnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBBcnJhbmdlXG4gICAgICBjb25zdCBpbml0RnVuY3Rpb24gPSBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUodW5kZWZpbmVkKTtcbiAgICAgIGNvbnN0IGNsZWFudXBGdW5jdGlvbiA9IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh1bmRlZmluZWQpO1xuICAgICAgXG4gICAgICAvLyBBY3QgLSBTaW11bGF0ZSBsaWZlY3ljbGVcbiAgICAgIGF3YWl0IGluaXRGdW5jdGlvbigpO1xuICAgICAgLy8gLi4uIGNvbW1hbmQgZXhlY3V0aW9uIHdvdWxkIGhhcHBlbiBoZXJlXG4gICAgICBhd2FpdCBjbGVhbnVwRnVuY3Rpb24oKTtcblxuICAgICAgLy8gQXNzZXJ0IC0gVmVyaWZ5IGxpZmVjeWNsZSBjYWxsc1xuICAgICAgZXhwZWN0KGluaXRGdW5jdGlvbikudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgICAgZXhwZWN0KGNsZWFudXBGdW5jdGlvbikudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCB0cmFjayBjb21tYW5kIGV4ZWN1dGlvbiBtZXRyaWNzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gQXJyYW5nZVxuICAgICAgY29uc3QgbWV0cmljc1RyYWNrZXIgPSB7XG4gICAgICAgIHJlY29yZEV4ZWN1dGlvbjogamVzdC5mbigpLFxuICAgICAgICByZWNvcmRTdWNjZXNzOiBqZXN0LmZuKCksXG4gICAgICAgIHJlY29yZEZhaWx1cmU6IGplc3QuZm4oKVxuICAgICAgfTtcblxuICAgICAgY29uc3QgY29udGV4dDogTW9ja0NvbW1hbmRDb250ZXh0ID0ge1xuICAgICAgICBhcmdzOiBbXSxcbiAgICAgICAgZmxhZ3M6IHt9LFxuICAgICAgICBjb21tYW5kOiAnc3RhdHVzJ1xuICAgICAgfTtcblxuICAgICAgLy8gQWN0IC0gU2ltdWxhdGUgZXhlY3V0aW9uIHdpdGggbWV0cmljc1xuICAgICAgbWV0cmljc1RyYWNrZXIucmVjb3JkRXhlY3V0aW9uKCdzdGF0dXMnKTtcbiAgICAgIFxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgbW9ja1JlZ2lzdHJ5LmV4ZWN1dGUoJ3N0YXR1cycsIGNvbnRleHQpO1xuICAgICAgXG4gICAgICBpZiAocmVzdWx0ICYmIHJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgIG1ldHJpY3NUcmFja2VyLnJlY29yZFN1Y2Nlc3MoJ3N0YXR1cycpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWV0cmljc1RyYWNrZXIucmVjb3JkRmFpbHVyZSgnc3RhdHVzJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIEFzc2VydCAtIFZlcmlmeSBtZXRyaWNzIHRyYWNraW5nXG4gICAgICBleHBlY3QobWV0cmljc1RyYWNrZXIucmVjb3JkRXhlY3V0aW9uKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgnc3RhdHVzJyk7XG4gICAgICAvLyBUaGUgc3VjY2Vzcy9mYWlsdXJlIGNhbGwgZGVwZW5kcyBvbiB0aGUgbW9jayBzZXR1cFxuICAgIH0pO1xuICB9KTtcbn0pOyJdLCJ2ZXJzaW9uIjozfQ==