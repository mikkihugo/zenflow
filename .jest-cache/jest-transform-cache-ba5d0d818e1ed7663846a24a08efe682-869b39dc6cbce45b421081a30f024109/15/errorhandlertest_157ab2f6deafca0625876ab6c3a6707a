022af81cf145f133b2bc5d441a26be38
/**
 * Error Handler Tests - TDD London School
 *
 * Tests the behavior of error handling functionality using mocks
 * and interaction-based testing. Focuses on how the error handler
 * collaborates with logging, formatting, and recovery systems.
 */
import { jest } from '@jest/globals';
// Mock implementation for testing
class MockErrorHandler {
    handlers = new Map();
    recoveryStrategies = [];
    defaults = {};
    metrics = {
        totalErrors: 0,
        errorsByType: {},
        recoveredErrors: 0,
        fatalErrors: 0,
        averageHandlingTime: 0
    };
    logger;
    handleFunction;
    constructor(handleFunction, logger) {
        this.handleFunction = handleFunction || jest.fn();
        this.logger = logger || {
            error: jest.fn(),
            warn: jest.fn(),
            info: jest.fn(),
            debug: jest.fn()
        };
    }
    async handle(error, context) {
        const startTime = Date.now();
        // Update metrics
        this.metrics.totalErrors++;
        const errorType = error.constructor.name;
        this.metrics.errorsByType[errorType] = (this.metrics.errorsByType[errorType] || 0) + 1;
        // Call mock function for testing
        const result = await this.handleFunction(error, context);
        // Update timing metrics
        const handlingTime = Date.now() - startTime;
        this.metrics.averageHandlingTime =
            (this.metrics.averageHandlingTime * (this.metrics.totalErrors - 1) + handlingTime) / this.metrics.totalErrors;
        if (result.recovered) {
            this.metrics.recoveredErrors++;
        }
        else if (result.exitCode !== 0) {
            this.metrics.fatalErrors++;
        }
        return result;
    }
    register(type, handler) {
        this.handlers.set(type, handler);
    }
    setDefaults(defaults) {
        this.defaults = { ...this.defaults, ...defaults };
    }
    addRecoveryStrategy(strategy) {
        // Insert strategy in priority order
        const index = this.recoveryStrategies.findIndex(s => s.priority < strategy.priority);
        if (index === -1) {
            this.recoveryStrategies.push(strategy);
        }
        else {
            this.recoveryStrategies.splice(index, 0, strategy);
        }
    }
    getMetrics() {
        return { ...this.metrics };
    }
    // Test helpers
    getHandler(type) {
        return this.handlers.get(type);
    }
    getDefaults() {
        return { ...this.defaults };
    }
    getRecoveryStrategies() {
        return [...this.recoveryStrategies];
    }
    getLogger() {
        return this.logger;
    }
}
// Custom error types for testing
class ValidationError extends Error {
    field;
    constructor(message, field) {
        super(message);
        this.field = field;
        this.name = 'ValidationError';
    }
}
class NetworkError extends Error {
    statusCode;
    constructor(message, statusCode) {
        super(message);
        this.statusCode = statusCode;
        this.name = 'NetworkError';
    }
}
class CommandNotFoundError extends Error {
    constructor(command) {
        super(`Command '${command}' not found`);
        this.name = 'CommandNotFoundError';
    }
}
describe('ErrorHandler - TDD London', () => {
    let errorHandler;
    let mockHandleFunction;
    let mockLogger;
    beforeEach(() => {
        mockHandleFunction = jest.fn();
        mockLogger = {
            error: jest.fn(),
            warn: jest.fn(),
            info: jest.fn(),
            debug: jest.fn()
        };
        errorHandler = new MockErrorHandler(mockHandleFunction, mockLogger);
    });
    describe('basic error handling behavior', () => {
        it('should handle error and return result', async () => {
            // Arrange
            const error = new Error('Test error');
            const context = {
                command: 'test-command',
                severity: 'medium'
            };
            const expectedResult = {
                handled: true,
                recovered: false,
                exitCode: 1,
                message: 'Test error handled',
                retryable: false,
                logged: true
            };
            mockHandleFunction.mockResolvedValue(expectedResult);
            // Act
            const result = await errorHandler.handle(error, context);
            // Assert - verify error handling behavior
            expect(mockHandleFunction).toHaveBeenCalledWith(error, context);
            expect(result).toEqual(expectedResult);
        });
        it('should update metrics when handling errors', async () => {
            // Arrange
            const error1 = new ValidationError('Validation failed');
            const error2 = new NetworkError('Network timeout');
            const error3 = new ValidationError('Another validation error');
            mockHandleFunction.mockImplementation(async () => {
                // Add small delay to simulate processing time
                await new Promise(resolve => setTimeout(resolve, 1));
                return {
                    handled: true,
                    recovered: false,
                    exitCode: 1,
                    message: 'Error handled',
                    retryable: false,
                    logged: true
                };
            });
            // Act
            await errorHandler.handle(error1);
            await errorHandler.handle(error2);
            await errorHandler.handle(error3);
            // Assert - verify metrics tracking behavior
            const metrics = errorHandler.getMetrics();
            expect(metrics.totalErrors).toBe(3);
            expect(metrics.errorsByType.ValidationError).toBe(2);
            expect(metrics.errorsByType.NetworkError).toBe(1);
            expect(metrics.averageHandlingTime).toBeGreaterThan(0);
        });
        it('should track recovery metrics correctly', async () => {
            // Arrange
            const recoverableError = new NetworkError('Timeout');
            const fatalError = new Error('Fatal error');
            mockHandleFunction
                .mockResolvedValueOnce({
                handled: true,
                recovered: true,
                exitCode: 0,
                message: 'Recovered from timeout',
                retryable: true,
                logged: true
            })
                .mockResolvedValueOnce({
                handled: true,
                recovered: false,
                exitCode: 1,
                message: 'Fatal error occurred',
                retryable: false,
                logged: true
            });
            // Act
            await errorHandler.handle(recoverableError);
            await errorHandler.handle(fatalError);
            // Assert - verify recovery metrics
            const metrics = errorHandler.getMetrics();
            expect(metrics.recoveredErrors).toBe(1);
            expect(metrics.fatalErrors).toBe(1);
        });
    });
    describe('error handler registration behavior', () => {
        it('should register custom error handlers for specific types', () => {
            // Arrange
            const validationHandler = jest.fn().mockReturnValue({
                handled: true,
                recovered: true,
                exitCode: 0,
                message: 'Validation error recovered',
                retryable: true,
                logged: false
            });
            // Act
            errorHandler.register('ValidationError', validationHandler);
            // Assert - verify handler registration
            expect(errorHandler.getHandler('ValidationError')).toBe(validationHandler);
        });
        it('should allow multiple handlers for different error types', () => {
            // Arrange
            const validationHandler = jest.fn();
            const networkHandler = jest.fn();
            const genericHandler = jest.fn();
            // Act
            errorHandler.register('ValidationError', validationHandler);
            errorHandler.register('NetworkError', networkHandler);
            errorHandler.register('Error', genericHandler);
            // Assert - verify multiple handler registration
            expect(errorHandler.getHandler('ValidationError')).toBe(validationHandler);
            expect(errorHandler.getHandler('NetworkError')).toBe(networkHandler);
            expect(errorHandler.getHandler('Error')).toBe(genericHandler);
        });
    });
    describe('defaults configuration behavior', () => {
        it('should apply default error handling configuration', () => {
            // Arrange
            const defaults = {
                exitOnError: false,
                logErrors: true,
                showStack: true,
                colorOutput: false,
                verboseErrors: true
            };
            // Act
            errorHandler.setDefaults(defaults);
            // Assert - verify defaults application
            expect(errorHandler.getDefaults()).toEqual(defaults);
        });
        it('should merge defaults with existing configuration', () => {
            // Arrange
            errorHandler.setDefaults({ logErrors: true, showStack: false });
            errorHandler.setDefaults({ colorOutput: true }); // Additional defaults
            // Act
            const appliedDefaults = errorHandler.getDefaults();
            // Assert - verify defaults merging
            expect(appliedDefaults).toEqual({
                logErrors: true,
                showStack: false,
                colorOutput: true
            });
        });
    });
    describe('recovery strategy behavior', () => {
        it('should register recovery strategies in priority order', () => {
            // Arrange
            const lowPriorityStrategy = {
                name: 'low-priority',
                canRecover: jest.fn(() => true),
                recover: jest.fn().mockResolvedValue(true),
                priority: 1
            };
            const highPriorityStrategy = {
                name: 'high-priority',
                canRecover: jest.fn(() => true),
                recover: jest.fn().mockResolvedValue(true),
                priority: 10
            };
            const mediumPriorityStrategy = {
                name: 'medium-priority',
                canRecover: jest.fn(() => true),
                recover: jest.fn().mockResolvedValue(true),
                priority: 5
            };
            // Act
            errorHandler.addRecoveryStrategy(lowPriorityStrategy);
            errorHandler.addRecoveryStrategy(highPriorityStrategy);
            errorHandler.addRecoveryStrategy(mediumPriorityStrategy);
            // Assert - verify priority-based ordering
            const strategies = errorHandler.getRecoveryStrategies();
            expect(strategies.map(s => s.name)).toEqual([
                'high-priority',
                'medium-priority',
                'low-priority'
            ]);
        });
        it('should attempt recovery strategies in order', () => {
            // Arrange
            const retryStrategy = {
                name: 'retry',
                canRecover: jest.fn(() => true),
                recover: jest.fn().mockResolvedValue(false), // Fails to recover
                priority: 5
            };
            const fallbackStrategy = {
                name: 'fallback',
                canRecover: jest.fn(() => true),
                recover: jest.fn().mockResolvedValue(true), // Successfully recovers
                priority: 1
            };
            errorHandler.addRecoveryStrategy(retryStrategy);
            errorHandler.addRecoveryStrategy(fallbackStrategy);
            // This would be tested in the actual implementation
            // Here we just verify strategies are available
            const strategies = errorHandler.getRecoveryStrategies();
            expect(strategies).toHaveLength(2);
            expect(strategies[0].name).toBe('retry');
            expect(strategies[1].name).toBe('fallback');
        });
    });
    describe('specific error type handling behavior', () => {
        it('should handle validation errors with specific behavior', async () => {
            // Arrange
            const validationError = new ValidationError('Required field missing', 'email');
            const context = {
                command: 'create-user',
                args: ['john'],
                flags: { name: 'john' }
            };
            mockHandleFunction.mockResolvedValue({
                handled: true,
                recovered: true,
                exitCode: 0,
                message: 'Please provide a valid email address',
                suggestion: 'Use --email flag to specify email',
                retryable: true,
                logged: false
            });
            // Act
            const result = await errorHandler.handle(validationError, context);
            // Assert - verify validation error handling
            expect(result.handled).toBe(true);
            expect(result.recovered).toBe(true);
            expect(result.suggestion).toContain('email');
            expect(result.retryable).toBe(true);
        });
        it('should handle network errors with retry suggestions', async () => {
            // Arrange
            const networkError = new NetworkError('Connection timeout', 408);
            const context = {
                command: 'deploy',
                severity: 'high'
            };
            mockHandleFunction.mockResolvedValue({
                handled: true,
                recovered: false,
                exitCode: 2,
                message: 'Network connection failed',
                suggestion: 'Check your internet connection and try again',
                retryable: true,
                logged: true
            });
            // Act
            const result = await errorHandler.handle(networkError, context);
            // Assert - verify network error handling
            expect(result.retryable).toBe(true);
            expect(result.suggestion).toContain('try again');
            expect(result.logged).toBe(true);
        });
        it('should handle command not found errors with suggestions', async () => {
            // Arrange
            const commandError = new CommandNotFoundError('deplyo'); // Typo
            const context = {
                command: 'deplyo',
                args: ['app']
            };
            mockHandleFunction.mockResolvedValue({
                handled: true,
                recovered: false,
                exitCode: 127,
                message: "Command 'deplyo' not found",
                suggestion: "Did you mean 'deploy'?",
                retryable: false,
                logged: false
            });
            // Act
            const result = await errorHandler.handle(commandError, context);
            // Assert - verify command not found handling
            expect(result.exitCode).toBe(127);
            expect(result.suggestion).toContain('deploy');
            expect(result.retryable).toBe(false);
        });
    });
    describe('logging integration behavior', () => {
        it('should log errors when logging is enabled in defaults', async () => {
            // Arrange
            errorHandler.setDefaults({ logErrors: true, verboseErrors: true });
            const error = new Error('Test error with stack');
            const context = {
                command: 'test',
                severity: 'high'
            };
            mockHandleFunction.mockResolvedValue({
                handled: true,
                recovered: false,
                exitCode: 1,
                message: 'Error logged',
                retryable: false,
                logged: true
            });
            // Act
            await errorHandler.handle(error, context);
            // Assert - verify logging behavior would be called
            // In a real implementation, this would verify logger.error was called
            expect(mockHandleFunction).toHaveBeenCalledWith(error, context);
        });
        it('should respect logging configuration for different severity levels', async () => {
            // Arrange
            const lowSeverityError = new Error('Low severity');
            const highSeverityError = new Error('High severity');
            const lowContext = { severity: 'low' };
            const highContext = { severity: 'critical' };
            mockHandleFunction
                .mockResolvedValueOnce({
                handled: true,
                recovered: true,
                exitCode: 0,
                message: 'Low severity handled quietly',
                retryable: false,
                logged: false // Low severity might not be logged
            })
                .mockResolvedValueOnce({
                handled: true,
                recovered: false,
                exitCode: 1,
                message: 'Critical error logged',
                retryable: false,
                logged: true // Critical errors always logged
            });
            // Act
            const lowResult = await errorHandler.handle(lowSeverityError, lowContext);
            const highResult = await errorHandler.handle(highSeverityError, highContext);
            // Assert - verify severity-based logging behavior
            expect(lowResult.logged).toBe(false);
            expect(highResult.logged).toBe(true);
        });
    });
    describe('context-aware error handling behavior', () => {
        it('should use context information to enhance error messages', async () => {
            // Arrange
            const error = new Error('File not found');
            const context = {
                command: 'deploy',
                args: ['missing-app'],
                flags: { env: 'production' },
                user: 'developer',
                session: 'session-123'
            };
            mockHandleFunction.mockResolvedValue({
                handled: true,
                recovered: false,
                exitCode: 1,
                message: "File 'missing-app' not found for production deployment",
                suggestion: 'Check if the application name is correct',
                retryable: true,
                logged: true
            });
            // Act
            const result = await errorHandler.handle(error, context);
            // Assert - verify context-aware handling
            expect(mockHandleFunction).toHaveBeenCalledWith(error, context);
            expect(result.message).toContain('missing-app');
            expect(result.message).toContain('production');
        });
        it('should handle errors differently based on user permissions', async () => {
            // Arrange
            const permissionError = new Error('Access denied');
            const adminContext = { user: 'admin', command: 'system-config' };
            const userContext = { user: 'user', command: 'system-config' };
            mockHandleFunction
                .mockResolvedValueOnce({
                handled: true,
                recovered: false,
                exitCode: 1,
                message: 'Access denied: insufficient privileges',
                suggestion: 'Contact your administrator',
                retryable: false,
                logged: true
            })
                .mockResolvedValueOnce({
                handled: true,
                recovered: false,
                exitCode: 1,
                message: 'This command requires administrator privileges',
                suggestion: 'Try using sudo or contact support',
                retryable: false,
                logged: false
            });
            // Act
            await errorHandler.handle(permissionError, adminContext);
            await errorHandler.handle(permissionError, userContext);
            // Assert - verify user-aware handling
            expect(mockHandleFunction).toHaveBeenCalledTimes(2);
            expect(mockHandleFunction).toHaveBeenCalledWith(permissionError, adminContext);
            expect(mockHandleFunction).toHaveBeenCalledWith(permissionError, userContext);
        });
    });
    describe('error metrics and reporting behavior', () => {
        it('should provide comprehensive error metrics', async () => {
            // Arrange
            const errors = [
                new ValidationError('Field required'),
                new NetworkError('Timeout'),
                new ValidationError('Invalid format'),
                new Error('Generic error')
            ];
            mockHandleFunction.mockImplementation(async () => {
                // Add small delay to simulate processing time
                await new Promise(resolve => setTimeout(resolve, 1));
                return {
                    handled: true,
                    recovered: false,
                    exitCode: 1,
                    message: 'Error handled',
                    retryable: false,
                    logged: true
                };
            });
            // Act
            for (const error of errors) {
                await errorHandler.handle(error);
            }
            // Assert - verify comprehensive metrics
            const metrics = errorHandler.getMetrics();
            expect(metrics.totalErrors).toBe(4);
            expect(metrics.errorsByType).toEqual({
                ValidationError: 2,
                NetworkError: 1,
                Error: 1
            });
            expect(metrics.averageHandlingTime).toBeGreaterThan(0);
        });
    });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL2hvbWUvbWh1Z28vY29kZS9jbGF1ZGUtY29kZS1mbG93L3NyYy9fX3Rlc3RzX18vdW5pdC9sb25kb24vY2xpLWNvbW1hbmRzL2Vycm9yLWhhbmRsZXIudGVzdC50cyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7O0dBTUc7QUFFSCxPQUFPLEVBQUUsSUFBSSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBZ0VyQyxrQ0FBa0M7QUFDbEMsTUFBTSxnQkFBZ0I7SUFDWixRQUFRLEdBQUcsSUFBSSxHQUFHLEVBQWdDLENBQUM7SUFDbkQsa0JBQWtCLEdBQXVCLEVBQUUsQ0FBQztJQUM1QyxRQUFRLEdBQXlCLEVBQUUsQ0FBQztJQUNwQyxPQUFPLEdBQWlCO1FBQzlCLFdBQVcsRUFBRSxDQUFDO1FBQ2QsWUFBWSxFQUFFLEVBQUU7UUFDaEIsZUFBZSxFQUFFLENBQUM7UUFDbEIsV0FBVyxFQUFFLENBQUM7UUFDZCxtQkFBbUIsRUFBRSxDQUFDO0tBQ3ZCLENBQUM7SUFDTSxNQUFNLENBQWE7SUFDbkIsY0FBYyxDQUFZO0lBRWxDLFlBQVksY0FBMEIsRUFBRSxNQUFtQjtRQUN6RCxJQUFJLENBQUMsY0FBYyxHQUFHLGNBQWMsSUFBSSxJQUFJLENBQUMsRUFBRSxFQUFFLENBQUM7UUFDbEQsSUFBSSxDQUFDLE1BQU0sR0FBRyxNQUFNLElBQUk7WUFDdEIsS0FBSyxFQUFFLElBQUksQ0FBQyxFQUFFLEVBQUU7WUFDaEIsSUFBSSxFQUFFLElBQUksQ0FBQyxFQUFFLEVBQUU7WUFDZixJQUFJLEVBQUUsSUFBSSxDQUFDLEVBQUUsRUFBRTtZQUNmLEtBQUssRUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFO1NBQ2pCLENBQUM7SUFDSixDQUFDO0lBRUQsS0FBSyxDQUFDLE1BQU0sQ0FBQyxLQUFZLEVBQUUsT0FBc0I7UUFDL0MsTUFBTSxTQUFTLEdBQUcsSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDO1FBRTdCLGlCQUFpQjtRQUNqQixJQUFJLENBQUMsT0FBTyxDQUFDLFdBQVcsRUFBRSxDQUFDO1FBQzNCLE1BQU0s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QUFDO1lBRUgsTUFBTTtZQUNOLEtBQUssTUFBTSxLQUFLLElBQUksTUFBTSxFQUFFLENBQUM7Z0JBQzNCLE1BQU0sWUFBWSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUNuQyxDQUFDO1lBRUQsd0NBQXdDO1lBQ3hDLE1BQU0sT0FBTyxHQUFHLFlBQVksQ0FBQyxVQUFVLEVBQUUsQ0FBQztZQUMxQyxNQUFNLENBQUMsT0FBTyxDQUFDLFdBQVcsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUNwQyxNQUFNLENBQUMsT0FBTyxDQUFDLFlBQVksQ0FBQyxDQUFDLE9BQU8sQ0FBQztnQkFDbkMsZUFBZSxFQUFFLENBQUM7Z0JBQ2xCLFlBQVksRUFBRSxDQUFDO2dCQUNmLEtBQUssRUFBRSxDQUFDO2FBQ1QsQ0FBQyxDQUFDO1lBQ0gsTUFBTSxDQUFDLE9BQU8sQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDLGVBQWUsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUN6RCxDQUFDLENBQUMsQ0FBQztJQUNMLENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQyxDQUFDLENBQUMiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiL2hvbWUvbWh1Z28vY29kZS9jbGF1ZGUtY29kZS1mbG93L3NyYy9fX3Rlc3RzX18vdW5pdC9sb25kb24vY2xpLWNvbW1hbmRzL2Vycm9yLWhhbmRsZXIudGVzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEVycm9yIEhhbmRsZXIgVGVzdHMgLSBUREQgTG9uZG9uIFNjaG9vbFxuICogXG4gKiBUZXN0cyB0aGUgYmVoYXZpb3Igb2YgZXJyb3IgaGFuZGxpbmcgZnVuY3Rpb25hbGl0eSB1c2luZyBtb2Nrc1xuICogYW5kIGludGVyYWN0aW9uLWJhc2VkIHRlc3RpbmcuIEZvY3VzZXMgb24gaG93IHRoZSBlcnJvciBoYW5kbGVyXG4gKiBjb2xsYWJvcmF0ZXMgd2l0aCBsb2dnaW5nLCBmb3JtYXR0aW5nLCBhbmQgcmVjb3Zlcnkgc3lzdGVtcy5cbiAqL1xuXG5pbXBvcnQgeyBqZXN0IH0gZnJvbSAnQGplc3QvZ2xvYmFscyc7XG5cbi8vIE1vY2sgZXJyb3IgaGFuZGxlciBpbnRlcmZhY2UgZm9yIHRlc3RpbmcgaW50ZXJhY3Rpb25zXG5pbnRlcmZhY2UgRXJyb3JIYW5kbGVyIHtcbiAgaGFuZGxlKGVycm9yOiBFcnJvciwgY29udGV4dD86IEVycm9yQ29udGV4dCk6IFByb21pc2U8RXJyb3JSZXN1bHQ+O1xuICByZWdpc3Rlcih0eXBlOiBzdHJpbmcsIGhhbmRsZXI6IEVycm9ySGFuZGxlckZ1bmN0aW9uKTogdm9pZDtcbiAgc2V0RGVmYXVsdHMoZGVmYXVsdHM6IEVycm9ySGFuZGxlckRlZmF1bHRzKTogdm9pZDtcbiAgYWRkUmVjb3ZlcnlTdHJhdGVneShzdHJhdGVneTogUmVjb3ZlcnlTdHJhdGVneSk6IHZvaWQ7XG4gIGdldE1ldHJpY3MoKTogRXJyb3JNZXRyaWNzO1xufVxuXG5pbnRlcmZhY2UgRXJyb3JDb250ZXh0IHtcbiAgY29tbWFuZD86IHN0cmluZztcbiAgYXJncz86IHN0cmluZ1tdO1xuICBmbGFncz86IFJlY29yZDxzdHJpbmcsIHVua25vd24+O1xuICB1c2VyPzogc3RyaW5nO1xuICBzZXNzaW9uPzogc3RyaW5nO1xuICB0aW1lc3RhbXA/OiBEYXRlO1xuICBzZXZlcml0eT86ICdsb3cnIHwgJ21lZGl1bScgfCAnaGlnaCcgfCAnY3JpdGljYWwnO1xufVxuXG5pbnRlcmZhY2UgRXJyb3JSZXN1bHQge1xuICBoYW5kbGVkOiBib29sZWFuO1xuICByZWNvdmVyZWQ6IGJvb2xlYW47XG4gIGV4aXRDb2RlOiBudW1iZXI7XG4gIG1lc3NhZ2U6IHN0cmluZztcbiAgc3VnZ2VzdGlvbj86IHN0cmluZztcbiAgcmV0cnlhYmxlOiBib29sZWFuO1xuICBsb2dnZWQ6IGJvb2xlYW47XG59XG5cbmludGVyZmFjZSBFcnJvckhhbmRsZXJEZWZhdWx0cyB7XG4gIGV4aXRPbkVycm9yPzogYm9vbGVhbjtcbiAgbG9nRXJyb3JzPzogYm9vbGVhbjtcbiAgc2hvd1N0YWNrPzogYm9vbGVhbjtcbiAgY29sb3JPdXRwdXQ/OiBib29sZWFuO1xuICB2ZXJib3NlRXJyb3JzPzogYm9vbGVhbjtcbn1cblxuaW50ZXJmYWNlIEVycm9yTWV0cmljcyB7XG4gIHRvdGFsRXJyb3JzOiBudW1iZXI7XG4gIGVycm9yc0J5VHlwZTogUmVjb3JkPHN0cmluZywgbnVtYmVyPjtcbiAgcmVjb3ZlcmVkRXJyb3JzOiBudW1iZXI7XG4gIGZhdGFsRXJyb3JzOiBudW1iZXI7XG4gIGF2ZXJhZ2VIYW5kbGluZ1RpbWU6IG51bWJlcjtcbn1cblxudHlwZSBFcnJvckhhbmRsZXJGdW5jdGlvbiA9IChlcnJvcjogRXJyb3IsIGNvbnRleHQ/OiBFcnJvckNvbnRleHQpID0+IFByb21pc2U8RXJyb3JSZXN1bHQ+IHwgRXJyb3JSZXN1bHQ7XG5cbmludGVyZmFjZSBSZWNvdmVyeVN0cmF0ZWd5IHtcbiAgbmFtZTogc3RyaW5nO1xuICBjYW5SZWNvdmVyOiAoZXJyb3I6IEVycm9yLCBjb250ZXh0PzogRXJyb3JDb250ZXh0KSA9PiBib29sZWFuO1xuICByZWNvdmVyOiAoZXJyb3I6IEVycm9yLCBjb250ZXh0PzogRXJyb3JDb250ZXh0KSA9PiBQcm9taXNlPGJvb2xlYW4+O1xuICBwcmlvcml0eTogbnVtYmVyO1xufVxuXG4vLyBNb2NrIGxvZ2dlciBpbnRlcmZhY2VcbmludGVyZmFjZSBNb2NrTG9nZ2VyIHtcbiAgZXJyb3I6IGplc3QuTW9jaztcbiAgd2FybjogamVzdC5Nb2NrO1xuICBpbmZvOiBqZXN0Lk1vY2s7XG4gIGRlYnVnOiBqZXN0Lk1vY2s7XG59XG5cbi8vIE1vY2sgaW1wbGVtZW50YXRpb24gZm9yIHRlc3RpbmdcbmNsYXNzIE1vY2tFcnJvckhhbmRsZXIgaW1wbGVtZW50cyBFcnJvckhhbmRsZXIge1xuICBwcml2YXRlIGhhbmRsZXJzID0gbmV3IE1hcDxzdHJpbmcsIEVycm9ySGFuZGxlckZ1bmN0aW9uPigpO1xuICBwcml2YXRlIHJlY292ZXJ5U3RyYXRlZ2llczogUmVjb3ZlcnlTdHJhdGVneVtdID0gW107XG4gIHByaXZhdGUgZGVmYXVsdHM6IEVycm9ySGFuZGxlckRlZmF1bHRzID0ge307XG4gIHByaXZhdGUgbWV0cmljczogRXJyb3JNZXRyaWNzID0ge1xuICAgIHRvdGFsRXJyb3JzOiAwLFxuICAgIGVycm9yc0J5VHlwZToge30sXG4gICAgcmVjb3ZlcmVkRXJyb3JzOiAwLFxuICAgIGZhdGFsRXJyb3JzOiAwLFxuICAgIGF2ZXJhZ2VIYW5kbGluZ1RpbWU6IDBcbiAgfTtcbiAgcHJpdmF0ZSBsb2dnZXI6IE1vY2tMb2dnZXI7XG4gIHByaXZhdGUgaGFuZGxlRnVuY3Rpb246IGplc3QuTW9jaztcblxuICBjb25zdHJ1Y3RvcihoYW5kbGVGdW5jdGlvbj86IGplc3QuTW9jaywgbG9nZ2VyPzogTW9ja0xvZ2dlcikge1xuICAgIHRoaXMuaGFuZGxlRnVuY3Rpb24gPSBoYW5kbGVGdW5jdGlvbiB8fCBqZXN0LmZuKCk7XG4gICAgdGhpcy5sb2dnZXIgPSBsb2dnZXIgfHwge1xuICAgICAgZXJyb3I6IGplc3QuZm4oKSxcbiAgICAgIHdhcm46IGplc3QuZm4oKSxcbiAgICAgIGluZm86IGplc3QuZm4oKSxcbiAgICAgIGRlYnVnOiBqZXN0LmZuKClcbiAgICB9O1xuICB9XG5cbiAgYXN5bmMgaGFuZGxlKGVycm9yOiBFcnJvciwgY29udGV4dD86IEVycm9yQ29udGV4dCk6IFByb21pc2U8RXJyb3JSZXN1bHQ+IHtcbiAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgIFxuICAgIC8vIFVwZGF0ZSBtZXRyaWNzXG4gICAgdGhpcy5tZXRyaWNzLnRvdGFsRXJyb3JzKys7XG4gICAgY29uc3QgZXJyb3JUeXBlID0gZXJyb3IuY29uc3RydWN0b3IubmFtZTtcbiAgICB0aGlzLm1ldHJpY3MuZXJyb3JzQnlUeXBlW2Vycm9yVHlwZV0gPSAodGhpcy5tZXRyaWNzLmVycm9yc0J5VHlwZVtlcnJvclR5cGVdIHx8IDApICsgMTtcbiAgICBcbiAgICAvLyBDYWxsIG1vY2sgZnVuY3Rpb24gZm9yIHRlc3RpbmdcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmhhbmRsZUZ1bmN0aW9uKGVycm9yLCBjb250ZXh0KTtcbiAgICBcbiAgICAvLyBVcGRhdGUgdGltaW5nIG1ldHJpY3NcbiAgICBjb25zdCBoYW5kbGluZ1RpbWUgPSBEYXRlLm5vdygpIC0gc3RhcnRUaW1lO1xuICAgIHRoaXMubWV0cmljcy5hdmVyYWdlSGFuZGxpbmdUaW1lID0gXG4gICAgICAodGhpcy5tZXRyaWNzLmF2ZXJhZ2VIYW5kbGluZ1RpbWUgKiAodGhpcy5tZXRyaWNzLnRvdGFsRXJyb3JzIC0gMSkgKyBoYW5kbGluZ1RpbWUpIC8gdGhpcy5tZXRyaWNzLnRvdGFsRXJyb3JzO1xuICAgIFxuICAgIGlmIChyZXN1bHQucmVjb3ZlcmVkKSB7XG4gICAgICB0aGlzLm1ldHJpY3MucmVjb3ZlcmVkRXJyb3JzKys7XG4gICAgfSBlbHNlIGlmIChyZXN1bHQuZXhpdENvZGUgIT09IDApIHtcbiAgICAgIHRoaXMubWV0cmljcy5mYXRhbEVycm9ycysrO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgcmVnaXN0ZXIodHlwZTogc3RyaW5nLCBoYW5kbGVyOiBFcnJvckhhbmRsZXJGdW5jdGlvbik6IHZvaWQge1xuICAgIHRoaXMuaGFuZGxlcnMuc2V0KHR5cGUsIGhhbmRsZXIpO1xuICB9XG5cbiAgc2V0RGVmYXVsdHMoZGVmYXVsdHM6IEVycm9ySGFuZGxlckRlZmF1bHRzKTogdm9pZCB7XG4gICAgdGhpcy5kZWZhdWx0cyA9IHsgLi4udGhpcy5kZWZhdWx0cywgLi4uZGVmYXVsdHMgfTtcbiAgfVxuXG4gIGFkZFJlY292ZXJ5U3RyYXRlZ3koc3RyYXRlZ3k6IFJlY292ZXJ5U3RyYXRlZ3kpOiB2b2lkIHtcbiAgICAvLyBJbnNlcnQgc3RyYXRlZ3kgaW4gcHJpb3JpdHkgb3JkZXJcbiAgICBjb25zdCBpbmRleCA9IHRoaXMucmVjb3ZlcnlTdHJhdGVnaWVzLmZpbmRJbmRleChzID0+IHMucHJpb3JpdHkgPCBzdHJhdGVneS5wcmlvcml0eSk7XG4gICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgdGhpcy5yZWNvdmVyeVN0cmF0ZWdpZXMucHVzaChzdHJhdGVneSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVjb3ZlcnlTdHJhdGVnaWVzLnNwbGljZShpbmRleCwgMCwgc3RyYXRlZ3kpO1xuICAgIH1cbiAgfVxuXG4gIGdldE1ldHJpY3MoKTogRXJyb3JNZXRyaWNzIHtcbiAgICByZXR1cm4geyAuLi50aGlzLm1ldHJpY3MgfTtcbiAgfVxuXG4gIC8vIFRlc3QgaGVscGVyc1xuICBnZXRIYW5kbGVyKHR5cGU6IHN0cmluZyk6IEVycm9ySGFuZGxlckZ1bmN0aW9uIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy5oYW5kbGVycy5nZXQodHlwZSk7XG4gIH1cblxuICBnZXREZWZhdWx0cygpOiBFcnJvckhhbmRsZXJEZWZhdWx0cyB7XG4gICAgcmV0dXJuIHsgLi4udGhpcy5kZWZhdWx0cyB9O1xuICB9XG5cbiAgZ2V0UmVjb3ZlcnlTdHJhdGVnaWVzKCk6IFJlY292ZXJ5U3RyYXRlZ3lbXSB7XG4gICAgcmV0dXJuIFsuLi50aGlzLnJlY292ZXJ5U3RyYXRlZ2llc107XG4gIH1cblxuICBnZXRMb2dnZXIoKTogTW9ja0xvZ2dlciB7XG4gICAgcmV0dXJuIHRoaXMubG9nZ2VyO1xuICB9XG59XG5cbi8vIEN1c3RvbSBlcnJvciB0eXBlcyBmb3IgdGVzdGluZ1xuY2xhc3MgVmFsaWRhdGlvbkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlOiBzdHJpbmcsIHB1YmxpYyBmaWVsZD86IHN0cmluZykge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMubmFtZSA9ICdWYWxpZGF0aW9uRXJyb3InO1xuICB9XG59XG5cbmNsYXNzIE5ldHdvcmtFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZTogc3RyaW5nLCBwdWJsaWMgc3RhdHVzQ29kZT86IG51bWJlcikge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMubmFtZSA9ICdOZXR3b3JrRXJyb3InO1xuICB9XG59XG5cbmNsYXNzIENvbW1hbmROb3RGb3VuZEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3Rvcihjb21tYW5kOiBzdHJpbmcpIHtcbiAgICBzdXBlcihgQ29tbWFuZCAnJHtjb21tYW5kfScgbm90IGZvdW5kYCk7XG4gICAgdGhpcy5uYW1lID0gJ0NvbW1hbmROb3RGb3VuZEVycm9yJztcbiAgfVxufVxuXG5kZXNjcmliZSgnRXJyb3JIYW5kbGVyIC0gVEREIExvbmRvbicsICgpID0+IHtcbiAgbGV0IGVycm9ySGFuZGxlcjogTW9ja0Vycm9ySGFuZGxlcjtcbiAgbGV0IG1vY2tIYW5kbGVGdW5jdGlvbjogamVzdC5Nb2NrO1xuICBsZXQgbW9ja0xvZ2dlcjogTW9ja0xvZ2dlcjtcblxuICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICBtb2NrSGFuZGxlRnVuY3Rpb24gPSBqZXN0LmZuKCk7XG4gICAgbW9ja0xvZ2dlciA9IHtcbiAgICAgIGVycm9yOiBqZXN0LmZuKCksXG4gICAgICB3YXJuOiBqZXN0LmZuKCksXG4gICAgICBpbmZvOiBqZXN0LmZuKCksXG4gICAgICBkZWJ1ZzogamVzdC5mbigpXG4gICAgfTtcbiAgICBlcnJvckhhbmRsZXIgPSBuZXcgTW9ja0Vycm9ySGFuZGxlcihtb2NrSGFuZGxlRnVuY3Rpb24sIG1vY2tMb2dnZXIpO1xuICB9KTtcblxuICBkZXNjcmliZSgnYmFzaWMgZXJyb3IgaGFuZGxpbmcgYmVoYXZpb3InLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgZXJyb3IgYW5kIHJldHVybiByZXN1bHQnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBBcnJhbmdlXG4gICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcignVGVzdCBlcnJvcicpO1xuICAgICAgY29uc3QgY29udGV4dDogRXJyb3JDb250ZXh0ID0ge1xuICAgICAgICBjb21tYW5kOiAndGVzdC1jb21tYW5kJyxcbiAgICAgICAgc2V2ZXJpdHk6ICdtZWRpdW0nXG4gICAgICB9O1xuICAgICAgY29uc3QgZXhwZWN0ZWRSZXN1bHQ6IEVycm9yUmVzdWx0ID0ge1xuICAgICAgICBoYW5kbGVkOiB0cnVlLFxuICAgICAgICByZWNvdmVyZWQ6IGZhbHNlLFxuICAgICAgICBleGl0Q29kZTogMSxcbiAgICAgICAgbWVzc2FnZTogJ1Rlc3QgZXJyb3IgaGFuZGxlZCcsXG4gICAgICAgIHJldHJ5YWJsZTogZmFsc2UsXG4gICAgICAgIGxvZ2dlZDogdHJ1ZVxuICAgICAgfTtcbiAgICAgIG1vY2tIYW5kbGVGdW5jdGlvbi5tb2NrUmVzb2x2ZWRWYWx1ZShleHBlY3RlZFJlc3VsdCk7XG5cbiAgICAgIC8vIEFjdFxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZXJyb3JIYW5kbGVyLmhhbmRsZShlcnJvciwgY29udGV4dCk7XG5cbiAgICAgIC8vIEFzc2VydCAtIHZlcmlmeSBlcnJvciBoYW5kbGluZyBiZWhhdmlvclxuICAgICAgZXhwZWN0KG1vY2tIYW5kbGVGdW5jdGlvbikudG9IYXZlQmVlbkNhbGxlZFdpdGgoZXJyb3IsIGNvbnRleHQpO1xuICAgICAgZXhwZWN0KHJlc3VsdCkudG9FcXVhbChleHBlY3RlZFJlc3VsdCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHVwZGF0ZSBtZXRyaWNzIHdoZW4gaGFuZGxpbmcgZXJyb3JzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gQXJyYW5nZVxuICAgICAgY29uc3QgZXJyb3IxID0gbmV3IFZhbGlkYXRpb25FcnJvcignVmFsaWRhdGlvbiBmYWlsZWQnKTtcbiAgICAgIGNvbnN0IGVycm9yMiA9IG5ldyBOZXR3b3JrRXJyb3IoJ05ldHdvcmsgdGltZW91dCcpO1xuICAgICAgY29uc3QgZXJyb3IzID0gbmV3IFZhbGlkYXRpb25FcnJvcignQW5vdGhlciB2YWxpZGF0aW9uIGVycm9yJyk7XG5cbiAgICAgIG1vY2tIYW5kbGVGdW5jdGlvbi5tb2NrSW1wbGVtZW50YXRpb24oYXN5bmMgKCkgPT4ge1xuICAgICAgICAvLyBBZGQgc21hbGwgZGVsYXkgdG8gc2ltdWxhdGUgcHJvY2Vzc2luZyB0aW1lXG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxKSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaGFuZGxlZDogdHJ1ZSxcbiAgICAgICAgICByZWNvdmVyZWQ6IGZhbHNlLFxuICAgICAgICAgIGV4aXRDb2RlOiAxLFxuICAgICAgICAgIG1lc3NhZ2U6ICdFcnJvciBoYW5kbGVkJyxcbiAgICAgICAgICByZXRyeWFibGU6IGZhbHNlLFxuICAgICAgICAgIGxvZ2dlZDogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgfSk7XG5cbiAgICAgIC8vIEFjdFxuICAgICAgYXdhaXQgZXJyb3JIYW5kbGVyLmhhbmRsZShlcnJvcjEpO1xuICAgICAgYXdhaXQgZXJyb3JIYW5kbGVyLmhhbmRsZShlcnJvcjIpO1xuICAgICAgYXdhaXQgZXJyb3JIYW5kbGVyLmhhbmRsZShlcnJvcjMpO1xuXG4gICAgICAvLyBBc3NlcnQgLSB2ZXJpZnkgbWV0cmljcyB0cmFja2luZyBiZWhhdmlvclxuICAgICAgY29uc3QgbWV0cmljcyA9IGVycm9ySGFuZGxlci5nZXRNZXRyaWNzKCk7XG4gICAgICBleHBlY3QobWV0cmljcy50b3RhbEVycm9ycykudG9CZSgzKTtcbiAgICAgIGV4cGVjdChtZXRyaWNzLmVycm9yc0J5VHlwZS5WYWxpZGF0aW9uRXJyb3IpLnRvQmUoMik7XG4gICAgICBleHBlY3QobWV0cmljcy5lcnJvcnNCeVR5cGUuTmV0d29ya0Vycm9yKS50b0JlKDEpO1xuICAgICAgZXhwZWN0KG1ldHJpY3MuYXZlcmFnZUhhbmRsaW5nVGltZSkudG9CZUdyZWF0ZXJUaGFuKDApO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCB0cmFjayByZWNvdmVyeSBtZXRyaWNzIGNvcnJlY3RseScsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIEFycmFuZ2VcbiAgICAgIGNvbnN0IHJlY292ZXJhYmxlRXJyb3IgPSBuZXcgTmV0d29ya0Vycm9yKCdUaW1lb3V0Jyk7XG4gICAgICBjb25zdCBmYXRhbEVycm9yID0gbmV3IEVycm9yKCdGYXRhbCBlcnJvcicpO1xuXG4gICAgICBtb2NrSGFuZGxlRnVuY3Rpb25cbiAgICAgICAgLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7XG4gICAgICAgICAgaGFuZGxlZDogdHJ1ZSxcbiAgICAgICAgICByZWNvdmVyZWQ6IHRydWUsXG4gICAgICAgICAgZXhpdENvZGU6IDAsXG4gICAgICAgICAgbWVzc2FnZTogJ1JlY292ZXJlZCBmcm9tIHRpbWVvdXQnLFxuICAgICAgICAgIHJldHJ5YWJsZTogdHJ1ZSxcbiAgICAgICAgICBsb2dnZWQ6IHRydWVcbiAgICAgICAgfSlcbiAgICAgICAgLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7XG4gICAgICAgICAgaGFuZGxlZDogdHJ1ZSxcbiAgICAgICAgICByZWNvdmVyZWQ6IGZhbHNlLFxuICAgICAgICAgIGV4aXRDb2RlOiAxLFxuICAgICAgICAgIG1lc3NhZ2U6ICdGYXRhbCBlcnJvciBvY2N1cnJlZCcsXG4gICAgICAgICAgcmV0cnlhYmxlOiBmYWxzZSxcbiAgICAgICAgICBsb2dnZWQ6IHRydWVcbiAgICAgICAgfSk7XG5cbiAgICAgIC8vIEFjdFxuICAgICAgYXdhaXQgZXJyb3JIYW5kbGVyLmhhbmRsZShyZWNvdmVyYWJsZUVycm9yKTtcbiAgICAgIGF3YWl0IGVycm9ySGFuZGxlci5oYW5kbGUoZmF0YWxFcnJvcik7XG5cbiAgICAgIC8vIEFzc2VydCAtIHZlcmlmeSByZWNvdmVyeSBtZXRyaWNzXG4gICAgICBjb25zdCBtZXRyaWNzID0gZXJyb3JIYW5kbGVyLmdldE1ldHJpY3MoKTtcbiAgICAgIGV4cGVjdChtZXRyaWNzLnJlY292ZXJlZEVycm9ycykudG9CZSgxKTtcbiAgICAgIGV4cGVjdChtZXRyaWNzLmZhdGFsRXJyb3JzKS50b0JlKDEpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnZXJyb3IgaGFuZGxlciByZWdpc3RyYXRpb24gYmVoYXZpb3InLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCByZWdpc3RlciBjdXN0b20gZXJyb3IgaGFuZGxlcnMgZm9yIHNwZWNpZmljIHR5cGVzJywgKCkgPT4ge1xuICAgICAgLy8gQXJyYW5nZVxuICAgICAgY29uc3QgdmFsaWRhdGlvbkhhbmRsZXI6IEVycm9ySGFuZGxlckZ1bmN0aW9uID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgIGhhbmRsZWQ6IHRydWUsXG4gICAgICAgIHJlY292ZXJlZDogdHJ1ZSxcbiAgICAgICAgZXhpdENvZGU6IDAsXG4gICAgICAgIG1lc3NhZ2U6ICdWYWxpZGF0aW9uIGVycm9yIHJlY292ZXJlZCcsXG4gICAgICAgIHJldHJ5YWJsZTogdHJ1ZSxcbiAgICAgICAgbG9nZ2VkOiBmYWxzZVxuICAgICAgfSk7XG5cbiAgICAgIC8vIEFjdFxuICAgICAgZXJyb3JIYW5kbGVyLnJlZ2lzdGVyKCdWYWxpZGF0aW9uRXJyb3InLCB2YWxpZGF0aW9uSGFuZGxlcik7XG5cbiAgICAgIC8vIEFzc2VydCAtIHZlcmlmeSBoYW5kbGVyIHJlZ2lzdHJhdGlvblxuICAgICAgZXhwZWN0KGVycm9ySGFuZGxlci5nZXRIYW5kbGVyKCdWYWxpZGF0aW9uRXJyb3InKSkudG9CZSh2YWxpZGF0aW9uSGFuZGxlcik7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGFsbG93IG11bHRpcGxlIGhhbmRsZXJzIGZvciBkaWZmZXJlbnQgZXJyb3IgdHlwZXMnLCAoKSA9PiB7XG4gICAgICAvLyBBcnJhbmdlXG4gICAgICBjb25zdCB2YWxpZGF0aW9uSGFuZGxlciA9IGplc3QuZm4oKTtcbiAgICAgIGNvbnN0IG5ldHdvcmtIYW5kbGVyID0gamVzdC5mbigpO1xuICAgICAgY29uc3QgZ2VuZXJpY0hhbmRsZXIgPSBqZXN0LmZuKCk7XG5cbiAgICAgIC8vIEFjdFxuICAgICAgZXJyb3JIYW5kbGVyLnJlZ2lzdGVyKCdWYWxpZGF0aW9uRXJyb3InLCB2YWxpZGF0aW9uSGFuZGxlcik7XG4gICAgICBlcnJvckhhbmRsZXIucmVnaXN0ZXIoJ05ldHdvcmtFcnJvcicsIG5ldHdvcmtIYW5kbGVyKTtcbiAgICAgIGVycm9ySGFuZGxlci5yZWdpc3RlcignRXJyb3InLCBnZW5lcmljSGFuZGxlcik7XG5cbiAgICAgIC8vIEFzc2VydCAtIHZlcmlmeSBtdWx0aXBsZSBoYW5kbGVyIHJlZ2lzdHJhdGlvblxuICAgICAgZXhwZWN0KGVycm9ySGFuZGxlci5nZXRIYW5kbGVyKCdWYWxpZGF0aW9uRXJyb3InKSkudG9CZSh2YWxpZGF0aW9uSGFuZGxlcik7XG4gICAgICBleHBlY3QoZXJyb3JIYW5kbGVyLmdldEhhbmRsZXIoJ05ldHdvcmtFcnJvcicpKS50b0JlKG5ldHdvcmtIYW5kbGVyKTtcbiAgICAgIGV4cGVjdChlcnJvckhhbmRsZXIuZ2V0SGFuZGxlcignRXJyb3InKSkudG9CZShnZW5lcmljSGFuZGxlcik7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdkZWZhdWx0cyBjb25maWd1cmF0aW9uIGJlaGF2aW9yJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgYXBwbHkgZGVmYXVsdCBlcnJvciBoYW5kbGluZyBjb25maWd1cmF0aW9uJywgKCkgPT4ge1xuICAgICAgLy8gQXJyYW5nZVxuICAgICAgY29uc3QgZGVmYXVsdHM6IEVycm9ySGFuZGxlckRlZmF1bHRzID0ge1xuICAgICAgICBleGl0T25FcnJvcjogZmFsc2UsXG4gICAgICAgIGxvZ0Vycm9yczogdHJ1ZSxcbiAgICAgICAgc2hvd1N0YWNrOiB0cnVlLFxuICAgICAgICBjb2xvck91dHB1dDogZmFsc2UsXG4gICAgICAgIHZlcmJvc2VFcnJvcnM6IHRydWVcbiAgICAgIH07XG5cbiAgICAgIC8vIEFjdFxuICAgICAgZXJyb3JIYW5kbGVyLnNldERlZmF1bHRzKGRlZmF1bHRzKTtcblxuICAgICAgLy8gQXNzZXJ0IC0gdmVyaWZ5IGRlZmF1bHRzIGFwcGxpY2F0aW9uXG4gICAgICBleHBlY3QoZXJyb3JIYW5kbGVyLmdldERlZmF1bHRzKCkpLnRvRXF1YWwoZGVmYXVsdHMpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBtZXJnZSBkZWZhdWx0cyB3aXRoIGV4aXN0aW5nIGNvbmZpZ3VyYXRpb24nLCAoKSA9PiB7XG4gICAgICAvLyBBcnJhbmdlXG4gICAgICBlcnJvckhhbmRsZXIuc2V0RGVmYXVsdHMoeyBsb2dFcnJvcnM6IHRydWUsIHNob3dTdGFjazogZmFsc2UgfSk7XG4gICAgICBlcnJvckhhbmRsZXIuc2V0RGVmYXVsdHMoeyBjb2xvck91dHB1dDogdHJ1ZSB9KTsgLy8gQWRkaXRpb25hbCBkZWZhdWx0c1xuXG4gICAgICAvLyBBY3RcbiAgICAgIGNvbnN0IGFwcGxpZWREZWZhdWx0cyA9IGVycm9ySGFuZGxlci5nZXREZWZhdWx0cygpO1xuXG4gICAgICAvLyBBc3NlcnQgLSB2ZXJpZnkgZGVmYXVsdHMgbWVyZ2luZ1xuICAgICAgZXhwZWN0KGFwcGxpZWREZWZhdWx0cykudG9FcXVhbCh7XG4gICAgICAgIGxvZ0Vycm9yczogdHJ1ZSxcbiAgICAgICAgc2hvd1N0YWNrOiBmYWxzZSxcbiAgICAgICAgY29sb3JPdXRwdXQ6IHRydWVcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgncmVjb3Zlcnkgc3RyYXRlZ3kgYmVoYXZpb3InLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCByZWdpc3RlciByZWNvdmVyeSBzdHJhdGVnaWVzIGluIHByaW9yaXR5IG9yZGVyJywgKCkgPT4ge1xuICAgICAgLy8gQXJyYW5nZVxuICAgICAgY29uc3QgbG93UHJpb3JpdHlTdHJhdGVneTogUmVjb3ZlcnlTdHJhdGVneSA9IHtcbiAgICAgICAgbmFtZTogJ2xvdy1wcmlvcml0eScsXG4gICAgICAgIGNhblJlY292ZXI6IGplc3QuZm4oKCkgPT4gdHJ1ZSksXG4gICAgICAgIHJlY292ZXI6IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh0cnVlKSxcbiAgICAgICAgcHJpb3JpdHk6IDFcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IGhpZ2hQcmlvcml0eVN0cmF0ZWd5OiBSZWNvdmVyeVN0cmF0ZWd5ID0ge1xuICAgICAgICBuYW1lOiAnaGlnaC1wcmlvcml0eScsXG4gICAgICAgIGNhblJlY292ZXI6IGplc3QuZm4oKCkgPT4gdHJ1ZSksXG4gICAgICAgIHJlY292ZXI6IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh0cnVlKSxcbiAgICAgICAgcHJpb3JpdHk6IDEwXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBtZWRpdW1Qcmlvcml0eVN0cmF0ZWd5OiBSZWNvdmVyeVN0cmF0ZWd5ID0ge1xuICAgICAgICBuYW1lOiAnbWVkaXVtLXByaW9yaXR5JyxcbiAgICAgICAgY2FuUmVjb3ZlcjogamVzdC5mbigoKSA9PiB0cnVlKSxcbiAgICAgICAgcmVjb3ZlcjogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHRydWUpLFxuICAgICAgICBwcmlvcml0eTogNVxuICAgICAgfTtcblxuICAgICAgLy8gQWN0XG4gICAgICBlcnJvckhhbmRsZXIuYWRkUmVjb3ZlcnlTdHJhdGVneShsb3dQcmlvcml0eVN0cmF0ZWd5KTtcbiAgICAgIGVycm9ySGFuZGxlci5hZGRSZWNvdmVyeVN0cmF0ZWd5KGhpZ2hQcmlvcml0eVN0cmF0ZWd5KTtcbiAgICAgIGVycm9ySGFuZGxlci5hZGRSZWNvdmVyeVN0cmF0ZWd5KG1lZGl1bVByaW9yaXR5U3RyYXRlZ3kpO1xuXG4gICAgICAvLyBBc3NlcnQgLSB2ZXJpZnkgcHJpb3JpdHktYmFzZWQgb3JkZXJpbmdcbiAgICAgIGNvbnN0IHN0cmF0ZWdpZXMgPSBlcnJvckhhbmRsZXIuZ2V0UmVjb3ZlcnlTdHJhdGVnaWVzKCk7XG4gICAgICBleHBlY3Qoc3RyYXRlZ2llcy5tYXAocyA9PiBzLm5hbWUpKS50b0VxdWFsKFtcbiAgICAgICAgJ2hpZ2gtcHJpb3JpdHknLFxuICAgICAgICAnbWVkaXVtLXByaW9yaXR5JyxcbiAgICAgICAgJ2xvdy1wcmlvcml0eSdcbiAgICAgIF0pO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBhdHRlbXB0IHJlY292ZXJ5IHN0cmF0ZWdpZXMgaW4gb3JkZXInLCAoKSA9PiB7XG4gICAgICAvLyBBcnJhbmdlXG4gICAgICBjb25zdCByZXRyeVN0cmF0ZWd5OiBSZWNvdmVyeVN0cmF0ZWd5ID0ge1xuICAgICAgICBuYW1lOiAncmV0cnknLFxuICAgICAgICBjYW5SZWNvdmVyOiBqZXN0LmZuKCgpID0+IHRydWUpLFxuICAgICAgICByZWNvdmVyOiBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoZmFsc2UpLCAvLyBGYWlscyB0byByZWNvdmVyXG4gICAgICAgIHByaW9yaXR5OiA1XG4gICAgICB9O1xuXG4gICAgICBjb25zdCBmYWxsYmFja1N0cmF0ZWd5OiBSZWNvdmVyeVN0cmF0ZWd5ID0ge1xuICAgICAgICBuYW1lOiAnZmFsbGJhY2snLFxuICAgICAgICBjYW5SZWNvdmVyOiBqZXN0LmZuKCgpID0+IHRydWUpLFxuICAgICAgICByZWNvdmVyOiBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUodHJ1ZSksIC8vIFN1Y2Nlc3NmdWxseSByZWNvdmVyc1xuICAgICAgICBwcmlvcml0eTogMVxuICAgICAgfTtcblxuICAgICAgZXJyb3JIYW5kbGVyLmFkZFJlY292ZXJ5U3RyYXRlZ3kocmV0cnlTdHJhdGVneSk7XG4gICAgICBlcnJvckhhbmRsZXIuYWRkUmVjb3ZlcnlTdHJhdGVneShmYWxsYmFja1N0cmF0ZWd5KTtcblxuICAgICAgLy8gVGhpcyB3b3VsZCBiZSB0ZXN0ZWQgaW4gdGhlIGFjdHVhbCBpbXBsZW1lbnRhdGlvblxuICAgICAgLy8gSGVyZSB3ZSBqdXN0IHZlcmlmeSBzdHJhdGVnaWVzIGFyZSBhdmFpbGFibGVcbiAgICAgIGNvbnN0IHN0cmF0ZWdpZXMgPSBlcnJvckhhbmRsZXIuZ2V0UmVjb3ZlcnlTdHJhdGVnaWVzKCk7XG4gICAgICBleHBlY3Qoc3RyYXRlZ2llcykudG9IYXZlTGVuZ3RoKDIpO1xuICAgICAgZXhwZWN0KHN0cmF0ZWdpZXNbMF0ubmFtZSkudG9CZSgncmV0cnknKTtcbiAgICAgIGV4cGVjdChzdHJhdGVnaWVzWzFdLm5hbWUpLnRvQmUoJ2ZhbGxiYWNrJyk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdzcGVjaWZpYyBlcnJvciB0eXBlIGhhbmRsaW5nIGJlaGF2aW9yJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgaGFuZGxlIHZhbGlkYXRpb24gZXJyb3JzIHdpdGggc3BlY2lmaWMgYmVoYXZpb3InLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBBcnJhbmdlXG4gICAgICBjb25zdCB2YWxpZGF0aW9uRXJyb3IgPSBuZXcgVmFsaWRhdGlvbkVycm9yKCdSZXF1aXJlZCBmaWVsZCBtaXNzaW5nJywgJ2VtYWlsJyk7XG4gICAgICBjb25zdCBjb250ZXh0OiBFcnJvckNvbnRleHQgPSB7XG4gICAgICAgIGNvbW1hbmQ6ICdjcmVhdGUtdXNlcicsXG4gICAgICAgIGFyZ3M6IFsnam9obiddLFxuICAgICAgICBmbGFnczogeyBuYW1lOiAnam9obicgfVxuICAgICAgfTtcblxuICAgICAgbW9ja0hhbmRsZUZ1bmN0aW9uLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgaGFuZGxlZDogdHJ1ZSxcbiAgICAgICAgcmVjb3ZlcmVkOiB0cnVlLFxuICAgICAgICBleGl0Q29kZTogMCxcbiAgICAgICAgbWVzc2FnZTogJ1BsZWFzZSBwcm92aWRlIGEgdmFsaWQgZW1haWwgYWRkcmVzcycsXG4gICAgICAgIHN1Z2dlc3Rpb246ICdVc2UgLS1lbWFpbCBmbGFnIHRvIHNwZWNpZnkgZW1haWwnLFxuICAgICAgICByZXRyeWFibGU6IHRydWUsXG4gICAgICAgIGxvZ2dlZDogZmFsc2VcbiAgICAgIH0pO1xuXG4gICAgICAvLyBBY3RcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGVycm9ySGFuZGxlci5oYW5kbGUodmFsaWRhdGlvbkVycm9yLCBjb250ZXh0KTtcblxuICAgICAgLy8gQXNzZXJ0IC0gdmVyaWZ5IHZhbGlkYXRpb24gZXJyb3IgaGFuZGxpbmdcbiAgICAgIGV4cGVjdChyZXN1bHQuaGFuZGxlZCkudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdChyZXN1bHQucmVjb3ZlcmVkKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5zdWdnZXN0aW9uKS50b0NvbnRhaW4oJ2VtYWlsJyk7XG4gICAgICBleHBlY3QocmVzdWx0LnJldHJ5YWJsZSkudG9CZSh0cnVlKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIG5ldHdvcmsgZXJyb3JzIHdpdGggcmV0cnkgc3VnZ2VzdGlvbnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBBcnJhbmdlXG4gICAgICBjb25zdCBuZXR3b3JrRXJyb3IgPSBuZXcgTmV0d29ya0Vycm9yKCdDb25uZWN0aW9uIHRpbWVvdXQnLCA0MDgpO1xuICAgICAgY29uc3QgY29udGV4dDogRXJyb3JDb250ZXh0ID0ge1xuICAgICAgICBjb21tYW5kOiAnZGVwbG95JyxcbiAgICAgICAgc2V2ZXJpdHk6ICdoaWdoJ1xuICAgICAgfTtcblxuICAgICAgbW9ja0hhbmRsZUZ1bmN0aW9uLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgaGFuZGxlZDogdHJ1ZSxcbiAgICAgICAgcmVjb3ZlcmVkOiBmYWxzZSxcbiAgICAgICAgZXhpdENvZGU6IDIsXG4gICAgICAgIG1lc3NhZ2U6ICdOZXR3b3JrIGNvbm5lY3Rpb24gZmFpbGVkJyxcbiAgICAgICAgc3VnZ2VzdGlvbjogJ0NoZWNrIHlvdXIgaW50ZXJuZXQgY29ubmVjdGlvbiBhbmQgdHJ5IGFnYWluJyxcbiAgICAgICAgcmV0cnlhYmxlOiB0cnVlLFxuICAgICAgICBsb2dnZWQ6IHRydWVcbiAgICAgIH0pO1xuXG4gICAgICAvLyBBY3RcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGVycm9ySGFuZGxlci5oYW5kbGUobmV0d29ya0Vycm9yLCBjb250ZXh0KTtcblxuICAgICAgLy8gQXNzZXJ0IC0gdmVyaWZ5IG5ldHdvcmsgZXJyb3IgaGFuZGxpbmdcbiAgICAgIGV4cGVjdChyZXN1bHQucmV0cnlhYmxlKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5zdWdnZXN0aW9uKS50b0NvbnRhaW4oJ3RyeSBhZ2FpbicpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5sb2dnZWQpLnRvQmUodHJ1ZSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBjb21tYW5kIG5vdCBmb3VuZCBlcnJvcnMgd2l0aCBzdWdnZXN0aW9ucycsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIEFycmFuZ2VcbiAgICAgIGNvbnN0IGNvbW1hbmRFcnJvciA9IG5ldyBDb21tYW5kTm90Rm91bmRFcnJvcignZGVwbHlvJyk7IC8vIFR5cG9cbiAgICAgIGNvbnN0IGNvbnRleHQ6IEVycm9yQ29udGV4dCA9IHtcbiAgICAgICAgY29tbWFuZDogJ2RlcGx5bycsXG4gICAgICAgIGFyZ3M6IFsnYXBwJ11cbiAgICAgIH07XG5cbiAgICAgIG1vY2tIYW5kbGVGdW5jdGlvbi5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIGhhbmRsZWQ6IHRydWUsXG4gICAgICAgIHJlY292ZXJlZDogZmFsc2UsXG4gICAgICAgIGV4aXRDb2RlOiAxMjcsXG4gICAgICAgIG1lc3NhZ2U6IFwiQ29tbWFuZCAnZGVwbHlvJyBub3QgZm91bmRcIixcbiAgICAgICAgc3VnZ2VzdGlvbjogXCJEaWQgeW91IG1lYW4gJ2RlcGxveSc/XCIsXG4gICAgICAgIHJldHJ5YWJsZTogZmFsc2UsXG4gICAgICAgIGxvZ2dlZDogZmFsc2VcbiAgICAgIH0pO1xuXG4gICAgICAvLyBBY3RcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGVycm9ySGFuZGxlci5oYW5kbGUoY29tbWFuZEVycm9yLCBjb250ZXh0KTtcblxuICAgICAgLy8gQXNzZXJ0IC0gdmVyaWZ5IGNvbW1hbmQgbm90IGZvdW5kIGhhbmRsaW5nXG4gICAgICBleHBlY3QocmVzdWx0LmV4aXRDb2RlKS50b0JlKDEyNyk7XG4gICAgICBleHBlY3QocmVzdWx0LnN1Z2dlc3Rpb24pLnRvQ29udGFpbignZGVwbG95Jyk7XG4gICAgICBleHBlY3QocmVzdWx0LnJldHJ5YWJsZSkudG9CZShmYWxzZSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdsb2dnaW5nIGludGVncmF0aW9uIGJlaGF2aW9yJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgbG9nIGVycm9ycyB3aGVuIGxvZ2dpbmcgaXMgZW5hYmxlZCBpbiBkZWZhdWx0cycsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIEFycmFuZ2VcbiAgICAgIGVycm9ySGFuZGxlci5zZXREZWZhdWx0cyh7IGxvZ0Vycm9yczogdHJ1ZSwgdmVyYm9zZUVycm9yczogdHJ1ZSB9KTtcbiAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKCdUZXN0IGVycm9yIHdpdGggc3RhY2snKTtcbiAgICAgIGNvbnN0IGNvbnRleHQ6IEVycm9yQ29udGV4dCA9IHtcbiAgICAgICAgY29tbWFuZDogJ3Rlc3QnLFxuICAgICAgICBzZXZlcml0eTogJ2hpZ2gnXG4gICAgICB9O1xuXG4gICAgICBtb2NrSGFuZGxlRnVuY3Rpb24ubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBoYW5kbGVkOiB0cnVlLFxuICAgICAgICByZWNvdmVyZWQ6IGZhbHNlLFxuICAgICAgICBleGl0Q29kZTogMSxcbiAgICAgICAgbWVzc2FnZTogJ0Vycm9yIGxvZ2dlZCcsXG4gICAgICAgIHJldHJ5YWJsZTogZmFsc2UsXG4gICAgICAgIGxvZ2dlZDogdHJ1ZVxuICAgICAgfSk7XG5cbiAgICAgIC8vIEFjdFxuICAgICAgYXdhaXQgZXJyb3JIYW5kbGVyLmhhbmRsZShlcnJvciwgY29udGV4dCk7XG5cbiAgICAgIC8vIEFzc2VydCAtIHZlcmlmeSBsb2dnaW5nIGJlaGF2aW9yIHdvdWxkIGJlIGNhbGxlZFxuICAgICAgLy8gSW4gYSByZWFsIGltcGxlbWVudGF0aW9uLCB0aGlzIHdvdWxkIHZlcmlmeSBsb2dnZXIuZXJyb3Igd2FzIGNhbGxlZFxuICAgICAgZXhwZWN0KG1vY2tIYW5kbGVGdW5jdGlvbikudG9IYXZlQmVlbkNhbGxlZFdpdGgoZXJyb3IsIGNvbnRleHQpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZXNwZWN0IGxvZ2dpbmcgY29uZmlndXJhdGlvbiBmb3IgZGlmZmVyZW50IHNldmVyaXR5IGxldmVscycsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIEFycmFuZ2VcbiAgICAgIGNvbnN0IGxvd1NldmVyaXR5RXJyb3IgPSBuZXcgRXJyb3IoJ0xvdyBzZXZlcml0eScpO1xuICAgICAgY29uc3QgaGlnaFNldmVyaXR5RXJyb3IgPSBuZXcgRXJyb3IoJ0hpZ2ggc2V2ZXJpdHknKTtcblxuICAgICAgY29uc3QgbG93Q29udGV4dDogRXJyb3JDb250ZXh0ID0geyBzZXZlcml0eTogJ2xvdycgfTtcbiAgICAgIGNvbnN0IGhpZ2hDb250ZXh0OiBFcnJvckNvbnRleHQgPSB7IHNldmVyaXR5OiAnY3JpdGljYWwnIH07XG5cbiAgICAgIG1vY2tIYW5kbGVGdW5jdGlvblxuICAgICAgICAubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAgICBoYW5kbGVkOiB0cnVlLFxuICAgICAgICAgIHJlY292ZXJlZDogdHJ1ZSxcbiAgICAgICAgICBleGl0Q29kZTogMCxcbiAgICAgICAgICBtZXNzYWdlOiAnTG93IHNldmVyaXR5IGhhbmRsZWQgcXVpZXRseScsXG4gICAgICAgICAgcmV0cnlhYmxlOiBmYWxzZSxcbiAgICAgICAgICBsb2dnZWQ6IGZhbHNlIC8vIExvdyBzZXZlcml0eSBtaWdodCBub3QgYmUgbG9nZ2VkXG4gICAgICAgIH0pXG4gICAgICAgIC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICAgIGhhbmRsZWQ6IHRydWUsXG4gICAgICAgICAgcmVjb3ZlcmVkOiBmYWxzZSxcbiAgICAgICAgICBleGl0Q29kZTogMSxcbiAgICAgICAgICBtZXNzYWdlOiAnQ3JpdGljYWwgZXJyb3IgbG9nZ2VkJyxcbiAgICAgICAgICByZXRyeWFibGU6IGZhbHNlLFxuICAgICAgICAgIGxvZ2dlZDogdHJ1ZSAvLyBDcml0aWNhbCBlcnJvcnMgYWx3YXlzIGxvZ2dlZFxuICAgICAgICB9KTtcblxuICAgICAgLy8gQWN0XG4gICAgICBjb25zdCBsb3dSZXN1bHQgPSBhd2FpdCBlcnJvckhhbmRsZXIuaGFuZGxlKGxvd1NldmVyaXR5RXJyb3IsIGxvd0NvbnRleHQpO1xuICAgICAgY29uc3QgaGlnaFJlc3VsdCA9IGF3YWl0IGVycm9ySGFuZGxlci5oYW5kbGUoaGlnaFNldmVyaXR5RXJyb3IsIGhpZ2hDb250ZXh0KTtcblxuICAgICAgLy8gQXNzZXJ0IC0gdmVyaWZ5IHNldmVyaXR5LWJhc2VkIGxvZ2dpbmcgYmVoYXZpb3JcbiAgICAgIGV4cGVjdChsb3dSZXN1bHQubG9nZ2VkKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdChoaWdoUmVzdWx0LmxvZ2dlZCkudG9CZSh0cnVlKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ2NvbnRleHQtYXdhcmUgZXJyb3IgaGFuZGxpbmcgYmVoYXZpb3InLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCB1c2UgY29udGV4dCBpbmZvcm1hdGlvbiB0byBlbmhhbmNlIGVycm9yIG1lc3NhZ2VzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gQXJyYW5nZVxuICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoJ0ZpbGUgbm90IGZvdW5kJyk7XG4gICAgICBjb25zdCBjb250ZXh0OiBFcnJvckNvbnRleHQgPSB7XG4gICAgICAgIGNvbW1hbmQ6ICdkZXBsb3knLFxuICAgICAgICBhcmdzOiBbJ21pc3NpbmctYXBwJ10sXG4gICAgICAgIGZsYWdzOiB7IGVudjogJ3Byb2R1Y3Rpb24nIH0sXG4gICAgICAgIHVzZXI6ICdkZXZlbG9wZXInLFxuICAgICAgICBzZXNzaW9uOiAnc2Vzc2lvbi0xMjMnXG4gICAgICB9O1xuXG4gICAgICBtb2NrSGFuZGxlRnVuY3Rpb24ubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBoYW5kbGVkOiB0cnVlLFxuICAgICAgICByZWNvdmVyZWQ6IGZhbHNlLFxuICAgICAgICBleGl0Q29kZTogMSxcbiAgICAgICAgbWVzc2FnZTogXCJGaWxlICdtaXNzaW5nLWFwcCcgbm90IGZvdW5kIGZvciBwcm9kdWN0aW9uIGRlcGxveW1lbnRcIixcbiAgICAgICAgc3VnZ2VzdGlvbjogJ0NoZWNrIGlmIHRoZSBhcHBsaWNhdGlvbiBuYW1lIGlzIGNvcnJlY3QnLFxuICAgICAgICByZXRyeWFibGU6IHRydWUsXG4gICAgICAgIGxvZ2dlZDogdHJ1ZVxuICAgICAgfSk7XG5cbiAgICAgIC8vIEFjdFxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZXJyb3JIYW5kbGVyLmhhbmRsZShlcnJvciwgY29udGV4dCk7XG5cbiAgICAgIC8vIEFzc2VydCAtIHZlcmlmeSBjb250ZXh0LWF3YXJlIGhhbmRsaW5nXG4gICAgICBleHBlY3QobW9ja0hhbmRsZUZ1bmN0aW9uKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChlcnJvciwgY29udGV4dCk7XG4gICAgICBleHBlY3QocmVzdWx0Lm1lc3NhZ2UpLnRvQ29udGFpbignbWlzc2luZy1hcHAnKTtcbiAgICAgIGV4cGVjdChyZXN1bHQubWVzc2FnZSkudG9Db250YWluKCdwcm9kdWN0aW9uJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBlcnJvcnMgZGlmZmVyZW50bHkgYmFzZWQgb24gdXNlciBwZXJtaXNzaW9ucycsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIEFycmFuZ2VcbiAgICAgIGNvbnN0IHBlcm1pc3Npb25FcnJvciA9IG5ldyBFcnJvcignQWNjZXNzIGRlbmllZCcpO1xuICAgICAgY29uc3QgYWRtaW5Db250ZXh0OiBFcnJvckNvbnRleHQgPSB7IHVzZXI6ICdhZG1pbicsIGNvbW1hbmQ6ICdzeXN0ZW0tY29uZmlnJyB9O1xuICAgICAgY29uc3QgdXNlckNvbnRleHQ6IEVycm9yQ29udGV4dCA9IHsgdXNlcjogJ3VzZXInLCBjb21tYW5kOiAnc3lzdGVtLWNvbmZpZycgfTtcblxuICAgICAgbW9ja0hhbmRsZUZ1bmN0aW9uXG4gICAgICAgIC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICAgIGhhbmRsZWQ6IHRydWUsXG4gICAgICAgICAgcmVjb3ZlcmVkOiBmYWxzZSxcbiAgICAgICAgICBleGl0Q29kZTogMSxcbiAgICAgICAgICBtZXNzYWdlOiAnQWNjZXNzIGRlbmllZDogaW5zdWZmaWNpZW50IHByaXZpbGVnZXMnLFxuICAgICAgICAgIHN1Z2dlc3Rpb246ICdDb250YWN0IHlvdXIgYWRtaW5pc3RyYXRvcicsXG4gICAgICAgICAgcmV0cnlhYmxlOiBmYWxzZSxcbiAgICAgICAgICBsb2dnZWQ6IHRydWVcbiAgICAgICAgfSlcbiAgICAgICAgLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7XG4gICAgICAgICAgaGFuZGxlZDogdHJ1ZSxcbiAgICAgICAgICByZWNvdmVyZWQ6IGZhbHNlLFxuICAgICAgICAgIGV4aXRDb2RlOiAxLFxuICAgICAgICAgIG1lc3NhZ2U6ICdUaGlzIGNvbW1hbmQgcmVxdWlyZXMgYWRtaW5pc3RyYXRvciBwcml2aWxlZ2VzJyxcbiAgICAgICAgICBzdWdnZXN0aW9uOiAnVHJ5IHVzaW5nIHN1ZG8gb3IgY29udGFjdCBzdXBwb3J0JyxcbiAgICAgICAgICByZXRyeWFibGU6IGZhbHNlLFxuICAgICAgICAgIGxvZ2dlZDogZmFsc2VcbiAgICAgICAgfSk7XG5cbiAgICAgIC8vIEFjdFxuICAgICAgYXdhaXQgZXJyb3JIYW5kbGVyLmhhbmRsZShwZXJtaXNzaW9uRXJyb3IsIGFkbWluQ29udGV4dCk7XG4gICAgICBhd2FpdCBlcnJvckhhbmRsZXIuaGFuZGxlKHBlcm1pc3Npb25FcnJvciwgdXNlckNvbnRleHQpO1xuXG4gICAgICAvLyBBc3NlcnQgLSB2ZXJpZnkgdXNlci1hd2FyZSBoYW5kbGluZ1xuICAgICAgZXhwZWN0KG1vY2tIYW5kbGVGdW5jdGlvbikudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDIpO1xuICAgICAgZXhwZWN0KG1vY2tIYW5kbGVGdW5jdGlvbikudG9IYXZlQmVlbkNhbGxlZFdpdGgocGVybWlzc2lvbkVycm9yLCBhZG1pbkNvbnRleHQpO1xuICAgICAgZXhwZWN0KG1vY2tIYW5kbGVGdW5jdGlvbikudG9IYXZlQmVlbkNhbGxlZFdpdGgocGVybWlzc2lvbkVycm9yLCB1c2VyQ29udGV4dCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdlcnJvciBtZXRyaWNzIGFuZCByZXBvcnRpbmcgYmVoYXZpb3InLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBwcm92aWRlIGNvbXByZWhlbnNpdmUgZXJyb3IgbWV0cmljcycsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIEFycmFuZ2VcbiAgICAgIGNvbnN0IGVycm9ycyA9IFtcbiAgICAgICAgbmV3IFZhbGlkYXRpb25FcnJvcignRmllbGQgcmVxdWlyZWQnKSxcbiAgICAgICAgbmV3IE5ldHdvcmtFcnJvcignVGltZW91dCcpLFxuICAgICAgICBuZXcgVmFsaWRhdGlvbkVycm9yKCdJbnZhbGlkIGZvcm1hdCcpLFxuICAgICAgICBuZXcgRXJyb3IoJ0dlbmVyaWMgZXJyb3InKVxuICAgICAgXTtcblxuICAgICAgbW9ja0hhbmRsZUZ1bmN0aW9uLm1vY2tJbXBsZW1lbnRhdGlvbihhc3luYyAoKSA9PiB7XG4gICAgICAgIC8vIEFkZCBzbWFsbCBkZWxheSB0byBzaW11bGF0ZSBwcm9jZXNzaW5nIHRpbWVcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDEpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBoYW5kbGVkOiB0cnVlLFxuICAgICAgICAgIHJlY292ZXJlZDogZmFsc2UsXG4gICAgICAgICAgZXhpdENvZGU6IDEsXG4gICAgICAgICAgbWVzc2FnZTogJ0Vycm9yIGhhbmRsZWQnLFxuICAgICAgICAgIHJldHJ5YWJsZTogZmFsc2UsXG4gICAgICAgICAgbG9nZ2VkOiB0cnVlXG4gICAgICAgIH07XG4gICAgICB9KTtcblxuICAgICAgLy8gQWN0XG4gICAgICBmb3IgKGNvbnN0IGVycm9yIG9mIGVycm9ycykge1xuICAgICAgICBhd2FpdCBlcnJvckhhbmRsZXIuaGFuZGxlKGVycm9yKTtcbiAgICAgIH1cblxuICAgICAgLy8gQXNzZXJ0IC0gdmVyaWZ5IGNvbXByZWhlbnNpdmUgbWV0cmljc1xuICAgICAgY29uc3QgbWV0cmljcyA9IGVycm9ySGFuZGxlci5nZXRNZXRyaWNzKCk7XG4gICAgICBleHBlY3QobWV0cmljcy50b3RhbEVycm9ycykudG9CZSg0KTtcbiAgICAgIGV4cGVjdChtZXRyaWNzLmVycm9yc0J5VHlwZSkudG9FcXVhbCh7XG4gICAgICAgIFZhbGlkYXRpb25FcnJvcjogMixcbiAgICAgICAgTmV0d29ya0Vycm9yOiAxLFxuICAgICAgICBFcnJvcjogMVxuICAgICAgfSk7XG4gICAgICBleHBlY3QobWV0cmljcy5hdmVyYWdlSGFuZGxpbmdUaW1lKS50b0JlR3JlYXRlclRoYW4oMCk7XG4gICAgfSk7XG4gIH0pO1xufSk7Il0sInZlcnNpb24iOjN9