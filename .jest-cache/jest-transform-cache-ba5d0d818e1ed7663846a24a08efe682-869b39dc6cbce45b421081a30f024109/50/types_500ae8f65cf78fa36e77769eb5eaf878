972297dceacb59ab01556fdfc03261a1
/* istanbul ignore next */
function cov_1ut1s5klmn() {
  var path = "/home/mhugo/code/claude-code-flow/src/__tests__/helpers/types.ts";
  var hash = "29f7ea45c45223a7131bf9a18e1787c35683dff2";
  var global = new Function("return this")();
  var gcv = "__coverage__";
  var coverageData = {
    path: "/home/mhugo/code/claude-code-flow/src/__tests__/helpers/types.ts",
    statementMap: {},
    fnMap: {},
    branchMap: {},
    s: {},
    f: {},
    b: {},
    inputSourceMap: {
      file: "/home/mhugo/code/claude-code-flow/src/__tests__/helpers/types.ts",
      mappings: "AAAA;;GAEG",
      names: [],
      sources: ["/home/mhugo/code/claude-code-flow/src/__tests__/helpers/types.ts"],
      sourcesContent: ["/**\n * Type definitions for test helper utilities\n */\n\nexport interface MockConfiguration {\n  /** Mock strategy: 'strict' for London School, 'minimal' for Classical */\n  strategy: 'strict' | 'minimal' | 'hybrid';\n  /** Auto-generate return values based on method signatures */\n  autoGenerate?: boolean;\n  /** Track all method calls for interaction verification */\n  trackInteractions?: boolean;\n  /** Reset mocks between tests automatically */\n  autoReset?: boolean;\n}\n\nexport interface TestDataOptions {\n  /** Seed for reproducible random data generation */\n  seed?: number;\n  /** Size constraints for generated data */\n  size?: {\n    min?: number;\n    max?: number;\n    default?: number;\n  };\n  /** Data validation rules */\n  validation?: {\n    required?: string[];\n    optional?: string[];\n    constraints?: Record<string, any>;\n  };\n}\n\nexport interface PerformanceTestOptions {\n  /** Number of iterations for performance tests */\n  iterations?: number;\n  /** Warm-up iterations before measurement */\n  warmup?: number;\n  /** Maximum acceptable execution time (ms) */\n  maxExecutionTime?: number;\n  /** Memory usage thresholds */\n  memoryThresholds?: {\n    heap?: number;\n    external?: number;\n  };\n  /** Statistical analysis options */\n  statistics?: {\n    percentiles?: number[];\n    includeVariance?: boolean;\n    includeDeviation?: boolean;\n  };\n}\n\nexport interface IntegrationTestConfig {\n  /** Test environment setup */\n  environment?: {\n    database?: 'memory' | 'sqlite' | 'postgres';\n    filesystem?: 'mock' | 'temp' | 'real';\n    network?: 'mock' | 'localhost' | 'integration';\n  };\n  /** Service dependencies to start */\n  services?: string[];\n  /** Cleanup strategy */\n  cleanup?: 'aggressive' | 'conservative' | 'manual';\n  /** Timeout for integration operations */\n  timeout?: number;\n}\n\nexport interface AssertionOptions {\n  /** Precision for floating point comparisons */\n  precision?: number;\n  /** Tolerance for performance assertions */\n  tolerance?: number;\n  /** Custom error messages */\n  messages?: Record<string, string>;\n  /** Retry configuration for flaky assertions */\n  retry?: {\n    attempts?: number;\n    delay?: number;\n    backoff?: 'linear' | 'exponential';\n  };\n}\n\n// Mock object types\nexport interface MockObject {\n  [key: string]: jest.Mock | MockObject;\n}\n\nexport interface MockBuilder {\n  create<T>(type: new (...args: any[]) => T, config?: MockConfiguration): T;\n  createPartial<T>(overrides: Partial<T>): T;\n  createSpy<T extends object>(obj: T, methods?: (keyof T)[]): T;\n}\n\n// Test data types\nexport interface UserTestData {\n  id: string;\n  name: string;\n  email: string;\n  preferences?: Record<string, any>;\n  metadata?: Record<string, any>;\n}\n\nexport interface ProjectTestData {\n  name: string;\n  path: string;\n  type: 'typescript' | 'javascript' | 'python' | 'rust';\n  structure: Record<string, any>;\n  dependencies?: string[];\n}\n\nexport interface SwarmTestData {\n  id: string;\n  topology: 'mesh' | 'hierarchical' | 'ring' | 'star';\n  agents: AgentTestData[];\n  configuration: Record<string, any>;\n}\n\nexport interface AgentTestData {\n  id: string;\n  type: 'researcher' | 'coder' | 'analyst' | 'tester' | 'coordinator';\n  capabilities: string[];\n  state: 'idle' | 'working' | 'error' | 'completed';\n}\n\n// Performance measurement types\nexport interface PerformanceMetrics {\n  executionTime: number;\n  memoryUsage: {\n    heap: number;\n    external: number;\n    total: number;\n  };\n  cpuUsage?: number;\n  throughput?: number;\n  statistics?: {\n    mean: number;\n    median: number;\n    p95: number;\n    p99: number;\n    variance: number;\n    standardDeviation: number;\n  };\n}\n\n// Integration test types\nexport interface DatabaseTestHelper {\n  setup(): Promise<void>;\n  cleanup(): Promise<void>;\n  seed(data: any[]): Promise<void>;\n  reset(): Promise<void>;\n  getConnection(): any;\n}\n\nexport interface FileSystemTestHelper {\n  createTempDir(): Promise<string>;\n  createFile(path: string, content: string): Promise<void>;\n  cleanup(): Promise<void>;\n  mockFileSystem(): void;\n  restoreFileSystem(): void;\n}\n\nexport interface NetworkTestHelper {\n  startMockServer(port?: number): Promise<void>;\n  stopMockServer(): Promise<void>;\n  mockRequest(path: string, response: any): void;\n  captureRequests(): any[];\n  clearRequests(): void;\n}"],
      version: 3
    },
    _coverageSchema: "1a1c01bbd47fc00a2c39e90264f33305004495a9",
    hash: "29f7ea45c45223a7131bf9a18e1787c35683dff2"
  };
  var coverage = global[gcv] || (global[gcv] = {});
  if (!coverage[path] || coverage[path].hash !== hash) {
    coverage[path] = coverageData;
  }
  var actualCoverage = coverage[path];
  {
    // @ts-ignore
    cov_1ut1s5klmn = function () {
      return actualCoverage;
    };
  }
  return actualCoverage;
}
cov_1ut1s5klmn();
/**
 * Type definitions for test helper utilities
 */
export {};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiL2hvbWUvbWh1Z28vY29kZS9jbGF1ZGUtY29kZS1mbG93L3NyYy9fX3Rlc3RzX18vaGVscGVycy90eXBlcy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFR5cGUgZGVmaW5pdGlvbnMgZm9yIHRlc3QgaGVscGVyIHV0aWxpdGllc1xuICovXG5cbmV4cG9ydCBpbnRlcmZhY2UgTW9ja0NvbmZpZ3VyYXRpb24ge1xuICAvKiogTW9jayBzdHJhdGVneTogJ3N0cmljdCcgZm9yIExvbmRvbiBTY2hvb2wsICdtaW5pbWFsJyBmb3IgQ2xhc3NpY2FsICovXG4gIHN0cmF0ZWd5OiAnc3RyaWN0JyB8ICdtaW5pbWFsJyB8ICdoeWJyaWQnO1xuICAvKiogQXV0by1nZW5lcmF0ZSByZXR1cm4gdmFsdWVzIGJhc2VkIG9uIG1ldGhvZCBzaWduYXR1cmVzICovXG4gIGF1dG9HZW5lcmF0ZT86IGJvb2xlYW47XG4gIC8qKiBUcmFjayBhbGwgbWV0aG9kIGNhbGxzIGZvciBpbnRlcmFjdGlvbiB2ZXJpZmljYXRpb24gKi9cbiAgdHJhY2tJbnRlcmFjdGlvbnM/OiBib29sZWFuO1xuICAvKiogUmVzZXQgbW9ja3MgYmV0d2VlbiB0ZXN0cyBhdXRvbWF0aWNhbGx5ICovXG4gIGF1dG9SZXNldD86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVGVzdERhdGFPcHRpb25zIHtcbiAgLyoqIFNlZWQgZm9yIHJlcHJvZHVjaWJsZSByYW5kb20gZGF0YSBnZW5lcmF0aW9uICovXG4gIHNlZWQ/OiBudW1iZXI7XG4gIC8qKiBTaXplIGNvbnN0cmFpbnRzIGZvciBnZW5lcmF0ZWQgZGF0YSAqL1xuICBzaXplPzoge1xuICAgIG1pbj86IG51bWJlcjtcbiAgICBtYXg/OiBudW1iZXI7XG4gICAgZGVmYXVsdD86IG51bWJlcjtcbiAgfTtcbiAgLyoqIERhdGEgdmFsaWRhdGlvbiBydWxlcyAqL1xuICB2YWxpZGF0aW9uPzoge1xuICAgIHJlcXVpcmVkPzogc3RyaW5nW107XG4gICAgb3B0aW9uYWw/OiBzdHJpbmdbXTtcbiAgICBjb25zdHJhaW50cz86IFJlY29yZDxzdHJpbmcsIGFueT47XG4gIH07XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUGVyZm9ybWFuY2VUZXN0T3B0aW9ucyB7XG4gIC8qKiBOdW1iZXIgb2YgaXRlcmF0aW9ucyBmb3IgcGVyZm9ybWFuY2UgdGVzdHMgKi9cbiAgaXRlcmF0aW9ucz86IG51bWJlcjtcbiAgLyoqIFdhcm0tdXAgaXRlcmF0aW9ucyBiZWZvcmUgbWVhc3VyZW1lbnQgKi9cbiAgd2FybXVwPzogbnVtYmVyO1xuICAvKiogTWF4aW11bSBhY2NlcHRhYmxlIGV4ZWN1dGlvbiB0aW1lIChtcykgKi9cbiAgbWF4RXhlY3V0aW9uVGltZT86IG51bWJlcjtcbiAgLyoqIE1lbW9yeSB1c2FnZSB0aHJlc2hvbGRzICovXG4gIG1lbW9yeVRocmVzaG9sZHM/OiB7XG4gICAgaGVhcD86IG51bWJlcjtcbiAgICBleHRlcm5hbD86IG51bWJlcjtcbiAgfTtcbiAgLyoqIFN0YXRpc3RpY2FsIGFuYWx5c2lzIG9wdGlvbnMgKi9cbiAgc3RhdGlzdGljcz86IHtcbiAgICBwZXJjZW50aWxlcz86IG51bWJlcltdO1xuICAgIGluY2x1ZGVWYXJpYW5jZT86IGJvb2xlYW47XG4gICAgaW5jbHVkZURldmlhdGlvbj86IGJvb2xlYW47XG4gIH07XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSW50ZWdyYXRpb25UZXN0Q29uZmlnIHtcbiAgLyoqIFRlc3QgZW52aXJvbm1lbnQgc2V0dXAgKi9cbiAgZW52aXJvbm1lbnQ/OiB7XG4gICAgZGF0YWJhc2U/OiAnbWVtb3J5JyB8ICdzcWxpdGUnIHwgJ3Bvc3RncmVzJztcbiAgICBmaWxlc3lzdGVtPzogJ21vY2snIHwgJ3RlbXAnIHwgJ3JlYWwnO1xuICAgIG5ldHdvcms/OiAnbW9jaycgfCAnbG9jYWxob3N0JyB8ICdpbnRlZ3JhdGlvbic7XG4gIH07XG4gIC8qKiBTZXJ2aWNlIGRlcGVuZGVuY2llcyB0byBzdGFydCAqL1xuICBzZXJ2aWNlcz86IHN0cmluZ1tdO1xuICAvKiogQ2xlYW51cCBzdHJhdGVneSAqL1xuICBjbGVhbnVwPzogJ2FnZ3Jlc3NpdmUnIHwgJ2NvbnNlcnZhdGl2ZScgfCAnbWFudWFsJztcbiAgLyoqIFRpbWVvdXQgZm9yIGludGVncmF0aW9uIG9wZXJhdGlvbnMgKi9cbiAgdGltZW91dD86IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBBc3NlcnRpb25PcHRpb25zIHtcbiAgLyoqIFByZWNpc2lvbiBmb3IgZmxvYXRpbmcgcG9pbnQgY29tcGFyaXNvbnMgKi9cbiAgcHJlY2lzaW9uPzogbnVtYmVyO1xuICAvKiogVG9sZXJhbmNlIGZvciBwZXJmb3JtYW5jZSBhc3NlcnRpb25zICovXG4gIHRvbGVyYW5jZT86IG51bWJlcjtcbiAgLyoqIEN1c3RvbSBlcnJvciBtZXNzYWdlcyAqL1xuICBtZXNzYWdlcz86IFJlY29yZDxzdHJpbmcsIHN0cmluZz47XG4gIC8qKiBSZXRyeSBjb25maWd1cmF0aW9uIGZvciBmbGFreSBhc3NlcnRpb25zICovXG4gIHJldHJ5Pzoge1xuICAgIGF0dGVtcHRzPzogbnVtYmVyO1xuICAgIGRlbGF5PzogbnVtYmVyO1xuICAgIGJhY2tvZmY/OiAnbGluZWFyJyB8ICdleHBvbmVudGlhbCc7XG4gIH07XG59XG5cbi8vIE1vY2sgb2JqZWN0IHR5cGVzXG5leHBvcnQgaW50ZXJmYWNlIE1vY2tPYmplY3Qge1xuICBba2V5OiBzdHJpbmddOiBqZXN0Lk1vY2sgfCBNb2NrT2JqZWN0O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE1vY2tCdWlsZGVyIHtcbiAgY3JlYXRlPFQ+KHR5cGU6IG5ldyAoLi4uYXJnczogYW55W10pID0+IFQsIGNvbmZpZz86IE1vY2tDb25maWd1cmF0aW9uKTogVDtcbiAgY3JlYXRlUGFydGlhbDxUPihvdmVycmlkZXM6IFBhcnRpYWw8VD4pOiBUO1xuICBjcmVhdGVTcHk8VCBleHRlbmRzIG9iamVjdD4ob2JqOiBULCBtZXRob2RzPzogKGtleW9mIFQpW10pOiBUO1xufVxuXG4vLyBUZXN0IGRhdGEgdHlwZXNcbmV4cG9ydCBpbnRlcmZhY2UgVXNlclRlc3REYXRhIHtcbiAgaWQ6IHN0cmluZztcbiAgbmFtZTogc3RyaW5nO1xuICBlbWFpbDogc3RyaW5nO1xuICBwcmVmZXJlbmNlcz86IFJlY29yZDxzdHJpbmcsIGFueT47XG4gIG1ldGFkYXRhPzogUmVjb3JkPHN0cmluZywgYW55Pjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQcm9qZWN0VGVzdERhdGEge1xuICBuYW1lOiBzdHJpbmc7XG4gIHBhdGg6IHN0cmluZztcbiAgdHlwZTogJ3R5cGVzY3JpcHQnIHwgJ2phdmFzY3JpcHQnIHwgJ3B5dGhvbicgfCAncnVzdCc7XG4gIHN0cnVjdHVyZTogUmVjb3JkPHN0cmluZywgYW55PjtcbiAgZGVwZW5kZW5jaWVzPzogc3RyaW5nW107XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU3dhcm1UZXN0RGF0YSB7XG4gIGlkOiBzdHJpbmc7XG4gIHRvcG9sb2d5OiAnbWVzaCcgfCAnaGllcmFyY2hpY2FsJyB8ICdyaW5nJyB8ICdzdGFyJztcbiAgYWdlbnRzOiBBZ2VudFRlc3REYXRhW107XG4gIGNvbmZpZ3VyYXRpb246IFJlY29yZDxzdHJpbmcsIGFueT47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQWdlbnRUZXN0RGF0YSB7XG4gIGlkOiBzdHJpbmc7XG4gIHR5cGU6ICdyZXNlYXJjaGVyJyB8ICdjb2RlcicgfCAnYW5hbHlzdCcgfCAndGVzdGVyJyB8ICdjb29yZGluYXRvcic7XG4gIGNhcGFiaWxpdGllczogc3RyaW5nW107XG4gIHN0YXRlOiAnaWRsZScgfCAnd29ya2luZycgfCAnZXJyb3InIHwgJ2NvbXBsZXRlZCc7XG59XG5cbi8vIFBlcmZvcm1hbmNlIG1lYXN1cmVtZW50IHR5cGVzXG5leHBvcnQgaW50ZXJmYWNlIFBlcmZvcm1hbmNlTWV0cmljcyB7XG4gIGV4ZWN1dGlvblRpbWU6IG51bWJlcjtcbiAgbWVtb3J5VXNhZ2U6IHtcbiAgICBoZWFwOiBudW1iZXI7XG4gICAgZXh0ZXJuYWw6IG51bWJlcjtcbiAgICB0b3RhbDogbnVtYmVyO1xuICB9O1xuICBjcHVVc2FnZT86IG51bWJlcjtcbiAgdGhyb3VnaHB1dD86IG51bWJlcjtcbiAgc3RhdGlzdGljcz86IHtcbiAgICBtZWFuOiBudW1iZXI7XG4gICAgbWVkaWFuOiBudW1iZXI7XG4gICAgcDk1OiBudW1iZXI7XG4gICAgcDk5OiBudW1iZXI7XG4gICAgdmFyaWFuY2U6IG51bWJlcjtcbiAgICBzdGFuZGFyZERldmlhdGlvbjogbnVtYmVyO1xuICB9O1xufVxuXG4vLyBJbnRlZ3JhdGlvbiB0ZXN0IHR5cGVzXG5leHBvcnQgaW50ZXJmYWNlIERhdGFiYXNlVGVzdEhlbHBlciB7XG4gIHNldHVwKCk6IFByb21pc2U8dm9pZD47XG4gIGNsZWFudXAoKTogUHJvbWlzZTx2b2lkPjtcbiAgc2VlZChkYXRhOiBhbnlbXSk6IFByb21pc2U8dm9pZD47XG4gIHJlc2V0KCk6IFByb21pc2U8dm9pZD47XG4gIGdldENvbm5lY3Rpb24oKTogYW55O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEZpbGVTeXN0ZW1UZXN0SGVscGVyIHtcbiAgY3JlYXRlVGVtcERpcigpOiBQcm9taXNlPHN0cmluZz47XG4gIGNyZWF0ZUZpbGUocGF0aDogc3RyaW5nLCBjb250ZW50OiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+O1xuICBjbGVhbnVwKCk6IFByb21pc2U8dm9pZD47XG4gIG1vY2tGaWxlU3lzdGVtKCk6IHZvaWQ7XG4gIHJlc3RvcmVGaWxlU3lzdGVtKCk6IHZvaWQ7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTmV0d29ya1Rlc3RIZWxwZXIge1xuICBzdGFydE1vY2tTZXJ2ZXIocG9ydD86IG51bWJlcik6IFByb21pc2U8dm9pZD47XG4gIHN0b3BNb2NrU2VydmVyKCk6IFByb21pc2U8dm9pZD47XG4gIG1vY2tSZXF1ZXN0KHBhdGg6IHN0cmluZywgcmVzcG9uc2U6IGFueSk6IHZvaWQ7XG4gIGNhcHR1cmVSZXF1ZXN0cygpOiBhbnlbXTtcbiAgY2xlYXJSZXF1ZXN0cygpOiB2b2lkO1xufSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEiLCJpZ25vcmVMaXN0IjpbXX0=