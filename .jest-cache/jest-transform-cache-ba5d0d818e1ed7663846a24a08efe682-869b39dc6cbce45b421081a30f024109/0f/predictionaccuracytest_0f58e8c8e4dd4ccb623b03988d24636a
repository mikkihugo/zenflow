343cf3e3516d300d4d22c177a0a29299
/**
 * Classical TDD (Detroit School) - Prediction Accuracy Tests
 *
 * Focus: Test actual prediction results and mathematical accuracy
 * No mocks - verify real predictions on known datasets and mathematical functions
 */
import { describe, it, expect, beforeEach } from '@jest/globals';
import { initializeNeuralWasm, createNeuralNetwork, createTrainer, ACTIVATION_FUNCTIONS, TRAINING_ALGORITHMS } from '../../../../../ruv-FANN-zen/ruv-swarm-zen/npm/src/neural-network';
describe('Prediction Accuracy - Classical TDD', () => {
    let wasmModule;
    beforeEach(async () => {
        try {
            wasmModule = await initializeNeuralWasm();
        }
        catch (error) {
            console.warn('WASM module not available, skipping prediction accuracy tests');
        }
    });
    describe('Boolean Function Accuracy', () => {
        it('should achieve perfect accuracy on AND function', async () => {
            if (!wasmModule) {
                console.warn('WASM not available, skipping test');
                expect(true).toBe(true);
                return;
            }
            const networkConfig = {
                inputSize: 2,
                hiddenLayers: [{ size: 3, activation: ACTIVATION_FUNCTIONS.SIGMOID }],
                outputSize: 1,
                outputActivation: ACTIVATION_FUNCTIONS.SIGMOID,
                randomSeed: 101
            };
            const trainingConfig = {
                algorithm: TRAINING_ALGORITHMS.RPROP,
                maxEpochs: 500,
                targetError: 0.01
            };
            const andData = {
                inputs: [[0, 0], [0, 1], [1, 0], [1, 1]],
                outputs: [[0], [0], [0], [1]]
            };
            const network = await createNeuralNetwork(networkConfig);
            const trainer = await createTrainer(trainingConfig);
            network.setTrainingData(andData);
            await trainer.trainUntilTarget(network, andData, 0.01, 500);
            // Test prediction accuracy
            const predictions = [
                { input: [0, 0], expected: 0, name: '0 AND 0' },
                { input: [0, 1], expected: 0, name: '0 AND 1' },
                { input: [1, 0], expected: 0, name: '1 AND 0' },
                { input: [1, 1], expected: 1, name: '1 AND 1' }
            ];
            let correctPredictions = 0;
            for (const test of predictions) {
                const result = await network.run(test.input);
                const predicted = result[0] > 0.5 ? 1 : 0;
                expect(predicted).toBe(test.expected);
                if (predicted === test.expected)
                    correctPredictions++;
            }
            // Should achieve 100% accuracy
            expect(correctPredictions).toBe(4);
        });
        it('should achieve perfect accuracy on OR function', async () => {
            if (!wasmModule) {
                console.warn('WASM not available, skipping test');
                expect(true).toBe(true);
                return;
            }
            const networkConfig = {
                inputSize: 2,
                hiddenLayers: [{ size: 3, activation: ACTIVATION_FUNCTIONS.SIGMOID }],
                outputSize: 1,
                outputActivation: ACTIVATION_FUNCTIONS.SIGMOID,
                randomSeed: 202
            };
            const trainingConfig = {
                algorithm: TRAINING_ALGORITHMS.RPROP,
                maxEpochs: 300,
                targetError: 0.01
            };
            const orData = {
                inputs: [[0, 0], [0, 1], [1, 0], [1, 1]],
                outputs: [[0], [1], [1], [1]]
            };
            const network = await createNeuralNetwork(networkConfig);
            const trainer = await createTrainer(trainingConfig);
            network.setTrainingData(orData);
            await trainer.trainUntilTarget(network, orData, 0.01, 300);
            // Test prediction accuracy
            const predictions = [
                { input: [0, 0], expected: 0, name: '0 OR 0' },
                { input: [0, 1], expected: 1, name: '0 OR 1' },
                { input: [1, 0], expected: 1, name: '1 OR 0' },
                { input: [1, 1], expected: 1, name: '1 OR 1' }
            ];
            let correctPredictions = 0;
            for (const test of predictions) {
                const result = await network.run(test.input);
                const predicted = result[0] > 0.5 ? 1 : 0;
                expect(predicted).toBe(test.expected);
                if (predicted === test.expected)
                    correctPredictions++;
            }
            expect(correctPredictions).toBe(4);
        });
        it('should achieve high accuracy on XOR function with adequate architecture', async () => {
            if (!wasmModule) {
                console.warn('WASM not available, skipping test');
                expect(true).toBe(true);
                return;
            }
            const networkConfig = {
                inputSize: 2,
                hiddenLayers: [{ size: 4, activation: ACTIVATION_FUNCTIONS.SIGMOID }],
                outputSize: 1,
                outputActivation: ACTIVATION_FUNCTIONS.SIGMOID,
                randomSeed: 303
            };
            const trainingConfig = {
                algorithm: TRAINING_ALGORITHMS.RPROP,
                maxEpochs: 1000,
                targetError: 0.01
            };
            const xorData = {
                inputs: [[0, 0], [0, 1], [1, 0], [1, 1]],
                outputs: [[0], [1], [1], [0]]
            };
            const network = await createNeuralNetwork(networkConfig);
            const trainer = await createTrainer(trainingConfig);
            network.setTrainingData(xorData);
            const result = await trainer.trainUntilTarget(network, xorData, 0.01, 1000);
            // XOR is more complex, but should still achieve good accuracy
            expect(result.finalError).toBeLessThan(0.05);
            const predictions = [
                { input: [0, 0], expected: 0, name: '0 XOR 0' },
                { input: [0, 1], expected: 1, name: '0 XOR 1' },
                { input: [1, 0], expected: 1, name: '1 XOR 0' },
                { input: [1, 1], expected: 0, name: '1 XOR 1' }
            ];
            let correctPredictions = 0;
            for (const test of predictions) {
                const networkResult = await network.run(test.input);
                const predicted = networkResult[0] > 0.5 ? 1 : 0;
                if (predicted === test.expected)
                    correctPredictions++;
            }
            // Should achieve at least 75% accuracy, ideally 100%
            expect(correctPredictions).toBeGreaterThanOrEqual(3);
        });
    });
    describe('Mathematical Function Approximation', () => {
        it('should accurately approximate quadratic function', async () => {
            if (!wasmModule) {
                console.warn('WASM not available, skipping test');
                expect(true).toBe(true);
                return;
            }
            const networkConfig = {
                inputSize: 1,
                hiddenLayers: [
                    { size: 6, activation: ACTIVATION_FUNCTIONS.SIGMOID },
                    { size: 4, activation: ACTIVATION_FUNCTIONS.SIGMOID }
                ],
                outputSize: 1,
                outputActivation: ACTIVATION_FUNCTIONS.LINEAR
            };
            const trainingConfig = {
                algorithm: TRAINING_ALGORITHMS.RPROP,
                maxEpochs: 800,
                targetError: 0.05
            };
            // Quadratic function: y = x^2
            const quadraticData = {
                inputs: [],
                outputs: []
            };
            for (let i = 0; i <= 10; i++) {
                const x = i / 10; // 0 to 1
                const y = x * x;
                quadraticData.inputs.push([x]);
                quadraticData.outputs.push([y]);
            }
            const network = await createNeuralNetwork(networkConfig);
            const trainer = await createTrainer(trainingConfig);
            network.setTrainingData(quadraticData);
            await trainer.trainUntilTarget(network, quadraticData, 0.05, 800);
            // Test prediction accuracy on known quadratic values
            const testPoints = [
                { x: 0.0, expected: 0.0 },
                { x: 0.5, expected: 0.25 },
                { x: 0.7, expected: 0.49 },
                { x: 1.0, expected: 1.0 }
            ];
            for (const point of testPoints) {
                const prediction = await network.run([point.x]);
                expect(prediction[0]).toBeCloseTo(point.expected, 1);
            }
            // Test interpolation accuracy
            const interpolationTests = [
                { x: 0.25, expected: 0.0625 },
                { x: 0.75, expected: 0.5625 }
            ];
            for (const test of interpolationTests) {
                const prediction = await network.run([test.x]);
                expect(prediction[0]).toBeCloseTo(test.expected, 1);
            }
        });
        it('should accurately approximate trigonometric functions', async () => {
            if (!wasmModule) {
                console.warn('WASM not available, skipping test');
                expect(true).toBe(true);
                return;
            }
            const networkConfig = {
                inputSize: 1,
                hiddenLayers: [
                    { size: 10, activation: ACTIVATION_FUNCTIONS.TANH },
                    { size: 8, activation: ACTIVATION_FUNCTIONS.TANH }
                ],
                outputSize: 1,
                outputActivation: ACTIVATION_FUNCTIONS.LINEAR
            };
            const trainingConfig = {
                algorithm: TRAINING_ALGORITHMS.RPROP,
                maxEpochs: 1200,
                targetError: 0.1
            };
            // Cosine function over [0, 2π]
            const cosineData = {
                inputs: [],
                outputs: []
            };
            for (let i = 0; i <= 16; i++) {
                const x = (i / 16) * 2 * Math.PI;
                const normalizedX = x / (2 * Math.PI); // Normalize to [0,1]
                const y = Math.cos(x);
                cosineData.inputs.push([normalizedX]);
                cosineData.outputs.push([y]);
            }
            const network = await createNeuralNetwork(networkConfig);
            const trainer = await createTrainer(trainingConfig);
            network.setTrainingData(cosineData);
            await trainer.trainUntilTarget(network, cosineData, 0.1, 1200);
            // Test key cosine values
            const testPoints = [
                { x: 0, expected: 1 }, // cos(0) = 1
                { x: 0.25, expected: 0 }, // cos(π/2) ≈ 0
                { x: 0.5, expected: -1 }, // cos(π) = -1
                { x: 0.75, expected: 0 }, // cos(3π/2) ≈ 0
                { x: 1, expected: 1 } // cos(2π) = 1
            ];
            for (const point of testPoints) {
                const prediction = await network.run([point.x]);
                expect(prediction[0]).toBeCloseTo(point.expected, 0.5);
            }
        });
    });
    describe('Pattern Recognition Accuracy', () => {
        it('should classify simple 2D patterns with high accuracy', async () => {
            if (!wasmModule) {
                console.warn('WASM not available, skipping test');
                expect(true).toBe(true);
                return;
            }
            const networkConfig = {
                inputSize: 2,
                hiddenLayers: [
                    { size: 8, activation: ACTIVATION_FUNCTIONS.SIGMOID }
                ],
                outputSize: 2,
                outputActivation: ACTIVATION_FUNCTIONS.SIGMOID
            };
            const trainingConfig = {
                algorithm: TRAINING_ALGORITHMS.RPROP,
                maxEpochs: 600,
                targetError: 0.1
            };
            // Two classes: left half vs right half of unit square
            const patternData = {
                inputs: [
                    // Left half (Class 0)
                    [0.1, 0.1], [0.1, 0.5], [0.1, 0.9],
                    [0.2, 0.2], [0.2, 0.7], [0.3, 0.4],
                    [0.4, 0.1], [0.4, 0.6], [0.4, 0.9],
                    // Right half (Class 1)
                    [0.6, 0.1], [0.6, 0.5], [0.6, 0.9],
                    [0.7, 0.2], [0.7, 0.7], [0.8, 0.4],
                    [0.9, 0.1], [0.9, 0.6], [0.9, 0.9]
                ],
                outputs: [
                    // Class 0 (left)
                    [1, 0], [1, 0], [1, 0],
                    [1, 0], [1, 0], [1, 0],
                    [1, 0], [1, 0], [1, 0],
                    // Class 1 (right)
                    [0, 1], [0, 1], [0, 1],
                    [0, 1], [0, 1], [0, 1],
                    [0, 1], [0, 1], [0, 1]
                ]
            };
            const network = await createNeuralNetwork(networkConfig);
            const trainer = await createTrainer(trainingConfig);
            network.setTrainingData(patternData);
            await trainer.trainUntilTarget(network, patternData, 0.1, 600);
            // Test classification accuracy on new points
            const testPoints = [
                { input: [0.15, 0.5], expectedClass: 0, name: 'left side' },
                { input: [0.25, 0.3], expectedClass: 0, name: 'left side' },
                { input: [0.35, 0.8], expectedClass: 0, name: 'left side' },
                { input: [0.65, 0.2], expectedClass: 1, name: 'right side' },
                { input: [0.75, 0.6], expectedClass: 1, name: 'right side' },
                { input: [0.85, 0.4], expectedClass: 1, name: 'right side' }
            ];
            let correctClassifications = 0;
            for (const test of testPoints) {
                const prediction = await network.run(test.input);
                const predictedClass = prediction[0] > prediction[1] ? 0 : 1;
                if (predictedClass === test.expectedClass) {
                    correctClassifications++;
                }
            }
            // Should achieve at least 80% accuracy
            const accuracy = correctClassifications / testPoints.length;
            expect(accuracy).toBeGreaterThanOrEqual(0.8);
        });
        it('should distinguish concentric circular patterns', async () => {
            if (!wasmModule) {
                console.warn('WASM not available, skipping test');
                expect(true).toBe(true);
                return;
            }
            const networkConfig = {
                inputSize: 2,
                hiddenLayers: [
                    { size: 12, activation: ACTIVATION_FUNCTIONS.TANH },
                    { size: 8, activation: ACTIVATION_FUNCTIONS.TANH }
                ],
                outputSize: 2,
                outputActivation: ACTIVATION_FUNCTIONS.SIGMOID
            };
            const trainingConfig = {
                algorithm: TRAINING_ALGORITHMS.RPROP,
                maxEpochs: 1000,
                targetError: 0.15
            };
            // Generate circular pattern data
            const circularData = {
                inputs: [],
                outputs: []
            };
            // Inner circle (radius < 0.3) - Class 0
            // Outer ring (0.5 < radius < 0.8) - Class 1
            for (let i = 0; i < 60; i++) {
                const angle = (i / 60) * 2 * Math.PI;
                // Inner circle points
                const innerRadius = 0.1 + Math.random() * 0.2; // radius 0.1-0.3
                const innerX = 0.5 + innerRadius * Math.cos(angle);
                const innerY = 0.5 + innerRadius * Math.sin(angle);
                circularData.inputs.push([innerX, innerY]);
                circularData.outputs.push([1, 0]); // Class 0
                // Outer ring points
                const outerRadius = 0.5 + Math.random() * 0.3; // radius 0.5-0.8
                const outerX = 0.5 + outerRadius * Math.cos(angle);
                const outerY = 0.5 + outerRadius * Math.sin(angle);
                circularData.inputs.push([outerX, outerY]);
                circularData.outputs.push([0, 1]); // Class 1
            }
            const network = await createNeuralNetwork(networkConfig);
            const trainer = await createTrainer(trainingConfig);
            network.setTrainingData(circularData);
            await trainer.trainUntilTarget(network, circularData, 0.15, 1000);
            // Test classification on specific points
            const testPoints = [
                { input: [0.5, 0.5], expectedClass: 0, name: 'center' },
                { input: [0.6, 0.5], expectedClass: 0, name: 'inner circle' },
                { input: [0.5, 0.4], expectedClass: 0, name: 'inner circle' },
                { input: [0.8, 0.5], expectedClass: 1, name: 'outer ring' },
                { input: [0.5, 0.2], expectedClass: 1, name: 'outer ring' },
                { input: [0.2, 0.5], expectedClass: 1, name: 'outer ring' }
            ];
            let correctClassifications = 0;
            for (const test of testPoints) {
                const prediction = await network.run(test.input);
                const predictedClass = prediction[0] > prediction[1] ? 0 : 1;
                if (predictedClass === test.expectedClass) {
                    correctClassifications++;
                }
            }
            // This is a challenging pattern, expect at least 50% accuracy
            const accuracy = correctClassifications / testPoints.length;
            expect(accuracy).toBeGreaterThanOrEqual(0.5);
        });
    });
    describe('Generalization Accuracy', () => {
        it('should generalize to unseen data points', async () => {
            if (!wasmModule) {
                console.warn('WASM not available, skipping test');
                expect(true).toBe(true);
                return;
            }
            const networkConfig = {
                inputSize: 1,
                hiddenLayers: [
                    { size: 6, activation: ACTIVATION_FUNCTIONS.SIGMOID }
                ],
                outputSize: 1,
                outputActivation: ACTIVATION_FUNCTIONS.LINEAR
            };
            const trainingConfig = {
                algorithm: TRAINING_ALGORITHMS.RPROP,
                maxEpochs: 400,
                targetError: 0.05
            };
            // Train on subset of linear function y = 3x + 1
            const trainingData = {
                inputs: [[0.1], [0.3], [0.5], [0.7], [0.9]], // Skip some points
                outputs: [[1.3], [1.9], [2.5], [3.1], [3.7]]
            };
            const network = await createNeuralNetwork(networkConfig);
            const trainer = await createTrainer(trainingConfig);
            network.setTrainingData(trainingData);
            await trainer.trainUntilTarget(network, trainingData, 0.05, 400);
            // Test generalization on unseen points
            const testPoints = [
                { input: 0.0, expected: 1.0 }, // y = 3*0 + 1 = 1
                { input: 0.2, expected: 1.6 }, // y = 3*0.2 + 1 = 1.6
                { input: 0.4, expected: 2.2 }, // y = 3*0.4 + 1 = 2.2
                { input: 0.6, expected: 2.8 }, // y = 3*0.6 + 1 = 2.8
                { input: 0.8, expected: 3.4 }, // y = 3*0.8 + 1 = 3.4
                { input: 1.0, expected: 4.0 } // y = 3*1 + 1 = 4 (extrapolation)
            ];
            let accurateGeneralizations = 0;
            for (const test of testPoints) {
                const prediction = await network.run([test.input]);
                const error = Math.abs(prediction[0] - test.expected);
                if (error < 0.3) { // Allow 10% error for generalization
                    accurateGeneralizations++;
                }
            }
            // Should achieve good generalization on most points
            const generalizationRate = accurateGeneralizations / testPoints.length;
            expect(generalizationRate).toBeGreaterThanOrEqual(0.7);
        });
    });
    describe('Prediction Consistency', () => {
        it('should produce consistent predictions across multiple runs', async () => {
            if (!wasmModule) {
                console.warn('WASM not available, skipping test');
                expect(true).toBe(true);
                return;
            }
            const networkConfig = {
                inputSize: 2,
                hiddenLayers: [{ size: 4, activation: ACTIVATION_FUNCTIONS.SIGMOID }],
                outputSize: 1,
                outputActivation: ACTIVATION_FUNCTIONS.SIGMOID,
                randomSeed: 999 // Fixed seed for reproducibility
            };
            const network = await createNeuralNetwork(networkConfig);
            const testInput = [0.6, 0.4];
            const predictions = [];
            // Run multiple predictions
            for (let i = 0; i < 10; i++) {
                const result = await network.run(testInput);
                predictions.push(result[0]);
            }
            // All predictions should be identical (no randomness in inference)
            const firstPrediction = predictions[0];
            for (const prediction of predictions) {
                expect(prediction).toBeCloseTo(firstPrediction, 10);
            }
            // Verify predictions are valid
            expect(predictions.every(p => isFinite(p))).toBe(true);
            expect(predictions.every(p => p >= 0 && p <= 1)).toBe(true);
        });
    });
});
/**
 * Classical TDD Principles Demonstrated:
 *
 * 1. No mocks - testing actual prediction accuracy on real data
 * 2. Mathematical correctness validation through known functions
 * 3. Pattern recognition accuracy measurement
 * 4. Generalization capability testing on unseen data
 * 5. Consistency verification across multiple runs
 * 6. Statistical accuracy metrics and thresholds
 *
 * This is ideal for:
 * - Neural network accuracy validation
 * - Function approximation verification
 * - Pattern recognition testing
 * - Generalization capability assessment
 * - Prediction consistency validation
 */ 
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL2hvbWUvbWh1Z28vY29kZS9jbGF1ZGUtY29kZS1mbG93L3NyYy9fX3Rlc3RzX18vdW5pdC9jbGFzc2ljYWwvbmV1cmFsLWFsZ29yaXRobXMvcHJlZGljdGlvbi1hY2N1cmFjeS50ZXN0LnRzIiwibWFwcGluZ3MiOiJBQUFBOzs7OztHQUtHO0FBRUgsT0FBTyxFQUFFLFFBQVEsRUFBRSxFQUFFLEVBQUUsTUFBTSxFQUFFLFVBQVUsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUNqRSxPQUFPLEVBQ0wsb0JBQW9CLEVBQ3BCLG1CQUFtQixFQUNuQixhQUFhLEVBTWIsb0JBQW9CLEVBQ3BCLG1CQUFtQixFQUNwQixNQUFNLGtFQUFrRSxDQUFDO0FBRTFFLFFBQVEsQ0FBQyxxQ0FBcUMsRUFBRSxHQUFHLEVBQUU7SUFDbkQsSUFBSSxVQUFlLENBQUM7SUFFcEIsVUFBVSxDQUFDLEtBQUssSUFBSSxFQUFFO1FBQ3BCLElBQUksQ0FBQztZQUNILFVBQVUsR0FBRyxNQUFNLG9CQUFvQixFQUFFLENBQUM7UUFDNUMsQ0FBQztRQUFDLE9BQU8sS0FBSyxFQUFFLENBQUM7WUFDZixPQUFPLENBQUMsSUFBSSxDQUFDLCtEQUErRCxDQUFDLENBQUM7UUFDaEYsQ0FBQztJQUNILENBQUMsQ0FBQyxDQUFDO0lBRUgsUUFBUSxDQUFDLDJCQUEyQixFQUFFLEdBQUcsRUFBRTtRQUN6QyxFQUFFLENBQUMsaURBQWlELEVBQUUsS0FBSyxJQUFJLEVBQUU7WUFDL0QsSUFBSSxDQUFDLFVBQVUsRUFBRSxDQUFDO2dCQUNoQixPQUFPLENBQUMsSUFBSSxDQUFDLG1DQUFtQyxDQUFDLENBQUM7Z0JBQ2xELE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7Z0JBQ3hCLE9BQU87WUFDVCxDQUFDO1lBRUQsTUFBTSxhQUFhLEdBQWtCO2dCQUNuQyxTQUFTLEVBQUUsQ0FBQztnQkFDWixZQUFZLEVBQUUsQ0FBQyxFQUFFLElBQUksRUFBRSxDQUFDLEVBQUUsVUFBVSxFQUFFLG9CQUFv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WyIvaG9tZS9taHVnby9jb2RlL2NsYXVkZS1jb2RlLWZsb3cvc3JjL19fdGVzdHNfXy91bml0L2NsYXNzaWNhbC9uZXVyYWwtYWxnb3JpdGhtcy9wcmVkaWN0aW9uLWFjY3VyYWN5LnRlc3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDbGFzc2ljYWwgVEREIChEZXRyb2l0IFNjaG9vbCkgLSBQcmVkaWN0aW9uIEFjY3VyYWN5IFRlc3RzXG4gKiBcbiAqIEZvY3VzOiBUZXN0IGFjdHVhbCBwcmVkaWN0aW9uIHJlc3VsdHMgYW5kIG1hdGhlbWF0aWNhbCBhY2N1cmFjeVxuICogTm8gbW9ja3MgLSB2ZXJpZnkgcmVhbCBwcmVkaWN0aW9ucyBvbiBrbm93biBkYXRhc2V0cyBhbmQgbWF0aGVtYXRpY2FsIGZ1bmN0aW9uc1xuICovXG5cbmltcG9ydCB7IGRlc2NyaWJlLCBpdCwgZXhwZWN0LCBiZWZvcmVFYWNoIH0gZnJvbSAnQGplc3QvZ2xvYmFscyc7XG5pbXBvcnQgeyBcbiAgaW5pdGlhbGl6ZU5ldXJhbFdhc20sIFxuICBjcmVhdGVOZXVyYWxOZXR3b3JrLCBcbiAgY3JlYXRlVHJhaW5lcixcbiAgTmV1cmFsTmV0d29yayxcbiAgTmV1cmFsVHJhaW5lcixcbiAgTmV0d29ya0NvbmZpZyxcbiAgVHJhaW5pbmdDb25maWcsXG4gIFRyYWluaW5nRGF0YUNvbmZpZyxcbiAgQUNUSVZBVElPTl9GVU5DVElPTlMsXG4gIFRSQUlOSU5HX0FMR09SSVRITVNcbn0gZnJvbSAnLi4vLi4vLi4vLi4vLi4vcnV2LUZBTk4temVuL3J1di1zd2FybS16ZW4vbnBtL3NyYy9uZXVyYWwtbmV0d29yayc7XG5cbmRlc2NyaWJlKCdQcmVkaWN0aW9uIEFjY3VyYWN5IC0gQ2xhc3NpY2FsIFRERCcsICgpID0+IHtcbiAgbGV0IHdhc21Nb2R1bGU6IGFueTtcbiAgXG4gIGJlZm9yZUVhY2goYXN5bmMgKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICB3YXNtTW9kdWxlID0gYXdhaXQgaW5pdGlhbGl6ZU5ldXJhbFdhc20oKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS53YXJuKCdXQVNNIG1vZHVsZSBub3QgYXZhaWxhYmxlLCBza2lwcGluZyBwcmVkaWN0aW9uIGFjY3VyYWN5IHRlc3RzJyk7XG4gICAgfVxuICB9KTtcblxuICBkZXNjcmliZSgnQm9vbGVhbiBGdW5jdGlvbiBBY2N1cmFjeScsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGFjaGlldmUgcGVyZmVjdCBhY2N1cmFjeSBvbiBBTkQgZnVuY3Rpb24nLCBhc3luYyAoKSA9PiB7XG4gICAgICBpZiAoIXdhc21Nb2R1bGUpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdXQVNNIG5vdCBhdmFpbGFibGUsIHNraXBwaW5nIHRlc3QnKTtcbiAgICAgICAgZXhwZWN0KHRydWUpLnRvQmUodHJ1ZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbmV0d29ya0NvbmZpZzogTmV0d29ya0NvbmZpZyA9IHtcbiAgICAgICAgaW5wdXRTaXplOiAyLFxuICAgICAgICBoaWRkZW5MYXllcnM6IFt7IHNpemU6IDMsIGFjdGl2YXRpb246IEFDVElWQVRJT05fRlVOQ1RJT05TLlNJR01PSUQgfV0sXG4gICAgICAgIG91dHB1dFNpemU6IDEsXG4gICAgICAgIG91dHB1dEFjdGl2YXRpb246IEFDVElWQVRJT05fRlVOQ1RJT05TLlNJR01PSUQsXG4gICAgICAgIHJhbmRvbVNlZWQ6IDEwMVxuICAgICAgfTtcblxuICAgICAgY29uc3QgdHJhaW5pbmdDb25maWc6IFRyYWluaW5nQ29uZmlnID0ge1xuICAgICAgICBhbGdvcml0aG06IFRSQUlOSU5HX0FMR09SSVRITVMuUlBST1AsXG4gICAgICAgIG1heEVwb2NoczogNTAwLFxuICAgICAgICB0YXJnZXRFcnJvcjogMC4wMVxuICAgICAgfTtcblxuICAgICAgY29uc3QgYW5kRGF0YTogVHJhaW5pbmdEYXRhQ29uZmlnID0ge1xuICAgICAgICBpbnB1dHM6IFtbMCwgMF0sIFswLCAxXSwgWzEsIDBdLCBbMSwgMV1dLFxuICAgICAgICBvdXRwdXRzOiBbWzBdLCBbMF0sIFswXSwgWzFdXVxuICAgICAgfTtcblxuICAgICAgY29uc3QgbmV0d29yayA9IGF3YWl0IGNyZWF0ZU5ldXJhbE5ldHdvcmsobmV0d29ya0NvbmZpZyk7XG4gICAgICBjb25zdCB0cmFpbmVyID0gYXdhaXQgY3JlYXRlVHJhaW5lcih0cmFpbmluZ0NvbmZpZyk7XG4gICAgICBcbiAgICAgIG5ldHdvcmsuc2V0VHJhaW5pbmdEYXRhKGFuZERhdGEpO1xuICAgICAgYXdhaXQgdHJhaW5lci50cmFpblVudGlsVGFyZ2V0KG5ldHdvcmssIGFuZERhdGEsIDAuMDEsIDUwMCk7XG5cbiAgICAgIC8vIFRlc3QgcHJlZGljdGlvbiBhY2N1cmFjeVxuICAgICAgY29uc3QgcHJlZGljdGlvbnMgPSBbXG4gICAgICAgIHsgaW5wdXQ6IFswLCAwXSwgZXhwZWN0ZWQ6IDAsIG5hbWU6ICcwIEFORCAwJyB9LFxuICAgICAgICB7IGlucHV0OiBbMCwgMV0sIGV4cGVjdGVkOiAwLCBuYW1lOiAnMCBBTkQgMScgfSxcbiAgICAgICAgeyBpbnB1dDogWzEsIDBdLCBleHBlY3RlZDogMCwgbmFtZTogJzEgQU5EIDAnIH0sXG4gICAgICAgIHsgaW5wdXQ6IFsxLCAxXSwgZXhwZWN0ZWQ6IDEsIG5hbWU6ICcxIEFORCAxJyB9XG4gICAgICBdO1xuXG4gICAgICBsZXQgY29ycmVjdFByZWRpY3Rpb25zID0gMDtcbiAgICAgIGZvciAoY29uc3QgdGVzdCBvZiBwcmVkaWN0aW9ucykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBuZXR3b3JrLnJ1bih0ZXN0LmlucHV0KTtcbiAgICAgICAgY29uc3QgcHJlZGljdGVkID0gcmVzdWx0WzBdID4gMC41ID8gMSA6IDA7XG4gICAgICAgIFxuICAgICAgICBleHBlY3QocHJlZGljdGVkKS50b0JlKHRlc3QuZXhwZWN0ZWQpO1xuICAgICAgICBpZiAocHJlZGljdGVkID09PSB0ZXN0LmV4cGVjdGVkKSBjb3JyZWN0UHJlZGljdGlvbnMrKztcbiAgICAgIH1cblxuICAgICAgLy8gU2hvdWxkIGFjaGlldmUgMTAwJSBhY2N1cmFjeVxuICAgICAgZXhwZWN0KGNvcnJlY3RQcmVkaWN0aW9ucykudG9CZSg0KTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgYWNoaWV2ZSBwZXJmZWN0IGFjY3VyYWN5IG9uIE9SIGZ1bmN0aW9uJywgYXN5bmMgKCkgPT4ge1xuICAgICAgaWYgKCF3YXNtTW9kdWxlKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignV0FTTSBub3QgYXZhaWxhYmxlLCBza2lwcGluZyB0ZXN0Jyk7XG4gICAgICAgIGV4cGVjdCh0cnVlKS50b0JlKHRydWUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG5ldHdvcmtDb25maWc6IE5ldHdvcmtDb25maWcgPSB7XG4gICAgICAgIGlucHV0U2l6ZTogMixcbiAgICAgICAgaGlkZGVuTGF5ZXJzOiBbeyBzaXplOiAzLCBhY3RpdmF0aW9uOiBBQ1RJVkFUSU9OX0ZVTkNUSU9OUy5TSUdNT0lEIH1dLFxuICAgICAgICBvdXRwdXRTaXplOiAxLFxuICAgICAgICBvdXRwdXRBY3RpdmF0aW9uOiBBQ1RJVkFUSU9OX0ZVTkNUSU9OUy5TSUdNT0lELFxuICAgICAgICByYW5kb21TZWVkOiAyMDJcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHRyYWluaW5nQ29uZmlnOiBUcmFpbmluZ0NvbmZpZyA9IHtcbiAgICAgICAgYWxnb3JpdGhtOiBUUkFJTklOR19BTEdPUklUSE1TLlJQUk9QLFxuICAgICAgICBtYXhFcG9jaHM6IDMwMCxcbiAgICAgICAgdGFyZ2V0RXJyb3I6IDAuMDFcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IG9yRGF0YTogVHJhaW5pbmdEYXRhQ29uZmlnID0ge1xuICAgICAgICBpbnB1dHM6IFtbMCwgMF0sIFswLCAxXSwgWzEsIDBdLCBbMSwgMV1dLFxuICAgICAgICBvdXRwdXRzOiBbWzBdLCBbMV0sIFsxXSwgWzFdXVxuICAgICAgfTtcblxuICAgICAgY29uc3QgbmV0d29yayA9IGF3YWl0IGNyZWF0ZU5ldXJhbE5ldHdvcmsobmV0d29ya0NvbmZpZyk7XG4gICAgICBjb25zdCB0cmFpbmVyID0gYXdhaXQgY3JlYXRlVHJhaW5lcih0cmFpbmluZ0NvbmZpZyk7XG4gICAgICBcbiAgICAgIG5ldHdvcmsuc2V0VHJhaW5pbmdEYXRhKG9yRGF0YSk7XG4gICAgICBhd2FpdCB0cmFpbmVyLnRyYWluVW50aWxUYXJnZXQobmV0d29yaywgb3JEYXRhLCAwLjAxLCAzMDApO1xuXG4gICAgICAvLyBUZXN0IHByZWRpY3Rpb24gYWNjdXJhY3lcbiAgICAgIGNvbnN0IHByZWRpY3Rpb25zID0gW1xuICAgICAgICB7IGlucHV0OiBbMCwgMF0sIGV4cGVjdGVkOiAwLCBuYW1lOiAnMCBPUiAwJyB9LFxuICAgICAgICB7IGlucHV0OiBbMCwgMV0sIGV4cGVjdGVkOiAxLCBuYW1lOiAnMCBPUiAxJyB9LFxuICAgICAgICB7IGlucHV0OiBbMSwgMF0sIGV4cGVjdGVkOiAxLCBuYW1lOiAnMSBPUiAwJyB9LFxuICAgICAgICB7IGlucHV0OiBbMSwgMV0sIGV4cGVjdGVkOiAxLCBuYW1lOiAnMSBPUiAxJyB9XG4gICAgICBdO1xuXG4gICAgICBsZXQgY29ycmVjdFByZWRpY3Rpb25zID0gMDtcbiAgICAgIGZvciAoY29uc3QgdGVzdCBvZiBwcmVkaWN0aW9ucykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBuZXR3b3JrLnJ1bih0ZXN0LmlucHV0KTtcbiAgICAgICAgY29uc3QgcHJlZGljdGVkID0gcmVzdWx0WzBdID4gMC41ID8gMSA6IDA7XG4gICAgICAgIFxuICAgICAgICBleHBlY3QocHJlZGljdGVkKS50b0JlKHRlc3QuZXhwZWN0ZWQpO1xuICAgICAgICBpZiAocHJlZGljdGVkID09PSB0ZXN0LmV4cGVjdGVkKSBjb3JyZWN0UHJlZGljdGlvbnMrKztcbiAgICAgIH1cblxuICAgICAgZXhwZWN0KGNvcnJlY3RQcmVkaWN0aW9ucykudG9CZSg0KTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgYWNoaWV2ZSBoaWdoIGFjY3VyYWN5IG9uIFhPUiBmdW5jdGlvbiB3aXRoIGFkZXF1YXRlIGFyY2hpdGVjdHVyZScsIGFzeW5jICgpID0+IHtcbiAgICAgIGlmICghd2FzbU1vZHVsZSkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1dBU00gbm90IGF2YWlsYWJsZSwgc2tpcHBpbmcgdGVzdCcpO1xuICAgICAgICBleHBlY3QodHJ1ZSkudG9CZSh0cnVlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBuZXR3b3JrQ29uZmlnOiBOZXR3b3JrQ29uZmlnID0ge1xuICAgICAgICBpbnB1dFNpemU6IDIsXG4gICAgICAgIGhpZGRlbkxheWVyczogW3sgc2l6ZTogNCwgYWN0aXZhdGlvbjogQUNUSVZBVElPTl9GVU5DVElPTlMuU0lHTU9JRCB9XSxcbiAgICAgICAgb3V0cHV0U2l6ZTogMSxcbiAgICAgICAgb3V0cHV0QWN0aXZhdGlvbjogQUNUSVZBVElPTl9GVU5DVElPTlMuU0lHTU9JRCxcbiAgICAgICAgcmFuZG9tU2VlZDogMzAzXG4gICAgICB9O1xuXG4gICAgICBjb25zdCB0cmFpbmluZ0NvbmZpZzogVHJhaW5pbmdDb25maWcgPSB7XG4gICAgICAgIGFsZ29yaXRobTogVFJBSU5JTkdfQUxHT1JJVEhNUy5SUFJPUCxcbiAgICAgICAgbWF4RXBvY2hzOiAxMDAwLFxuICAgICAgICB0YXJnZXRFcnJvcjogMC4wMVxuICAgICAgfTtcblxuICAgICAgY29uc3QgeG9yRGF0YTogVHJhaW5pbmdEYXRhQ29uZmlnID0ge1xuICAgICAgICBpbnB1dHM6IFtbMCwgMF0sIFswLCAxXSwgWzEsIDBdLCBbMSwgMV1dLFxuICAgICAgICBvdXRwdXRzOiBbWzBdLCBbMV0sIFsxXSwgWzBdXVxuICAgICAgfTtcblxuICAgICAgY29uc3QgbmV0d29yayA9IGF3YWl0IGNyZWF0ZU5ldXJhbE5ldHdvcmsobmV0d29ya0NvbmZpZyk7XG4gICAgICBjb25zdCB0cmFpbmVyID0gYXdhaXQgY3JlYXRlVHJhaW5lcih0cmFpbmluZ0NvbmZpZyk7XG4gICAgICBcbiAgICAgIG5ldHdvcmsuc2V0VHJhaW5pbmdEYXRhKHhvckRhdGEpO1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdHJhaW5lci50cmFpblVudGlsVGFyZ2V0KG5ldHdvcmssIHhvckRhdGEsIDAuMDEsIDEwMDApO1xuXG4gICAgICAvLyBYT1IgaXMgbW9yZSBjb21wbGV4LCBidXQgc2hvdWxkIHN0aWxsIGFjaGlldmUgZ29vZCBhY2N1cmFjeVxuICAgICAgZXhwZWN0KHJlc3VsdC5maW5hbEVycm9yKS50b0JlTGVzc1RoYW4oMC4wNSk7XG5cbiAgICAgIGNvbnN0IHByZWRpY3Rpb25zID0gW1xuICAgICAgICB7IGlucHV0OiBbMCwgMF0sIGV4cGVjdGVkOiAwLCBuYW1lOiAnMCBYT1IgMCcgfSxcbiAgICAgICAgeyBpbnB1dDogWzAsIDFdLCBleHBlY3RlZDogMSwgbmFtZTogJzAgWE9SIDEnIH0sXG4gICAgICAgIHsgaW5wdXQ6IFsxLCAwXSwgZXhwZWN0ZWQ6IDEsIG5hbWU6ICcxIFhPUiAwJyB9LFxuICAgICAgICB7IGlucHV0OiBbMSwgMV0sIGV4cGVjdGVkOiAwLCBuYW1lOiAnMSBYT1IgMScgfVxuICAgICAgXTtcblxuICAgICAgbGV0IGNvcnJlY3RQcmVkaWN0aW9ucyA9IDA7XG4gICAgICBmb3IgKGNvbnN0IHRlc3Qgb2YgcHJlZGljdGlvbnMpIHtcbiAgICAgICAgY29uc3QgbmV0d29ya1Jlc3VsdCA9IGF3YWl0IG5ldHdvcmsucnVuKHRlc3QuaW5wdXQpO1xuICAgICAgICBjb25zdCBwcmVkaWN0ZWQgPSBuZXR3b3JrUmVzdWx0WzBdID4gMC41ID8gMSA6IDA7XG4gICAgICAgIFxuICAgICAgICBpZiAocHJlZGljdGVkID09PSB0ZXN0LmV4cGVjdGVkKSBjb3JyZWN0UHJlZGljdGlvbnMrKztcbiAgICAgIH1cblxuICAgICAgLy8gU2hvdWxkIGFjaGlldmUgYXQgbGVhc3QgNzUlIGFjY3VyYWN5LCBpZGVhbGx5IDEwMCVcbiAgICAgIGV4cGVjdChjb3JyZWN0UHJlZGljdGlvbnMpLnRvQmVHcmVhdGVyVGhhbk9yRXF1YWwoMyk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdNYXRoZW1hdGljYWwgRnVuY3Rpb24gQXBwcm94aW1hdGlvbicsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGFjY3VyYXRlbHkgYXBwcm94aW1hdGUgcXVhZHJhdGljIGZ1bmN0aW9uJywgYXN5bmMgKCkgPT4ge1xuICAgICAgaWYgKCF3YXNtTW9kdWxlKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignV0FTTSBub3QgYXZhaWxhYmxlLCBza2lwcGluZyB0ZXN0Jyk7XG4gICAgICAgIGV4cGVjdCh0cnVlKS50b0JlKHRydWUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG5ldHdvcmtDb25maWc6IE5ldHdvcmtDb25maWcgPSB7XG4gICAgICAgIGlucHV0U2l6ZTogMSxcbiAgICAgICAgaGlkZGVuTGF5ZXJzOiBbXG4gICAgICAgICAgeyBzaXplOiA2LCBhY3RpdmF0aW9uOiBBQ1RJVkFUSU9OX0ZVTkNUSU9OUy5TSUdNT0lEIH0sXG4gICAgICAgICAgeyBzaXplOiA0LCBhY3RpdmF0aW9uOiBBQ1RJVkFUSU9OX0ZVTkNUSU9OUy5TSUdNT0lEIH1cbiAgICAgICAgXSxcbiAgICAgICAgb3V0cHV0U2l6ZTogMSxcbiAgICAgICAgb3V0cHV0QWN0aXZhdGlvbjogQUNUSVZBVElPTl9GVU5DVElPTlMuTElORUFSXG4gICAgICB9O1xuXG4gICAgICBjb25zdCB0cmFpbmluZ0NvbmZpZzogVHJhaW5pbmdDb25maWcgPSB7XG4gICAgICAgIGFsZ29yaXRobTogVFJBSU5JTkdfQUxHT1JJVEhNUy5SUFJPUCxcbiAgICAgICAgbWF4RXBvY2hzOiA4MDAsXG4gICAgICAgIHRhcmdldEVycm9yOiAwLjA1XG4gICAgICB9O1xuXG4gICAgICAvLyBRdWFkcmF0aWMgZnVuY3Rpb246IHkgPSB4XjJcbiAgICAgIGNvbnN0IHF1YWRyYXRpY0RhdGE6IFRyYWluaW5nRGF0YUNvbmZpZyA9IHtcbiAgICAgICAgaW5wdXRzOiBbXSxcbiAgICAgICAgb3V0cHV0czogW11cbiAgICAgIH07XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IDEwOyBpKyspIHtcbiAgICAgICAgY29uc3QgeCA9IGkgLyAxMDsgLy8gMCB0byAxXG4gICAgICAgIGNvbnN0IHkgPSB4ICogeDtcbiAgICAgICAgcXVhZHJhdGljRGF0YS5pbnB1dHMucHVzaChbeF0pO1xuICAgICAgICBxdWFkcmF0aWNEYXRhLm91dHB1dHMucHVzaChbeV0pO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBuZXR3b3JrID0gYXdhaXQgY3JlYXRlTmV1cmFsTmV0d29yayhuZXR3b3JrQ29uZmlnKTtcbiAgICAgIGNvbnN0IHRyYWluZXIgPSBhd2FpdCBjcmVhdGVUcmFpbmVyKHRyYWluaW5nQ29uZmlnKTtcbiAgICAgIFxuICAgICAgbmV0d29yay5zZXRUcmFpbmluZ0RhdGEocXVhZHJhdGljRGF0YSk7XG4gICAgICBhd2FpdCB0cmFpbmVyLnRyYWluVW50aWxUYXJnZXQobmV0d29yaywgcXVhZHJhdGljRGF0YSwgMC4wNSwgODAwKTtcblxuICAgICAgLy8gVGVzdCBwcmVkaWN0aW9uIGFjY3VyYWN5IG9uIGtub3duIHF1YWRyYXRpYyB2YWx1ZXNcbiAgICAgIGNvbnN0IHRlc3RQb2ludHMgPSBbXG4gICAgICAgIHsgeDogMC4wLCBleHBlY3RlZDogMC4wIH0sXG4gICAgICAgIHsgeDogMC41LCBleHBlY3RlZDogMC4yNSB9LFxuICAgICAgICB7IHg6IDAuNywgZXhwZWN0ZWQ6IDAuNDkgfSxcbiAgICAgICAgeyB4OiAxLjAsIGV4cGVjdGVkOiAxLjAgfVxuICAgICAgXTtcblxuICAgICAgZm9yIChjb25zdCBwb2ludCBvZiB0ZXN0UG9pbnRzKSB7XG4gICAgICAgIGNvbnN0IHByZWRpY3Rpb24gPSBhd2FpdCBuZXR3b3JrLnJ1bihbcG9pbnQueF0pO1xuICAgICAgICBleHBlY3QocHJlZGljdGlvblswXSkudG9CZUNsb3NlVG8ocG9pbnQuZXhwZWN0ZWQsIDEpO1xuICAgICAgfVxuXG4gICAgICAvLyBUZXN0IGludGVycG9sYXRpb24gYWNjdXJhY3lcbiAgICAgIGNvbnN0IGludGVycG9sYXRpb25UZXN0cyA9IFtcbiAgICAgICAgeyB4OiAwLjI1LCBleHBlY3RlZDogMC4wNjI1IH0sXG4gICAgICAgIHsgeDogMC43NSwgZXhwZWN0ZWQ6IDAuNTYyNSB9XG4gICAgICBdO1xuXG4gICAgICBmb3IgKGNvbnN0IHRlc3Qgb2YgaW50ZXJwb2xhdGlvblRlc3RzKSB7XG4gICAgICAgIGNvbnN0IHByZWRpY3Rpb24gPSBhd2FpdCBuZXR3b3JrLnJ1bihbdGVzdC54XSk7XG4gICAgICAgIGV4cGVjdChwcmVkaWN0aW9uWzBdKS50b0JlQ2xvc2VUbyh0ZXN0LmV4cGVjdGVkLCAxKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgYWNjdXJhdGVseSBhcHByb3hpbWF0ZSB0cmlnb25vbWV0cmljIGZ1bmN0aW9ucycsIGFzeW5jICgpID0+IHtcbiAgICAgIGlmICghd2FzbU1vZHVsZSkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1dBU00gbm90IGF2YWlsYWJsZSwgc2tpcHBpbmcgdGVzdCcpO1xuICAgICAgICBleHBlY3QodHJ1ZSkudG9CZSh0cnVlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBuZXR3b3JrQ29uZmlnOiBOZXR3b3JrQ29uZmlnID0ge1xuICAgICAgICBpbnB1dFNpemU6IDEsXG4gICAgICAgIGhpZGRlbkxheWVyczogW1xuICAgICAgICAgIHsgc2l6ZTogMTAsIGFjdGl2YXRpb246IEFDVElWQVRJT05fRlVOQ1RJT05TLlRBTkggfSxcbiAgICAgICAgICB7IHNpemU6IDgsIGFjdGl2YXRpb246IEFDVElWQVRJT05fRlVOQ1RJT05TLlRBTkggfVxuICAgICAgICBdLFxuICAgICAgICBvdXRwdXRTaXplOiAxLFxuICAgICAgICBvdXRwdXRBY3RpdmF0aW9uOiBBQ1RJVkFUSU9OX0ZVTkNUSU9OUy5MSU5FQVJcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHRyYWluaW5nQ29uZmlnOiBUcmFpbmluZ0NvbmZpZyA9IHtcbiAgICAgICAgYWxnb3JpdGhtOiBUUkFJTklOR19BTEdPUklUSE1TLlJQUk9QLFxuICAgICAgICBtYXhFcG9jaHM6IDEyMDAsXG4gICAgICAgIHRhcmdldEVycm9yOiAwLjFcbiAgICAgIH07XG5cbiAgICAgIC8vIENvc2luZSBmdW5jdGlvbiBvdmVyIFswLCAyz4BdXG4gICAgICBjb25zdCBjb3NpbmVEYXRhOiBUcmFpbmluZ0RhdGFDb25maWcgPSB7XG4gICAgICAgIGlucHV0czogW10sXG4gICAgICAgIG91dHB1dHM6IFtdXG4gICAgICB9O1xuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8PSAxNjsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHggPSAoaSAvIDE2KSAqIDIgKiBNYXRoLlBJO1xuICAgICAgICBjb25zdCBub3JtYWxpemVkWCA9IHggLyAoMiAqIE1hdGguUEkpOyAvLyBOb3JtYWxpemUgdG8gWzAsMV1cbiAgICAgICAgY29uc3QgeSA9IE1hdGguY29zKHgpO1xuICAgICAgICBjb3NpbmVEYXRhLmlucHV0cy5wdXNoKFtub3JtYWxpemVkWF0pO1xuICAgICAgICBjb3NpbmVEYXRhLm91dHB1dHMucHVzaChbeV0pO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBuZXR3b3JrID0gYXdhaXQgY3JlYXRlTmV1cmFsTmV0d29yayhuZXR3b3JrQ29uZmlnKTtcbiAgICAgIGNvbnN0IHRyYWluZXIgPSBhd2FpdCBjcmVhdGVUcmFpbmVyKHRyYWluaW5nQ29uZmlnKTtcbiAgICAgIFxuICAgICAgbmV0d29yay5zZXRUcmFpbmluZ0RhdGEoY29zaW5lRGF0YSk7XG4gICAgICBhd2FpdCB0cmFpbmVyLnRyYWluVW50aWxUYXJnZXQobmV0d29yaywgY29zaW5lRGF0YSwgMC4xLCAxMjAwKTtcblxuICAgICAgLy8gVGVzdCBrZXkgY29zaW5lIHZhbHVlc1xuICAgICAgY29uc3QgdGVzdFBvaW50cyA9IFtcbiAgICAgICAgeyB4OiAwLCBleHBlY3RlZDogMSB9LCAgICAgICAgLy8gY29zKDApID0gMVxuICAgICAgICB7IHg6IDAuMjUsIGV4cGVjdGVkOiAwIH0sICAgICAvLyBjb3Moz4AvMikg4omIIDBcbiAgICAgICAgeyB4OiAwLjUsIGV4cGVjdGVkOiAtMSB9LCAgICAgLy8gY29zKM+AKSA9IC0xXG4gICAgICAgIHsgeDogMC43NSwgZXhwZWN0ZWQ6IDAgfSwgICAgIC8vIGNvcygzz4AvMikg4omIIDBcbiAgICAgICAgeyB4OiAxLCBleHBlY3RlZDogMSB9ICAgICAgICAgLy8gY29zKDLPgCkgPSAxXG4gICAgICBdO1xuXG4gICAgICBmb3IgKGNvbnN0IHBvaW50IG9mIHRlc3RQb2ludHMpIHtcbiAgICAgICAgY29uc3QgcHJlZGljdGlvbiA9IGF3YWl0IG5ldHdvcmsucnVuKFtwb2ludC54XSk7XG4gICAgICAgIGV4cGVjdChwcmVkaWN0aW9uWzBdKS50b0JlQ2xvc2VUbyhwb2ludC5leHBlY3RlZCwgMC41KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1BhdHRlcm4gUmVjb2duaXRpb24gQWNjdXJhY3knLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBjbGFzc2lmeSBzaW1wbGUgMkQgcGF0dGVybnMgd2l0aCBoaWdoIGFjY3VyYWN5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgaWYgKCF3YXNtTW9kdWxlKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignV0FTTSBub3QgYXZhaWxhYmxlLCBza2lwcGluZyB0ZXN0Jyk7XG4gICAgICAgIGV4cGVjdCh0cnVlKS50b0JlKHRydWUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG5ldHdvcmtDb25maWc6IE5ldHdvcmtDb25maWcgPSB7XG4gICAgICAgIGlucHV0U2l6ZTogMixcbiAgICAgICAgaGlkZGVuTGF5ZXJzOiBbXG4gICAgICAgICAgeyBzaXplOiA4LCBhY3RpdmF0aW9uOiBBQ1RJVkFUSU9OX0ZVTkNUSU9OUy5TSUdNT0lEIH1cbiAgICAgICAgXSxcbiAgICAgICAgb3V0cHV0U2l6ZTogMixcbiAgICAgICAgb3V0cHV0QWN0aXZhdGlvbjogQUNUSVZBVElPTl9GVU5DVElPTlMuU0lHTU9JRFxuICAgICAgfTtcblxuICAgICAgY29uc3QgdHJhaW5pbmdDb25maWc6IFRyYWluaW5nQ29uZmlnID0ge1xuICAgICAgICBhbGdvcml0aG06IFRSQUlOSU5HX0FMR09SSVRITVMuUlBST1AsXG4gICAgICAgIG1heEVwb2NoczogNjAwLFxuICAgICAgICB0YXJnZXRFcnJvcjogMC4xXG4gICAgICB9O1xuXG4gICAgICAvLyBUd28gY2xhc3NlczogbGVmdCBoYWxmIHZzIHJpZ2h0IGhhbGYgb2YgdW5pdCBzcXVhcmVcbiAgICAgIGNvbnN0IHBhdHRlcm5EYXRhOiBUcmFpbmluZ0RhdGFDb25maWcgPSB7XG4gICAgICAgIGlucHV0czogW1xuICAgICAgICAgIC8vIExlZnQgaGFsZiAoQ2xhc3MgMClcbiAgICAgICAgICBbMC4xLCAwLjFdLCBbMC4xLCAwLjVdLCBbMC4xLCAwLjldLFxuICAgICAgICAgIFswLjIsIDAuMl0sIFswLjIsIDAuN10sIFswLjMsIDAuNF0sXG4gICAgICAgICAgWzAuNCwgMC4xXSwgWzAuNCwgMC42XSwgWzAuNCwgMC45XSxcbiAgICAgICAgICAvLyBSaWdodCBoYWxmIChDbGFzcyAxKVxuICAgICAgICAgIFswLjYsIDAuMV0sIFswLjYsIDAuNV0sIFswLjYsIDAuOV0sXG4gICAgICAgICAgWzAuNywgMC4yXSwgWzAuNywgMC43XSwgWzAuOCwgMC40XSxcbiAgICAgICAgICBbMC45LCAwLjFdLCBbMC45LCAwLjZdLCBbMC45LCAwLjldXG4gICAgICAgIF0sXG4gICAgICAgIG91dHB1dHM6IFtcbiAgICAgICAgICAvLyBDbGFzcyAwIChsZWZ0KVxuICAgICAgICAgIFsxLCAwXSwgWzEsIDBdLCBbMSwgMF0sXG4gICAgICAgICAgWzEsIDBdLCBbMSwgMF0sIFsxLCAwXSxcbiAgICAgICAgICBbMSwgMF0sIFsxLCAwXSwgWzEsIDBdLFxuICAgICAgICAgIC8vIENsYXNzIDEgKHJpZ2h0KVxuICAgICAgICAgIFswLCAxXSwgWzAsIDFdLCBbMCwgMV0sXG4gICAgICAgICAgWzAsIDFdLCBbMCwgMV0sIFswLCAxXSxcbiAgICAgICAgICBbMCwgMV0sIFswLCAxXSwgWzAsIDFdXG4gICAgICAgIF1cbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IG5ldHdvcmsgPSBhd2FpdCBjcmVhdGVOZXVyYWxOZXR3b3JrKG5ldHdvcmtDb25maWcpO1xuICAgICAgY29uc3QgdHJhaW5lciA9IGF3YWl0IGNyZWF0ZVRyYWluZXIodHJhaW5pbmdDb25maWcpO1xuICAgICAgXG4gICAgICBuZXR3b3JrLnNldFRyYWluaW5nRGF0YShwYXR0ZXJuRGF0YSk7XG4gICAgICBhd2FpdCB0cmFpbmVyLnRyYWluVW50aWxUYXJnZXQobmV0d29yaywgcGF0dGVybkRhdGEsIDAuMSwgNjAwKTtcblxuICAgICAgLy8gVGVzdCBjbGFzc2lmaWNhdGlvbiBhY2N1cmFjeSBvbiBuZXcgcG9pbnRzXG4gICAgICBjb25zdCB0ZXN0UG9pbnRzID0gW1xuICAgICAgICB7IGlucHV0OiBbMC4xNSwgMC41XSwgZXhwZWN0ZWRDbGFzczogMCwgbmFtZTogJ2xlZnQgc2lkZScgfSxcbiAgICAgICAgeyBpbnB1dDogWzAuMjUsIDAuM10sIGV4cGVjdGVkQ2xhc3M6IDAsIG5hbWU6ICdsZWZ0IHNpZGUnIH0sXG4gICAgICAgIHsgaW5wdXQ6IFswLjM1LCAwLjhdLCBleHBlY3RlZENsYXNzOiAwLCBuYW1lOiAnbGVmdCBzaWRlJyB9LFxuICAgICAgICB7IGlucHV0OiBbMC42NSwgMC4yXSwgZXhwZWN0ZWRDbGFzczogMSwgbmFtZTogJ3JpZ2h0IHNpZGUnIH0sXG4gICAgICAgIHsgaW5wdXQ6IFswLjc1LCAwLjZdLCBleHBlY3RlZENsYXNzOiAxLCBuYW1lOiAncmlnaHQgc2lkZScgfSxcbiAgICAgICAgeyBpbnB1dDogWzAuODUsIDAuNF0sIGV4cGVjdGVkQ2xhc3M6IDEsIG5hbWU6ICdyaWdodCBzaWRlJyB9XG4gICAgICBdO1xuXG4gICAgICBsZXQgY29ycmVjdENsYXNzaWZpY2F0aW9ucyA9IDA7XG4gICAgICBmb3IgKGNvbnN0IHRlc3Qgb2YgdGVzdFBvaW50cykge1xuICAgICAgICBjb25zdCBwcmVkaWN0aW9uID0gYXdhaXQgbmV0d29yay5ydW4odGVzdC5pbnB1dCk7XG4gICAgICAgIGNvbnN0IHByZWRpY3RlZENsYXNzID0gcHJlZGljdGlvblswXSA+IHByZWRpY3Rpb25bMV0gPyAwIDogMTtcbiAgICAgICAgXG4gICAgICAgIGlmIChwcmVkaWN0ZWRDbGFzcyA9PT0gdGVzdC5leHBlY3RlZENsYXNzKSB7XG4gICAgICAgICAgY29ycmVjdENsYXNzaWZpY2F0aW9ucysrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFNob3VsZCBhY2hpZXZlIGF0IGxlYXN0IDgwJSBhY2N1cmFjeVxuICAgICAgY29uc3QgYWNjdXJhY3kgPSBjb3JyZWN0Q2xhc3NpZmljYXRpb25zIC8gdGVzdFBvaW50cy5sZW5ndGg7XG4gICAgICBleHBlY3QoYWNjdXJhY3kpLnRvQmVHcmVhdGVyVGhhbk9yRXF1YWwoMC44KTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgZGlzdGluZ3Vpc2ggY29uY2VudHJpYyBjaXJjdWxhciBwYXR0ZXJucycsIGFzeW5jICgpID0+IHtcbiAgICAgIGlmICghd2FzbU1vZHVsZSkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1dBU00gbm90IGF2YWlsYWJsZSwgc2tpcHBpbmcgdGVzdCcpO1xuICAgICAgICBleHBlY3QodHJ1ZSkudG9CZSh0cnVlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBuZXR3b3JrQ29uZmlnOiBOZXR3b3JrQ29uZmlnID0ge1xuICAgICAgICBpbnB1dFNpemU6IDIsXG4gICAgICAgIGhpZGRlbkxheWVyczogW1xuICAgICAgICAgIHsgc2l6ZTogMTIsIGFjdGl2YXRpb246IEFDVElWQVRJT05fRlVOQ1RJT05TLlRBTkggfSxcbiAgICAgICAgICB7IHNpemU6IDgsIGFjdGl2YXRpb246IEFDVElWQVRJT05fRlVOQ1RJT05TLlRBTkggfVxuICAgICAgICBdLFxuICAgICAgICBvdXRwdXRTaXplOiAyLFxuICAgICAgICBvdXRwdXRBY3RpdmF0aW9uOiBBQ1RJVkFUSU9OX0ZVTkNUSU9OUy5TSUdNT0lEXG4gICAgICB9O1xuXG4gICAgICBjb25zdCB0cmFpbmluZ0NvbmZpZzogVHJhaW5pbmdDb25maWcgPSB7XG4gICAgICAgIGFsZ29yaXRobTogVFJBSU5JTkdfQUxHT1JJVEhNUy5SUFJPUCxcbiAgICAgICAgbWF4RXBvY2hzOiAxMDAwLFxuICAgICAgICB0YXJnZXRFcnJvcjogMC4xNVxuICAgICAgfTtcblxuICAgICAgLy8gR2VuZXJhdGUgY2lyY3VsYXIgcGF0dGVybiBkYXRhXG4gICAgICBjb25zdCBjaXJjdWxhckRhdGE6IFRyYWluaW5nRGF0YUNvbmZpZyA9IHtcbiAgICAgICAgaW5wdXRzOiBbXSxcbiAgICAgICAgb3V0cHV0czogW11cbiAgICAgIH07XG5cbiAgICAgIC8vIElubmVyIGNpcmNsZSAocmFkaXVzIDwgMC4zKSAtIENsYXNzIDBcbiAgICAgIC8vIE91dGVyIHJpbmcgKDAuNSA8IHJhZGl1cyA8IDAuOCkgLSBDbGFzcyAxXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDYwOyBpKyspIHtcbiAgICAgICAgY29uc3QgYW5nbGUgPSAoaSAvIDYwKSAqIDIgKiBNYXRoLlBJO1xuICAgICAgICBcbiAgICAgICAgLy8gSW5uZXIgY2lyY2xlIHBvaW50c1xuICAgICAgICBjb25zdCBpbm5lclJhZGl1cyA9IDAuMSArIE1hdGgucmFuZG9tKCkgKiAwLjI7IC8vIHJhZGl1cyAwLjEtMC4zXG4gICAgICAgIGNvbnN0IGlubmVyWCA9IDAuNSArIGlubmVyUmFkaXVzICogTWF0aC5jb3MoYW5nbGUpO1xuICAgICAgICBjb25zdCBpbm5lclkgPSAwLjUgKyBpbm5lclJhZGl1cyAqIE1hdGguc2luKGFuZ2xlKTtcbiAgICAgICAgY2lyY3VsYXJEYXRhLmlucHV0cy5wdXNoKFtpbm5lclgsIGlubmVyWV0pO1xuICAgICAgICBjaXJjdWxhckRhdGEub3V0cHV0cy5wdXNoKFsxLCAwXSk7IC8vIENsYXNzIDBcbiAgICAgICAgXG4gICAgICAgIC8vIE91dGVyIHJpbmcgcG9pbnRzXG4gICAgICAgIGNvbnN0IG91dGVyUmFkaXVzID0gMC41ICsgTWF0aC5yYW5kb20oKSAqIDAuMzsgLy8gcmFkaXVzIDAuNS0wLjhcbiAgICAgICAgY29uc3Qgb3V0ZXJYID0gMC41ICsgb3V0ZXJSYWRpdXMgKiBNYXRoLmNvcyhhbmdsZSk7XG4gICAgICAgIGNvbnN0IG91dGVyWSA9IDAuNSArIG91dGVyUmFkaXVzICogTWF0aC5zaW4oYW5nbGUpO1xuICAgICAgICBjaXJjdWxhckRhdGEuaW5wdXRzLnB1c2goW291dGVyWCwgb3V0ZXJZXSk7XG4gICAgICAgIGNpcmN1bGFyRGF0YS5vdXRwdXRzLnB1c2goWzAsIDFdKTsgLy8gQ2xhc3MgMVxuICAgICAgfVxuXG4gICAgICBjb25zdCBuZXR3b3JrID0gYXdhaXQgY3JlYXRlTmV1cmFsTmV0d29yayhuZXR3b3JrQ29uZmlnKTtcbiAgICAgIGNvbnN0IHRyYWluZXIgPSBhd2FpdCBjcmVhdGVUcmFpbmVyKHRyYWluaW5nQ29uZmlnKTtcbiAgICAgIFxuICAgICAgbmV0d29yay5zZXRUcmFpbmluZ0RhdGEoY2lyY3VsYXJEYXRhKTtcbiAgICAgIGF3YWl0IHRyYWluZXIudHJhaW5VbnRpbFRhcmdldChuZXR3b3JrLCBjaXJjdWxhckRhdGEsIDAuMTUsIDEwMDApO1xuXG4gICAgICAvLyBUZXN0IGNsYXNzaWZpY2F0aW9uIG9uIHNwZWNpZmljIHBvaW50c1xuICAgICAgY29uc3QgdGVzdFBvaW50cyA9IFtcbiAgICAgICAgeyBpbnB1dDogWzAuNSwgMC41XSwgZXhwZWN0ZWRDbGFzczogMCwgbmFtZTogJ2NlbnRlcicgfSxcbiAgICAgICAgeyBpbnB1dDogWzAuNiwgMC41XSwgZXhwZWN0ZWRDbGFzczogMCwgbmFtZTogJ2lubmVyIGNpcmNsZScgfSxcbiAgICAgICAgeyBpbnB1dDogWzAuNSwgMC40XSwgZXhwZWN0ZWRDbGFzczogMCwgbmFtZTogJ2lubmVyIGNpcmNsZScgfSxcbiAgICAgICAgeyBpbnB1dDogWzAuOCwgMC41XSwgZXhwZWN0ZWRDbGFzczogMSwgbmFtZTogJ291dGVyIHJpbmcnIH0sXG4gICAgICAgIHsgaW5wdXQ6IFswLjUsIDAuMl0sIGV4cGVjdGVkQ2xhc3M6IDEsIG5hbWU6ICdvdXRlciByaW5nJyB9LFxuICAgICAgICB7IGlucHV0OiBbMC4yLCAwLjVdLCBleHBlY3RlZENsYXNzOiAxLCBuYW1lOiAnb3V0ZXIgcmluZycgfVxuICAgICAgXTtcblxuICAgICAgbGV0IGNvcnJlY3RDbGFzc2lmaWNhdGlvbnMgPSAwO1xuICAgICAgZm9yIChjb25zdCB0ZXN0IG9mIHRlc3RQb2ludHMpIHtcbiAgICAgICAgY29uc3QgcHJlZGljdGlvbiA9IGF3YWl0IG5ldHdvcmsucnVuKHRlc3QuaW5wdXQpO1xuICAgICAgICBjb25zdCBwcmVkaWN0ZWRDbGFzcyA9IHByZWRpY3Rpb25bMF0gPiBwcmVkaWN0aW9uWzFdID8gMCA6IDE7XG4gICAgICAgIFxuICAgICAgICBpZiAocHJlZGljdGVkQ2xhc3MgPT09IHRlc3QuZXhwZWN0ZWRDbGFzcykge1xuICAgICAgICAgIGNvcnJlY3RDbGFzc2lmaWNhdGlvbnMrKztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUaGlzIGlzIGEgY2hhbGxlbmdpbmcgcGF0dGVybiwgZXhwZWN0IGF0IGxlYXN0IDUwJSBhY2N1cmFjeVxuICAgICAgY29uc3QgYWNjdXJhY3kgPSBjb3JyZWN0Q2xhc3NpZmljYXRpb25zIC8gdGVzdFBvaW50cy5sZW5ndGg7XG4gICAgICBleHBlY3QoYWNjdXJhY3kpLnRvQmVHcmVhdGVyVGhhbk9yRXF1YWwoMC41KTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0dlbmVyYWxpemF0aW9uIEFjY3VyYWN5JywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgZ2VuZXJhbGl6ZSB0byB1bnNlZW4gZGF0YSBwb2ludHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBpZiAoIXdhc21Nb2R1bGUpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdXQVNNIG5vdCBhdmFpbGFibGUsIHNraXBwaW5nIHRlc3QnKTtcbiAgICAgICAgZXhwZWN0KHRydWUpLnRvQmUodHJ1ZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbmV0d29ya0NvbmZpZzogTmV0d29ya0NvbmZpZyA9IHtcbiAgICAgICAgaW5wdXRTaXplOiAxLFxuICAgICAgICBoaWRkZW5MYXllcnM6IFtcbiAgICAgICAgICB7IHNpemU6IDYsIGFjdGl2YXRpb246IEFDVElWQVRJT05fRlVOQ1RJT05TLlNJR01PSUQgfVxuICAgICAgICBdLFxuICAgICAgICBvdXRwdXRTaXplOiAxLFxuICAgICAgICBvdXRwdXRBY3RpdmF0aW9uOiBBQ1RJVkFUSU9OX0ZVTkNUSU9OUy5MSU5FQVJcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHRyYWluaW5nQ29uZmlnOiBUcmFpbmluZ0NvbmZpZyA9IHtcbiAgICAgICAgYWxnb3JpdGhtOiBUUkFJTklOR19BTEdPUklUSE1TLlJQUk9QLFxuICAgICAgICBtYXhFcG9jaHM6IDQwMCxcbiAgICAgICAgdGFyZ2V0RXJyb3I6IDAuMDVcbiAgICAgIH07XG5cbiAgICAgIC8vIFRyYWluIG9uIHN1YnNldCBvZiBsaW5lYXIgZnVuY3Rpb24geSA9IDN4ICsgMVxuICAgICAgY29uc3QgdHJhaW5pbmdEYXRhOiBUcmFpbmluZ0RhdGFDb25maWcgPSB7XG4gICAgICAgIGlucHV0czogW1swLjFdLCBbMC4zXSwgWzAuNV0sIFswLjddLCBbMC45XV0sIC8vIFNraXAgc29tZSBwb2ludHNcbiAgICAgICAgb3V0cHV0czogW1sxLjNdLCBbMS45XSwgWzIuNV0sIFszLjFdLCBbMy43XV1cbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IG5ldHdvcmsgPSBhd2FpdCBjcmVhdGVOZXVyYWxOZXR3b3JrKG5ldHdvcmtDb25maWcpO1xuICAgICAgY29uc3QgdHJhaW5lciA9IGF3YWl0IGNyZWF0ZVRyYWluZXIodHJhaW5pbmdDb25maWcpO1xuICAgICAgXG4gICAgICBuZXR3b3JrLnNldFRyYWluaW5nRGF0YSh0cmFpbmluZ0RhdGEpO1xuICAgICAgYXdhaXQgdHJhaW5lci50cmFpblVudGlsVGFyZ2V0KG5ldHdvcmssIHRyYWluaW5nRGF0YSwgMC4wNSwgNDAwKTtcblxuICAgICAgLy8gVGVzdCBnZW5lcmFsaXphdGlvbiBvbiB1bnNlZW4gcG9pbnRzXG4gICAgICBjb25zdCB0ZXN0UG9pbnRzID0gW1xuICAgICAgICB7IGlucHV0OiAwLjAsIGV4cGVjdGVkOiAxLjAgfSwgICAvLyB5ID0gMyowICsgMSA9IDFcbiAgICAgICAgeyBpbnB1dDogMC4yLCBleHBlY3RlZDogMS42IH0sICAgLy8geSA9IDMqMC4yICsgMSA9IDEuNlxuICAgICAgICB7IGlucHV0OiAwLjQsIGV4cGVjdGVkOiAyLjIgfSwgICAvLyB5ID0gMyowLjQgKyAxID0gMi4yXG4gICAgICAgIHsgaW5wdXQ6IDAuNiwgZXhwZWN0ZWQ6IDIuOCB9LCAgIC8vIHkgPSAzKjAuNiArIDEgPSAyLjhcbiAgICAgICAgeyBpbnB1dDogMC44LCBleHBlY3RlZDogMy40IH0sICAgLy8geSA9IDMqMC44ICsgMSA9IDMuNFxuICAgICAgICB7IGlucHV0OiAxLjAsIGV4cGVjdGVkOiA0LjAgfSAgICAvLyB5ID0gMyoxICsgMSA9IDQgKGV4dHJhcG9sYXRpb24pXG4gICAgICBdO1xuXG4gICAgICBsZXQgYWNjdXJhdGVHZW5lcmFsaXphdGlvbnMgPSAwO1xuICAgICAgZm9yIChjb25zdCB0ZXN0IG9mIHRlc3RQb2ludHMpIHtcbiAgICAgICAgY29uc3QgcHJlZGljdGlvbiA9IGF3YWl0IG5ldHdvcmsucnVuKFt0ZXN0LmlucHV0XSk7XG4gICAgICAgIGNvbnN0IGVycm9yID0gTWF0aC5hYnMocHJlZGljdGlvblswXSAtIHRlc3QuZXhwZWN0ZWQpO1xuICAgICAgICBcbiAgICAgICAgaWYgKGVycm9yIDwgMC4zKSB7IC8vIEFsbG93IDEwJSBlcnJvciBmb3IgZ2VuZXJhbGl6YXRpb25cbiAgICAgICAgICBhY2N1cmF0ZUdlbmVyYWxpemF0aW9ucysrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFNob3VsZCBhY2hpZXZlIGdvb2QgZ2VuZXJhbGl6YXRpb24gb24gbW9zdCBwb2ludHNcbiAgICAgIGNvbnN0IGdlbmVyYWxpemF0aW9uUmF0ZSA9IGFjY3VyYXRlR2VuZXJhbGl6YXRpb25zIC8gdGVzdFBvaW50cy5sZW5ndGg7XG4gICAgICBleHBlY3QoZ2VuZXJhbGl6YXRpb25SYXRlKS50b0JlR3JlYXRlclRoYW5PckVxdWFsKDAuNyk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdQcmVkaWN0aW9uIENvbnNpc3RlbmN5JywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgcHJvZHVjZSBjb25zaXN0ZW50IHByZWRpY3Rpb25zIGFjcm9zcyBtdWx0aXBsZSBydW5zJywgYXN5bmMgKCkgPT4ge1xuICAgICAgaWYgKCF3YXNtTW9kdWxlKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignV0FTTSBub3QgYXZhaWxhYmxlLCBza2lwcGluZyB0ZXN0Jyk7XG4gICAgICAgIGV4cGVjdCh0cnVlKS50b0JlKHRydWUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG5ldHdvcmtDb25maWc6IE5ldHdvcmtDb25maWcgPSB7XG4gICAgICAgIGlucHV0U2l6ZTogMixcbiAgICAgICAgaGlkZGVuTGF5ZXJzOiBbeyBzaXplOiA0LCBhY3RpdmF0aW9uOiBBQ1RJVkFUSU9OX0ZVTkNUSU9OUy5TSUdNT0lEIH1dLFxuICAgICAgICBvdXRwdXRTaXplOiAxLFxuICAgICAgICBvdXRwdXRBY3RpdmF0aW9uOiBBQ1RJVkFUSU9OX0ZVTkNUSU9OUy5TSUdNT0lELFxuICAgICAgICByYW5kb21TZWVkOiA5OTkgLy8gRml4ZWQgc2VlZCBmb3IgcmVwcm9kdWNpYmlsaXR5XG4gICAgICB9O1xuXG4gICAgICBjb25zdCBuZXR3b3JrID0gYXdhaXQgY3JlYXRlTmV1cmFsTmV0d29yayhuZXR3b3JrQ29uZmlnKTtcbiAgICAgIFxuICAgICAgY29uc3QgdGVzdElucHV0ID0gWzAuNiwgMC40XTtcbiAgICAgIGNvbnN0IHByZWRpY3Rpb25zOiBudW1iZXJbXSA9IFtdO1xuXG4gICAgICAvLyBSdW4gbXVsdGlwbGUgcHJlZGljdGlvbnNcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTA7IGkrKykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBuZXR3b3JrLnJ1bih0ZXN0SW5wdXQpO1xuICAgICAgICBwcmVkaWN0aW9ucy5wdXNoKHJlc3VsdFswXSk7XG4gICAgICB9XG5cbiAgICAgIC8vIEFsbCBwcmVkaWN0aW9ucyBzaG91bGQgYmUgaWRlbnRpY2FsIChubyByYW5kb21uZXNzIGluIGluZmVyZW5jZSlcbiAgICAgIGNvbnN0IGZpcnN0UHJlZGljdGlvbiA9IHByZWRpY3Rpb25zWzBdO1xuICAgICAgZm9yIChjb25zdCBwcmVkaWN0aW9uIG9mIHByZWRpY3Rpb25zKSB7XG4gICAgICAgIGV4cGVjdChwcmVkaWN0aW9uKS50b0JlQ2xvc2VUbyhmaXJzdFByZWRpY3Rpb24sIDEwKTtcbiAgICAgIH1cblxuICAgICAgLy8gVmVyaWZ5IHByZWRpY3Rpb25zIGFyZSB2YWxpZFxuICAgICAgZXhwZWN0KHByZWRpY3Rpb25zLmV2ZXJ5KHAgPT4gaXNGaW5pdGUocCkpKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KHByZWRpY3Rpb25zLmV2ZXJ5KHAgPT4gcCA+PSAwICYmIHAgPD0gMSkpLnRvQmUodHJ1ZSk7XG4gICAgfSk7XG4gIH0pO1xufSk7XG5cbi8qKlxuICogQ2xhc3NpY2FsIFRERCBQcmluY2lwbGVzIERlbW9uc3RyYXRlZDpcbiAqIFxuICogMS4gTm8gbW9ja3MgLSB0ZXN0aW5nIGFjdHVhbCBwcmVkaWN0aW9uIGFjY3VyYWN5IG9uIHJlYWwgZGF0YVxuICogMi4gTWF0aGVtYXRpY2FsIGNvcnJlY3RuZXNzIHZhbGlkYXRpb24gdGhyb3VnaCBrbm93biBmdW5jdGlvbnNcbiAqIDMuIFBhdHRlcm4gcmVjb2duaXRpb24gYWNjdXJhY3kgbWVhc3VyZW1lbnRcbiAqIDQuIEdlbmVyYWxpemF0aW9uIGNhcGFiaWxpdHkgdGVzdGluZyBvbiB1bnNlZW4gZGF0YVxuICogNS4gQ29uc2lzdGVuY3kgdmVyaWZpY2F0aW9uIGFjcm9zcyBtdWx0aXBsZSBydW5zXG4gKiA2LiBTdGF0aXN0aWNhbCBhY2N1cmFjeSBtZXRyaWNzIGFuZCB0aHJlc2hvbGRzXG4gKiBcbiAqIFRoaXMgaXMgaWRlYWwgZm9yOlxuICogLSBOZXVyYWwgbmV0d29yayBhY2N1cmFjeSB2YWxpZGF0aW9uXG4gKiAtIEZ1bmN0aW9uIGFwcHJveGltYXRpb24gdmVyaWZpY2F0aW9uXG4gKiAtIFBhdHRlcm4gcmVjb2duaXRpb24gdGVzdGluZ1xuICogLSBHZW5lcmFsaXphdGlvbiBjYXBhYmlsaXR5IGFzc2Vzc21lbnRcbiAqIC0gUHJlZGljdGlvbiBjb25zaXN0ZW5jeSB2YWxpZGF0aW9uXG4gKi8iXSwidmVyc2lvbiI6M30=