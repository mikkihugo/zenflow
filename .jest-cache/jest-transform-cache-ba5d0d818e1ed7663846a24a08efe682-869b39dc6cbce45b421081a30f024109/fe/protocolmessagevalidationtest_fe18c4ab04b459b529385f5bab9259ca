be9172121baeba033a6da63d3d649565
/**
 * MCP Protocol Message Validation - TDD London Style
 *
 * Tests protocol message validation using London School principles:
 * - Mock all dependencies to focus on interaction contracts
 * - Test behavior and communication patterns, not implementation
 * - Outside-in development from protocol requirements
 * - Verify the conversation between components
 */
import { jest, describe, it, expect, beforeEach, afterEach } from '@jest/globals';
// === MOCK DEPENDENCIES (London School Contract Definition) ===
const mockSchemaValidator = {
    validateJsonRpc: jest.fn(),
    validateMethod: jest.fn(),
    validateParams: jest.fn(),
    validateVersion: jest.fn(),
    getSchemaForMethod: jest.fn()
};
const mockLogger = {
    debug: jest.fn(),
    info: jest.fn(),
    warn: jest.fn(),
    error: jest.fn()
};
const mockMetricsCollector = {
    recordValidation: jest.fn(),
    recordValidationError: jest.fn(),
    incrementCounter: jest.fn()
};
// === MOCK IMPLEMENTATION ===
class MockMCPMessageValidator {
    schemaValidator;
    logger;
    metrics;
    constructor(schemaValidator = mockSchemaValidator, logger = mockLogger, metrics = mockMetricsCollector) {
        this.schemaValidator = schemaValidator;
        this.logger = logger;
        this.metrics = metrics;
    }
    async validate(message) {
        this.logger.debug('Validating MCP message', { messageType: typeof message });
        const jsonRpcResult = this.schemaValidator.validateJsonRpc(message);
        if (!jsonRpcResult.valid) {
            this.metrics.recordValidationError('jsonrpc_invalid');
            return { valid: false, errors: jsonRpcResult.errors };
        }
        const mcpMessage = message;
        if ('id' in mcpMessage && 'method' in mcpMessage) {
            return this.validateRequest(mcpMessage);
        }
        else if ('id' in mcpMessage && ('result' in mcpMessage || 'error' in mcpMessage)) {
            return this.validateResponse(mcpMessage);
        }
        else if ('method' in mcpMessage && !('id' in mcpMessage)) {
            return this.validateNotification(mcpMessage);
        }
        return { valid: false, errors: [{ field: 'message', code: 'UNKNOWN_TYPE', message: 'Unknown message type' }] };
    }
    async validateRequest(request) {
        this.logger.debug('Validating MCP request', { method: request.method });
        const methodResult = this.schemaValidator.validateMethod(request.method);
        if (!methodResult.valid) {
            this.metrics.recordValidationError('method_invalid');
            return { valid: false, errors: methodResult.errors };
        }
        const schema = this.schemaValidator.getSchemaForMethod(request.method);
        const paramsResult = this.schemaValidator.validateParams(request.params, schema);
        if (!paramsResult.valid) {
            this.metrics.recordValidationError('params_invalid');
            return { valid: false, errors: paramsResult.errors };
        }
        this.metrics.recordValidation('request_valid');
        return { valid: true, errors: [] };
    }
    async validateResponse(response) {
        this.logger.debug('Validating MCP response', { id: response.id });
        if (response.error) {
            const errorValid = this.validateError(response.error);
            if (!errorValid.valid) {
                this.metrics.recordValidationError('error_invalid');
                return errorValid;
            }
        }
        this.metrics.recordValidation('response_valid');
        return { valid: true, errors: [] };
    }
    async validateNotification(notification) {
        this.logger.debug('Validating MCP notification', { method: notification.method });
        const methodResult = this.schemaValidator.validateMethod(notification.method);
        if (!methodResult.valid) {
            this.metrics.recordValidationError('notification_method_invalid');
            return { valid: false, errors: methodResult.errors };
        }
        this.metrics.recordValidation('notification_valid');
        return { valid: true, errors: [] };
    }
    validateError(error) {
        const errors = [];
        if (typeof error.code !== 'number') {
            errors.push({ field: 'error.code', code: 'INVALID_TYPE', message: 'Error code must be a number' });
        }
        if (typeof error.message !== 'string') {
            errors.push({ field: 'error.message', code: 'INVALID_TYPE', message: 'Error message must be a string' });
        }
        return { valid: errors.length === 0, errors };
    }
}
describe('MCP Protocol Message Validation - London TDD', () => {
    describe('ðŸŽ¯ Acceptance Tests - Protocol Compliance', () => {
        describe('JSON-RPC 2.0 Base Protocol Validation', () => {
            it('should validate required JSON-RPC 2.0 fields in requests', async () => {
                // Arrange - Mock valid JSON-RPC validation
                mockSchemaValidator.validateJsonRpc.mockReturnValue({
                    valid: true,
                    errors: []
                });
                mockSchemaValidator.validateMethod.mockReturnValue({
                    valid: true,
                    errors: []
                });
                mockSchemaValidator.getSchemaForMethod.mockReturnValue({ type: 'object' });
                mockSchemaValidator.validateParams.mockReturnValue({
                    valid: true,
                    errors: []
                });
                const validator = new MockMCPMessageValidator();
                const validRequest = {
                    jsonrpc: '2.0',
                    id: 'test-123',
                    method: 'tools/list',
                    params: {}
                };
                // Act - Validate the request
                const result = await validator.validate(validRequest);
                // Assert - Verify JSON-RPC validation conversation
                expect(mockSchemaValidator.validateJsonRpc).toHaveBeenCalledWith(validRequest);
                expect(mockSchemaValidator.validateMethod).toHaveBeenCalledWith('tools/list');
                expect(mockSchemaValidator.validateParams).toHaveBeenCalledWith({}, { type: 'object' });
                expect(mockMetricsCollector.recordValidation).toHaveBeenCalledWith('request_valid');
                expect(result.valid).toBe(true);
            });
            it('should reject messages with invalid JSON-RPC version', async () => {
                // Arrange - Mock JSON-RPC validation failure
                mockSchemaValidator.validateJsonRpc.mockReturnValue({
                    valid: false,
                    errors: [{
                            field: 'jsonrpc',
                            code: 'INVALID_VERSION',
                            message: 'JSON-RPC version must be "2.0"'
                        }]
                });
                const validator = new MockMCPMessageValidator();
                const invalidRequest = {
                    jsonrpc: '1.0', // Invalid version
                    id: 'test-123',
                    method: 'tools/list'
                };
                // Act - Validate invalid request
                const result = await validator.validate(invalidRequest);
                // Assert - Verify error handling conversation
                expect(mockSchemaValidator.validateJsonRpc).toHaveBeenCalledWith(invalidRequest);
                expect(mockMetricsCollector.recordValidationError).toHaveBeenCalledWith('jsonrpc_invalid');
                expect(result.valid).toBe(false);
                expect(result.errors).toHaveLength(1);
                expect(result.errors[0].code).toBe('INVALID_VERSION');
            });
        });
        describe('MCP Method Validation', () => {
            it('should validate standard MCP methods', async () => {
                // Arrange - Mock standard MCP method validation
                mockSchemaValidator.validateJsonRpc.mockReturnValue({ valid: true, errors: [] });
                mockSchemaValidator.validateMethod.mockReturnValue({ valid: true, errors: [] });
                mockSchemaValidator.getSchemaForMethod.mockReturnValue({ type: 'object' });
                mockSchemaValidator.validateParams.mockReturnValue({ valid: true, errors: [] });
                const validator = new MockMCPMessageValidator();
                const standardMethods = [
                    'initialize',
                    'tools/list',
                    'tools/call',
                    'resources/list',
                    'resources/read',
                    'prompts/list',
                    'prompts/get',
                    'logging/setLevel'
                ];
                // Act - Validate each standard method
                for (const method of standardMethods) {
                    const request = {
                        jsonrpc: '2.0',
                        id: `test-${method}`,
                        method,
                        params: {}
                    };
                    const result = await validator.validate(request);
                    // Assert - Verify method validation conversation
                    expect(mockSchemaValidator.validateMethod).toHaveBeenCalledWith(method);
                    expect(result.valid).toBe(true);
                }
                expect(mockSchemaValidator.validateMethod).toHaveBeenCalledTimes(standardMethods.length);
            });
            it('should reject unknown methods', async () => {
                // Arrange - Mock unknown method rejection
                mockSchemaValidator.validateJsonRpc.mockReturnValue({ valid: true, errors: [] });
                mockSchemaValidator.validateMethod.mockReturnValue({
                    valid: false,
                    errors: [{
                            field: 'method',
                            code: 'UNKNOWN_METHOD',
                            message: 'Method not recognized'
                        }]
                });
                const validator = new MockMCPMessageValidator();
                const requestWithUnknownMethod = {
                    jsonrpc: '2.0',
                    id: 'test-123',
                    method: 'unknown/method',
                    params: {}
                };
                // Act - Validate unknown method
                const result = await validator.validate(requestWithUnknownMethod);
                // Assert - Verify unknown method handling
                expect(mockSchemaValidator.validateMethod).toHaveBeenCalledWith('unknown/method');
                expect(mockMetricsCollector.recordValidationError).toHaveBeenCalledWith('method_invalid');
                expect(result.valid).toBe(false);
                expect(result.errors[0].code).toBe('UNKNOWN_METHOD');
            });
        });
        describe('Parameter Validation', () => {
            it('should validate parameters against method schemas', async () => {
                // Arrange - Mock parameter validation
                mockSchemaValidator.validateJsonRpc.mockReturnValue({ valid: true, errors: [] });
                mockSchemaValidator.validateMethod.mockReturnValue({ valid: true, errors: [] });
                const toolCallSchema = {
                    type: 'object',
                    required: ['name'],
                    properties: {
                        name: { type: 'string' },
                        arguments: { type: 'object' }
                    }
                };
                mockSchemaValidator.getSchemaForMethod.mockReturnValue(toolCallSchema);
                mockSchemaValidator.validateParams.mockReturnValue({ valid: true, errors: [] });
                const validator = new MockMCPMessageValidator();
                const toolCallRequest = {
                    jsonrpc: '2.0',
                    id: 'tool-call-1',
                    method: 'tools/call',
                    params: {
                        name: 'analyze_code',
                        arguments: {
                            language: 'typescript',
                            file: 'src/main.ts'
                        }
                    }
                };
                // Act - Validate tool call with parameters
                const result = await validator.validate(toolCallRequest);
                // Assert - Verify parameter validation conversation
                expect(mockSchemaValidator.getSchemaForMethod).toHaveBeenCalledWith('tools/call');
                expect(mockSchemaValidator.validateParams).toHaveBeenCalledWith(toolCallRequest.params, toolCallSchema);
                expect(result.valid).toBe(true);
            });
            it('should reject invalid parameters', async () => {
                // Arrange - Mock parameter validation failure
                mockSchemaValidator.validateJsonRpc.mockReturnValue({ valid: true, errors: [] });
                mockSchemaValidator.validateMethod.mockReturnValue({ valid: true, errors: [] });
                mockSchemaValidator.getSchemaForMethod.mockReturnValue({
                    type: 'object',
                    required: ['name']
                });
                mockSchemaValidator.validateParams.mockReturnValue({
                    valid: false,
                    errors: [{
                            field: 'params.name',
                            code: 'MISSING_REQUIRED',
                            message: 'Required field "name" is missing'
                        }]
                });
                const validator = new MockMCPMessageValidator();
                const invalidToolCall = {
                    jsonrpc: '2.0',
                    id: 'invalid-call',
                    method: 'tools/call',
                    params: {
                        // Missing required 'name' field
                        arguments: { file: 'test.ts' }
                    }
                };
                // Act - Validate invalid parameters
                const result = await validator.validate(invalidToolCall);
                // Assert - Verify parameter error handling
                expect(mockSchemaValidator.validateParams).toHaveBeenCalled();
                expect(mockMetricsCollector.recordValidationError).toHaveBeenCalledWith('params_invalid');
                expect(result.valid).toBe(false);
                expect(result.errors[0].code).toBe('MISSING_REQUIRED');
            });
        });
    });
    describe('ðŸ”— Contract Verification - Response Validation', () => {
        describe('Success Response Validation', () => {
            it('should validate successful response structure', async () => {
                // Arrange - Mock successful response validation
                const validator = new MockMCPMessageValidator();
                const successResponse = {
                    jsonrpc: '2.0',
                    id: 'test-123',
                    result: {
                        tools: [
                            {
                                name: 'analyze_code',
                                description: 'Analyzes code structure and patterns',
                                inputSchema: { type: 'object' }
                            }
                        ]
                    }
                };
                // Act - Validate success response
                const result = await validator.validateResponse(successResponse);
                // Assert - Verify success response validation
                expect(mockLogger.debug).toHaveBeenCalledWith('Validating MCP response', { id: 'test-123' });
                expect(mockMetricsCollector.recordValidation).toHaveBeenCalledWith('response_valid');
                expect(result.valid).toBe(true);
            });
        });
        describe('Error Response Validation', () => {
            it('should validate error response structure', async () => {
                // Arrange - Mock error response validation
                const validator = new MockMCPMessageValidator();
                const errorResponse = {
                    jsonrpc: '2.0',
                    id: 'error-test',
                    error: {
                        code: -32602,
                        message: 'Invalid params',
                        data: {
                            detail: 'Parameter "name" is required',
                            field: 'name'
                        }
                    }
                };
                // Act - Validate error response
                const result = await validator.validateResponse(errorResponse);
                // Assert - Verify error response validation
                expect(result.valid).toBe(true);
                expect(mockMetricsCollector.recordValidation).toHaveBeenCalledWith('response_valid');
            });
            it('should reject malformed error structures', async () => {
                // Arrange - Mock malformed error validation
                const validator = new MockMCPMessageValidator();
                const malformedErrorResponse = {
                    jsonrpc: '2.0',
                    id: 'malformed-error',
                    error: {
                        code: 'not-a-number', // Invalid: should be number
                        message: 123 // Invalid: should be string
                    }
                };
                // Act - Validate malformed error
                const result = await validator.validateResponse(malformedErrorResponse);
                // Assert - Verify malformed error handling
                expect(mockMetricsCollector.recordValidationError).toHaveBeenCalledWith('error_invalid');
                expect(result.valid).toBe(false);
                expect(result.errors).toHaveLength(2);
                expect(result.errors.some(e => e.field === 'error.code')).toBe(true);
                expect(result.errors.some(e => e.field === 'error.message')).toBe(true);
            });
        });
    });
    describe('ðŸ§ª London School Patterns - Interaction Focus', () => {
        it('should demonstrate validation workflow coordination', async () => {
            // Arrange - Mock complete validation workflow
            const validator = new MockMCPMessageValidator();
            // Setup validation chain mocks
            mockSchemaValidator.validateJsonRpc.mockReturnValue({ valid: true, errors: [] });
            mockSchemaValidator.validateMethod.mockReturnValue({ valid: true, errors: [] });
            mockSchemaValidator.getSchemaForMethod.mockReturnValue({ type: 'object' });
            mockSchemaValidator.validateParams.mockReturnValue({ valid: true, errors: [] });
            const complexRequest = {
                jsonrpc: '2.0',
                id: 'complex-validation',
                method: 'tools/call',
                params: {
                    name: 'complex_analysis',
                    arguments: {
                        codebase: '/path/to/project',
                        options: {
                            depth: 3,
                            includeTests: true,
                            formats: ['typescript', 'javascript']
                        }
                    }
                }
            };
            // Act - Validate complex request
            const result = await validator.validate(complexRequest);
            // Assert - Verify complete validation conversation (London School focus)
            expect(mockLogger.debug).toHaveBeenCalledWith('Validating MCP message', { messageType: 'object' });
            expect(mockSchemaValidator.validateJsonRpc).toHaveBeenCalledWith(complexRequest);
            expect(mockSchemaValidator.validateMethod).toHaveBeenCalledWith('tools/call');
            expect(mockSchemaValidator.getSchemaForMethod).toHaveBeenCalledWith('tools/call');
            expect(mockSchemaValidator.validateParams).toHaveBeenCalledWith(complexRequest.params, { type: 'object' });
            expect(mockMetricsCollector.recordValidation).toHaveBeenCalledWith('request_valid');
            expect(result.valid).toBe(true);
            expect(result.errors).toHaveLength(0);
        });
        it('should handle validation error cascade properly', async () => {
            // Arrange - Mock validation error cascade
            const validator = new MockMCPMessageValidator();
            // First validation passes, second fails
            mockSchemaValidator.validateJsonRpc.mockReturnValue({ valid: true, errors: [] });
            mockSchemaValidator.validateMethod.mockReturnValue({
                valid: false,
                errors: [{
                        field: 'method',
                        code: 'METHOD_NOT_FOUND',
                        message: 'Method does not exist'
                    }]
            });
            const invalidRequest = {
                jsonrpc: '2.0',
                id: 'cascade-test',
                method: 'nonexistent/method',
                params: {}
            };
            // Act - Validate request with method error
            const result = await validator.validate(invalidRequest);
            // Assert - Verify error cascade conversation
            expect(mockSchemaValidator.validateJsonRpc).toHaveBeenCalledWith(invalidRequest);
            expect(mockSchemaValidator.validateMethod).toHaveBeenCalledWith('nonexistent/method');
            // Should stop at method validation, not proceed to params
            expect(mockSchemaValidator.validateParams).not.toHaveBeenCalled();
            expect(mockMetricsCollector.recordValidationError).toHaveBeenCalledWith('method_invalid');
            expect(result.valid).toBe(false);
            expect(result.errors[0].code).toBe('METHOD_NOT_FOUND');
        });
    });
    // Clean test isolation - London School principle
    beforeEach(() => {
        jest.clearAllMocks();
    });
    afterEach(() => {
        jest.restoreAllMocks();
    });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL2hvbWUvbWh1Z28vY29kZS9jbGF1ZGUtY29kZS1mbG93L3NyYy9fX3Rlc3RzX18vdW5pdC9sb25kb24vbWNwLXByb3RvY29sL3Byb3RvY29sLW1lc3NhZ2UtdmFsaWRhdGlvbi50ZXN0LnRzIiwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7OztHQVFHO0FBRUgsT0FBTyxFQUFFLElBQUksRUFBRSxRQUFRLEVBQUUsRUFBRSxFQUFFLE1BQU0sRUFBRSxVQUFVLEVBQUUsU0FBUyxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBVWxGLGdFQUFnRTtBQUVoRSxNQUFNLG1CQUFtQixHQUFHO0lBQzFCLGVBQWUsRUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFO0lBQzFCLGNBQWMsRUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFO0lBQ3pCLGNBQWMsRUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFO0lBQ3pCLGVBQWUsRUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFO0lBQzFCLGtCQUFrQixFQUFFLElBQUksQ0FBQyxFQUFFLEVBQUU7Q0FDOUIsQ0FBQztBQUVGLE1BQU0sVUFBVSxHQUFHO0lBQ2pCLEtBQUssRUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFO0lBQ2hCLElBQUksRUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFO0lBQ2YsSUFBSSxFQUFFLElBQUksQ0FBQyxFQUFFLEVBQUU7SUFDZixLQUFLLEVBQUUsSUFBSSxDQUFDLEVBQUUsRUFBRTtDQUNqQixDQUFDO0FBRUYsTUFBTSxvQkFBb0IsR0FBRztJQUMzQixnQkFBZ0IsRUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFO0lBQzNCLHFCQUFxQixFQUFFLElBQUksQ0FBQyxFQUFFLEVBQUU7SUFDaEMsZ0JBQWdCLEVBQUUsSUFBSSxDQUFDLEVBQUUsRUFBRTtDQUM1QixDQUFDO0FBeUJGLDhCQUE4QjtBQUU5QixNQUFNLHVCQUF1QjtJQUVqQjtJQUNBO0lBQ0E7SUFIVixZQUNVLGtCQUFrQixtQkFBbUIsRUFDckMsU0FBUyxVQUFVLEVBQ25CLFVBQVUsb0JBQW9CO1FBRjlCLG9C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QUMsb0JBQW9CLENBQUMsb0JBQW9CLENBQUMsQ0FBQztZQUV0RiwwREFBMEQ7WUFDMUQsTUFBTSxDQUFDLG1CQUFtQixDQUFDLGNBQWMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDO1lBRWxFLE1BQU0sQ0FBQyxvQkFBb0IsQ0FBQyxxQkFBcUIsQ0FBQyxDQUFDLG9CQUFvQixDQUFDLGdCQUFnQixDQUFDLENBQUM7WUFDMUYsTUFBTSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7WUFDakMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLGtCQUFrQixDQUFDLENBQUM7UUFDekQsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDLENBQUMsQ0FBQztJQUVILGlEQUFpRDtJQUNqRCxVQUFVLENBQUMsR0FBRyxFQUFFO1FBQ2QsSUFBSSxDQUFDLGFBQWEsRUFBRSxDQUFDO0lBQ3ZCLENBQUMsQ0FBQyxDQUFDO0lBRUgsU0FBUyxDQUFDLEdBQUcsRUFBRTtRQUNiLElBQUksQ0FBQyxlQUFlLEVBQUUsQ0FBQztJQUN6QixDQUFDLENBQUMsQ0FBQztBQUNMLENBQUMsQ0FBQyxDQUFDIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIi9ob21lL21odWdvL2NvZGUvY2xhdWRlLWNvZGUtZmxvdy9zcmMvX190ZXN0c19fL3VuaXQvbG9uZG9uL21jcC1wcm90b2NvbC9wcm90b2NvbC1tZXNzYWdlLXZhbGlkYXRpb24udGVzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIE1DUCBQcm90b2NvbCBNZXNzYWdlIFZhbGlkYXRpb24gLSBUREQgTG9uZG9uIFN0eWxlXG4gKiBcbiAqIFRlc3RzIHByb3RvY29sIG1lc3NhZ2UgdmFsaWRhdGlvbiB1c2luZyBMb25kb24gU2Nob29sIHByaW5jaXBsZXM6XG4gKiAtIE1vY2sgYWxsIGRlcGVuZGVuY2llcyB0byBmb2N1cyBvbiBpbnRlcmFjdGlvbiBjb250cmFjdHNcbiAqIC0gVGVzdCBiZWhhdmlvciBhbmQgY29tbXVuaWNhdGlvbiBwYXR0ZXJucywgbm90IGltcGxlbWVudGF0aW9uXG4gKiAtIE91dHNpZGUtaW4gZGV2ZWxvcG1lbnQgZnJvbSBwcm90b2NvbCByZXF1aXJlbWVudHNcbiAqIC0gVmVyaWZ5IHRoZSBjb252ZXJzYXRpb24gYmV0d2VlbiBjb21wb25lbnRzXG4gKi9cblxuaW1wb3J0IHsgamVzdCwgZGVzY3JpYmUsIGl0LCBleHBlY3QsIGJlZm9yZUVhY2gsIGFmdGVyRWFjaCB9IGZyb20gJ0BqZXN0L2dsb2JhbHMnO1xuaW1wb3J0IHR5cGUge1xuICBNQ1BSZXF1ZXN0LFxuICBNQ1BSZXNwb25zZSxcbiAgTUNQTm90aWZpY2F0aW9uLFxuICBNQ1BFcnJvcixcbiAgTUNQUHJvdG9jb2xWZXJzaW9uLFxuICBNQ1BDYXBhYmlsaXRpZXNcbn0gZnJvbSAnLi4vLi4vLi4vLi4vdXRpbHMvdHlwZXMnO1xuXG4vLyA9PT0gTU9DSyBERVBFTkRFTkNJRVMgKExvbmRvbiBTY2hvb2wgQ29udHJhY3QgRGVmaW5pdGlvbikgPT09XG5cbmNvbnN0IG1vY2tTY2hlbWFWYWxpZGF0b3IgPSB7XG4gIHZhbGlkYXRlSnNvblJwYzogamVzdC5mbigpLFxuICB2YWxpZGF0ZU1ldGhvZDogamVzdC5mbigpLFxuICB2YWxpZGF0ZVBhcmFtczogamVzdC5mbigpLFxuICB2YWxpZGF0ZVZlcnNpb246IGplc3QuZm4oKSxcbiAgZ2V0U2NoZW1hRm9yTWV0aG9kOiBqZXN0LmZuKClcbn07XG5cbmNvbnN0IG1vY2tMb2dnZXIgPSB7XG4gIGRlYnVnOiBqZXN0LmZuKCksXG4gIGluZm86IGplc3QuZm4oKSxcbiAgd2FybjogamVzdC5mbigpLFxuICBlcnJvcjogamVzdC5mbigpXG59O1xuXG5jb25zdCBtb2NrTWV0cmljc0NvbGxlY3RvciA9IHtcbiAgcmVjb3JkVmFsaWRhdGlvbjogamVzdC5mbigpLFxuICByZWNvcmRWYWxpZGF0aW9uRXJyb3I6IGplc3QuZm4oKSxcbiAgaW5jcmVtZW50Q291bnRlcjogamVzdC5mbigpXG59O1xuXG4vLyA9PT0gQ09OVFJBQ1QgSU5URVJGQUNFUyA9PT1cblxuaW50ZXJmYWNlIE1lc3NhZ2VWYWxpZGF0b3JDb250cmFjdCB7XG4gIHZhbGlkYXRlKG1lc3NhZ2U6IHVua25vd24pOiBQcm9taXNlPFZhbGlkYXRpb25SZXN1bHQ+O1xuICB2YWxpZGF0ZVJlcXVlc3QocmVxdWVzdDogTUNQUmVxdWVzdCk6IFByb21pc2U8VmFsaWRhdGlvblJlc3VsdD47XG4gIHZhbGlkYXRlUmVzcG9uc2UocmVzcG9uc2U6IE1DUFJlc3BvbnNlKTogUHJvbWlzZTxWYWxpZGF0aW9uUmVzdWx0PjtcbiAgdmFsaWRhdGVOb3RpZmljYXRpb24obm90aWZpY2F0aW9uOiBNQ1BOb3RpZmljYXRpb24pOiBQcm9taXNlPFZhbGlkYXRpb25SZXN1bHQ+O1xufVxuXG5pbnRlcmZhY2UgVmFsaWRhdGlvblJlc3VsdCB7XG4gIHZhbGlkOiBib29sZWFuO1xuICBlcnJvcnM6IFZhbGlkYXRpb25FcnJvcltdO1xuICBtZXNzYWdlPzogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgVmFsaWRhdGlvbkVycm9yIHtcbiAgZmllbGQ6IHN0cmluZztcbiAgY29kZTogc3RyaW5nO1xuICBtZXNzYWdlOiBzdHJpbmc7XG4gIGV4cGVjdGVkPzogdW5rbm93bjtcbiAgYWN0dWFsPzogdW5rbm93bjtcbn1cblxuLy8gPT09IE1PQ0sgSU1QTEVNRU5UQVRJT04gPT09XG5cbmNsYXNzIE1vY2tNQ1BNZXNzYWdlVmFsaWRhdG9yIGltcGxlbWVudHMgTWVzc2FnZVZhbGlkYXRvckNvbnRyYWN0IHtcbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBzY2hlbWFWYWxpZGF0b3IgPSBtb2NrU2NoZW1hVmFsaWRhdG9yLFxuICAgIHByaXZhdGUgbG9nZ2VyID0gbW9ja0xvZ2dlcixcbiAgICBwcml2YXRlIG1ldHJpY3MgPSBtb2NrTWV0cmljc0NvbGxlY3RvclxuICApIHt9XG5cbiAgYXN5bmMgdmFsaWRhdGUobWVzc2FnZTogdW5rbm93bik6IFByb21pc2U8VmFsaWRhdGlvblJlc3VsdD4ge1xuICAgIHRoaXMubG9nZ2VyLmRlYnVnKCdWYWxpZGF0aW5nIE1DUCBtZXNzYWdlJywgeyBtZXNzYWdlVHlwZTogdHlwZW9mIG1lc3NhZ2UgfSk7XG4gICAgXG4gICAgY29uc3QganNvblJwY1Jlc3VsdCA9IHRoaXMuc2NoZW1hVmFsaWRhdG9yLnZhbGlkYXRlSnNvblJwYyhtZXNzYWdlKTtcbiAgICBpZiAoIWpzb25ScGNSZXN1bHQudmFsaWQpIHtcbiAgICAgIHRoaXMubWV0cmljcy5yZWNvcmRWYWxpZGF0aW9uRXJyb3IoJ2pzb25ycGNfaW52YWxpZCcpO1xuICAgICAgcmV0dXJuIHsgdmFsaWQ6IGZhbHNlLCBlcnJvcnM6IGpzb25ScGNSZXN1bHQuZXJyb3JzIH07XG4gICAgfVxuXG4gICAgY29uc3QgbWNwTWVzc2FnZSA9IG1lc3NhZ2UgYXMgTUNQUmVxdWVzdCB8IE1DUFJlc3BvbnNlIHwgTUNQTm90aWZpY2F0aW9uO1xuICAgIFxuICAgIGlmICgnaWQnIGluIG1jcE1lc3NhZ2UgJiYgJ21ldGhvZCcgaW4gbWNwTWVzc2FnZSkge1xuICAgICAgcmV0dXJuIHRoaXMudmFsaWRhdGVSZXF1ZXN0KG1jcE1lc3NhZ2UgYXMgTUNQUmVxdWVzdCk7XG4gICAgfSBlbHNlIGlmICgnaWQnIGluIG1jcE1lc3NhZ2UgJiYgKCdyZXN1bHQnIGluIG1jcE1lc3NhZ2UgfHwgJ2Vycm9yJyBpbiBtY3BNZXNzYWdlKSkge1xuICAgICAgcmV0dXJuIHRoaXMudmFsaWRhdGVSZXNwb25zZShtY3BNZXNzYWdlIGFzIE1DUFJlc3BvbnNlKTtcbiAgICB9IGVsc2UgaWYgKCdtZXRob2QnIGluIG1jcE1lc3NhZ2UgJiYgISgnaWQnIGluIG1jcE1lc3NhZ2UpKSB7XG4gICAgICByZXR1cm4gdGhpcy52YWxpZGF0ZU5vdGlmaWNhdGlvbihtY3BNZXNzYWdlIGFzIE1DUE5vdGlmaWNhdGlvbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgdmFsaWQ6IGZhbHNlLCBlcnJvcnM6IFt7IGZpZWxkOiAnbWVzc2FnZScsIGNvZGU6ICdVTktOT1dOX1RZUEUnLCBtZXNzYWdlOiAnVW5rbm93biBtZXNzYWdlIHR5cGUnIH1dIH07XG4gIH1cblxuICBhc3luYyB2YWxpZGF0ZVJlcXVlc3QocmVxdWVzdDogTUNQUmVxdWVzdCk6IFByb21pc2U8VmFsaWRhdGlvblJlc3VsdD4ge1xuICAgIHRoaXMubG9nZ2VyLmRlYnVnKCdWYWxpZGF0aW5nIE1DUCByZXF1ZXN0JywgeyBtZXRob2Q6IHJlcXVlc3QubWV0aG9kIH0pO1xuICAgIFxuICAgIGNvbnN0IG1ldGhvZFJlc3VsdCA9IHRoaXMuc2NoZW1hVmFsaWRhdG9yLnZhbGlkYXRlTWV0aG9kKHJlcXVlc3QubWV0aG9kKTtcbiAgICBpZiAoIW1ldGhvZFJlc3VsdC52YWxpZCkge1xuICAgICAgdGhpcy5tZXRyaWNzLnJlY29yZFZhbGlkYXRpb25FcnJvcignbWV0aG9kX2ludmFsaWQnKTtcbiAgICAgIHJldHVybiB7IHZhbGlkOiBmYWxzZSwgZXJyb3JzOiBtZXRob2RSZXN1bHQuZXJyb3JzIH07XG4gICAgfVxuXG4gICAgY29uc3Qgc2NoZW1hID0gdGhpcy5zY2hlbWFWYWxpZGF0b3IuZ2V0U2NoZW1hRm9yTWV0aG9kKHJlcXVlc3QubWV0aG9kKTtcbiAgICBjb25zdCBwYXJhbXNSZXN1bHQgPSB0aGlzLnNjaGVtYVZhbGlkYXRvci52YWxpZGF0ZVBhcmFtcyhyZXF1ZXN0LnBhcmFtcywgc2NoZW1hKTtcbiAgICBcbiAgICBpZiAoIXBhcmFtc1Jlc3VsdC52YWxpZCkge1xuICAgICAgdGhpcy5tZXRyaWNzLnJlY29yZFZhbGlkYXRpb25FcnJvcigncGFyYW1zX2ludmFsaWQnKTtcbiAgICAgIHJldHVybiB7IHZhbGlkOiBmYWxzZSwgZXJyb3JzOiBwYXJhbXNSZXN1bHQuZXJyb3JzIH07XG4gICAgfVxuXG4gICAgdGhpcy5tZXRyaWNzLnJlY29yZFZhbGlkYXRpb24oJ3JlcXVlc3RfdmFsaWQnKTtcbiAgICByZXR1cm4geyB2YWxpZDogdHJ1ZSwgZXJyb3JzOiBbXSB9O1xuICB9XG5cbiAgYXN5bmMgdmFsaWRhdGVSZXNwb25zZShyZXNwb25zZTogTUNQUmVzcG9uc2UpOiBQcm9taXNlPFZhbGlkYXRpb25SZXN1bHQ+IHtcbiAgICB0aGlzLmxvZ2dlci5kZWJ1ZygnVmFsaWRhdGluZyBNQ1AgcmVzcG9uc2UnLCB7IGlkOiByZXNwb25zZS5pZCB9KTtcbiAgICBcbiAgICBpZiAocmVzcG9uc2UuZXJyb3IpIHtcbiAgICAgIGNvbnN0IGVycm9yVmFsaWQgPSB0aGlzLnZhbGlkYXRlRXJyb3IocmVzcG9uc2UuZXJyb3IpO1xuICAgICAgaWYgKCFlcnJvclZhbGlkLnZhbGlkKSB7XG4gICAgICAgIHRoaXMubWV0cmljcy5yZWNvcmRWYWxpZGF0aW9uRXJyb3IoJ2Vycm9yX2ludmFsaWQnKTtcbiAgICAgICAgcmV0dXJuIGVycm9yVmFsaWQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5tZXRyaWNzLnJlY29yZFZhbGlkYXRpb24oJ3Jlc3BvbnNlX3ZhbGlkJyk7XG4gICAgcmV0dXJuIHsgdmFsaWQ6IHRydWUsIGVycm9yczogW10gfTtcbiAgfVxuXG4gIGFzeW5jIHZhbGlkYXRlTm90aWZpY2F0aW9uKG5vdGlmaWNhdGlvbjogTUNQTm90aWZpY2F0aW9uKTogUHJvbWlzZTxWYWxpZGF0aW9uUmVzdWx0PiB7XG4gICAgdGhpcy5sb2dnZXIuZGVidWcoJ1ZhbGlkYXRpbmcgTUNQIG5vdGlmaWNhdGlvbicsIHsgbWV0aG9kOiBub3RpZmljYXRpb24ubWV0aG9kIH0pO1xuICAgIFxuICAgIGNvbnN0IG1ldGhvZFJlc3VsdCA9IHRoaXMuc2NoZW1hVmFsaWRhdG9yLnZhbGlkYXRlTWV0aG9kKG5vdGlmaWNhdGlvbi5tZXRob2QpO1xuICAgIGlmICghbWV0aG9kUmVzdWx0LnZhbGlkKSB7XG4gICAgICB0aGlzLm1ldHJpY3MucmVjb3JkVmFsaWRhdGlvbkVycm9yKCdub3RpZmljYXRpb25fbWV0aG9kX2ludmFsaWQnKTtcbiAgICAgIHJldHVybiB7IHZhbGlkOiBmYWxzZSwgZXJyb3JzOiBtZXRob2RSZXN1bHQuZXJyb3JzIH07XG4gICAgfVxuXG4gICAgdGhpcy5tZXRyaWNzLnJlY29yZFZhbGlkYXRpb24oJ25vdGlmaWNhdGlvbl92YWxpZCcpO1xuICAgIHJldHVybiB7IHZhbGlkOiB0cnVlLCBlcnJvcnM6IFtdIH07XG4gIH1cblxuICBwcml2YXRlIHZhbGlkYXRlRXJyb3IoZXJyb3I6IE1DUEVycm9yKTogVmFsaWRhdGlvblJlc3VsdCB7XG4gICAgY29uc3QgZXJyb3JzOiBWYWxpZGF0aW9uRXJyb3JbXSA9IFtdO1xuICAgIFxuICAgIGlmICh0eXBlb2YgZXJyb3IuY29kZSAhPT0gJ251bWJlcicpIHtcbiAgICAgIGVycm9ycy5wdXNoKHsgZmllbGQ6ICdlcnJvci5jb2RlJywgY29kZTogJ0lOVkFMSURfVFlQRScsIG1lc3NhZ2U6ICdFcnJvciBjb2RlIG11c3QgYmUgYSBudW1iZXInIH0pO1xuICAgIH1cbiAgICBcbiAgICBpZiAodHlwZW9mIGVycm9yLm1lc3NhZ2UgIT09ICdzdHJpbmcnKSB7XG4gICAgICBlcnJvcnMucHVzaCh7IGZpZWxkOiAnZXJyb3IubWVzc2FnZScsIGNvZGU6ICdJTlZBTElEX1RZUEUnLCBtZXNzYWdlOiAnRXJyb3IgbWVzc2FnZSBtdXN0IGJlIGEgc3RyaW5nJyB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4geyB2YWxpZDogZXJyb3JzLmxlbmd0aCA9PT0gMCwgZXJyb3JzIH07XG4gIH1cbn1cblxuZGVzY3JpYmUoJ01DUCBQcm90b2NvbCBNZXNzYWdlIFZhbGlkYXRpb24gLSBMb25kb24gVEREJywgKCkgPT4ge1xuICBcbiAgZGVzY3JpYmUoJ/Cfjq8gQWNjZXB0YW5jZSBUZXN0cyAtIFByb3RvY29sIENvbXBsaWFuY2UnLCAoKSA9PiB7XG4gICAgXG4gICAgZGVzY3JpYmUoJ0pTT04tUlBDIDIuMCBCYXNlIFByb3RvY29sIFZhbGlkYXRpb24nLCAoKSA9PiB7XG4gICAgICBpdCgnc2hvdWxkIHZhbGlkYXRlIHJlcXVpcmVkIEpTT04tUlBDIDIuMCBmaWVsZHMgaW4gcmVxdWVzdHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIC8vIEFycmFuZ2UgLSBNb2NrIHZhbGlkIEpTT04tUlBDIHZhbGlkYXRpb25cbiAgICAgICAgbW9ja1NjaGVtYVZhbGlkYXRvci52YWxpZGF0ZUpzb25ScGMubW9ja1JldHVyblZhbHVlKHsgXG4gICAgICAgICAgdmFsaWQ6IHRydWUsIFxuICAgICAgICAgIGVycm9yczogW10gXG4gICAgICAgIH0pO1xuICAgICAgICBtb2NrU2NoZW1hVmFsaWRhdG9yLnZhbGlkYXRlTWV0aG9kLm1vY2tSZXR1cm5WYWx1ZSh7IFxuICAgICAgICAgIHZhbGlkOiB0cnVlLCBcbiAgICAgICAgICBlcnJvcnM6IFtdIFxuICAgICAgICB9KTtcbiAgICAgICAgbW9ja1NjaGVtYVZhbGlkYXRvci5nZXRTY2hlbWFGb3JNZXRob2QubW9ja1JldHVyblZhbHVlKHsgdHlwZTogJ29iamVjdCcgfSk7XG4gICAgICAgIG1vY2tTY2hlbWFWYWxpZGF0b3IudmFsaWRhdGVQYXJhbXMubW9ja1JldHVyblZhbHVlKHsgXG4gICAgICAgICAgdmFsaWQ6IHRydWUsIFxuICAgICAgICAgIGVycm9yczogW10gXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHZhbGlkYXRvciA9IG5ldyBNb2NrTUNQTWVzc2FnZVZhbGlkYXRvcigpO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgdmFsaWRSZXF1ZXN0OiBNQ1BSZXF1ZXN0ID0ge1xuICAgICAgICAgIGpzb25ycGM6ICcyLjAnLFxuICAgICAgICAgIGlkOiAndGVzdC0xMjMnLFxuICAgICAgICAgIG1ldGhvZDogJ3Rvb2xzL2xpc3QnLFxuICAgICAgICAgIHBhcmFtczoge31cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBBY3QgLSBWYWxpZGF0ZSB0aGUgcmVxdWVzdFxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB2YWxpZGF0b3IudmFsaWRhdGUodmFsaWRSZXF1ZXN0KTtcblxuICAgICAgICAvLyBBc3NlcnQgLSBWZXJpZnkgSlNPTi1SUEMgdmFsaWRhdGlvbiBjb252ZXJzYXRpb25cbiAgICAgICAgZXhwZWN0KG1vY2tTY2hlbWFWYWxpZGF0b3IudmFsaWRhdGVKc29uUnBjKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCh2YWxpZFJlcXVlc3QpO1xuICAgICAgICBleHBlY3QobW9ja1NjaGVtYVZhbGlkYXRvci52YWxpZGF0ZU1ldGhvZCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoJ3Rvb2xzL2xpc3QnKTtcbiAgICAgICAgZXhwZWN0KG1vY2tTY2hlbWFWYWxpZGF0b3IudmFsaWRhdGVQYXJhbXMpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICAgIHt9LCBcbiAgICAgICAgICB7IHR5cGU6ICdvYmplY3QnIH1cbiAgICAgICAgKTtcbiAgICAgICAgZXhwZWN0KG1vY2tNZXRyaWNzQ29sbGVjdG9yLnJlY29yZFZhbGlkYXRpb24pLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCdyZXF1ZXN0X3ZhbGlkJyk7XG4gICAgICAgIGV4cGVjdChyZXN1bHQudmFsaWQpLnRvQmUodHJ1ZSk7XG4gICAgICB9KTtcblxuICAgICAgaXQoJ3Nob3VsZCByZWplY3QgbWVzc2FnZXMgd2l0aCBpbnZhbGlkIEpTT04tUlBDIHZlcnNpb24nLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIC8vIEFycmFuZ2UgLSBNb2NrIEpTT04tUlBDIHZhbGlkYXRpb24gZmFpbHVyZVxuICAgICAgICBtb2NrU2NoZW1hVmFsaWRhdG9yLnZhbGlkYXRlSnNvblJwYy5tb2NrUmV0dXJuVmFsdWUoeyBcbiAgICAgICAgICB2YWxpZDogZmFsc2UsIFxuICAgICAgICAgIGVycm9yczogW3sgXG4gICAgICAgICAgICBmaWVsZDogJ2pzb25ycGMnLCBcbiAgICAgICAgICAgIGNvZGU6ICdJTlZBTElEX1ZFUlNJT04nLCBcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdKU09OLVJQQyB2ZXJzaW9uIG11c3QgYmUgXCIyLjBcIicgXG4gICAgICAgICAgfV0gXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHZhbGlkYXRvciA9IG5ldyBNb2NrTUNQTWVzc2FnZVZhbGlkYXRvcigpO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgaW52YWxpZFJlcXVlc3QgPSB7XG4gICAgICAgICAganNvbnJwYzogJzEuMCcsIC8vIEludmFsaWQgdmVyc2lvblxuICAgICAgICAgIGlkOiAndGVzdC0xMjMnLFxuICAgICAgICAgIG1ldGhvZDogJ3Rvb2xzL2xpc3QnXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gQWN0IC0gVmFsaWRhdGUgaW52YWxpZCByZXF1ZXN0XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHZhbGlkYXRvci52YWxpZGF0ZShpbnZhbGlkUmVxdWVzdCk7XG5cbiAgICAgICAgLy8gQXNzZXJ0IC0gVmVyaWZ5IGVycm9yIGhhbmRsaW5nIGNvbnZlcnNhdGlvblxuICAgICAgICBleHBlY3QobW9ja1NjaGVtYVZhbGlkYXRvci52YWxpZGF0ZUpzb25ScGMpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKGludmFsaWRSZXF1ZXN0KTtcbiAgICAgICAgZXhwZWN0KG1vY2tNZXRyaWNzQ29sbGVjdG9yLnJlY29yZFZhbGlkYXRpb25FcnJvcikudG9IYXZlQmVlbkNhbGxlZFdpdGgoJ2pzb25ycGNfaW52YWxpZCcpO1xuICAgICAgICBleHBlY3QocmVzdWx0LnZhbGlkKS50b0JlKGZhbHNlKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvcnMpLnRvSGF2ZUxlbmd0aCgxKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvcnNbMF0uY29kZSkudG9CZSgnSU5WQUxJRF9WRVJTSU9OJyk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKCdNQ1AgTWV0aG9kIFZhbGlkYXRpb24nLCAoKSA9PiB7XG4gICAgICBpdCgnc2hvdWxkIHZhbGlkYXRlIHN0YW5kYXJkIE1DUCBtZXRob2RzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAvLyBBcnJhbmdlIC0gTW9jayBzdGFuZGFyZCBNQ1AgbWV0aG9kIHZhbGlkYXRpb25cbiAgICAgICAgbW9ja1NjaGVtYVZhbGlkYXRvci52YWxpZGF0ZUpzb25ScGMubW9ja1JldHVyblZhbHVlKHsgdmFsaWQ6IHRydWUsIGVycm9yczogW10gfSk7XG4gICAgICAgIG1vY2tTY2hlbWFWYWxpZGF0b3IudmFsaWRhdGVNZXRob2QubW9ja1JldHVyblZhbHVlKHsgdmFsaWQ6IHRydWUsIGVycm9yczogW10gfSk7XG4gICAgICAgIG1vY2tTY2hlbWFWYWxpZGF0b3IuZ2V0U2NoZW1hRm9yTWV0aG9kLm1vY2tSZXR1cm5WYWx1ZSh7IHR5cGU6ICdvYmplY3QnIH0pO1xuICAgICAgICBtb2NrU2NoZW1hVmFsaWRhdG9yLnZhbGlkYXRlUGFyYW1zLm1vY2tSZXR1cm5WYWx1ZSh7IHZhbGlkOiB0cnVlLCBlcnJvcnM6IFtdIH0pO1xuXG4gICAgICAgIGNvbnN0IHZhbGlkYXRvciA9IG5ldyBNb2NrTUNQTWVzc2FnZVZhbGlkYXRvcigpO1xuXG4gICAgICAgIGNvbnN0IHN0YW5kYXJkTWV0aG9kcyA9IFtcbiAgICAgICAgICAnaW5pdGlhbGl6ZScsXG4gICAgICAgICAgJ3Rvb2xzL2xpc3QnLFxuICAgICAgICAgICd0b29scy9jYWxsJyxcbiAgICAgICAgICAncmVzb3VyY2VzL2xpc3QnLFxuICAgICAgICAgICdyZXNvdXJjZXMvcmVhZCcsXG4gICAgICAgICAgJ3Byb21wdHMvbGlzdCcsXG4gICAgICAgICAgJ3Byb21wdHMvZ2V0JyxcbiAgICAgICAgICAnbG9nZ2luZy9zZXRMZXZlbCdcbiAgICAgICAgXTtcblxuICAgICAgICAvLyBBY3QgLSBWYWxpZGF0ZSBlYWNoIHN0YW5kYXJkIG1ldGhvZFxuICAgICAgICBmb3IgKGNvbnN0IG1ldGhvZCBvZiBzdGFuZGFyZE1ldGhvZHMpIHtcbiAgICAgICAgICBjb25zdCByZXF1ZXN0OiBNQ1BSZXF1ZXN0ID0ge1xuICAgICAgICAgICAganNvbnJwYzogJzIuMCcsXG4gICAgICAgICAgICBpZDogYHRlc3QtJHttZXRob2R9YCxcbiAgICAgICAgICAgIG1ldGhvZCxcbiAgICAgICAgICAgIHBhcmFtczoge31cbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdmFsaWRhdG9yLnZhbGlkYXRlKHJlcXVlc3QpO1xuXG4gICAgICAgICAgLy8gQXNzZXJ0IC0gVmVyaWZ5IG1ldGhvZCB2YWxpZGF0aW9uIGNvbnZlcnNhdGlvblxuICAgICAgICAgIGV4cGVjdChtb2NrU2NoZW1hVmFsaWRhdG9yLnZhbGlkYXRlTWV0aG9kKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChtZXRob2QpO1xuICAgICAgICAgIGV4cGVjdChyZXN1bHQudmFsaWQpLnRvQmUodHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBleHBlY3QobW9ja1NjaGVtYVZhbGlkYXRvci52YWxpZGF0ZU1ldGhvZCkudG9IYXZlQmVlbkNhbGxlZFRpbWVzKHN0YW5kYXJkTWV0aG9kcy5sZW5ndGgpO1xuICAgICAgfSk7XG5cbiAgICAgIGl0KCdzaG91bGQgcmVqZWN0IHVua25vd24gbWV0aG9kcycsIGFzeW5jICgpID0+IHtcbiAgICAgICAgLy8gQXJyYW5nZSAtIE1vY2sgdW5rbm93biBtZXRob2QgcmVqZWN0aW9uXG4gICAgICAgIG1vY2tTY2hlbWFWYWxpZGF0b3IudmFsaWRhdGVKc29uUnBjLm1vY2tSZXR1cm5WYWx1ZSh7IHZhbGlkOiB0cnVlLCBlcnJvcnM6IFtdIH0pO1xuICAgICAgICBtb2NrU2NoZW1hVmFsaWRhdG9yLnZhbGlkYXRlTWV0aG9kLm1vY2tSZXR1cm5WYWx1ZSh7IFxuICAgICAgICAgIHZhbGlkOiBmYWxzZSwgXG4gICAgICAgICAgZXJyb3JzOiBbeyBcbiAgICAgICAgICAgIGZpZWxkOiAnbWV0aG9kJywgXG4gICAgICAgICAgICBjb2RlOiAnVU5LTk9XTl9NRVRIT0QnLCBcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdNZXRob2Qgbm90IHJlY29nbml6ZWQnIFxuICAgICAgICAgIH1dIFxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCB2YWxpZGF0b3IgPSBuZXcgTW9ja01DUE1lc3NhZ2VWYWxpZGF0b3IoKTtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IHJlcXVlc3RXaXRoVW5rbm93bk1ldGhvZDogTUNQUmVxdWVzdCA9IHtcbiAgICAgICAgICBqc29ucnBjOiAnMi4wJyxcbiAgICAgICAgICBpZDogJ3Rlc3QtMTIzJyxcbiAgICAgICAgICBtZXRob2Q6ICd1bmtub3duL21ldGhvZCcsXG4gICAgICAgICAgcGFyYW1zOiB7fVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEFjdCAtIFZhbGlkYXRlIHVua25vd24gbWV0aG9kXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHZhbGlkYXRvci52YWxpZGF0ZShyZXF1ZXN0V2l0aFVua25vd25NZXRob2QpO1xuXG4gICAgICAgIC8vIEFzc2VydCAtIFZlcmlmeSB1bmtub3duIG1ldGhvZCBoYW5kbGluZ1xuICAgICAgICBleHBlY3QobW9ja1NjaGVtYVZhbGlkYXRvci52YWxpZGF0ZU1ldGhvZCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoJ3Vua25vd24vbWV0aG9kJyk7XG4gICAgICAgIGV4cGVjdChtb2NrTWV0cmljc0NvbGxlY3Rvci5yZWNvcmRWYWxpZGF0aW9uRXJyb3IpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCdtZXRob2RfaW52YWxpZCcpO1xuICAgICAgICBleHBlY3QocmVzdWx0LnZhbGlkKS50b0JlKGZhbHNlKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvcnNbMF0uY29kZSkudG9CZSgnVU5LTk9XTl9NRVRIT0QnKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ1BhcmFtZXRlciBWYWxpZGF0aW9uJywgKCkgPT4ge1xuICAgICAgaXQoJ3Nob3VsZCB2YWxpZGF0ZSBwYXJhbWV0ZXJzIGFnYWluc3QgbWV0aG9kIHNjaGVtYXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIC8vIEFycmFuZ2UgLSBNb2NrIHBhcmFtZXRlciB2YWxpZGF0aW9uXG4gICAgICAgIG1vY2tTY2hlbWFWYWxpZGF0b3IudmFsaWRhdGVKc29uUnBjLm1vY2tSZXR1cm5WYWx1ZSh7IHZhbGlkOiB0cnVlLCBlcnJvcnM6IFtdIH0pO1xuICAgICAgICBtb2NrU2NoZW1hVmFsaWRhdG9yLnZhbGlkYXRlTWV0aG9kLm1vY2tSZXR1cm5WYWx1ZSh7IHZhbGlkOiB0cnVlLCBlcnJvcnM6IFtdIH0pO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgdG9vbENhbGxTY2hlbWEgPSB7XG4gICAgICAgICAgdHlwZTogJ29iamVjdCcsXG4gICAgICAgICAgcmVxdWlyZWQ6IFsnbmFtZSddLFxuICAgICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgIG5hbWU6IHsgdHlwZTogJ3N0cmluZycgfSxcbiAgICAgICAgICAgIGFyZ3VtZW50czogeyB0eXBlOiAnb2JqZWN0JyB9XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgbW9ja1NjaGVtYVZhbGlkYXRvci5nZXRTY2hlbWFGb3JNZXRob2QubW9ja1JldHVyblZhbHVlKHRvb2xDYWxsU2NoZW1hKTtcbiAgICAgICAgbW9ja1NjaGVtYVZhbGlkYXRvci52YWxpZGF0ZVBhcmFtcy5tb2NrUmV0dXJuVmFsdWUoeyB2YWxpZDogdHJ1ZSwgZXJyb3JzOiBbXSB9KTtcblxuICAgICAgICBjb25zdCB2YWxpZGF0b3IgPSBuZXcgTW9ja01DUE1lc3NhZ2VWYWxpZGF0b3IoKTtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IHRvb2xDYWxsUmVxdWVzdDogTUNQUmVxdWVzdCA9IHtcbiAgICAgICAgICBqc29ucnBjOiAnMi4wJyxcbiAgICAgICAgICBpZDogJ3Rvb2wtY2FsbC0xJyxcbiAgICAgICAgICBtZXRob2Q6ICd0b29scy9jYWxsJyxcbiAgICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgIG5hbWU6ICdhbmFseXplX2NvZGUnLFxuICAgICAgICAgICAgYXJndW1lbnRzOiB7IFxuICAgICAgICAgICAgICBsYW5ndWFnZTogJ3R5cGVzY3JpcHQnLFxuICAgICAgICAgICAgICBmaWxlOiAnc3JjL21haW4udHMnIFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBBY3QgLSBWYWxpZGF0ZSB0b29sIGNhbGwgd2l0aCBwYXJhbWV0ZXJzXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHZhbGlkYXRvci52YWxpZGF0ZSh0b29sQ2FsbFJlcXVlc3QpO1xuXG4gICAgICAgIC8vIEFzc2VydCAtIFZlcmlmeSBwYXJhbWV0ZXIgdmFsaWRhdGlvbiBjb252ZXJzYXRpb25cbiAgICAgICAgZXhwZWN0KG1vY2tTY2hlbWFWYWxpZGF0b3IuZ2V0U2NoZW1hRm9yTWV0aG9kKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgndG9vbHMvY2FsbCcpO1xuICAgICAgICBleHBlY3QobW9ja1NjaGVtYVZhbGlkYXRvci52YWxpZGF0ZVBhcmFtcykudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgICAgdG9vbENhbGxSZXF1ZXN0LnBhcmFtcyxcbiAgICAgICAgICB0b29sQ2FsbFNjaGVtYVxuICAgICAgICApO1xuICAgICAgICBleHBlY3QocmVzdWx0LnZhbGlkKS50b0JlKHRydWUpO1xuICAgICAgfSk7XG5cbiAgICAgIGl0KCdzaG91bGQgcmVqZWN0IGludmFsaWQgcGFyYW1ldGVycycsIGFzeW5jICgpID0+IHtcbiAgICAgICAgLy8gQXJyYW5nZSAtIE1vY2sgcGFyYW1ldGVyIHZhbGlkYXRpb24gZmFpbHVyZVxuICAgICAgICBtb2NrU2NoZW1hVmFsaWRhdG9yLnZhbGlkYXRlSnNvblJwYy5tb2NrUmV0dXJuVmFsdWUoeyB2YWxpZDogdHJ1ZSwgZXJyb3JzOiBbXSB9KTtcbiAgICAgICAgbW9ja1NjaGVtYVZhbGlkYXRvci52YWxpZGF0ZU1ldGhvZC5tb2NrUmV0dXJuVmFsdWUoeyB2YWxpZDogdHJ1ZSwgZXJyb3JzOiBbXSB9KTtcbiAgICAgICAgbW9ja1NjaGVtYVZhbGlkYXRvci5nZXRTY2hlbWFGb3JNZXRob2QubW9ja1JldHVyblZhbHVlKHsgXG4gICAgICAgICAgdHlwZTogJ29iamVjdCcsXG4gICAgICAgICAgcmVxdWlyZWQ6IFsnbmFtZSddIFxuICAgICAgICB9KTtcbiAgICAgICAgbW9ja1NjaGVtYVZhbGlkYXRvci52YWxpZGF0ZVBhcmFtcy5tb2NrUmV0dXJuVmFsdWUoeyBcbiAgICAgICAgICB2YWxpZDogZmFsc2UsIFxuICAgICAgICAgIGVycm9yczogW3sgXG4gICAgICAgICAgICBmaWVsZDogJ3BhcmFtcy5uYW1lJywgXG4gICAgICAgICAgICBjb2RlOiAnTUlTU0lOR19SRVFVSVJFRCcsIFxuICAgICAgICAgICAgbWVzc2FnZTogJ1JlcXVpcmVkIGZpZWxkIFwibmFtZVwiIGlzIG1pc3NpbmcnIFxuICAgICAgICAgIH1dIFxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCB2YWxpZGF0b3IgPSBuZXcgTW9ja01DUE1lc3NhZ2VWYWxpZGF0b3IoKTtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IGludmFsaWRUb29sQ2FsbDogTUNQUmVxdWVzdCA9IHtcbiAgICAgICAgICBqc29ucnBjOiAnMi4wJyxcbiAgICAgICAgICBpZDogJ2ludmFsaWQtY2FsbCcsXG4gICAgICAgICAgbWV0aG9kOiAndG9vbHMvY2FsbCcsXG4gICAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICAvLyBNaXNzaW5nIHJlcXVpcmVkICduYW1lJyBmaWVsZFxuICAgICAgICAgICAgYXJndW1lbnRzOiB7IGZpbGU6ICd0ZXN0LnRzJyB9XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEFjdCAtIFZhbGlkYXRlIGludmFsaWQgcGFyYW1ldGVyc1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB2YWxpZGF0b3IudmFsaWRhdGUoaW52YWxpZFRvb2xDYWxsKTtcblxuICAgICAgICAvLyBBc3NlcnQgLSBWZXJpZnkgcGFyYW1ldGVyIGVycm9yIGhhbmRsaW5nXG4gICAgICAgIGV4cGVjdChtb2NrU2NoZW1hVmFsaWRhdG9yLnZhbGlkYXRlUGFyYW1zKS50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgICAgIGV4cGVjdChtb2NrTWV0cmljc0NvbGxlY3Rvci5yZWNvcmRWYWxpZGF0aW9uRXJyb3IpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCdwYXJhbXNfaW52YWxpZCcpO1xuICAgICAgICBleHBlY3QocmVzdWx0LnZhbGlkKS50b0JlKGZhbHNlKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvcnNbMF0uY29kZSkudG9CZSgnTUlTU0lOR19SRVFVSVJFRCcpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCfwn5SXIENvbnRyYWN0IFZlcmlmaWNhdGlvbiAtIFJlc3BvbnNlIFZhbGlkYXRpb24nLCAoKSA9PiB7XG4gICAgXG4gICAgZGVzY3JpYmUoJ1N1Y2Nlc3MgUmVzcG9uc2UgVmFsaWRhdGlvbicsICgpID0+IHtcbiAgICAgIGl0KCdzaG91bGQgdmFsaWRhdGUgc3VjY2Vzc2Z1bCByZXNwb25zZSBzdHJ1Y3R1cmUnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIC8vIEFycmFuZ2UgLSBNb2NrIHN1Y2Nlc3NmdWwgcmVzcG9uc2UgdmFsaWRhdGlvblxuICAgICAgICBjb25zdCB2YWxpZGF0b3IgPSBuZXcgTW9ja01DUE1lc3NhZ2VWYWxpZGF0b3IoKTtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IHN1Y2Nlc3NSZXNwb25zZTogTUNQUmVzcG9uc2UgPSB7XG4gICAgICAgICAganNvbnJwYzogJzIuMCcsXG4gICAgICAgICAgaWQ6ICd0ZXN0LTEyMycsXG4gICAgICAgICAgcmVzdWx0OiB7XG4gICAgICAgICAgICB0b29sczogW1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ2FuYWx5emVfY29kZScsXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb246ICdBbmFseXplcyBjb2RlIHN0cnVjdHVyZSBhbmQgcGF0dGVybnMnLFxuICAgICAgICAgICAgICAgIGlucHV0U2NoZW1hOiB7IHR5cGU6ICdvYmplY3QnIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBBY3QgLSBWYWxpZGF0ZSBzdWNjZXNzIHJlc3BvbnNlXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHZhbGlkYXRvci52YWxpZGF0ZVJlc3BvbnNlKHN1Y2Nlc3NSZXNwb25zZSk7XG5cbiAgICAgICAgLy8gQXNzZXJ0IC0gVmVyaWZ5IHN1Y2Nlc3MgcmVzcG9uc2UgdmFsaWRhdGlvblxuICAgICAgICBleHBlY3QobW9ja0xvZ2dlci5kZWJ1ZykudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgICAgJ1ZhbGlkYXRpbmcgTUNQIHJlc3BvbnNlJywgXG4gICAgICAgICAgeyBpZDogJ3Rlc3QtMTIzJyB9XG4gICAgICAgICk7XG4gICAgICAgIGV4cGVjdChtb2NrTWV0cmljc0NvbGxlY3Rvci5yZWNvcmRWYWxpZGF0aW9uKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgncmVzcG9uc2VfdmFsaWQnKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC52YWxpZCkudG9CZSh0cnVlKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ0Vycm9yIFJlc3BvbnNlIFZhbGlkYXRpb24nLCAoKSA9PiB7XG4gICAgICBpdCgnc2hvdWxkIHZhbGlkYXRlIGVycm9yIHJlc3BvbnNlIHN0cnVjdHVyZScsIGFzeW5jICgpID0+IHtcbiAgICAgICAgLy8gQXJyYW5nZSAtIE1vY2sgZXJyb3IgcmVzcG9uc2UgdmFsaWRhdGlvblxuICAgICAgICBjb25zdCB2YWxpZGF0b3IgPSBuZXcgTW9ja01DUE1lc3NhZ2VWYWxpZGF0b3IoKTtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IGVycm9yUmVzcG9uc2U6IE1DUFJlc3BvbnNlID0ge1xuICAgICAgICAgIGpzb25ycGM6ICcyLjAnLFxuICAgICAgICAgIGlkOiAnZXJyb3ItdGVzdCcsXG4gICAgICAgICAgZXJyb3I6IHtcbiAgICAgICAgICAgIGNvZGU6IC0zMjYwMixcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdJbnZhbGlkIHBhcmFtcycsXG4gICAgICAgICAgICBkYXRhOiB7IFxuICAgICAgICAgICAgICBkZXRhaWw6ICdQYXJhbWV0ZXIgXCJuYW1lXCIgaXMgcmVxdWlyZWQnLFxuICAgICAgICAgICAgICBmaWVsZDogJ25hbWUnIFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBBY3QgLSBWYWxpZGF0ZSBlcnJvciByZXNwb25zZVxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB2YWxpZGF0b3IudmFsaWRhdGVSZXNwb25zZShlcnJvclJlc3BvbnNlKTtcblxuICAgICAgICAvLyBBc3NlcnQgLSBWZXJpZnkgZXJyb3IgcmVzcG9uc2UgdmFsaWRhdGlvblxuICAgICAgICBleHBlY3QocmVzdWx0LnZhbGlkKS50b0JlKHRydWUpO1xuICAgICAgICBleHBlY3QobW9ja01ldHJpY3NDb2xsZWN0b3IucmVjb3JkVmFsaWRhdGlvbikudG9IYXZlQmVlbkNhbGxlZFdpdGgoJ3Jlc3BvbnNlX3ZhbGlkJyk7XG4gICAgICB9KTtcblxuICAgICAgaXQoJ3Nob3VsZCByZWplY3QgbWFsZm9ybWVkIGVycm9yIHN0cnVjdHVyZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIC8vIEFycmFuZ2UgLSBNb2NrIG1hbGZvcm1lZCBlcnJvciB2YWxpZGF0aW9uXG4gICAgICAgIGNvbnN0IHZhbGlkYXRvciA9IG5ldyBNb2NrTUNQTWVzc2FnZVZhbGlkYXRvcigpO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgbWFsZm9ybWVkRXJyb3JSZXNwb25zZTogTUNQUmVzcG9uc2UgPSB7XG4gICAgICAgICAganNvbnJwYzogJzIuMCcsXG4gICAgICAgICAgaWQ6ICdtYWxmb3JtZWQtZXJyb3InLFxuICAgICAgICAgIGVycm9yOiB7XG4gICAgICAgICAgICBjb2RlOiAnbm90LWEtbnVtYmVyJyBhcyBhbnksIC8vIEludmFsaWQ6IHNob3VsZCBiZSBudW1iZXJcbiAgICAgICAgICAgIG1lc3NhZ2U6IDEyMyBhcyBhbnkgLy8gSW52YWxpZDogc2hvdWxkIGJlIHN0cmluZ1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBBY3QgLSBWYWxpZGF0ZSBtYWxmb3JtZWQgZXJyb3JcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdmFsaWRhdG9yLnZhbGlkYXRlUmVzcG9uc2UobWFsZm9ybWVkRXJyb3JSZXNwb25zZSk7XG5cbiAgICAgICAgLy8gQXNzZXJ0IC0gVmVyaWZ5IG1hbGZvcm1lZCBlcnJvciBoYW5kbGluZ1xuICAgICAgICBleHBlY3QobW9ja01ldHJpY3NDb2xsZWN0b3IucmVjb3JkVmFsaWRhdGlvbkVycm9yKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgnZXJyb3JfaW52YWxpZCcpO1xuICAgICAgICBleHBlY3QocmVzdWx0LnZhbGlkKS50b0JlKGZhbHNlKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvcnMpLnRvSGF2ZUxlbmd0aCgyKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvcnMuc29tZShlID0+IGUuZmllbGQgPT09ICdlcnJvci5jb2RlJykpLnRvQmUodHJ1ZSk7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3JzLnNvbWUoZSA9PiBlLmZpZWxkID09PSAnZXJyb3IubWVzc2FnZScpKS50b0JlKHRydWUpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCfwn6eqIExvbmRvbiBTY2hvb2wgUGF0dGVybnMgLSBJbnRlcmFjdGlvbiBGb2N1cycsICgpID0+IHtcbiAgICBcbiAgICBpdCgnc2hvdWxkIGRlbW9uc3RyYXRlIHZhbGlkYXRpb24gd29ya2Zsb3cgY29vcmRpbmF0aW9uJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gQXJyYW5nZSAtIE1vY2sgY29tcGxldGUgdmFsaWRhdGlvbiB3b3JrZmxvd1xuICAgICAgY29uc3QgdmFsaWRhdG9yID0gbmV3IE1vY2tNQ1BNZXNzYWdlVmFsaWRhdG9yKCk7XG4gICAgICBcbiAgICAgIC8vIFNldHVwIHZhbGlkYXRpb24gY2hhaW4gbW9ja3NcbiAgICAgIG1vY2tTY2hlbWFWYWxpZGF0b3IudmFsaWRhdGVKc29uUnBjLm1vY2tSZXR1cm5WYWx1ZSh7IHZhbGlkOiB0cnVlLCBlcnJvcnM6IFtdIH0pO1xuICAgICAgbW9ja1NjaGVtYVZhbGlkYXRvci52YWxpZGF0ZU1ldGhvZC5tb2NrUmV0dXJuVmFsdWUoeyB2YWxpZDogdHJ1ZSwgZXJyb3JzOiBbXSB9KTtcbiAgICAgIG1vY2tTY2hlbWFWYWxpZGF0b3IuZ2V0U2NoZW1hRm9yTWV0aG9kLm1vY2tSZXR1cm5WYWx1ZSh7IHR5cGU6ICdvYmplY3QnIH0pO1xuICAgICAgbW9ja1NjaGVtYVZhbGlkYXRvci52YWxpZGF0ZVBhcmFtcy5tb2NrUmV0dXJuVmFsdWUoeyB2YWxpZDogdHJ1ZSwgZXJyb3JzOiBbXSB9KTtcblxuICAgICAgY29uc3QgY29tcGxleFJlcXVlc3Q6IE1DUFJlcXVlc3QgPSB7XG4gICAgICAgIGpzb25ycGM6ICcyLjAnLFxuICAgICAgICBpZDogJ2NvbXBsZXgtdmFsaWRhdGlvbicsXG4gICAgICAgIG1ldGhvZDogJ3Rvb2xzL2NhbGwnLFxuICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICBuYW1lOiAnY29tcGxleF9hbmFseXNpcycsXG4gICAgICAgICAgYXJndW1lbnRzOiB7XG4gICAgICAgICAgICBjb2RlYmFzZTogJy9wYXRoL3RvL3Byb2plY3QnLFxuICAgICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgICBkZXB0aDogMyxcbiAgICAgICAgICAgICAgaW5jbHVkZVRlc3RzOiB0cnVlLFxuICAgICAgICAgICAgICBmb3JtYXRzOiBbJ3R5cGVzY3JpcHQnLCAnamF2YXNjcmlwdCddXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAvLyBBY3QgLSBWYWxpZGF0ZSBjb21wbGV4IHJlcXVlc3RcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHZhbGlkYXRvci52YWxpZGF0ZShjb21wbGV4UmVxdWVzdCk7XG5cbiAgICAgIC8vIEFzc2VydCAtIFZlcmlmeSBjb21wbGV0ZSB2YWxpZGF0aW9uIGNvbnZlcnNhdGlvbiAoTG9uZG9uIFNjaG9vbCBmb2N1cylcbiAgICAgIGV4cGVjdChtb2NrTG9nZ2VyLmRlYnVnKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgJ1ZhbGlkYXRpbmcgTUNQIG1lc3NhZ2UnLCBcbiAgICAgICAgeyBtZXNzYWdlVHlwZTogJ29iamVjdCcgfVxuICAgICAgKTtcbiAgICAgIGV4cGVjdChtb2NrU2NoZW1hVmFsaWRhdG9yLnZhbGlkYXRlSnNvblJwYykudG9IYXZlQmVlbkNhbGxlZFdpdGgoY29tcGxleFJlcXVlc3QpO1xuICAgICAgZXhwZWN0KG1vY2tTY2hlbWFWYWxpZGF0b3IudmFsaWRhdGVNZXRob2QpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCd0b29scy9jYWxsJyk7XG4gICAgICBleHBlY3QobW9ja1NjaGVtYVZhbGlkYXRvci5nZXRTY2hlbWFGb3JNZXRob2QpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCd0b29scy9jYWxsJyk7XG4gICAgICBleHBlY3QobW9ja1NjaGVtYVZhbGlkYXRvci52YWxpZGF0ZVBhcmFtcykudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgIGNvbXBsZXhSZXF1ZXN0LnBhcmFtcyxcbiAgICAgICAgeyB0eXBlOiAnb2JqZWN0JyB9XG4gICAgICApO1xuICAgICAgZXhwZWN0KG1vY2tNZXRyaWNzQ29sbGVjdG9yLnJlY29yZFZhbGlkYXRpb24pLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCdyZXF1ZXN0X3ZhbGlkJyk7XG4gICAgICBcbiAgICAgIGV4cGVjdChyZXN1bHQudmFsaWQpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QocmVzdWx0LmVycm9ycykudG9IYXZlTGVuZ3RoKDApO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgdmFsaWRhdGlvbiBlcnJvciBjYXNjYWRlIHByb3Blcmx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gQXJyYW5nZSAtIE1vY2sgdmFsaWRhdGlvbiBlcnJvciBjYXNjYWRlXG4gICAgICBjb25zdCB2YWxpZGF0b3IgPSBuZXcgTW9ja01DUE1lc3NhZ2VWYWxpZGF0b3IoKTtcbiAgICAgIFxuICAgICAgLy8gRmlyc3QgdmFsaWRhdGlvbiBwYXNzZXMsIHNlY29uZCBmYWlsc1xuICAgICAgbW9ja1NjaGVtYVZhbGlkYXRvci52YWxpZGF0ZUpzb25ScGMubW9ja1JldHVyblZhbHVlKHsgdmFsaWQ6IHRydWUsIGVycm9yczogW10gfSk7XG4gICAgICBtb2NrU2NoZW1hVmFsaWRhdG9yLnZhbGlkYXRlTWV0aG9kLm1vY2tSZXR1cm5WYWx1ZSh7IFxuICAgICAgICB2YWxpZDogZmFsc2UsIFxuICAgICAgICBlcnJvcnM6IFt7IFxuICAgICAgICAgIGZpZWxkOiAnbWV0aG9kJywgXG4gICAgICAgICAgY29kZTogJ01FVEhPRF9OT1RfRk9VTkQnLCBcbiAgICAgICAgICBtZXNzYWdlOiAnTWV0aG9kIGRvZXMgbm90IGV4aXN0JyBcbiAgICAgICAgfV0gXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgaW52YWxpZFJlcXVlc3Q6IE1DUFJlcXVlc3QgPSB7XG4gICAgICAgIGpzb25ycGM6ICcyLjAnLFxuICAgICAgICBpZDogJ2Nhc2NhZGUtdGVzdCcsXG4gICAgICAgIG1ldGhvZDogJ25vbmV4aXN0ZW50L21ldGhvZCcsXG4gICAgICAgIHBhcmFtczoge31cbiAgICAgIH07XG5cbiAgICAgIC8vIEFjdCAtIFZhbGlkYXRlIHJlcXVlc3Qgd2l0aCBtZXRob2QgZXJyb3JcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHZhbGlkYXRvci52YWxpZGF0ZShpbnZhbGlkUmVxdWVzdCk7XG5cbiAgICAgIC8vIEFzc2VydCAtIFZlcmlmeSBlcnJvciBjYXNjYWRlIGNvbnZlcnNhdGlvblxuICAgICAgZXhwZWN0KG1vY2tTY2hlbWFWYWxpZGF0b3IudmFsaWRhdGVKc29uUnBjKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChpbnZhbGlkUmVxdWVzdCk7XG4gICAgICBleHBlY3QobW9ja1NjaGVtYVZhbGlkYXRvci52YWxpZGF0ZU1ldGhvZCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoJ25vbmV4aXN0ZW50L21ldGhvZCcpO1xuICAgICAgXG4gICAgICAvLyBTaG91bGQgc3RvcCBhdCBtZXRob2QgdmFsaWRhdGlvbiwgbm90IHByb2NlZWQgdG8gcGFyYW1zXG4gICAgICBleHBlY3QobW9ja1NjaGVtYVZhbGlkYXRvci52YWxpZGF0ZVBhcmFtcykubm90LnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KG1vY2tNZXRyaWNzQ29sbGVjdG9yLnJlY29yZFZhbGlkYXRpb25FcnJvcikudG9IYXZlQmVlbkNhbGxlZFdpdGgoJ21ldGhvZF9pbnZhbGlkJyk7XG4gICAgICBleHBlY3QocmVzdWx0LnZhbGlkKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3JzWzBdLmNvZGUpLnRvQmUoJ01FVEhPRF9OT1RfRk9VTkQnKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgLy8gQ2xlYW4gdGVzdCBpc29sYXRpb24gLSBMb25kb24gU2Nob29sIHByaW5jaXBsZVxuICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKTtcbiAgfSk7XG4gIFxuICBhZnRlckVhY2goKCkgPT4ge1xuICAgIGplc3QucmVzdG9yZUFsbE1vY2tzKCk7XG4gIH0pO1xufSk7Il0sInZlcnNpb24iOjN9