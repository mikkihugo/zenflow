{"file":"/home/mhugo/code/claude-code-flow/src/__tests__/helpers/assertion-helpers.ts","mappings":"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","names":[],"sources":["/home/mhugo/code/claude-code-flow/src/__tests__/helpers/assertion-helpers.ts"],"sourcesContent":["/**\n * Assertion Helpers - Enhanced Testing Assertions\n * \n * Custom assertions for both London and Classical TDD approaches\n */\n\nimport { expect } from '@jest/globals';\nimport type { AssertionOptions, PerformanceMetrics } from './types.js';\n\nexport class AssertionHelpers {\n  private options: AssertionOptions;\n\n  constructor(options: AssertionOptions = {}) {\n    this.options = {\n      precision: 2,\n      tolerance: 0.05,\n      messages: {},\n      retry: {\n        attempts: 3,\n        delay: 100,\n        backoff: 'linear'\n      },\n      ...options\n    };\n  }\n\n  /**\n   * Assert that a value is approximately equal (for floating point comparisons)\n   */\n  toBeApproximately(actual: number, expected: number, precision?: number): void {\n    const actualPrecision = precision ?? this.options.precision!;\n    const message = this.options.messages?.approximately || \n      `Expected ${actual} to be approximately ${expected} within ${actualPrecision} decimal places`;\n    \n    expect(actual).toBeCloseTo(expected, actualPrecision);\n  }\n\n  /**\n   * Assert performance characteristics\n   */\n  toMeetPerformanceThreshold(\n    metrics: PerformanceMetrics, \n    thresholds: Partial<PerformanceMetrics>\n  ): void {\n    if (thresholds.executionTime !== undefined) {\n      const message = `Execution time ${metrics.executionTime}ms exceeded threshold ${thresholds.executionTime}ms`;\n      expect(metrics.executionTime).toBeLessThanOrEqual(thresholds.executionTime);\n    }\n\n    if (thresholds.memoryUsage?.heap !== undefined) {\n      const message = `Heap usage ${metrics.memoryUsage.heap} exceeded threshold ${thresholds.memoryUsage.heap}`;\n      expect(metrics.memoryUsage.heap).toBeLessThanOrEqual(thresholds.memoryUsage.heap);\n    }\n\n    if (thresholds.memoryUsage?.total !== undefined) {\n      const message = `Total memory ${metrics.memoryUsage.total} exceeded threshold ${thresholds.memoryUsage.total}`;\n      expect(metrics.memoryUsage.total).toBeLessThanOrEqual(thresholds.memoryUsage.total);\n    }\n\n    if (thresholds.throughput !== undefined) {\n      const message = `Throughput ${metrics.throughput} below threshold ${thresholds.throughput}`;\n      expect(metrics.throughput).toBeGreaterThanOrEqual(thresholds.throughput);\n    }\n  }\n\n  /**\n   * Assert that a promise resolves within a time limit\n   */\n  async toResolveWithin<T>(promise: Promise<T>, timeoutMs: number): Promise<T> {\n    const timeout = new Promise<never>((_, reject) => {\n      setTimeout(() => reject(new Error(`Promise did not resolve within ${timeoutMs}ms`)), timeoutMs);\n    });\n\n    return Promise.race([promise, timeout]);\n  }\n\n  /**\n   * Assert that a function eventually becomes true (with retries)\n   */\n  async toEventuallyBeTrue(\n    predicate: () => boolean | Promise<boolean>,\n    options: { timeout?: number; interval?: number } = {}\n  ): Promise<void> {\n    const timeout = options.timeout || 5000;\n    const interval = options.interval || 100;\n    const startTime = Date.now();\n\n    while (Date.now() - startTime < timeout) {\n      try {\n        const result = await predicate();\n        if (result) {\n          return;\n        }\n      } catch (error) {\n        // Continue trying\n      }\n      \n      await this.sleep(interval);\n    }\n\n    throw new Error(`Predicate did not become true within ${timeout}ms`);\n  }\n\n  /**\n   * Assert array contains elements in any order\n   */\n  toContainElementsInAnyOrder<T>(actual: T[], expected: T[]): void {\n    expect(actual).toHaveLength(expected.length);\n    \n    for (const element of expected) {\n      expect(actual).toContain(element);\n    }\n  }\n\n  /**\n   * Assert deep equality with custom comparison\n   */\n  toDeepEqualWith<T>(\n    actual: T, \n    expected: T, \n    customComparator?: (a: any, b: any, path: string) => boolean\n  ): void {\n    if (customComparator) {\n      const isEqual = this.deepEqualWithCustom(actual, expected, customComparator);\n      expect(isEqual).toBe(true);\n    } else {\n      expect(actual).toEqual(expected);\n    }\n  }\n\n  /**\n   * Assert that an object matches a partial structure\n   */\n  toMatchPartialStructure<T>(actual: T, expected: Partial<T>): void {\n    expect(actual).toMatchObject(expected);\n  }\n\n  /**\n   * Assert that a string matches a pattern (with custom error message)\n   */\n  toMatchPattern(actual: string, pattern: RegExp, customMessage?: string): void {\n    const message = customMessage || `Expected \"${actual}\" to match pattern ${pattern}`;\n    expect(actual).toMatch(pattern);\n  }\n\n  /**\n   * Assert that an error has specific properties\n   */\n  toBeErrorWithProperties(\n    actual: Error, \n    expectedProperties: { message?: string; code?: string | number; type?: string }\n  ): void {\n    expect(actual).toBeInstanceOf(Error);\n    \n    if (expectedProperties.message) {\n      expect(actual.message).toBe(expectedProperties.message);\n    }\n    \n    if (expectedProperties.code) {\n      expect((actual as any).code).toBe(expectedProperties.code);\n    }\n    \n    if (expectedProperties.type) {\n      expect(actual.constructor.name).toBe(expectedProperties.type);\n    }\n  }\n\n  /**\n   * Assert that an async operation throws with specific error\n   */\n  async toThrowAsyncError<T>(\n    operation: () => Promise<T>,\n    expectedError?: string | RegExp | Error\n  ): Promise<void> {\n    try {\n      await operation();\n      throw new Error('Expected operation to throw, but it succeeded');\n    } catch (error) {\n      if (expectedError) {\n        if (typeof expectedError === 'string') {\n          expect((error as Error).message).toBe(expectedError);\n        } else if (expectedError instanceof RegExp) {\n          expect((error as Error).message).toMatch(expectedError);\n        } else if (expectedError instanceof Error) {\n          expect(error).toEqual(expectedError);\n        }\n      }\n    }\n  }\n\n  /**\n   * Assert HTTP response characteristics\n   */\n  toBeHttpResponse(\n    response: any,\n    expectedStatus: number,\n    expectedHeaders?: Record<string, string>\n  ): void {\n    expect(response.status).toBe(expectedStatus);\n    \n    if (expectedHeaders) {\n      Object.entries(expectedHeaders).forEach(([header, value]) => {\n        expect(response.headers[header.toLowerCase()]).toBe(value);\n      });\n    }\n  }\n\n  /**\n   * Assert neural network training convergence\n   */\n  toConvergeToTarget(\n    trainingResults: { epoch: number; error: number }[],\n    targetError: number,\n    maxEpochs?: number\n  ): void {\n    const finalResult = trainingResults[trainingResults.length - 1];\n    \n    if (maxEpochs) {\n      expect(finalResult.epoch).toBeLessThanOrEqual(maxEpochs);\n    }\n    \n    expect(finalResult.error).toBeLessThan(targetError);\n    \n    // Check that error generally decreases over time\n    const errorReductions = trainingResults.slice(1).filter((result, index) => \n      result.error < trainingResults[index].error\n    );\n    \n    const reductionRatio = errorReductions.length / (trainingResults.length - 1);\n    expect(reductionRatio).toBeGreaterThan(0.7); // 70% of epochs should show improvement\n  }\n\n  /**\n   * Assert swarm coordination patterns\n   */\n  toHaveSwarmCoordination(\n    swarmMetrics: any,\n    expectedPatterns: {\n      agentCount?: number;\n      topology?: string;\n      efficiency?: number;\n      completion?: number;\n    }\n  ): void {\n    if (expectedPatterns.agentCount !== undefined) {\n      expect(swarmMetrics.activeAgents).toBe(expectedPatterns.agentCount);\n    }\n    \n    if (expectedPatterns.topology) {\n      expect(swarmMetrics.topology).toBe(expectedPatterns.topology);\n    }\n    \n    if (expectedPatterns.efficiency !== undefined) {\n      expect(swarmMetrics.efficiency).toBeGreaterThanOrEqual(expectedPatterns.efficiency);\n    }\n    \n    if (expectedPatterns.completion !== undefined) {\n      expect(swarmMetrics.completionRate).toBeGreaterThanOrEqual(expectedPatterns.completion);\n    }\n  }\n\n  /**\n   * London School: Assert interaction sequence\n   */\n  toHaveInteractionSequence(\n    mock: any,\n    expectedSequence: { method: string; args?: any[] }[]\n  ): void {\n    const interactions = mock.__interactions || [];\n    \n    expect(interactions).toHaveLength(expectedSequence.length);\n    \n    expectedSequence.forEach((expected, index) => {\n      const interaction = interactions[index];\n      expect(interaction.method).toBe(expected.method);\n      \n      if (expected.args) {\n        expect(interaction.args).toEqual(expected.args);\n      }\n    });\n  }\n\n  /**\n   * Classical School: Assert mathematical properties\n   */\n  toSatisfyMathematicalProperty(\n    values: number[],\n    property: 'monotonic-increasing' | 'monotonic-decreasing' | 'convex' | 'concave'\n  ): void {\n    switch (property) {\n      case 'monotonic-increasing':\n        for (let i = 1; i < values.length; i++) {\n          expect(values[i]).toBeGreaterThanOrEqual(values[i - 1]);\n        }\n        break;\n      \n      case 'monotonic-decreasing':\n        for (let i = 1; i < values.length; i++) {\n          expect(values[i]).toBeLessThanOrEqual(values[i - 1]);\n        }\n        break;\n      \n      case 'convex':\n        // Check second derivative > 0 (simplified)\n        for (let i = 2; i < values.length; i++) {\n          const secondDerivative = values[i] - 2 * values[i - 1] + values[i - 2];\n          expect(secondDerivative).toBeGreaterThanOrEqual(0);\n        }\n        break;\n      \n      case 'concave':\n        // Check second derivative < 0 (simplified)\n        for (let i = 2; i < values.length; i++) {\n          const secondDerivative = values[i] - 2 * values[i - 1] + values[i - 2];\n          expect(secondDerivative).toBeLessThanOrEqual(0);\n        }\n        break;\n    }\n  }\n\n  private deepEqualWithCustom(\n    a: any, \n    b: any, \n    customComparator: (a: any, b: any, path: string) => boolean,\n    path: string = ''\n  ): boolean {\n    if (customComparator(a, b, path)) {\n      return true;\n    }\n\n    if (a === b) return true;\n    if (a == null || b == null) return false;\n    if (typeof a !== typeof b) return false;\n\n    if (typeof a === 'object') {\n      const keysA = Object.keys(a);\n      const keysB = Object.keys(b);\n      \n      if (keysA.length !== keysB.length) return false;\n      \n      for (const key of keysA) {\n        if (!keysB.includes(key)) return false;\n        if (!this.deepEqualWithCustom(a[key], b[key], customComparator, `${path}.${key}`)) {\n          return false;\n        }\n      }\n      \n      return true;\n    }\n\n    return false;\n  }\n\n  private sleep(ms: number): Promise<void> {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n}\n\n// Global assertion helpers instance\nexport const assertionHelpers = new AssertionHelpers();\n\n// Convenience functions for common assertions\nexport function expectApproximately(actual: number, expected: number, precision?: number): void {\n  assertionHelpers.toBeApproximately(actual, expected, precision);\n}\n\nexport function expectPerformance(\n  metrics: PerformanceMetrics, \n  thresholds: Partial<PerformanceMetrics>\n): void {\n  assertionHelpers.toMeetPerformanceThreshold(metrics, thresholds);\n}\n\nexport async function expectEventually(\n  predicate: () => boolean | Promise<boolean>,\n  options?: { timeout?: number; interval?: number }\n): Promise<void> {\n  return assertionHelpers.toEventuallyBeTrue(predicate, options);\n}\n\nexport function expectInteractionSequence(\n  mock: any,\n  sequence: { method: string; args?: any[] }[]\n): void {\n  assertionHelpers.toHaveInteractionSequence(mock, sequence);\n}"],"version":3}