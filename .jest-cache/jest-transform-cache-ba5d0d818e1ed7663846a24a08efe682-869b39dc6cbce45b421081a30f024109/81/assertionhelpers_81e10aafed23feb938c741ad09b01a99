ef67b660c41d044ac642cd31e2bebdc0
/**
 * Assertion Helpers - Enhanced Testing Assertions
 *
 * Custom assertions for both London and Classical TDD approaches
 */
import { expect } from '@jest/globals';
export class AssertionHelpers {
    options;
    constructor(options = {}) {
        this.options = {
            precision: 2,
            tolerance: 0.05,
            messages: {},
            retry: {
                attempts: 3,
                delay: 100,
                backoff: 'linear'
            },
            ...options
        };
    }
    /**
     * Assert that a value is approximately equal (for floating point comparisons)
     */
    toBeApproximately(actual, expected, precision) {
        const actualPrecision = precision ?? this.options.precision;
        const message = this.options.messages?.approximately ||
            `Expected ${actual} to be approximately ${expected} within ${actualPrecision} decimal places`;
        expect(actual).toBeCloseTo(expected, actualPrecision);
    }
    /**
     * Assert performance characteristics
     */
    toMeetPerformanceThreshold(metrics, thresholds) {
        if (thresholds.executionTime !== undefined) {
            const message = `Execution time ${metrics.executionTime}ms exceeded threshold ${thresholds.executionTime}ms`;
            expect(metrics.executionTime).toBeLessThanOrEqual(thresholds.executionTime);
        }
        if (thresholds.memoryUsage?.heap !== undefined) {
            const message = `Heap usage ${metrics.memoryUsage.heap} exceeded threshold ${thresholds.memoryUsage.heap}`;
            expect(metrics.memoryUsage.heap).toBeLessThanOrEqual(thresholds.memoryUsage.heap);
        }
        if (thresholds.memoryUsage?.total !== undefined) {
            const message = `Total memory ${metrics.memoryUsage.total} exceeded threshold ${thresholds.memoryUsage.total}`;
            expect(metrics.memoryUsage.total).toBeLessThanOrEqual(thresholds.memoryUsage.total);
        }
        if (thresholds.throughput !== undefined) {
            const message = `Throughput ${metrics.throughput} below threshold ${thresholds.throughput}`;
            expect(metrics.throughput).toBeGreaterThanOrEqual(thresholds.throughput);
        }
    }
    /**
     * Assert that a promise resolves within a time limit
     */
    async toResolveWithin(promise, timeoutMs) {
        const timeout = new Promise((_, reject) => {
            setTimeout(() => reject(new Error(`Promise did not resolve within ${timeoutMs}ms`)), timeoutMs);
        });
        return Promise.race([promise, timeout]);
    }
    /**
     * Assert that a function eventually becomes true (with retries)
     */
    async toEventuallyBeTrue(predicate, options = {}) {
        const timeout = options.timeout || 5000;
        const interval = options.interval || 100;
        const startTime = Date.now();
        while (Date.now() - startTime < timeout) {
            try {
                const result = await predicate();
                if (result) {
                    return;
                }
            }
            catch (error) {
                // Continue trying
            }
            await this.sleep(interval);
        }
        throw new Error(`Predicate did not become true within ${timeout}ms`);
    }
    /**
     * Assert array contains elements in any order
     */
    toContainElementsInAnyOrder(actual, expected) {
        expect(actual).toHaveLength(expected.length);
        for (const element of expected) {
            expect(actual).toContain(element);
        }
    }
    /**
     * Assert deep equality with custom comparison
     */
    toDeepEqualWith(actual, expected, customComparator) {
        if (customComparator) {
            const isEqual = this.deepEqualWithCustom(actual, expected, customComparator);
            expect(isEqual).toBe(true);
        }
        else {
            expect(actual).toEqual(expected);
        }
    }
    /**
     * Assert that an object matches a partial structure
     */
    toMatchPartialStructure(actual, expected) {
        expect(actual).toMatchObject(expected);
    }
    /**
     * Assert that a string matches a pattern (with custom error message)
     */
    toMatchPattern(actual, pattern, customMessage) {
        const message = customMessage || `Expected "${actual}" to match pattern ${pattern}`;
        expect(actual).toMatch(pattern);
    }
    /**
     * Assert that an error has specific properties
     */
    toBeErrorWithProperties(actual, expectedProperties) {
        expect(actual).toBeInstanceOf(Error);
        if (expectedProperties.message) {
            expect(actual.message).toBe(expectedProperties.message);
        }
        if (expectedProperties.code) {
            expect(actual.code).toBe(expectedProperties.code);
        }
        if (expectedProperties.type) {
            expect(actual.constructor.name).toBe(expectedProperties.type);
        }
    }
    /**
     * Assert that an async operation throws with specific error
     */
    async toThrowAsyncError(operation, expectedError) {
        try {
            await operation();
            throw new Error('Expected operation to throw, but it succeeded');
        }
        catch (error) {
            if (expectedError) {
                if (typeof expectedError === 'string') {
                    expect(error.message).toBe(expectedError);
                }
                else if (expectedError instanceof RegExp) {
                    expect(error.message).toMatch(expectedError);
                }
                else if (expectedError instanceof Error) {
                    expect(error).toEqual(expectedError);
                }
            }
        }
    }
    /**
     * Assert HTTP response characteristics
     */
    toBeHttpResponse(response, expectedStatus, expectedHeaders) {
        expect(response.status).toBe(expectedStatus);
        if (expectedHeaders) {
            Object.entries(expectedHeaders).forEach(([header, value]) => {
                expect(response.headers[header.toLowerCase()]).toBe(value);
            });
        }
    }
    /**
     * Assert neural network training convergence
     */
    toConvergeToTarget(trainingResults, targetError, maxEpochs) {
        const finalResult = trainingResults[trainingResults.length - 1];
        if (maxEpochs) {
            expect(finalResult.epoch).toBeLessThanOrEqual(maxEpochs);
        }
        expect(finalResult.error).toBeLessThan(targetError);
        // Check that error generally decreases over time
        const errorReductions = trainingResults.slice(1).filter((result, index) => result.error < trainingResults[index].error);
        const reductionRatio = errorReductions.length / (trainingResults.length - 1);
        expect(reductionRatio).toBeGreaterThan(0.7); // 70% of epochs should show improvement
    }
    /**
     * Assert swarm coordination patterns
     */
    toHaveSwarmCoordination(swarmMetrics, expectedPatterns) {
        if (expectedPatterns.agentCount !== undefined) {
            expect(swarmMetrics.activeAgents).toBe(expectedPatterns.agentCount);
        }
        if (expectedPatterns.topology) {
            expect(swarmMetrics.topology).toBe(expectedPatterns.topology);
        }
        if (expectedPatterns.efficiency !== undefined) {
            expect(swarmMetrics.efficiency).toBeGreaterThanOrEqual(expectedPatterns.efficiency);
        }
        if (expectedPatterns.completion !== undefined) {
            expect(swarmMetrics.completionRate).toBeGreaterThanOrEqual(expectedPatterns.completion);
        }
    }
    /**
     * London School: Assert interaction sequence
     */
    toHaveInteractionSequence(mock, expectedSequence) {
        const interactions = mock.__interactions || [];
        expect(interactions).toHaveLength(expectedSequence.length);
        expectedSequence.forEach((expected, index) => {
            const interaction = interactions[index];
            expect(interaction.method).toBe(expected.method);
            if (expected.args) {
                expect(interaction.args).toEqual(expected.args);
            }
        });
    }
    /**
     * Classical School: Assert mathematical properties
     */
    toSatisfyMathematicalProperty(values, property) {
        switch (property) {
            case 'monotonic-increasing':
                for (let i = 1; i < values.length; i++) {
                    expect(values[i]).toBeGreaterThanOrEqual(values[i - 1]);
                }
                break;
            case 'monotonic-decreasing':
                for (let i = 1; i < values.length; i++) {
                    expect(values[i]).toBeLessThanOrEqual(values[i - 1]);
                }
                break;
            case 'convex':
                // Check second derivative > 0 (simplified)
                for (let i = 2; i < values.length; i++) {
                    const secondDerivative = values[i] - 2 * values[i - 1] + values[i - 2];
                    expect(secondDerivative).toBeGreaterThanOrEqual(0);
                }
                break;
            case 'concave':
                // Check second derivative < 0 (simplified)
                for (let i = 2; i < values.length; i++) {
                    const secondDerivative = values[i] - 2 * values[i - 1] + values[i - 2];
                    expect(secondDerivative).toBeLessThanOrEqual(0);
                }
                break;
        }
    }
    deepEqualWithCustom(a, b, customComparator, path = '') {
        if (customComparator(a, b, path)) {
            return true;
        }
        if (a === b)
            return true;
        if (a == null || b == null)
            return false;
        if (typeof a !== typeof b)
            return false;
        if (typeof a === 'object') {
            const keysA = Object.keys(a);
            const keysB = Object.keys(b);
            if (keysA.length !== keysB.length)
                return false;
            for (const key of keysA) {
                if (!keysB.includes(key))
                    return false;
                if (!this.deepEqualWithCustom(a[key], b[key], customComparator, `${path}.${key}`)) {
                    return false;
                }
            }
            return true;
        }
        return false;
    }
    sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
}
// Global assertion helpers instance
export const assertionHelpers = new AssertionHelpers();
// Convenience functions for common assertions
export function expectApproximately(actual, expected, precision) {
    assertionHelpers.toBeApproximately(actual, expected, precision);
}
export function expectPerformance(metrics, thresholds) {
    assertionHelpers.toMeetPerformanceThreshold(metrics, thresholds);
}
export async function expectEventually(predicate, options) {
    return assertionHelpers.toEventuallyBeTrue(predicate, options);
}
export function expectInteractionSequence(mock, sequence) {
    assertionHelpers.toHaveInteractionSequence(mock, sequence);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL2hvbWUvbWh1Z28vY29kZS9jbGF1ZGUtY29kZS1mbG93L3NyYy9fX3Rlc3RzX18vaGVscGVycy9hc3NlcnRpb24taGVscGVycy50cyIsIm1hcHBpbmdzIjoiQUFBQTs7OztHQUlHO0FBRUgsT0FBTyxFQUFFLE1BQU0sRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUd2QyxNQUFNLE9BQU8sZ0JBQWdCO0lBQ25CLE9BQU8sQ0FBbUI7SUFFbEMsWUFBWSxVQUE0QixFQUFFO1FBQ3hDLElBQUksQ0FBQyxPQUFPLEdBQUc7WUFDYixTQUFTLEVBQUUsQ0FBQztZQUNaLFNBQVMsRUFBRSxJQUFJO1lBQ2YsUUFBUSxFQUFFLEVBQUU7WUFDWixLQUFLLEVBQUU7Z0JBQ0wsUUFBUSxFQUFFLENBQUM7Z0JBQ1gsS0FBSyxFQUFFLEdBQUc7Z0JBQ1YsT0FBTyxFQUFFLFFBQVE7YUFDbEI7WUFDRCxHQUFHLE9BQU87U0FDWCxDQUFDO0lBQ0osQ0FBQztJQUVEOztPQUVHO0lBQ0gsaUJBQWlCLENBQUMsTUFBYyxFQUFFLFFBQWdCLEVBQUUsU0FBa0I7UUFDcEUsTUFBTSxlQUFlLEdBQUcsU0FBUyxJQUFJLElBQUksQ0FBQyxPQUFPLENBQUMsU0FBVSxDQUFDO1FBQzdELE1BQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsUUFBUSxFQUFFLGFBQWE7WUFDbEQsWUFBWSxNQUFNLHdCQUF3QixRQUFRLFdBQVcsZUFBZSxpQkFBaUIsQ0FBQztRQUVoRyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsV0FBVyxDQUFDLFFBQVEsRUFBRSxlQUFlLENBQUMsQ0FBQztJQUN4RCxDQUFDO0lBRUQ7O09BRUc7SUFDSCwwQkFBMEIsQ0FDeEIsT0FBMkIsRUFDM0IsVUFBdUM7UUFFdkMsSUFBSSxVQUFVLENBQUMsYUFBYSxLQUFLLFNBQVMsRUFBRSxDQUFDO1lBQzNDLE1BQU0sT0FBTyxHQUFHLGtCQUFrQixPQUFPLENBQUMsYUFBYSx5QkFBeUIsVUFBVSxDQUFDLGFBQWEsSUFBSSxDQUFDO1lBQzdHLE1BQU0sQ0FB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QUFDLENBQUM7QUFDbEUsQ0FBQztBQUVELE1BQU0sVUFBVSxpQkFBaUIsQ0FDL0IsT0FBMkIsRUFDM0IsVUFBdUM7SUFFdkMsZ0JBQWdCLENBQUMsMEJBQTBCLENBQUMsT0FBTyxFQUFFLFVBQVUsQ0FBQyxDQUFDO0FBQ25FLENBQUM7QUFFRCxNQUFNLENBQUMsS0FBSyxVQUFVLGdCQUFnQixDQUNwQyxTQUEyQyxFQUMzQyxPQUFpRDtJQUVqRCxPQUFPLGdCQUFnQixDQUFDLGtCQUFrQixDQUFDLFNBQVMsRUFBRSxPQUFPLENBQUMsQ0FBQztBQUNqRSxDQUFDO0FBRUQsTUFBTSxVQUFVLHlCQUF5QixDQUN2QyxJQUFTLEVBQ1QsUUFBNEM7SUFFNUMsZ0JBQWdCLENBQUMseUJBQXlCLENBQUMsSUFBSSxFQUFFLFFBQVEsQ0FBQyxDQUFDO0FBQzdELENBQUMiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiL2hvbWUvbWh1Z28vY29kZS9jbGF1ZGUtY29kZS1mbG93L3NyYy9fX3Rlc3RzX18vaGVscGVycy9hc3NlcnRpb24taGVscGVycy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEFzc2VydGlvbiBIZWxwZXJzIC0gRW5oYW5jZWQgVGVzdGluZyBBc3NlcnRpb25zXG4gKiBcbiAqIEN1c3RvbSBhc3NlcnRpb25zIGZvciBib3RoIExvbmRvbiBhbmQgQ2xhc3NpY2FsIFRERCBhcHByb2FjaGVzXG4gKi9cblxuaW1wb3J0IHsgZXhwZWN0IH0gZnJvbSAnQGplc3QvZ2xvYmFscyc7XG5pbXBvcnQgdHlwZSB7IEFzc2VydGlvbk9wdGlvbnMsIFBlcmZvcm1hbmNlTWV0cmljcyB9IGZyb20gJy4vdHlwZXMuanMnO1xuXG5leHBvcnQgY2xhc3MgQXNzZXJ0aW9uSGVscGVycyB7XG4gIHByaXZhdGUgb3B0aW9uczogQXNzZXJ0aW9uT3B0aW9ucztcblxuICBjb25zdHJ1Y3RvcihvcHRpb25zOiBBc3NlcnRpb25PcHRpb25zID0ge30pIHtcbiAgICB0aGlzLm9wdGlvbnMgPSB7XG4gICAgICBwcmVjaXNpb246IDIsXG4gICAgICB0b2xlcmFuY2U6IDAuMDUsXG4gICAgICBtZXNzYWdlczoge30sXG4gICAgICByZXRyeToge1xuICAgICAgICBhdHRlbXB0czogMyxcbiAgICAgICAgZGVsYXk6IDEwMCxcbiAgICAgICAgYmFja29mZjogJ2xpbmVhcidcbiAgICAgIH0sXG4gICAgICAuLi5vcHRpb25zXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBc3NlcnQgdGhhdCBhIHZhbHVlIGlzIGFwcHJveGltYXRlbHkgZXF1YWwgKGZvciBmbG9hdGluZyBwb2ludCBjb21wYXJpc29ucylcbiAgICovXG4gIHRvQmVBcHByb3hpbWF0ZWx5KGFjdHVhbDogbnVtYmVyLCBleHBlY3RlZDogbnVtYmVyLCBwcmVjaXNpb24/OiBudW1iZXIpOiB2b2lkIHtcbiAgICBjb25zdCBhY3R1YWxQcmVjaXNpb24gPSBwcmVjaXNpb24gPz8gdGhpcy5vcHRpb25zLnByZWNpc2lvbiE7XG4gICAgY29uc3QgbWVzc2FnZSA9IHRoaXMub3B0aW9ucy5tZXNzYWdlcz8uYXBwcm94aW1hdGVseSB8fCBcbiAgICAgIGBFeHBlY3RlZCAke2FjdHVhbH0gdG8gYmUgYXBwcm94aW1hdGVseSAke2V4cGVjdGVkfSB3aXRoaW4gJHthY3R1YWxQcmVjaXNpb259IGRlY2ltYWwgcGxhY2VzYDtcbiAgICBcbiAgICBleHBlY3QoYWN0dWFsKS50b0JlQ2xvc2VUbyhleHBlY3RlZCwgYWN0dWFsUHJlY2lzaW9uKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBc3NlcnQgcGVyZm9ybWFuY2UgY2hhcmFjdGVyaXN0aWNzXG4gICAqL1xuICB0b01lZXRQZXJmb3JtYW5jZVRocmVzaG9sZChcbiAgICBtZXRyaWNzOiBQZXJmb3JtYW5jZU1ldHJpY3MsIFxuICAgIHRocmVzaG9sZHM6IFBhcnRpYWw8UGVyZm9ybWFuY2VNZXRyaWNzPlxuICApOiB2b2lkIHtcbiAgICBpZiAodGhyZXNob2xkcy5leGVjdXRpb25UaW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBgRXhlY3V0aW9uIHRpbWUgJHttZXRyaWNzLmV4ZWN1dGlvblRpbWV9bXMgZXhjZWVkZWQgdGhyZXNob2xkICR7dGhyZXNob2xkcy5leGVjdXRpb25UaW1lfW1zYDtcbiAgICAgIGV4cGVjdChtZXRyaWNzLmV4ZWN1dGlvblRpbWUpLnRvQmVMZXNzVGhhbk9yRXF1YWwodGhyZXNob2xkcy5leGVjdXRpb25UaW1lKTtcbiAgICB9XG5cbiAgICBpZiAodGhyZXNob2xkcy5tZW1vcnlVc2FnZT8uaGVhcCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCBtZXNzYWdlID0gYEhlYXAgdXNhZ2UgJHttZXRyaWNzLm1lbW9yeVVzYWdlLmhlYXB9IGV4Y2VlZGVkIHRocmVzaG9sZCAke3RocmVzaG9sZHMubWVtb3J5VXNhZ2UuaGVhcH1gO1xuICAgICAgZXhwZWN0KG1ldHJpY3MubWVtb3J5VXNhZ2UuaGVhcCkudG9CZUxlc3NUaGFuT3JFcXVhbCh0aHJlc2hvbGRzLm1lbW9yeVVzYWdlLmhlYXApO1xuICAgIH1cblxuICAgIGlmICh0aHJlc2hvbGRzLm1lbW9yeVVzYWdlPy50b3RhbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCBtZXNzYWdlID0gYFRvdGFsIG1lbW9yeSAke21ldHJpY3MubWVtb3J5VXNhZ2UudG90YWx9IGV4Y2VlZGVkIHRocmVzaG9sZCAke3RocmVzaG9sZHMubWVtb3J5VXNhZ2UudG90YWx9YDtcbiAgICAgIGV4cGVjdChtZXRyaWNzLm1lbW9yeVVzYWdlLnRvdGFsKS50b0JlTGVzc1RoYW5PckVxdWFsKHRocmVzaG9sZHMubWVtb3J5VXNhZ2UudG90YWwpO1xuICAgIH1cblxuICAgIGlmICh0aHJlc2hvbGRzLnRocm91Z2hwdXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgbWVzc2FnZSA9IGBUaHJvdWdocHV0ICR7bWV0cmljcy50aHJvdWdocHV0fSBiZWxvdyB0aHJlc2hvbGQgJHt0aHJlc2hvbGRzLnRocm91Z2hwdXR9YDtcbiAgICAgIGV4cGVjdChtZXRyaWNzLnRocm91Z2hwdXQpLnRvQmVHcmVhdGVyVGhhbk9yRXF1YWwodGhyZXNob2xkcy50aHJvdWdocHV0KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQXNzZXJ0IHRoYXQgYSBwcm9taXNlIHJlc29sdmVzIHdpdGhpbiBhIHRpbWUgbGltaXRcbiAgICovXG4gIGFzeW5jIHRvUmVzb2x2ZVdpdGhpbjxUPihwcm9taXNlOiBQcm9taXNlPFQ+LCB0aW1lb3V0TXM6IG51bWJlcik6IFByb21pc2U8VD4ge1xuICAgIGNvbnN0IHRpbWVvdXQgPSBuZXcgUHJvbWlzZTxuZXZlcj4oKF8sIHJlamVjdCkgPT4ge1xuICAgICAgc2V0VGltZW91dCgoKSA9PiByZWplY3QobmV3IEVycm9yKGBQcm9taXNlIGRpZCBub3QgcmVzb2x2ZSB3aXRoaW4gJHt0aW1lb3V0TXN9bXNgKSksIHRpbWVvdXRNcyk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gUHJvbWlzZS5yYWNlKFtwcm9taXNlLCB0aW1lb3V0XSk7XG4gIH1cblxuICAvKipcbiAgICogQXNzZXJ0IHRoYXQgYSBmdW5jdGlvbiBldmVudHVhbGx5IGJlY29tZXMgdHJ1ZSAod2l0aCByZXRyaWVzKVxuICAgKi9cbiAgYXN5bmMgdG9FdmVudHVhbGx5QmVUcnVlKFxuICAgIHByZWRpY2F0ZTogKCkgPT4gYm9vbGVhbiB8IFByb21pc2U8Ym9vbGVhbj4sXG4gICAgb3B0aW9uczogeyB0aW1lb3V0PzogbnVtYmVyOyBpbnRlcnZhbD86IG51bWJlciB9ID0ge31cbiAgKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgdGltZW91dCA9IG9wdGlvbnMudGltZW91dCB8fCA1MDAwO1xuICAgIGNvbnN0IGludGVydmFsID0gb3B0aW9ucy5pbnRlcnZhbCB8fCAxMDA7XG4gICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcblxuICAgIHdoaWxlIChEYXRlLm5vdygpIC0gc3RhcnRUaW1lIDwgdGltZW91dCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcHJlZGljYXRlKCk7XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIC8vIENvbnRpbnVlIHRyeWluZ1xuICAgICAgfVxuICAgICAgXG4gICAgICBhd2FpdCB0aGlzLnNsZWVwKGludGVydmFsKTtcbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgRXJyb3IoYFByZWRpY2F0ZSBkaWQgbm90IGJlY29tZSB0cnVlIHdpdGhpbiAke3RpbWVvdXR9bXNgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBc3NlcnQgYXJyYXkgY29udGFpbnMgZWxlbWVudHMgaW4gYW55IG9yZGVyXG4gICAqL1xuICB0b0NvbnRhaW5FbGVtZW50c0luQW55T3JkZXI8VD4oYWN0dWFsOiBUW10sIGV4cGVjdGVkOiBUW10pOiB2b2lkIHtcbiAgICBleHBlY3QoYWN0dWFsKS50b0hhdmVMZW5ndGgoZXhwZWN0ZWQubGVuZ3RoKTtcbiAgICBcbiAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgZXhwZWN0ZWQpIHtcbiAgICAgIGV4cGVjdChhY3R1YWwpLnRvQ29udGFpbihlbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQXNzZXJ0IGRlZXAgZXF1YWxpdHkgd2l0aCBjdXN0b20gY29tcGFyaXNvblxuICAgKi9cbiAgdG9EZWVwRXF1YWxXaXRoPFQ+KFxuICAgIGFjdHVhbDogVCwgXG4gICAgZXhwZWN0ZWQ6IFQsIFxuICAgIGN1c3RvbUNvbXBhcmF0b3I/OiAoYTogYW55LCBiOiBhbnksIHBhdGg6IHN0cmluZykgPT4gYm9vbGVhblxuICApOiB2b2lkIHtcbiAgICBpZiAoY3VzdG9tQ29tcGFyYXRvcikge1xuICAgICAgY29uc3QgaXNFcXVhbCA9IHRoaXMuZGVlcEVxdWFsV2l0aEN1c3RvbShhY3R1YWwsIGV4cGVjdGVkLCBjdXN0b21Db21wYXJhdG9yKTtcbiAgICAgIGV4cGVjdChpc0VxdWFsKS50b0JlKHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleHBlY3QoYWN0dWFsKS50b0VxdWFsKGV4cGVjdGVkKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQXNzZXJ0IHRoYXQgYW4gb2JqZWN0IG1hdGNoZXMgYSBwYXJ0aWFsIHN0cnVjdHVyZVxuICAgKi9cbiAgdG9NYXRjaFBhcnRpYWxTdHJ1Y3R1cmU8VD4oYWN0dWFsOiBULCBleHBlY3RlZDogUGFydGlhbDxUPik6IHZvaWQge1xuICAgIGV4cGVjdChhY3R1YWwpLnRvTWF0Y2hPYmplY3QoZXhwZWN0ZWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFzc2VydCB0aGF0IGEgc3RyaW5nIG1hdGNoZXMgYSBwYXR0ZXJuICh3aXRoIGN1c3RvbSBlcnJvciBtZXNzYWdlKVxuICAgKi9cbiAgdG9NYXRjaFBhdHRlcm4oYWN0dWFsOiBzdHJpbmcsIHBhdHRlcm46IFJlZ0V4cCwgY3VzdG9tTWVzc2FnZT86IHN0cmluZyk6IHZvaWQge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBjdXN0b21NZXNzYWdlIHx8IGBFeHBlY3RlZCBcIiR7YWN0dWFsfVwiIHRvIG1hdGNoIHBhdHRlcm4gJHtwYXR0ZXJufWA7XG4gICAgZXhwZWN0KGFjdHVhbCkudG9NYXRjaChwYXR0ZXJuKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBc3NlcnQgdGhhdCBhbiBlcnJvciBoYXMgc3BlY2lmaWMgcHJvcGVydGllc1xuICAgKi9cbiAgdG9CZUVycm9yV2l0aFByb3BlcnRpZXMoXG4gICAgYWN0dWFsOiBFcnJvciwgXG4gICAgZXhwZWN0ZWRQcm9wZXJ0aWVzOiB7IG1lc3NhZ2U/OiBzdHJpbmc7IGNvZGU/OiBzdHJpbmcgfCBudW1iZXI7IHR5cGU/OiBzdHJpbmcgfVxuICApOiB2b2lkIHtcbiAgICBleHBlY3QoYWN0dWFsKS50b0JlSW5zdGFuY2VPZihFcnJvcik7XG4gICAgXG4gICAgaWYgKGV4cGVjdGVkUHJvcGVydGllcy5tZXNzYWdlKSB7XG4gICAgICBleHBlY3QoYWN0dWFsLm1lc3NhZ2UpLnRvQmUoZXhwZWN0ZWRQcm9wZXJ0aWVzLm1lc3NhZ2UpO1xuICAgIH1cbiAgICBcbiAgICBpZiAoZXhwZWN0ZWRQcm9wZXJ0aWVzLmNvZGUpIHtcbiAgICAgIGV4cGVjdCgoYWN0dWFsIGFzIGFueSkuY29kZSkudG9CZShleHBlY3RlZFByb3BlcnRpZXMuY29kZSk7XG4gICAgfVxuICAgIFxuICAgIGlmIChleHBlY3RlZFByb3BlcnRpZXMudHlwZSkge1xuICAgICAgZXhwZWN0KGFjdHVhbC5jb25zdHJ1Y3Rvci5uYW1lKS50b0JlKGV4cGVjdGVkUHJvcGVydGllcy50eXBlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQXNzZXJ0IHRoYXQgYW4gYXN5bmMgb3BlcmF0aW9uIHRocm93cyB3aXRoIHNwZWNpZmljIGVycm9yXG4gICAqL1xuICBhc3luYyB0b1Rocm93QXN5bmNFcnJvcjxUPihcbiAgICBvcGVyYXRpb246ICgpID0+IFByb21pc2U8VD4sXG4gICAgZXhwZWN0ZWRFcnJvcj86IHN0cmluZyB8IFJlZ0V4cCB8IEVycm9yXG4gICk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBvcGVyYXRpb24oKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgb3BlcmF0aW9uIHRvIHRocm93LCBidXQgaXQgc3VjY2VlZGVkJyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChleHBlY3RlZEVycm9yKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZXhwZWN0ZWRFcnJvciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBleHBlY3QoKGVycm9yIGFzIEVycm9yKS5tZXNzYWdlKS50b0JlKGV4cGVjdGVkRXJyb3IpO1xuICAgICAgICB9IGVsc2UgaWYgKGV4cGVjdGVkRXJyb3IgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgICBleHBlY3QoKGVycm9yIGFzIEVycm9yKS5tZXNzYWdlKS50b01hdGNoKGV4cGVjdGVkRXJyb3IpO1xuICAgICAgICB9IGVsc2UgaWYgKGV4cGVjdGVkRXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgIGV4cGVjdChlcnJvcikudG9FcXVhbChleHBlY3RlZEVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBc3NlcnQgSFRUUCByZXNwb25zZSBjaGFyYWN0ZXJpc3RpY3NcbiAgICovXG4gIHRvQmVIdHRwUmVzcG9uc2UoXG4gICAgcmVzcG9uc2U6IGFueSxcbiAgICBleHBlY3RlZFN0YXR1czogbnVtYmVyLFxuICAgIGV4cGVjdGVkSGVhZGVycz86IFJlY29yZDxzdHJpbmcsIHN0cmluZz5cbiAgKTogdm9pZCB7XG4gICAgZXhwZWN0KHJlc3BvbnNlLnN0YXR1cykudG9CZShleHBlY3RlZFN0YXR1cyk7XG4gICAgXG4gICAgaWYgKGV4cGVjdGVkSGVhZGVycykge1xuICAgICAgT2JqZWN0LmVudHJpZXMoZXhwZWN0ZWRIZWFkZXJzKS5mb3JFYWNoKChbaGVhZGVyLCB2YWx1ZV0pID0+IHtcbiAgICAgICAgZXhwZWN0KHJlc3BvbnNlLmhlYWRlcnNbaGVhZGVyLnRvTG93ZXJDYXNlKCldKS50b0JlKHZhbHVlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBc3NlcnQgbmV1cmFsIG5ldHdvcmsgdHJhaW5pbmcgY29udmVyZ2VuY2VcbiAgICovXG4gIHRvQ29udmVyZ2VUb1RhcmdldChcbiAgICB0cmFpbmluZ1Jlc3VsdHM6IHsgZXBvY2g6IG51bWJlcjsgZXJyb3I6IG51bWJlciB9W10sXG4gICAgdGFyZ2V0RXJyb3I6IG51bWJlcixcbiAgICBtYXhFcG9jaHM/OiBudW1iZXJcbiAgKTogdm9pZCB7XG4gICAgY29uc3QgZmluYWxSZXN1bHQgPSB0cmFpbmluZ1Jlc3VsdHNbdHJhaW5pbmdSZXN1bHRzLmxlbmd0aCAtIDFdO1xuICAgIFxuICAgIGlmIChtYXhFcG9jaHMpIHtcbiAgICAgIGV4cGVjdChmaW5hbFJlc3VsdC5lcG9jaCkudG9CZUxlc3NUaGFuT3JFcXVhbChtYXhFcG9jaHMpO1xuICAgIH1cbiAgICBcbiAgICBleHBlY3QoZmluYWxSZXN1bHQuZXJyb3IpLnRvQmVMZXNzVGhhbih0YXJnZXRFcnJvcik7XG4gICAgXG4gICAgLy8gQ2hlY2sgdGhhdCBlcnJvciBnZW5lcmFsbHkgZGVjcmVhc2VzIG92ZXIgdGltZVxuICAgIGNvbnN0IGVycm9yUmVkdWN0aW9ucyA9IHRyYWluaW5nUmVzdWx0cy5zbGljZSgxKS5maWx0ZXIoKHJlc3VsdCwgaW5kZXgpID0+IFxuICAgICAgcmVzdWx0LmVycm9yIDwgdHJhaW5pbmdSZXN1bHRzW2luZGV4XS5lcnJvclxuICAgICk7XG4gICAgXG4gICAgY29uc3QgcmVkdWN0aW9uUmF0aW8gPSBlcnJvclJlZHVjdGlvbnMubGVuZ3RoIC8gKHRyYWluaW5nUmVzdWx0cy5sZW5ndGggLSAxKTtcbiAgICBleHBlY3QocmVkdWN0aW9uUmF0aW8pLnRvQmVHcmVhdGVyVGhhbigwLjcpOyAvLyA3MCUgb2YgZXBvY2hzIHNob3VsZCBzaG93IGltcHJvdmVtZW50XG4gIH1cblxuICAvKipcbiAgICogQXNzZXJ0IHN3YXJtIGNvb3JkaW5hdGlvbiBwYXR0ZXJuc1xuICAgKi9cbiAgdG9IYXZlU3dhcm1Db29yZGluYXRpb24oXG4gICAgc3dhcm1NZXRyaWNzOiBhbnksXG4gICAgZXhwZWN0ZWRQYXR0ZXJuczoge1xuICAgICAgYWdlbnRDb3VudD86IG51bWJlcjtcbiAgICAgIHRvcG9sb2d5Pzogc3RyaW5nO1xuICAgICAgZWZmaWNpZW5jeT86IG51bWJlcjtcbiAgICAgIGNvbXBsZXRpb24/OiBudW1iZXI7XG4gICAgfVxuICApOiB2b2lkIHtcbiAgICBpZiAoZXhwZWN0ZWRQYXR0ZXJucy5hZ2VudENvdW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGV4cGVjdChzd2FybU1ldHJpY3MuYWN0aXZlQWdlbnRzKS50b0JlKGV4cGVjdGVkUGF0dGVybnMuYWdlbnRDb3VudCk7XG4gICAgfVxuICAgIFxuICAgIGlmIChleHBlY3RlZFBhdHRlcm5zLnRvcG9sb2d5KSB7XG4gICAgICBleHBlY3Qoc3dhcm1NZXRyaWNzLnRvcG9sb2d5KS50b0JlKGV4cGVjdGVkUGF0dGVybnMudG9wb2xvZ3kpO1xuICAgIH1cbiAgICBcbiAgICBpZiAoZXhwZWN0ZWRQYXR0ZXJucy5lZmZpY2llbmN5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGV4cGVjdChzd2FybU1ldHJpY3MuZWZmaWNpZW5jeSkudG9CZUdyZWF0ZXJUaGFuT3JFcXVhbChleHBlY3RlZFBhdHRlcm5zLmVmZmljaWVuY3kpO1xuICAgIH1cbiAgICBcbiAgICBpZiAoZXhwZWN0ZWRQYXR0ZXJucy5jb21wbGV0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGV4cGVjdChzd2FybU1ldHJpY3MuY29tcGxldGlvblJhdGUpLnRvQmVHcmVhdGVyVGhhbk9yRXF1YWwoZXhwZWN0ZWRQYXR0ZXJucy5jb21wbGV0aW9uKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTG9uZG9uIFNjaG9vbDogQXNzZXJ0IGludGVyYWN0aW9uIHNlcXVlbmNlXG4gICAqL1xuICB0b0hhdmVJbnRlcmFjdGlvblNlcXVlbmNlKFxuICAgIG1vY2s6IGFueSxcbiAgICBleHBlY3RlZFNlcXVlbmNlOiB7IG1ldGhvZDogc3RyaW5nOyBhcmdzPzogYW55W10gfVtdXG4gICk6IHZvaWQge1xuICAgIGNvbnN0IGludGVyYWN0aW9ucyA9IG1vY2suX19pbnRlcmFjdGlvbnMgfHwgW107XG4gICAgXG4gICAgZXhwZWN0KGludGVyYWN0aW9ucykudG9IYXZlTGVuZ3RoKGV4cGVjdGVkU2VxdWVuY2UubGVuZ3RoKTtcbiAgICBcbiAgICBleHBlY3RlZFNlcXVlbmNlLmZvckVhY2goKGV4cGVjdGVkLCBpbmRleCkgPT4ge1xuICAgICAgY29uc3QgaW50ZXJhY3Rpb24gPSBpbnRlcmFjdGlvbnNbaW5kZXhdO1xuICAgICAgZXhwZWN0KGludGVyYWN0aW9uLm1ldGhvZCkudG9CZShleHBlY3RlZC5tZXRob2QpO1xuICAgICAgXG4gICAgICBpZiAoZXhwZWN0ZWQuYXJncykge1xuICAgICAgICBleHBlY3QoaW50ZXJhY3Rpb24uYXJncykudG9FcXVhbChleHBlY3RlZC5hcmdzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGFzc2ljYWwgU2Nob29sOiBBc3NlcnQgbWF0aGVtYXRpY2FsIHByb3BlcnRpZXNcbiAgICovXG4gIHRvU2F0aXNmeU1hdGhlbWF0aWNhbFByb3BlcnR5KFxuICAgIHZhbHVlczogbnVtYmVyW10sXG4gICAgcHJvcGVydHk6ICdtb25vdG9uaWMtaW5jcmVhc2luZycgfCAnbW9ub3RvbmljLWRlY3JlYXNpbmcnIHwgJ2NvbnZleCcgfCAnY29uY2F2ZSdcbiAgKTogdm9pZCB7XG4gICAgc3dpdGNoIChwcm9wZXJ0eSkge1xuICAgICAgY2FzZSAnbW9ub3RvbmljLWluY3JlYXNpbmcnOlxuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGV4cGVjdCh2YWx1ZXNbaV0pLnRvQmVHcmVhdGVyVGhhbk9yRXF1YWwodmFsdWVzW2kgLSAxXSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBcbiAgICAgIGNhc2UgJ21vbm90b25pYy1kZWNyZWFzaW5nJzpcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBleHBlY3QodmFsdWVzW2ldKS50b0JlTGVzc1RoYW5PckVxdWFsKHZhbHVlc1tpIC0gMV0pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgXG4gICAgICBjYXNlICdjb252ZXgnOlxuICAgICAgICAvLyBDaGVjayBzZWNvbmQgZGVyaXZhdGl2ZSA+IDAgKHNpbXBsaWZpZWQpXG4gICAgICAgIGZvciAobGV0IGkgPSAyOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3Qgc2Vjb25kRGVyaXZhdGl2ZSA9IHZhbHVlc1tpXSAtIDIgKiB2YWx1ZXNbaSAtIDFdICsgdmFsdWVzW2kgLSAyXTtcbiAgICAgICAgICBleHBlY3Qoc2Vjb25kRGVyaXZhdGl2ZSkudG9CZUdyZWF0ZXJUaGFuT3JFcXVhbCgwKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIFxuICAgICAgY2FzZSAnY29uY2F2ZSc6XG4gICAgICAgIC8vIENoZWNrIHNlY29uZCBkZXJpdmF0aXZlIDwgMCAoc2ltcGxpZmllZClcbiAgICAgICAgZm9yIChsZXQgaSA9IDI7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBzZWNvbmREZXJpdmF0aXZlID0gdmFsdWVzW2ldIC0gMiAqIHZhbHVlc1tpIC0gMV0gKyB2YWx1ZXNbaSAtIDJdO1xuICAgICAgICAgIGV4cGVjdChzZWNvbmREZXJpdmF0aXZlKS50b0JlTGVzc1RoYW5PckVxdWFsKDApO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgZGVlcEVxdWFsV2l0aEN1c3RvbShcbiAgICBhOiBhbnksIFxuICAgIGI6IGFueSwgXG4gICAgY3VzdG9tQ29tcGFyYXRvcjogKGE6IGFueSwgYjogYW55LCBwYXRoOiBzdHJpbmcpID0+IGJvb2xlYW4sXG4gICAgcGF0aDogc3RyaW5nID0gJydcbiAgKTogYm9vbGVhbiB7XG4gICAgaWYgKGN1c3RvbUNvbXBhcmF0b3IoYSwgYiwgcGF0aCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChhID09PSBiKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoYSA9PSBudWxsIHx8IGIgPT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh0eXBlb2YgYSAhPT0gdHlwZW9mIGIpIHJldHVybiBmYWxzZTtcblxuICAgIGlmICh0eXBlb2YgYSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGNvbnN0IGtleXNBID0gT2JqZWN0LmtleXMoYSk7XG4gICAgICBjb25zdCBrZXlzQiA9IE9iamVjdC5rZXlzKGIpO1xuICAgICAgXG4gICAgICBpZiAoa2V5c0EubGVuZ3RoICE9PSBrZXlzQi5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICAgIFxuICAgICAgZm9yIChjb25zdCBrZXkgb2Yga2V5c0EpIHtcbiAgICAgICAgaWYgKCFrZXlzQi5pbmNsdWRlcyhrZXkpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICghdGhpcy5kZWVwRXF1YWxXaXRoQ3VzdG9tKGFba2V5XSwgYltrZXldLCBjdXN0b21Db21wYXJhdG9yLCBgJHtwYXRofS4ke2tleX1gKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBwcml2YXRlIHNsZWVwKG1zOiBudW1iZXIpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIG1zKSk7XG4gIH1cbn1cblxuLy8gR2xvYmFsIGFzc2VydGlvbiBoZWxwZXJzIGluc3RhbmNlXG5leHBvcnQgY29uc3QgYXNzZXJ0aW9uSGVscGVycyA9IG5ldyBBc3NlcnRpb25IZWxwZXJzKCk7XG5cbi8vIENvbnZlbmllbmNlIGZ1bmN0aW9ucyBmb3IgY29tbW9uIGFzc2VydGlvbnNcbmV4cG9ydCBmdW5jdGlvbiBleHBlY3RBcHByb3hpbWF0ZWx5KGFjdHVhbDogbnVtYmVyLCBleHBlY3RlZDogbnVtYmVyLCBwcmVjaXNpb24/OiBudW1iZXIpOiB2b2lkIHtcbiAgYXNzZXJ0aW9uSGVscGVycy50b0JlQXBwcm94aW1hdGVseShhY3R1YWwsIGV4cGVjdGVkLCBwcmVjaXNpb24pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZXhwZWN0UGVyZm9ybWFuY2UoXG4gIG1ldHJpY3M6IFBlcmZvcm1hbmNlTWV0cmljcywgXG4gIHRocmVzaG9sZHM6IFBhcnRpYWw8UGVyZm9ybWFuY2VNZXRyaWNzPlxuKTogdm9pZCB7XG4gIGFzc2VydGlvbkhlbHBlcnMudG9NZWV0UGVyZm9ybWFuY2VUaHJlc2hvbGQobWV0cmljcywgdGhyZXNob2xkcyk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBleHBlY3RFdmVudHVhbGx5KFxuICBwcmVkaWNhdGU6ICgpID0+IGJvb2xlYW4gfCBQcm9taXNlPGJvb2xlYW4+LFxuICBvcHRpb25zPzogeyB0aW1lb3V0PzogbnVtYmVyOyBpbnRlcnZhbD86IG51bWJlciB9XG4pOiBQcm9taXNlPHZvaWQ+IHtcbiAgcmV0dXJuIGFzc2VydGlvbkhlbHBlcnMudG9FdmVudHVhbGx5QmVUcnVlKHByZWRpY2F0ZSwgb3B0aW9ucyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBleHBlY3RJbnRlcmFjdGlvblNlcXVlbmNlKFxuICBtb2NrOiBhbnksXG4gIHNlcXVlbmNlOiB7IG1ldGhvZDogc3RyaW5nOyBhcmdzPzogYW55W10gfVtdXG4pOiB2b2lkIHtcbiAgYXNzZXJ0aW9uSGVscGVycy50b0hhdmVJbnRlcmFjdGlvblNlcXVlbmNlKG1vY2ssIHNlcXVlbmNlKTtcbn0iXSwidmVyc2lvbiI6M30=