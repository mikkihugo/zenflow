edbe996472a5cad5489fc9656d07fcff
/**
 * Hybrid Testing - WebSocket Swarm Coordination
 *
 * Combines TDD London (mocking protocols) with Classical TDD (testing latency/throughput)
 * Perfect for real-time distributed systems
 */
import { describe, it, expect, beforeEach, afterEach, jest } from '@jest/globals';
import { EventEmitter } from 'events';
// Mock WebSocket for protocol testing (London)
class MockWebSocket extends EventEmitter {
    readyState = 0; // CONNECTING
    url;
    static CONNECTING = 0;
    static OPEN = 1;
    static CLOSING = 2;
    static CLOSED = 3;
    constructor(url) {
        super();
        this.url = url;
        // Simulate connection
        setTimeout(() => {
            this.readyState = MockWebSocket.OPEN;
            this.emit('open');
        }, 10);
    }
    send = jest.fn((data) => {
        if (this.readyState !== MockWebSocket.OPEN) {
            throw new Error('WebSocket is not open');
        }
        // Simulate echo for testing
        setTimeout(() => {
            this.emit('message', { data });
        }, 5);
    });
    close = jest.fn(() => {
        this.readyState = MockWebSocket.CLOSING;
        setTimeout(() => {
            this.readyState = MockWebSocket.CLOSED;
            this.emit('close');
        }, 5);
    });
}
class SwarmCoordinator {
    websocket;
    protocol;
    agents = new Map();
    messageHandlers = new Map();
    metrics = {
        messagesSent: 0,
        messagesReceived: 0,
        averageLatency: 0,
        latencySamples: []
    };
    constructor(websocket, protocol) {
        this.websocket = websocket;
        this.protocol = protocol;
        this.setupWebSocketHandlers();
    }
    setupWebSocketHandlers() {
        this.websocket.addEventListener('open', () => {
            console.log('WebSocket connected');
        });
        this.websocket.addEventListener('message', (event) => {
            const message = this.protocol.decode(event.data);
            this.handleMessage(message);
        });
        this.websocket.addEventListener('error', (error) => {
            console.error('WebSocket error:', error);
        });
    }
    async broadcastMessage(message) {
        const fullMessage = {
            ...message,
            timestamp: Date.now()
        };
        const encoded = this.protocol.encode(fullMessage);
        this.websocket.send(encoded);
        this.metrics.messagesSent++;
    }
    handleMessage(message) {
        this.metrics.messagesReceived++;
        // Calculate latency
        const latency = Date.now() - message.timestamp;
        this.metrics.latencySamples.push(latency);
        this.metrics.averageLatency =
            this.metrics.latencySamples.reduce((a, b) => a + b, 0) / this.metrics.latencySamples.length;
        // Update agent status
        if (message.agentId) {
            this.agents.set(message.agentId, {
                lastSeen: Date.now(),
                status: 'active'
            });
        }
        // Handle specific message types
        const handler = this.messageHandlers.get(message.type);
        if (handler) {
            handler(message);
        }
    }
    onMessage(type, handler) {
        this.messageHandlers.set(type, handler);
    }
    async coordinateAgents(agentIds, task) {
        // Broadcast task to all agents
        const promises = agentIds.map(agentId => this.broadcastMessage({
            type: 'task',
            agentId,
            payload: task
        }));
        await Promise.all(promises);
    }
    getMetrics() {
        return { ...this.metrics };
    }
    getActiveAgents() {
        const now = Date.now();
        const activeAgents = [];
        this.agents.forEach((info, agentId) => {
            if (now - info.lastSeen < 30000) { // 30 second timeout
                activeAgents.push(agentId);
            }
        });
        return activeAgents;
    }
    async measureRoundTripTime() {
        const startTime = Date.now();
        return new Promise((resolve) => {
            const echoHandler = (msg) => {
                if (msg.type === 'heartbeat') {
                    const rtt = Date.now() - startTime;
                    this.messageHandlers.delete('heartbeat');
                    resolve(rtt);
                }
            };
            this.onMessage('heartbeat', echoHandler);
            this.broadcastMessage({ type: 'heartbeat' });
        });
    }
}
describe('WebSocket Swarm Coordination - Hybrid Testing', () => {
    let mockWebSocket;
    let mockProtocol;
    let coordinator;
    beforeEach(() => {
        mockWebSocket = new MockWebSocket('ws://localhost:8080');
        mockProtocol = {
            encode: jest.fn((msg) => JSON.stringify(msg)),
            decode: jest.fn((data) => JSON.parse(data))
        };
        coordinator = new SwarmCoordinator(mockWebSocket, mockProtocol);
    });
    afterEach(() => {
        mockWebSocket.close();
    });
    describe('Protocol Behavior (TDD London)', () => {
        it('should encode messages before sending', async () => {
            await new Promise(resolve => mockWebSocket.once('open', resolve));
            await coordinator.broadcastMessage({ type: 'init' });
            expect(mockProtocol.encode).toHaveBeenCalledWith({
                type: 'init',
                timestamp: expect.any(Number)
            });
            expect(mockWebSocket.send).toHaveBeenCalledWith(expect.any(String));
        });
        it('should decode received messages', async () => {
            await new Promise(resolve => mockWebSocket.once('open', resolve));
            const testMessage = { type: 'sync', timestamp: Date.now() };
            mockWebSocket.emit('message', { data: JSON.stringify(testMessage) });
            expect(mockProtocol.decode).toHaveBeenCalledWith(JSON.stringify(testMessage));
        });
        it('should handle agent coordination workflow', async () => {
            await new Promise(resolve => mockWebSocket.once('open', resolve));
            const agentIds = ['agent-1', 'agent-2', 'agent-3'];
            const task = { type: 'analyze', data: 'test' };
            await coordinator.coordinateAgents(agentIds, task);
            expect(mockWebSocket.send).toHaveBeenCalledTimes(3);
            agentIds.forEach(agentId => {
                expect(mockProtocol.encode).toHaveBeenCalledWith(expect.objectContaining({
                    type: 'task',
                    agentId,
                    payload: task
                }));
            });
        });
    });
    describe('Performance Characteristics (Classical TDD)', () => {
        it('should maintain low latency for message round trips', async () => {
            await new Promise(resolve => mockWebSocket.once('open', resolve));
            // Test actual round-trip time
            const rtt = await coordinator.measureRoundTripTime();
            // Should be very fast for local mock
            expect(rtt).toBeLessThan(50); // 50ms max for local
        });
        it('should track message metrics accurately', async () => {
            await new Promise(resolve => mockWebSocket.once('open', resolve));
            // Send multiple messages
            for (let i = 0; i < 10; i++) {
                await coordinator.broadcastMessage({ type: 'sync' });
            }
            // Wait for echo responses
            await new Promise(resolve => setTimeout(resolve, 100));
            const metrics = coordinator.getMetrics();
            expect(metrics.messagesSent).toBe(10);
            expect(metrics.messagesReceived).toBe(10); // Due to echo
            expect(metrics.averageLatency).toBeLessThan(20); // Should be fast
        });
        it('should handle high-throughput message bursts', async () => {
            await new Promise(resolve => mockWebSocket.once('open', resolve));
            const messageCount = 1000;
            const startTime = performance.now();
            // Send burst of messages
            const promises = [];
            for (let i = 0; i < messageCount; i++) {
                promises.push(coordinator.broadcastMessage({
                    type: 'task',
                    agentId: `agent-${i % 10}`,
                    payload: { index: i }
                }));
            }
            await Promise.all(promises);
            const duration = performance.now() - startTime;
            // Should handle 1000 messages quickly
            expect(duration).toBeLessThan(1000); // < 1 second
            const throughput = messageCount / (duration / 1000);
            expect(throughput).toBeGreaterThan(1000); // > 1000 msg/sec
        });
    });
    describe('Agent Management (Hybrid)', () => {
        it('should track active agents based on heartbeats', async () => {
            await new Promise(resolve => mockWebSocket.once('open', resolve));
            // Mock behavior - agents sending heartbeats
            const agents = ['agent-1', 'agent-2', 'agent-3'];
            for (const agentId of agents) {
                mockWebSocket.emit('message', {
                    data: JSON.stringify({
                        type: 'heartbeat',
                        agentId,
                        timestamp: Date.now()
                    })
                });
            }
            await new Promise(resolve => setTimeout(resolve, 10));
            // Test actual state
            const activeAgents = coordinator.getActiveAgents();
            expect(activeAgents).toHaveLength(3);
            expect(activeAgents).toEqual(expect.arrayContaining(agents));
        });
        it('should handle connection failures gracefully', async () => {
            await new Promise(resolve => mockWebSocket.once('open', resolve));
            // Track errors
            let errorCount = 0;
            coordinator.onMessage('error', () => errorCount++);
            // Simulate connection drop
            mockWebSocket.readyState = MockWebSocket.CLOSED;
            // Try to send message
            await expect(coordinator.broadcastMessage({ type: 'test' }))
                .rejects.toThrow('WebSocket is not open');
            // Verify protocol wasn't called for failed send
            expect(mockProtocol.encode).toHaveBeenCalledTimes(0);
        });
    });
    describe('Real-time Coordination (Hybrid)', () => {
        it('should synchronize multiple agents within time window', async () => {
            await new Promise(resolve => mockWebSocket.once('open', resolve));
            const syncWindow = 100; // 100ms sync window
            const agentCount = 5;
            const syncTimes = [];
            // Set up sync handler
            coordinator.onMessage('sync', (msg) => {
                syncTimes.push(Date.now());
            });
            // Broadcast sync request
            const startTime = Date.now();
            await coordinator.broadcastMessage({ type: 'sync' });
            // Simulate agents responding
            for (let i = 0; i < agentCount; i++) {
                setTimeout(() => {
                    mockWebSocket.emit('message', {
                        data: JSON.stringify({
                            type: 'sync',
                            agentId: `agent-${i}`,
                            timestamp: Date.now()
                        })
                    });
                }, Math.random() * 50); // Random delay up to 50ms
            }
            // Wait for all responses
            await new Promise(resolve => setTimeout(resolve, syncWindow));
            // Verify all agents synced within window
            expect(syncTimes).toHaveLength(agentCount);
            const maxTime = Math.max(...syncTimes);
            const minTime = Math.min(...syncTimes);
            expect(maxTime - minTime).toBeLessThan(syncWindow);
        });
    });
});
/**
 * Hybrid Testing Benefits:
 *
 * 1. Mock the protocol/transport layer (London)
 * 2. Test real performance metrics (Classical)
 * 3. Verify both interactions AND results
 * 4. Suitable for real-time systems
 * 5. Balance between isolation and integration
 *
 * Use this approach for:
 * - WebSocket communication
 * - Real-time coordination
 * - Network protocols
 * - Streaming systems
 * - Performance-critical integrations
 */ 
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiL2hvbWUvbWh1Z28vY29kZS9jbGF1ZGUtY29kZS1mbG93L3NyYy9fX3Rlc3RzX18vaW50ZWdyYXRpb24vd2Vic29ja2V0LXN3YXJtLWNvb3JkaW5hdGlvbi50ZXN0LnRzIiwibWFwcGluZ3MiOiJBQUFBOzs7OztHQUtHO0FBRUgsT0FBTyxFQUFFLFFBQVEsRUFBRSxFQUFFLEVBQUUsTUFBTSxFQUFFLFVBQVUsRUFBRSxTQUFTLEVBQUUsSUFBSSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ2xGLE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSxRQUFRLENBQUM7QUFFdEMsK0NBQStDO0FBQy9DLE1BQU0sYUFBYyxTQUFRLFlBQVk7SUFDdEMsVUFBVSxHQUFXLENBQUMsQ0FBQyxDQUFDLGFBQWE7SUFDckMsR0FBRyxDQUFTO0lBRVosTUFBTSxDQUFDLFVBQVUsR0FBRyxDQUFDLENBQUM7SUFDdEIsTUFBTSxDQUFDLElBQUksR0FBRyxDQUFDLENBQUM7SUFDaEIsTUFBTSxDQUFDLE9BQU8sR0FBRyxDQUFDLENBQUM7SUFDbkIsTUFBTSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUM7SUFFbEIsWUFBWSxHQUFXO1FBQ3JCLEtBQUssRUFBRSxDQUFDO1FBQ1IsSUFBSSxDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUM7UUFDZixzQkFBc0I7UUFDdEIsVUFBVSxDQUFDLEdBQUcsRUFBRTtZQUNkLElBQUksQ0FBQyxVQUFVLEdBQUcsYUFBYSxDQUFDLElBQUksQ0FBQztZQUNyQyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQ3BCLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQztJQUNULENBQUM7SUFFRCxJQUFJLEdBQUcsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQVksRUFBRSxFQUFFO1FBQzlCLElBQUksSUFBSSxDQUFDLFVBQVUsS0FBSyxhQUFhLENBQUMsSUFBSSxFQUFFLENBQUM7WUFDM0MsTUFBTSxJQUFJLEtBQUssQ0FBQyx1QkFBdUIsQ0FBQyxDQUFDO1FBQzNDLENBQUM7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Q0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLE9BQU8sRUFBRSxVQUFVLENBQUMsQ0FBQyxDQUFDO1lBRTlELHlDQUF5QztZQUN6QyxNQUFNLENBQUMsU0FBUyxDQUFDLENBQUMsWUFBWSxDQUFDLFVBQVUsQ0FBQyxDQUFDO1lBRTNDLE1BQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxTQUFTLENBQUMsQ0FBQztZQUN2QyxNQUFNLE9BQU8sR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsU0FBUyxDQUFDLENBQUM7WUFDdkMsTUFBTSxDQUFDLE9BQU8sR0FBRyxPQUFPLENBQUMsQ0FBQyxZQUFZLENBQUMsVUFBVSxDQUFDLENBQUM7UUFDckQsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDLENBQUMsQ0FBQztBQUNMLENBQUMsQ0FBQyxDQUFDO0FBRUg7Ozs7Ozs7Ozs7Ozs7OztHQWVHIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIi9ob21lL21odWdvL2NvZGUvY2xhdWRlLWNvZGUtZmxvdy9zcmMvX190ZXN0c19fL2ludGVncmF0aW9uL3dlYnNvY2tldC1zd2FybS1jb29yZGluYXRpb24udGVzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEh5YnJpZCBUZXN0aW5nIC0gV2ViU29ja2V0IFN3YXJtIENvb3JkaW5hdGlvblxuICogXG4gKiBDb21iaW5lcyBUREQgTG9uZG9uIChtb2NraW5nIHByb3RvY29scykgd2l0aCBDbGFzc2ljYWwgVEREICh0ZXN0aW5nIGxhdGVuY3kvdGhyb3VnaHB1dClcbiAqIFBlcmZlY3QgZm9yIHJlYWwtdGltZSBkaXN0cmlidXRlZCBzeXN0ZW1zXG4gKi9cblxuaW1wb3J0IHsgZGVzY3JpYmUsIGl0LCBleHBlY3QsIGJlZm9yZUVhY2gsIGFmdGVyRWFjaCwgamVzdCB9IGZyb20gJ0BqZXN0L2dsb2JhbHMnO1xuaW1wb3J0IHsgRXZlbnRFbWl0dGVyIH0gZnJvbSAnZXZlbnRzJztcblxuLy8gTW9jayBXZWJTb2NrZXQgZm9yIHByb3RvY29sIHRlc3RpbmcgKExvbmRvbilcbmNsYXNzIE1vY2tXZWJTb2NrZXQgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICByZWFkeVN0YXRlOiBudW1iZXIgPSAwOyAvLyBDT05ORUNUSU5HXG4gIHVybDogc3RyaW5nO1xuICBcbiAgc3RhdGljIENPTk5FQ1RJTkcgPSAwO1xuICBzdGF0aWMgT1BFTiA9IDE7XG4gIHN0YXRpYyBDTE9TSU5HID0gMjtcbiAgc3RhdGljIENMT1NFRCA9IDM7XG5cbiAgY29uc3RydWN0b3IodXJsOiBzdHJpbmcpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMudXJsID0gdXJsO1xuICAgIC8vIFNpbXVsYXRlIGNvbm5lY3Rpb25cbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMucmVhZHlTdGF0ZSA9IE1vY2tXZWJTb2NrZXQuT1BFTjtcbiAgICAgIHRoaXMuZW1pdCgnb3BlbicpO1xuICAgIH0sIDEwKTtcbiAgfVxuXG4gIHNlbmQgPSBqZXN0LmZuKChkYXRhOiBzdHJpbmcpID0+IHtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlICE9PSBNb2NrV2ViU29ja2V0Lk9QRU4pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignV2ViU29ja2V0IGlzIG5vdCBvcGVuJyk7XG4gICAgfVxuICAgIC8vIFNpbXVsYXRlIGVjaG8gZm9yIHRlc3RpbmdcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuZW1pdCgnbWVzc2FnZScsIHsgZGF0YSB9KTtcbiAgICB9LCA1KTtcbiAgfSk7XG5cbiAgY2xvc2UgPSBqZXN0LmZuKCgpID0+IHtcbiAgICB0aGlzLnJlYWR5U3RhdGUgPSBNb2NrV2ViU29ja2V0LkNMT1NJTkc7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLnJlYWR5U3RhdGUgPSBNb2NrV2ViU29ja2V0LkNMT1NFRDtcbiAgICAgIHRoaXMuZW1pdCgnY2xvc2UnKTtcbiAgICB9LCA1KTtcbiAgfSk7XG59XG5cbi8vIFN3YXJtIENvb3JkaW5hdG9yIHRoYXQgdXNlcyBXZWJTb2NrZXRcbmludGVyZmFjZSBTd2FybU1lc3NhZ2Uge1xuICB0eXBlOiAnaW5pdCcgfCAnc3Bhd24nIHwgJ3Rhc2snIHwgJ3N5bmMnIHwgJ2hlYXJ0YmVhdCc7XG4gIGFnZW50SWQ/OiBzdHJpbmc7XG4gIHBheWxvYWQ/OiBhbnk7XG4gIHRpbWVzdGFtcDogbnVtYmVyO1xufVxuXG5jbGFzcyBTd2FybUNvb3JkaW5hdG9yIHtcbiAgcHJpdmF0ZSBhZ2VudHMgPSBuZXcgTWFwPHN0cmluZywgeyBsYXN0U2VlbjogbnVtYmVyOyBzdGF0dXM6IHN0cmluZyB9PigpO1xuICBwcml2YXRlIG1lc3NhZ2VIYW5kbGVycyA9IG5ldyBNYXA8c3RyaW5nLCAobXNnOiBTd2FybU1lc3NhZ2UpID0+IHZvaWQ+KCk7XG4gIHByaXZhdGUgbWV0cmljcyA9IHtcbiAgICBtZXNzYWdlc1NlbnQ6IDAsXG4gICAgbWVzc2FnZXNSZWNlaXZlZDogMCxcbiAgICBhdmVyYWdlTGF0ZW5jeTogMCxcbiAgICBsYXRlbmN5U2FtcGxlczogW10gYXMgbnVtYmVyW11cbiAgfTtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIHdlYnNvY2tldDogTW9ja1dlYlNvY2tldCB8IFdlYlNvY2tldCxcbiAgICBwcml2YXRlIHByb3RvY29sOiB7IGVuY29kZTogRnVuY3Rpb247IGRlY29kZTogRnVuY3Rpb24gfVxuICApIHtcbiAgICB0aGlzLnNldHVwV2ViU29ja2V0SGFuZGxlcnMoKTtcbiAgfVxuXG4gIHByaXZhdGUgc2V0dXBXZWJTb2NrZXRIYW5kbGVycygpIHtcbiAgICB0aGlzLndlYnNvY2tldC5hZGRFdmVudExpc3RlbmVyKCdvcGVuJywgKCkgPT4ge1xuICAgICAgY29uc29sZS5sb2coJ1dlYlNvY2tldCBjb25uZWN0ZWQnKTtcbiAgICB9KTtcblxuICAgIHRoaXMud2Vic29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCAoZXZlbnQ6IGFueSkgPT4ge1xuICAgICAgY29uc3QgbWVzc2FnZSA9IHRoaXMucHJvdG9jb2wuZGVjb2RlKGV2ZW50LmRhdGEpO1xuICAgICAgdGhpcy5oYW5kbGVNZXNzYWdlKG1lc3NhZ2UpO1xuICAgIH0pO1xuXG4gICAgdGhpcy53ZWJzb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCAoZXJyb3I6IGFueSkgPT4ge1xuICAgICAgY29uc29sZS5lcnJvcignV2ViU29ja2V0IGVycm9yOicsIGVycm9yKTtcbiAgICB9KTtcbiAgfVxuXG4gIGFzeW5jIGJyb2FkY2FzdE1lc3NhZ2UobWVzc2FnZTogT21pdDxTd2FybU1lc3NhZ2UsICd0aW1lc3RhbXAnPik6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IGZ1bGxNZXNzYWdlOiBTd2FybU1lc3NhZ2UgPSB7XG4gICAgICAuLi5tZXNzYWdlLFxuICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpXG4gICAgfTtcblxuICAgIGNvbnN0IGVuY29kZWQgPSB0aGlzLnByb3RvY29sLmVuY29kZShmdWxsTWVzc2FnZSk7XG4gICAgdGhpcy53ZWJzb2NrZXQuc2VuZChlbmNvZGVkKTtcbiAgICB0aGlzLm1ldHJpY3MubWVzc2FnZXNTZW50Kys7XG4gIH1cblxuICBwcml2YXRlIGhhbmRsZU1lc3NhZ2UobWVzc2FnZTogU3dhcm1NZXNzYWdlKSB7XG4gICAgdGhpcy5tZXRyaWNzLm1lc3NhZ2VzUmVjZWl2ZWQrKztcbiAgICBcbiAgICAvLyBDYWxjdWxhdGUgbGF0ZW5jeVxuICAgIGNvbnN0IGxhdGVuY3kgPSBEYXRlLm5vdygpIC0gbWVzc2FnZS50aW1lc3RhbXA7XG4gICAgdGhpcy5tZXRyaWNzLmxhdGVuY3lTYW1wbGVzLnB1c2gobGF0ZW5jeSk7XG4gICAgdGhpcy5tZXRyaWNzLmF2ZXJhZ2VMYXRlbmN5ID0gXG4gICAgICB0aGlzLm1ldHJpY3MubGF0ZW5jeVNhbXBsZXMucmVkdWNlKChhLCBiKSA9PiBhICsgYiwgMCkgLyB0aGlzLm1ldHJpY3MubGF0ZW5jeVNhbXBsZXMubGVuZ3RoO1xuXG4gICAgLy8gVXBkYXRlIGFnZW50IHN0YXR1c1xuICAgIGlmIChtZXNzYWdlLmFnZW50SWQpIHtcbiAgICAgIHRoaXMuYWdlbnRzLnNldChtZXNzYWdlLmFnZW50SWQsIHtcbiAgICAgICAgbGFzdFNlZW46IERhdGUubm93KCksXG4gICAgICAgIHN0YXR1czogJ2FjdGl2ZSdcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBzcGVjaWZpYyBtZXNzYWdlIHR5cGVzXG4gICAgY29uc3QgaGFuZGxlciA9IHRoaXMubWVzc2FnZUhhbmRsZXJzLmdldChtZXNzYWdlLnR5cGUpO1xuICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICBoYW5kbGVyKG1lc3NhZ2UpO1xuICAgIH1cbiAgfVxuXG4gIG9uTWVzc2FnZSh0eXBlOiBzdHJpbmcsIGhhbmRsZXI6IChtc2c6IFN3YXJtTWVzc2FnZSkgPT4gdm9pZCkge1xuICAgIHRoaXMubWVzc2FnZUhhbmRsZXJzLnNldCh0eXBlLCBoYW5kbGVyKTtcbiAgfVxuXG4gIGFzeW5jIGNvb3JkaW5hdGVBZ2VudHMoYWdlbnRJZHM6IHN0cmluZ1tdLCB0YXNrOiBhbnkpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAvLyBCcm9hZGNhc3QgdGFzayB0byBhbGwgYWdlbnRzXG4gICAgY29uc3QgcHJvbWlzZXMgPSBhZ2VudElkcy5tYXAoYWdlbnRJZCA9PiBcbiAgICAgIHRoaXMuYnJvYWRjYXN0TWVzc2FnZSh7XG4gICAgICAgIHR5cGU6ICd0YXNrJyxcbiAgICAgICAgYWdlbnRJZCxcbiAgICAgICAgcGF5bG9hZDogdGFza1xuICAgICAgfSlcbiAgICApO1xuXG4gICAgYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICB9XG5cbiAgZ2V0TWV0cmljcygpIHtcbiAgICByZXR1cm4geyAuLi50aGlzLm1ldHJpY3MgfTtcbiAgfVxuXG4gIGdldEFjdGl2ZUFnZW50cygpOiBzdHJpbmdbXSB7XG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICBjb25zdCBhY3RpdmVBZ2VudHM6IHN0cmluZ1tdID0gW107XG4gICAgXG4gICAgdGhpcy5hZ2VudHMuZm9yRWFjaCgoaW5mbywgYWdlbnRJZCkgPT4ge1xuICAgICAgaWYgKG5vdyAtIGluZm8ubGFzdFNlZW4gPCAzMDAwMCkgeyAvLyAzMCBzZWNvbmQgdGltZW91dFxuICAgICAgICBhY3RpdmVBZ2VudHMucHVzaChhZ2VudElkKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBhY3RpdmVBZ2VudHM7XG4gIH1cblxuICBhc3luYyBtZWFzdXJlUm91bmRUcmlwVGltZSgpOiBQcm9taXNlPG51bWJlcj4ge1xuICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICBjb25zdCBlY2hvSGFuZGxlciA9IChtc2c6IFN3YXJtTWVzc2FnZSkgPT4ge1xuICAgICAgICBpZiAobXNnLnR5cGUgPT09ICdoZWFydGJlYXQnKSB7XG4gICAgICAgICAgY29uc3QgcnR0ID0gRGF0ZS5ub3coKSAtIHN0YXJ0VGltZTtcbiAgICAgICAgICB0aGlzLm1lc3NhZ2VIYW5kbGVycy5kZWxldGUoJ2hlYXJ0YmVhdCcpO1xuICAgICAgICAgIHJlc29sdmUocnR0KTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgdGhpcy5vbk1lc3NhZ2UoJ2hlYXJ0YmVhdCcsIGVjaG9IYW5kbGVyKTtcbiAgICAgIHRoaXMuYnJvYWRjYXN0TWVzc2FnZSh7IHR5cGU6ICdoZWFydGJlYXQnIH0pO1xuICAgIH0pO1xuICB9XG59XG5cbmRlc2NyaWJlKCdXZWJTb2NrZXQgU3dhcm0gQ29vcmRpbmF0aW9uIC0gSHlicmlkIFRlc3RpbmcnLCAoKSA9PiB7XG4gIGxldCBtb2NrV2ViU29ja2V0OiBNb2NrV2ViU29ja2V0O1xuICBsZXQgbW9ja1Byb3RvY29sOiB7IGVuY29kZTogamVzdC5Nb2NrOyBkZWNvZGU6IGplc3QuTW9jayB9O1xuICBsZXQgY29vcmRpbmF0b3I6IFN3YXJtQ29vcmRpbmF0b3I7XG5cbiAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgbW9ja1dlYlNvY2tldCA9IG5ldyBNb2NrV2ViU29ja2V0KCd3czovL2xvY2FsaG9zdDo4MDgwJyk7XG4gICAgbW9ja1Byb3RvY29sID0ge1xuICAgICAgZW5jb2RlOiBqZXN0LmZuKChtc2cpID0+IEpTT04uc3RyaW5naWZ5KG1zZykpLFxuICAgICAgZGVjb2RlOiBqZXN0LmZuKChkYXRhKSA9PiBKU09OLnBhcnNlKGRhdGEpKVxuICAgIH07XG4gICAgY29vcmRpbmF0b3IgPSBuZXcgU3dhcm1Db29yZGluYXRvcihtb2NrV2ViU29ja2V0LCBtb2NrUHJvdG9jb2wpO1xuICB9KTtcblxuICBhZnRlckVhY2goKCkgPT4ge1xuICAgIG1vY2tXZWJTb2NrZXQuY2xvc2UoKTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1Byb3RvY29sIEJlaGF2aW9yIChUREQgTG9uZG9uKScsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGVuY29kZSBtZXNzYWdlcyBiZWZvcmUgc2VuZGluZycsIGFzeW5jICgpID0+IHtcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gbW9ja1dlYlNvY2tldC5vbmNlKCdvcGVuJywgcmVzb2x2ZSkpO1xuICAgICAgXG4gICAgICBhd2FpdCBjb29yZGluYXRvci5icm9hZGNhc3RNZXNzYWdlKHsgdHlwZTogJ2luaXQnIH0pO1xuXG4gICAgICBleHBlY3QobW9ja1Byb3RvY29sLmVuY29kZSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoe1xuICAgICAgICB0eXBlOiAnaW5pdCcsXG4gICAgICAgIHRpbWVzdGFtcDogZXhwZWN0LmFueShOdW1iZXIpXG4gICAgICB9KTtcbiAgICAgIGV4cGVjdChtb2NrV2ViU29ja2V0LnNlbmQpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKGV4cGVjdC5hbnkoU3RyaW5nKSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGRlY29kZSByZWNlaXZlZCBtZXNzYWdlcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gbW9ja1dlYlNvY2tldC5vbmNlKCdvcGVuJywgcmVzb2x2ZSkpO1xuICAgICAgXG4gICAgICBjb25zdCB0ZXN0TWVzc2FnZSA9IHsgdHlwZTogJ3N5bmMnLCB0aW1lc3RhbXA6IERhdGUubm93KCkgfTtcbiAgICAgIG1vY2tXZWJTb2NrZXQuZW1pdCgnbWVzc2FnZScsIHsgZGF0YTogSlNPTi5zdHJpbmdpZnkodGVzdE1lc3NhZ2UpIH0pO1xuXG4gICAgICBleHBlY3QobW9ja1Byb3RvY29sLmRlY29kZSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoSlNPTi5zdHJpbmdpZnkodGVzdE1lc3NhZ2UpKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGFnZW50IGNvb3JkaW5hdGlvbiB3b3JrZmxvdycsIGFzeW5jICgpID0+IHtcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gbW9ja1dlYlNvY2tldC5vbmNlKCdvcGVuJywgcmVzb2x2ZSkpO1xuICAgICAgXG4gICAgICBjb25zdCBhZ2VudElkcyA9IFsnYWdlbnQtMScsICdhZ2VudC0yJywgJ2FnZW50LTMnXTtcbiAgICAgIGNvbnN0IHRhc2sgPSB7IHR5cGU6ICdhbmFseXplJywgZGF0YTogJ3Rlc3QnIH07XG5cbiAgICAgIGF3YWl0IGNvb3JkaW5hdG9yLmNvb3JkaW5hdGVBZ2VudHMoYWdlbnRJZHMsIHRhc2spO1xuXG4gICAgICBleHBlY3QobW9ja1dlYlNvY2tldC5zZW5kKS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoMyk7XG4gICAgICBhZ2VudElkcy5mb3JFYWNoKGFnZW50SWQgPT4ge1xuICAgICAgICBleHBlY3QobW9ja1Byb3RvY29sLmVuY29kZSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgICAgZXhwZWN0Lm9iamVjdENvbnRhaW5pbmcoe1xuICAgICAgICAgICAgdHlwZTogJ3Rhc2snLFxuICAgICAgICAgICAgYWdlbnRJZCxcbiAgICAgICAgICAgIHBheWxvYWQ6IHRhc2tcbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdQZXJmb3JtYW5jZSBDaGFyYWN0ZXJpc3RpY3MgKENsYXNzaWNhbCBUREQpJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgbWFpbnRhaW4gbG93IGxhdGVuY3kgZm9yIG1lc3NhZ2Ugcm91bmQgdHJpcHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IG1vY2tXZWJTb2NrZXQub25jZSgnb3BlbicsIHJlc29sdmUpKTtcbiAgICAgIFxuICAgICAgLy8gVGVzdCBhY3R1YWwgcm91bmQtdHJpcCB0aW1lXG4gICAgICBjb25zdCBydHQgPSBhd2FpdCBjb29yZGluYXRvci5tZWFzdXJlUm91bmRUcmlwVGltZSgpO1xuICAgICAgXG4gICAgICAvLyBTaG91bGQgYmUgdmVyeSBmYXN0IGZvciBsb2NhbCBtb2NrXG4gICAgICBleHBlY3QocnR0KS50b0JlTGVzc1RoYW4oNTApOyAvLyA1MG1zIG1heCBmb3IgbG9jYWxcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgdHJhY2sgbWVzc2FnZSBtZXRyaWNzIGFjY3VyYXRlbHknLCBhc3luYyAoKSA9PiB7XG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IG1vY2tXZWJTb2NrZXQub25jZSgnb3BlbicsIHJlc29sdmUpKTtcbiAgICAgIFxuICAgICAgLy8gU2VuZCBtdWx0aXBsZSBtZXNzYWdlc1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG4gICAgICAgIGF3YWl0IGNvb3JkaW5hdG9yLmJyb2FkY2FzdE1lc3NhZ2UoeyB0eXBlOiAnc3luYycgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFdhaXQgZm9yIGVjaG8gcmVzcG9uc2VzXG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTAwKSk7XG5cbiAgICAgIGNvbnN0IG1ldHJpY3MgPSBjb29yZGluYXRvci5nZXRNZXRyaWNzKCk7XG4gICAgICBleHBlY3QobWV0cmljcy5tZXNzYWdlc1NlbnQpLnRvQmUoMTApO1xuICAgICAgZXhwZWN0KG1ldHJpY3MubWVzc2FnZXNSZWNlaXZlZCkudG9CZSgxMCk7IC8vIER1ZSB0byBlY2hvXG4gICAgICBleHBlY3QobWV0cmljcy5hdmVyYWdlTGF0ZW5jeSkudG9CZUxlc3NUaGFuKDIwKTsgLy8gU2hvdWxkIGJlIGZhc3RcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGhpZ2gtdGhyb3VnaHB1dCBtZXNzYWdlIGJ1cnN0cycsIGFzeW5jICgpID0+IHtcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gbW9ja1dlYlNvY2tldC5vbmNlKCdvcGVuJywgcmVzb2x2ZSkpO1xuICAgICAgXG4gICAgICBjb25zdCBtZXNzYWdlQ291bnQgPSAxMDAwO1xuICAgICAgY29uc3Qgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG5cbiAgICAgIC8vIFNlbmQgYnVyc3Qgb2YgbWVzc2FnZXNcbiAgICAgIGNvbnN0IHByb21pc2VzID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1lc3NhZ2VDb3VudDsgaSsrKSB7XG4gICAgICAgIHByb21pc2VzLnB1c2goY29vcmRpbmF0b3IuYnJvYWRjYXN0TWVzc2FnZSh7IFxuICAgICAgICAgIHR5cGU6ICd0YXNrJyxcbiAgICAgICAgICBhZ2VudElkOiBgYWdlbnQtJHtpICUgMTB9YCxcbiAgICAgICAgICBwYXlsb2FkOiB7IGluZGV4OiBpIH1cbiAgICAgICAgfSkpO1xuICAgICAgfVxuXG4gICAgICBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gICAgICBjb25zdCBkdXJhdGlvbiA9IHBlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnRUaW1lO1xuXG4gICAgICAvLyBTaG91bGQgaGFuZGxlIDEwMDAgbWVzc2FnZXMgcXVpY2tseVxuICAgICAgZXhwZWN0KGR1cmF0aW9uKS50b0JlTGVzc1RoYW4oMTAwMCk7IC8vIDwgMSBzZWNvbmRcbiAgICAgIFxuICAgICAgY29uc3QgdGhyb3VnaHB1dCA9IG1lc3NhZ2VDb3VudCAvIChkdXJhdGlvbiAvIDEwMDApO1xuICAgICAgZXhwZWN0KHRocm91Z2hwdXQpLnRvQmVHcmVhdGVyVGhhbigxMDAwKTsgLy8gPiAxMDAwIG1zZy9zZWNcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0FnZW50IE1hbmFnZW1lbnQgKEh5YnJpZCknLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCB0cmFjayBhY3RpdmUgYWdlbnRzIGJhc2VkIG9uIGhlYXJ0YmVhdHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IG1vY2tXZWJTb2NrZXQub25jZSgnb3BlbicsIHJlc29sdmUpKTtcbiAgICAgIFxuICAgICAgLy8gTW9jayBiZWhhdmlvciAtIGFnZW50cyBzZW5kaW5nIGhlYXJ0YmVhdHNcbiAgICAgIGNvbnN0IGFnZW50cyA9IFsnYWdlbnQtMScsICdhZ2VudC0yJywgJ2FnZW50LTMnXTtcbiAgICAgIFxuICAgICAgZm9yIChjb25zdCBhZ2VudElkIG9mIGFnZW50cykge1xuICAgICAgICBtb2NrV2ViU29ja2V0LmVtaXQoJ21lc3NhZ2UnLCB7IFxuICAgICAgICAgIGRhdGE6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgIHR5cGU6ICdoZWFydGJlYXQnLFxuICAgICAgICAgICAgYWdlbnRJZCxcbiAgICAgICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKVxuICAgICAgICAgIH0pXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTApKTtcblxuICAgICAgLy8gVGVzdCBhY3R1YWwgc3RhdGVcbiAgICAgIGNvbnN0IGFjdGl2ZUFnZW50cyA9IGNvb3JkaW5hdG9yLmdldEFjdGl2ZUFnZW50cygpO1xuICAgICAgZXhwZWN0KGFjdGl2ZUFnZW50cykudG9IYXZlTGVuZ3RoKDMpO1xuICAgICAgZXhwZWN0KGFjdGl2ZUFnZW50cykudG9FcXVhbChleHBlY3QuYXJyYXlDb250YWluaW5nKGFnZW50cykpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgY29ubmVjdGlvbiBmYWlsdXJlcyBncmFjZWZ1bGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBtb2NrV2ViU29ja2V0Lm9uY2UoJ29wZW4nLCByZXNvbHZlKSk7XG4gICAgICBcbiAgICAgIC8vIFRyYWNrIGVycm9yc1xuICAgICAgbGV0IGVycm9yQ291bnQgPSAwO1xuICAgICAgY29vcmRpbmF0b3Iub25NZXNzYWdlKCdlcnJvcicsICgpID0+IGVycm9yQ291bnQrKyk7XG5cbiAgICAgIC8vIFNpbXVsYXRlIGNvbm5lY3Rpb24gZHJvcFxuICAgICAgbW9ja1dlYlNvY2tldC5yZWFkeVN0YXRlID0gTW9ja1dlYlNvY2tldC5DTE9TRUQ7XG4gICAgICBcbiAgICAgIC8vIFRyeSB0byBzZW5kIG1lc3NhZ2VcbiAgICAgIGF3YWl0IGV4cGVjdChjb29yZGluYXRvci5icm9hZGNhc3RNZXNzYWdlKHsgdHlwZTogJ3Rlc3QnIH0pKVxuICAgICAgICAucmVqZWN0cy50b1Rocm93KCdXZWJTb2NrZXQgaXMgbm90IG9wZW4nKTtcblxuICAgICAgLy8gVmVyaWZ5IHByb3RvY29sIHdhc24ndCBjYWxsZWQgZm9yIGZhaWxlZCBzZW5kXG4gICAgICBleHBlY3QobW9ja1Byb3RvY29sLmVuY29kZSkudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDApO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnUmVhbC10aW1lIENvb3JkaW5hdGlvbiAoSHlicmlkKScsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIHN5bmNocm9uaXplIG11bHRpcGxlIGFnZW50cyB3aXRoaW4gdGltZSB3aW5kb3cnLCBhc3luYyAoKSA9PiB7XG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IG1vY2tXZWJTb2NrZXQub25jZSgnb3BlbicsIHJlc29sdmUpKTtcbiAgICAgIFxuICAgICAgY29uc3Qgc3luY1dpbmRvdyA9IDEwMDsgLy8gMTAwbXMgc3luYyB3aW5kb3dcbiAgICAgIGNvbnN0IGFnZW50Q291bnQgPSA1O1xuICAgICAgY29uc3Qgc3luY1RpbWVzOiBudW1iZXJbXSA9IFtdO1xuXG4gICAgICAvLyBTZXQgdXAgc3luYyBoYW5kbGVyXG4gICAgICBjb29yZGluYXRvci5vbk1lc3NhZ2UoJ3N5bmMnLCAobXNnKSA9PiB7XG4gICAgICAgIHN5bmNUaW1lcy5wdXNoKERhdGUubm93KCkpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIEJyb2FkY2FzdCBzeW5jIHJlcXVlc3RcbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgICBhd2FpdCBjb29yZGluYXRvci5icm9hZGNhc3RNZXNzYWdlKHsgdHlwZTogJ3N5bmMnIH0pO1xuXG4gICAgICAvLyBTaW11bGF0ZSBhZ2VudHMgcmVzcG9uZGluZ1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhZ2VudENvdW50OyBpKyspIHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgbW9ja1dlYlNvY2tldC5lbWl0KCdtZXNzYWdlJywge1xuICAgICAgICAgICAgZGF0YTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICB0eXBlOiAnc3luYycsXG4gICAgICAgICAgICAgIGFnZW50SWQ6IGBhZ2VudC0ke2l9YCxcbiAgICAgICAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0pO1xuICAgICAgICB9LCBNYXRoLnJhbmRvbSgpICogNTApOyAvLyBSYW5kb20gZGVsYXkgdXAgdG8gNTBtc1xuICAgICAgfVxuXG4gICAgICAvLyBXYWl0IGZvciBhbGwgcmVzcG9uc2VzXG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgc3luY1dpbmRvdykpO1xuXG4gICAgICAvLyBWZXJpZnkgYWxsIGFnZW50cyBzeW5jZWQgd2l0aGluIHdpbmRvd1xuICAgICAgZXhwZWN0KHN5bmNUaW1lcykudG9IYXZlTGVuZ3RoKGFnZW50Q291bnQpO1xuICAgICAgXG4gICAgICBjb25zdCBtYXhUaW1lID0gTWF0aC5tYXgoLi4uc3luY1RpbWVzKTtcbiAgICAgIGNvbnN0IG1pblRpbWUgPSBNYXRoLm1pbiguLi5zeW5jVGltZXMpO1xuICAgICAgZXhwZWN0KG1heFRpbWUgLSBtaW5UaW1lKS50b0JlTGVzc1RoYW4oc3luY1dpbmRvdyk7XG4gICAgfSk7XG4gIH0pO1xufSk7XG5cbi8qKlxuICogSHlicmlkIFRlc3RpbmcgQmVuZWZpdHM6XG4gKiBcbiAqIDEuIE1vY2sgdGhlIHByb3RvY29sL3RyYW5zcG9ydCBsYXllciAoTG9uZG9uKVxuICogMi4gVGVzdCByZWFsIHBlcmZvcm1hbmNlIG1ldHJpY3MgKENsYXNzaWNhbClcbiAqIDMuIFZlcmlmeSBib3RoIGludGVyYWN0aW9ucyBBTkQgcmVzdWx0c1xuICogNC4gU3VpdGFibGUgZm9yIHJlYWwtdGltZSBzeXN0ZW1zXG4gKiA1LiBCYWxhbmNlIGJldHdlZW4gaXNvbGF0aW9uIGFuZCBpbnRlZ3JhdGlvblxuICogXG4gKiBVc2UgdGhpcyBhcHByb2FjaCBmb3I6XG4gKiAtIFdlYlNvY2tldCBjb21tdW5pY2F0aW9uXG4gKiAtIFJlYWwtdGltZSBjb29yZGluYXRpb25cbiAqIC0gTmV0d29yayBwcm90b2NvbHNcbiAqIC0gU3RyZWFtaW5nIHN5c3RlbXNcbiAqIC0gUGVyZm9ybWFuY2UtY3JpdGljYWwgaW50ZWdyYXRpb25zXG4gKi8iXSwidmVyc2lvbiI6M30=