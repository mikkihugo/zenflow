"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = Share;
var solid_js_1 = require("solid-js");
var store_1 = require("solid-js/store");
function scrollToAnchor(id) {
    var el = document.getElementById(id);
    if (!el)
        return;
    el.scrollIntoView({ behavior: "smooth" });
}
function getStatusText(status) {
    switch (status[0]) {
        case "connected":
            return "Connected, waiting for messages...";
        case "connecting":
            return "Connecting...";
        case "disconnected":
            return "Disconnected";
        case "reconnecting":
            return "Reconnecting...";
        case "error":
            return status[1] || "Error";
        default:
            return "Unknown";
    }
}
function Share(props) {
    var lastScrollY = 0;
    var hasScrolledToAnchor = false;
    var scrollTimeout;
    var scrollSentinel;
    var scrollObserver;
    var id = props.id;
    var params = new URLSearchParams(window.location.search);
    var debug = params.get("debug") === "true";
    var _a = (0, solid_js_1.createSignal)(false), showScrollButton = _a[0], setShowScrollButton = _a[1];
    var _b = (0, solid_js_1.createSignal)(false), isButtonHovered = _b[0], setIsButtonHovered = _b[1];
    var _c = (0, solid_js_1.createSignal)(false), isNearBottom = _c[0], setIsNearBottom = _c[1];
    var _d = (0, store_1.createStore)({ info: props.info, messages: props.messages }), store = _d[0], setStore = _d[1];
    var messages = (0, solid_js_1.createMemo)(function () { return Object.values(store.messages).toSorted(function (a, b) { var _a; return (_a = a.id) === null || _a === void 0 ? void 0 : _a.localeCompare(b.id); }); });
    var _e = (0, solid_js_1.createSignal)(["disconnected", "Disconnected"]), connectionStatus = _e[0], setConnectionStatus = _e[1];
    (0, solid_js_1.createEffect)(function () {
        console.log((0, store_1.unwrap)(store));
    });
    (0, solid_js_1.onMount)(function () {
        var apiUrl = props.api;
        if (!id) {
            setConnectionStatus(["error", "id not found"]);
            return;
        }
        if (!apiUrl) {
            console.error("API URL not found in environment variables");
            setConnectionStatus(["error", "API URL not found"]);
            return;
        }
        var reconnectTimer;
        var socket = null;
        // Function to create and set up WebSocket with auto-reconnect
        var setupWebSocket = function () {
            // Close any existing connection
            if (socket) {
                socket.close();
            }
            setConnectionStatus(["connecting"]);
            // Always use secure WebSocket protocol (wss)
            var wsBaseUrl = apiUrl.replace(/^https?:\/\//, "wss://");
            var wsUrl = "".concat(wsBaseUrl, "/share_poll?id=").concat(id, "\n      console.log(\"Connecting to WebSocket URL:\", wsUrl)\n\n      // Create WebSocket connection\n      socket = new WebSocket(wsUrl)\n\n      // Handle connection opening\n      socket.onopen = () => {\n        setConnectionStatus([\"connected\"])\n        console.log(\"WebSocket connection established\")\n      }\n\n      // Handle incoming messages\n      socket.onmessage = (event) => {\n        console.log(\"WebSocket message received\")\n        try {\n          const d = JSON.parse(event.data)\n          const [root, type, ...splits] = d.key.split(\"/\")\n          if (root !== \"session\") return\n          if (type === \"info\") {\n            setStore(\"info\", reconcile(d.content))\n            return\n          }\n          if (type === \"message\") {\n            const [, messageID] = splits\n            if (\"metadata\" in d.content) {\n              d.content = fromV1(d.content)\n            }\n            d.content.parts = d.content.parts ?? store.messages[messageID]?.parts ?? []\n            setStore(\"messages\", messageID, reconcile(d.content))\n          }\n          if (type === \"part\") {\n            setStore(\"messages\", d.content.messageID, \"parts\", (arr) => {\n              const index = arr.findIndex((x) => x.id === d.content.id)\n              if (index === -1) arr.push(d.content)\n              if (index > -1) arr[index] = d.content\n              return [...arr]\n            })\n          }\n        } catch (error) {\n          console.error(\"Error parsing WebSocket message:\", error)\n        }\n      }\n\n      // Handle errors\n      socket.onerror = (error) => {\n        console.error(\"WebSocket error:\", error)\n        setConnectionStatus([\"error\", \"Connection failed\"])\n      }\n\n      // Handle connection close and reconnection\n      socket.onclose = (event) => {\n        console.log("), WebSocket, closed, _a = void 0, event = _a.event, code = _a.code, $, _b = void 0, event = _b.event, reason = _b.reason;
            ")\n        setConnectionStatus([\"reconnecting\"])\n\n        // Try to reconnect after 2 seconds\n        clearTimeout(reconnectTimer)\n        reconnectTimer = window.setTimeout(setupWebSocket, 2000) as unknown as number\n      }\n    }\n\n    // Initial connection\n    setupWebSocket()\n\n    // Clean up on component unmount\n    onCleanup(() => {\n      console.log(\"Cleaning up WebSocket connection\")\n      if (socket) {\n        socket.close()\n      }\n      clearTimeout(reconnectTimer)\n    })\n  })\n\n  function checkScrollNeed() {\n    const currentScrollY = window.scrollY\n    const isScrollingDown = currentScrollY > lastScrollY\n    const scrolled = currentScrollY > 200 // Show after scrolling 200px\n\n    // Only show when scrolling down, scrolled enough, and not near bottom\n    const shouldShow = isScrollingDown && scrolled && !isNearBottom()\n\n    // Update last scroll position\n    lastScrollY = currentScrollY\n\n    if (shouldShow) {\n      setShowScrollButton(true)\n      // Clear existing timeout\n      if (scrollTimeout) {\n        clearTimeout(scrollTimeout)\n      }\n      // Hide button after 3 seconds of no scrolling (unless hovered)\n      scrollTimeout = window.setTimeout(() => {\n        if (!isButtonHovered()) {\n          setShowScrollButton(false)\n        }\n      }, 1500)\n    } else if (!isButtonHovered()) {\n      // Only hide if not hovered (to prevent disappearing while user is about to click)\n      setShowScrollButton(false)\n      if (scrollTimeout) {\n        clearTimeout(scrollTimeout)\n      }\n    }\n  }\n\n  onMount(() => {\n    lastScrollY = window.scrollY // Initialize scroll position\n\n    // Create sentinel element\n    const sentinel = document.createElement(\"div\")\n    sentinel.style.height = \"1px\"\n    sentinel.style.position = \"absolute\"\n    sentinel.style.bottom = \"100px\"\n    sentinel.style.width = \"100%\"\n    sentinel.style.pointerEvents = \"none\"\n    document.body.appendChild(sentinel)\n\n    // Create intersection observer\n    const observer = new IntersectionObserver((entries) => {\n      setIsNearBottom(entries[0].isIntersecting)\n    })\n    observer.observe(sentinel)\n\n    // Store references for cleanup\n    scrollSentinel = sentinel\n    scrollObserver = observer\n\n    checkScrollNeed()\n    window.addEventListener(\"scroll\", checkScrollNeed)\n    window.addEventListener(\"resize\", checkScrollNeed)\n  })\n\n  onCleanup(() => {\n    window.removeEventListener(\"scroll\", checkScrollNeed)\n    window.removeEventListener(\"resize\", checkScrollNeed)\n\n    // Clean up observer and sentinel\n    if (scrollObserver) {\n      scrollObserver.disconnect()\n    }\n    if (scrollSentinel) {\n      document.body.removeChild(scrollSentinel)\n    }\n\n    if (scrollTimeout) {\n      clearTimeout(scrollTimeout)\n    }\n  })\n\n  const data = createMemo(() => {\n    const result = {\n      rootDir: undefined as string | undefined,\n      created: undefined as number | undefined,\n      completed: undefined as number | undefined,\n      messages: [] as MessageWithParts[],\n      models: {} as Record<string, string[]>,\n      cost: 0,\n      tokens: {\n        input: 0,\n        output: 0,\n        reasoning: 0,\n      },\n    }\n\n    result.created = props.info.time.created\n\n    const msgs = messages()\n    for (const msg of msgs) {\n      result.messages.push(msg)\n\n      if (msg.role === \"assistant\") {\n        result.cost += msg.cost\n        result.tokens.input += msg.tokens.input\n        result.tokens.output += msg.tokens.output\n        result.tokens.reasoning += msg.tokens.reasoning\n\n        result.models[";
            $;
            {
                msg.providerID;
            }
            $;
            {
                msg.modelID;
            }
            "] = [msg.providerID, msg.modelID]\n\n        if (msg.path.root) {\n          result.rootDir = msg.path.root\n        }\n\n        if (msg.time.completed) {\n          result.completed = msg.time.completed\n        }\n      }\n    }\n    return result\n  })\n\n  return (\n    <main classList={{ [styles.root]: true, \"not-content\": true }}>\n      <div data-component=\"header\">\n        <h1 data-component=\"header-title\">{store.info?.title}</h1>\n        <div data-component=\"header-details\">\n          <ul data-component=\"header-stats\">\n            <li title=\"opencode version\" data-slot=\"item\">\n              <div data-slot=\"icon\" title=\"opencode\">\n                <IconOpencode width={16} height={16} />\n              </div>\n              <Show when={store.info?.version} fallback=\"v0.0.1\">\n                <span>v{store.info?.version}</span>\n              </Show>\n            </li>\n            {Object.values(data().models).length > 0 ? (\n              <For each={Object.values(data().models)}>\n                {([provider, model]) => (\n                  <li data-slot=\"item\">\n                    <div data-slot=\"icon\" title={provider}>\n                      <ProviderIcon model={model} />\n                    </div>\n                    <span data-slot=\"model\">{model}</span>\n                  </li>\n                )}\n              </For>\n            ) : (\n              <li>\n                <span data-element-label>Models</span>\n                <span data-placeholder>&mdash;</span>\n              </li>\n            )}\n          </ul>\n          <div\n            data-component=\"header-time\"\n            title={DateTime.fromMillis(data().created || 0).toLocaleString(DateTime.DATETIME_FULL_WITH_SECONDS)}\n          >\n            {DateTime.fromMillis(data().created || 0).toLocaleString(DateTime.DATETIME_MED)}\n          </div>\n        </div>\n      </div>\n\n      <div>\n        <Show when={data().messages.length > 0} fallback={<p>Waiting for messages...</p>}>\n          <div class={styles.parts}>\n            <SuspenseList revealOrder=\"forwards\">\n              <For each={data().messages}>\n                {(msg, msgIndex) => {\n                  const filteredParts = createMemo(() =>\n                    msg.parts.filter((x, index) => {\n                      if (x.type === \"step-start\" && index > 0) return false\n                      if (x.type === \"snapshot\") return false\n                      if (x.type === \"step-finish\") return false\n                      if (x.type === \"text\" && x.synthetic === true) return false\n                      if (x.type === \"tool\" && x.tool === \"todoread\") return false\n                      if (x.type === \"text\" && !x.text) return false\n                      if (x.type === \"tool\" && (x.state.status === \"pending\" || x.state.status === \"running\"))\n                        return false\n                      return true\n                    }),\n                  )\n\n                  return (\n                    <Suspense>\n                      <For each={filteredParts()}>\n                        {(part, partIndex) => {\n                          const last = createMemo(\n                            () =>\n                              data().messages.length === msgIndex() + 1 && filteredParts().length === partIndex() + 1,\n                          )\n\n                          onMount(() => {\n                            const hash = window.location.hash.slice(1)\n                            // Wait till all parts are loaded\n                            if (\n                              hash !== \"\" &&\n                              !hasScrolledToAnchor &&\n                              filteredParts().length === partIndex() + 1 &&\n                              data().messages.length === msgIndex() + 1\n                            ) {\n                              hasScrolledToAnchor = true\n                              scrollToAnchor(hash)\n                            }\n                          })\n\n                          return <Part last={last()} part={part} index={partIndex()} message={msg} />\n                        }}\n                      </For>\n                    </Suspense>\n                  )\n                }}\n              </For>\n            </SuspenseList>\n            <div data-section=\"part\" data-part-type=\"summary\">\n              <div data-section=\"decoration\">\n                <span data-status={connectionStatus()[0]}></span>\n              </div>\n              <div data-section=\"content\">\n                <p data-section=\"copy\">{getStatusText(connectionStatus())}</p>\n                <ul data-section=\"stats\">\n                  <li>\n                    <span data-element-label>Cost</span>\n                    {data().cost !== undefined ? (\n                      <span>".concat(data().cost.toFixed(2), "</span>\n                    ) : (\n                      <span data-placeholder>&mdash;</span>\n                    )}\n                  </li>\n                  <li>\n                    <span data-element-label>Input Tokens</span>\n                    {data().tokens.input ? <span>{data().tokens.input}</span> : <span data-placeholder>&mdash;</span>}\n                  </li>\n                  <li>\n                    <span data-element-label>Output Tokens</span>\n                    {data().tokens.output ? <span>{data().tokens.output}</span> : <span data-placeholder>&mdash;</span>}\n                  </li>\n                  <li>\n                    <span data-element-label>Reasoning Tokens</span>\n                    {data().tokens.reasoning ? (\n                      <span>{data().tokens.reasoning}</span>\n                    ) : (\n                      <span data-placeholder>&mdash;</span>\n                    )}\n                  </li>\n                </ul>\n              </div>\n            </div>\n          </div>\n        </Show>\n      </div>\n\n      <Show when={debug}>\n        <div style={{ margin: \"2rem 0\" }}>\n          <div\n            style={{\n              border: \"1px solid #ccc\",\n              padding: \"1rem\",\n              \"overflow-y\": \"auto\",\n            }}\n          >\n            <Show when={data().messages.length > 0} fallback={<p>Waiting for messages...</p>}>\n              <ul style={{ \"list-style-type\": \"none\", padding: 0 }}>\n                <For each={data().messages}>\n                  {(msg) => (\n                    <li\n                      style={{\n                        padding: \"0.75rem\",\n                        margin: \"0.75rem 0\",\n                        \"box-shadow\": \"0 1px 3px rgba(0,0,0,0.1)\",\n                      }}\n                    >\n                      <div>\n                        <strong>Key:</strong> {msg.id}\n                      </div>\n                      <pre>{JSON.stringify(msg, null, 2)}</pre>\n                    </li>\n                  )}\n                </For>\n              </ul>\n            </Show>\n          </div>\n        </div>\n      </Show>\n\n      <Show when={showScrollButton()}>\n        <button\n          type=\"button\"\n          class={styles[\"scroll-button\"]}\n          onClick={() => document.body.scrollIntoView({ behavior: \"smooth\", block: \"end\" })}\n          onMouseEnter={() => {\n            setIsButtonHovered(true)\n            if (scrollTimeout) {\n              clearTimeout(scrollTimeout)\n            }\n          }}\n          onMouseLeave={() => {\n            setIsButtonHovered(false)\n            if (showScrollButton()) {\n              scrollTimeout = window.setTimeout(() => {\n                if (!isButtonHovered()) {\n                  setShowScrollButton(false)\n                }\n              }, 3000)\n            }\n          }}\n          title=\"Scroll to bottom\"\n          aria-label=\"Scroll to bottom\"\n        >\n          <IconArrowDown width={20} height={20} />\n        </button>\n      </Show>\n    </main>\n  )\n}\n\nexport function fromV1(v1: Message.Info): MessageWithParts {\n  if (v1.role === \"assistant\") {\n    return {\n      id: v1.id,\n      sessionID: v1.metadata.sessionID,\n      role: \"assistant\",\n      time: {\n        created: v1.metadata.time.created,\n        completed: v1.metadata.time.completed,\n      },\n      cost: v1.metadata.assistant?.cost,\n      path: v1.metadata.assistant?.path,\n      summary: v1.metadata.assistant?.summary,\n      tokens: v1.metadata.assistant?.tokens ?? {\n        input: 0,\n        output: 0,\n        cache: {\n          read: 0,\n          write: 0,\n        },\n        reasoning: 0,\n      },\n      modelID: v1.metadata.assistant?.modelID,\n      providerID: v1.metadata.assistant?.providerID,\n      system: v1.metadata.assistant?.system,\n      error: v1.metadata.error,\n      parts: v1.parts.flatMap((part, index): MessageV2.Part[] => {\n        const base = {\n          id: index.toString(),\n          messageID: v1.id,\n          sessionID: v1.metadata.sessionID,\n        }\n        if (part.type === \"text\") {\n          return [\n            {\n              ...base,\n              type: \"text\",\n              text: part.text,\n            },\n          ]\n        }\n        if (part.type === \"step-start\") {\n          return [\n            {\n              ...base,\n              type: \"step-start\",\n            },\n          ]\n        }\n        if (part.type === \"tool-invocation\") {\n          return [\n            {\n              ...base,\n              type: \"tool\",\n              callID: part.toolInvocation.toolCallId,\n              tool: part.toolInvocation.toolName,\n              state: (() => {\n                if (part.toolInvocation.state === \"partial-call\") {\n                  return {\n                    status: \"pending\",\n                  }\n                }\n\n                const { title, time, ...metadata } = v1.metadata.tool[part.toolInvocation.toolCallId]\n                if (part.toolInvocation.state === \"call\") {\n                  return {\n                    status: \"running\",\n                    input: part.toolInvocation.args,\n                    time: {\n                      start: time.start,\n                    },\n                  }\n                }\n\n                if (part.toolInvocation.state === \"result\") {\n                  return {\n                    status: \"completed\",\n                    input: part.toolInvocation.args,\n                    output: part.toolInvocation.result,\n                    title,\n                    time,\n                    metadata,\n                  }\n                }\n                throw new Error(\"unknown tool invocation state\")\n              })(),\n            },\n          ]\n        }\n        return []\n      }),\n    }\n  }\n\n  if (v1.role === \"user\") {\n    return {\n      id: v1.id,\n      sessionID: v1.metadata.sessionID,\n      role: \"user\",\n      time: {\n        created: v1.metadata.time.created,\n      },\n      parts: v1.parts.flatMap((part, index): MessageV2.Part[] => {\n        const base = {\n          id: index.toString(),\n          messageID: v1.id,\n          sessionID: v1.metadata.sessionID,\n        }\n        if (part.type === \"text\") {\n          return [\n            {\n              ...base,\n              type: \"text\",\n              text: part.text,\n            },\n          ]\n        }\n        if (part.type === \"file\") {\n          return [\n            {\n              ...base,\n              type: \"file\",\n              mime: part.mediaType,\n              filename: part.filename,\n              url: part.url,\n            },\n          ]\n        }\n        return []\n      }),\n    }\n  }\n\n  throw new Error(\"unknown message type\")\n}\n");
        };
    });
}
