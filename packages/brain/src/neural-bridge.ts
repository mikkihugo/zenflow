/**
 * @file Neural Network Bridge
 * Integrates neural network components with Claude-Zen system.
 * Enhanced with SmartNeuralCoordinator for intelligent neural backend system.
 */

import { 
  getLogger, 
  getDatabaseAccess, 
  type DatabaseAccess 
, 
  inject, 
  TOKENS, 
  type Logger 
} from '@claude-zen/foundation';

import { 
  SmartNeuralCoordinator,
  type NeuralBackendConfig,
  type NeuralEmbeddingRequest,
  type NeuralEmbeddingResult
} from './smart-neural-coordinator';

// Foundation-optimized logging via dependency injection - using this.foundationLogger in class

export interface NeuralConfig {
  wasmPath?: string;
  gpuAcceleration?: boolean;
  modelPath?: string;
  enableTraining?: boolean;
  smartNeuralBackend?: NeuralBackendConfig;
}

export interface NeuralNetwork {
  id: string;
  type: 'feedforward' | 'lstm' | 'transformer' | 'autoencoder';
  layers: number[];
  weights?: Float32Array; // Changed to Float32Array for WASM compatibility
  status: 'idle' | 'training' | 'predicting' | 'error';
  handle?: number; // WASM network handle
}

export interface TrainingData {
  inputs: number[][];
  outputs: number[][];
}

export interface PredictionResult {
  outputs: number[];
  confidence: number;
  processingTime: number;
}

export interface NetworkArchitecture {
  type: 'feedforward' | 'lstm' | 'transformer' | 'autoencoder' | 'cnn' | 'gnn';
  layers: number[];
  activation: ActivationFunction;
  outputActivation?: ActivationFunction;
  learningRate: number;
  batchSize: number;
  epochs?: number;
  metadata?: Record<string, unknown>;
}

export type ActivationFunction = 
  | 'sigmoid' 
  | 'tanh' 
  | 'relu' 
  | 'leaky_relu' 
  | 'softmax' 
  | 'linear' 
  | 'swish' 
  | 'gelu';

/**
 * Neural Network Bridge for Claude-Zen integration.
 * Optimized with @claude-zen/foundation:
 * - Database storage for model persistence
 * - Performance metrics integration
 * - Foundation logging system
 * 
 * @example
 * ```typescript
 * const bridge = container.get(NeuralBridge);
 * await bridge.initialize();
 * const networkId = await bridge.createNetwork('classifier', 'feedforward', [10, 5, 2]);
 * ```
 */
// Import type for WASM module (will be generated by wasm-pack)
type WasmNetwork = any; // Will be replaced with actual type after wasm-pack build

// @injectable - Temporarily removed due to constructor type incompatibility 
export class NeuralBridge {
  private static instance: NeuralBridge;
  private networks: Map<string, WasmNetwork> = new Map(); // Now stores WASM networks
  private networkMetadata: Map<string, NeuralNetwork> = new Map(); // Stores metadata
  private config: NeuralConfig;
  private initialized = false;
  private wasmModule: any = null; // Will hold the WASM module
  private dbAccess: DatabaseAccess | null = null; // Foundation database access
  private smartNeuralCoordinator: SmartNeuralCoordinator | null = null; // Smart neural backend

  constructor(
    @inject(TOKENS.Logger) private foundationLogger: Logger,
    config: NeuralConfig = {}
  ) {
    this.config = {
      wasmPath: './wasm/claude_zen_neural', // Points to neural/wasm/ directory
      gpuAcceleration: false,
      enableTraining: true,
      ...config,
    };
  }

  static getInstance(logger?: Logger, config?: NeuralConfig): NeuralBridge {
    if (!NeuralBridge.instance) {
      // For singleton pattern with DI, we need to provide a logger
      const defaultLogger = logger || getLogger('Neural');
      NeuralBridge.instance = new NeuralBridge(defaultLogger, config);
    }
    return NeuralBridge.instance;
  }

  /**
   * Initialize neural network bridge.
   */
  async initialize(): Promise<void> {
    if (this.initialized) return;

    this.foundationLogger.info('Initializing Neural Bridge with Foundation integration...');

    try {
      // Initialize database access for model persistence
      this.dbAccess = getDatabaseAccess();
      
      // Initialize SmartNeuralCoordinator for intelligent neural backend
      if (this.config.smartNeuralBackend !== undefined) {
        this.smartNeuralCoordinator = new SmartNeuralCoordinator(
          this.config.smartNeuralBackend || {}
        );
        await this.smartNeuralCoordinator.initialize();
        this.foundationLogger.info('âœ… SmartNeuralCoordinator integrated successfully');
      }
      
      // Load WASM module if available
      if (this.config.wasmPath) {
        await this.loadWasmModule();
      }

      // Initialize GPU acceleration if enabled
      if (this.config.gpuAcceleration) {
        await this.initializeGPU();
      }
      
      // Initialize database schema for neural networks
      await this.initializeDatabaseSchema();

      this.initialized = true;
      this.foundationLogger.info('Neural Bridge initialized successfully with database, metrics, and smart neural backend integration');
    } catch (error) {
      this.foundationLogger.error('Failed to initialize Neural Bridge:', error);
      throw error;
    }
  }

  /**
   * Create a new neural network.
   *
   * @param id
   * @param type
   * @param layers
   */
  async createNetwork(
    id: string,
    type: NeuralNetwork['type'],
    layers: number[]
  ): Promise<string> {
    if (!this.initialized) {
      await this.initialize();
    }

    if (!this.wasmModule) {
      throw new Error('WASM module not loaded');
    }

    try {
      // Create the actual WASM network using our Rust implementation
      const layersArray = new Uint32Array(layers);
      const wasmNetwork = new this.wasmModule.WasmNetwork(layersArray);

      // Store the WASM network instance
      this.networks.set(id, wasmNetwork);

      // Store metadata separately for status tracking
      const metadata: NeuralNetwork = {
        id,
        type,
        layers,
        status: 'idle',
      };
      this.networkMetadata.set(id, metadata);

      // Persist network metadata to database
      if (this.dbAccess) {
        const kv = await this.dbAccess.getKV('neural');
        await kv.set(`metadata:${id}`, JSON.stringify(metadata));
        await kv.set(`layers:${id}`, JSON.stringify(layers));
      }
      
      this.foundationLogger.info(`Created WASM neural network: ${id} (${type}) with layers: [${layers.join(', ')}]`);
      return id;
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      this.foundationLogger.error(`Failed to create network ${id}:`, error);
      throw new Error(`Network creation failed: ${errorMessage}`);
    }
  }

  /**
   * Train a neural network.
   *
   * @param networkId
   * @param trainingData
   * @param epochs
   */
  async trainNetwork(
    networkId: string,
    trainingData: TrainingData,
    epochs: number = 1000
  ): Promise<boolean> {
    const wasmNetwork = this.networks.get(networkId);
    const metadata = this.networkMetadata.get(networkId);
    
    if (!wasmNetwork || !metadata) {
      throw new Error(`Network not found: ${networkId}`);
    }

    if (!this.config.enableTraining) {
      throw new Error('Training is disabled in configuration');
    }

    metadata.status = 'training';
    this.foundationLogger.info(`Training WASM network ${networkId} for ${epochs} epochs`);

    try {
      const startTime = Date.now();

      // Flatten the training data into Float32Arrays for WASM
      const flatInputs = new Float32Array(trainingData.inputs.flat());
      const flatOutputs = new Float32Array(trainingData.outputs.flat());

      // Call the actual WASM training function
      const finalError = wasmNetwork.train(flatInputs, flatOutputs, epochs);

      const trainingTime = Date.now() - startTime;
      metadata.status = 'idle';

      // Store training metrics in database
      if (this.dbAccess) {
        const kv = await this.dbAccess.getKV('neural');
        await kv.set(`training:${networkId}:${Date.now()}`, JSON.stringify({
          epochs,
          finalError,
          trainingTime,
          timestamp: new Date().toISOString()
        }));
      }
      
      this.foundationLogger.info(`WASM training completed for ${networkId} in ${trainingTime}ms with final error: ${finalError}`);
      return true;
    } catch (error) {
      metadata.status = 'error';
      this.foundationLogger.error(`WASM training failed for ${networkId}:`, error);
      return false;
    }
  }

  /**
   * Make predictions with a neural network.
   *
   * @param networkId
   * @param inputs
   */
  async predict(
    networkId: string,
    inputs: number[]
  ): Promise<PredictionResult> {
    const wasmNetwork = this.networks.get(networkId);
    const metadata = this.networkMetadata.get(networkId);
    
    if (!wasmNetwork || !metadata) {
      throw new Error(`Network not found: ${networkId}`);
    }

    metadata.status = 'predicting';
    const startTime = Date.now();

    try {
      // Convert inputs to Float32Array for WASM
      const inputsArray = new Float32Array(inputs);
      
      // Call the actual WASM predict function
      const outputsArray = wasmNetwork.predict(inputsArray);
      
      // Convert the result back to a standard number array
      const outputs = Array.from(outputsArray as ArrayLike<number>);
      const processingTime = Date.now() - startTime;

      metadata.status = 'idle';

      return {
        outputs,
        confidence: this.calculateConfidence(outputs),
        processingTime,
      };
    } catch (error) {
      metadata.status = 'error';
      this.foundationLogger.error(`WASM prediction failed for ${networkId}:`, error);
      throw error;
    }
  }

  /**
   * Calculate confidence from network outputs.
   * For softmax outputs, this would be the max probability.
   * For regression, this could be based on output variance.
   *
   * @param outputs
   */
  private calculateConfidence(outputs: number[]): number {
    if (outputs.length === 0) return 0;
    
    // For classification (softmax-like outputs), use max value
    if (outputs.every(x => x >= 0 && x <= 1)) {
      return Math.max(...outputs);
    }
    
    // For regression or other outputs, use a different heuristic
    // This is a simple approach - could be more sophisticated
    const mean = outputs.reduce((a, b) => a + b, 0) / outputs.length;
    const variance = outputs.reduce((a, b) => a + (b - mean) ** 2, 0) / outputs.length;
    return Math.max(0, Math.min(1, 1 - variance)); // Lower variance = higher confidence
  }

  /**
   * Get network status.
   *
   * @param networkId
   */
  getNetworkStatus(networkId: string): NeuralNetwork | undefined {
    return this.networkMetadata.get(networkId);
  }

  /**
   * List all networks.
   */
  listNetworks(): NeuralNetwork[] {
    return Array.from(this.networkMetadata.values());
  }

  /**
   * Remove a network.
   *
   * @param networkId
   */
  removeNetwork(networkId: string): boolean {
    const wasmNetwork = this.networks.get(networkId);
    if (wasmNetwork) {
      // WASM networks are automatically cleaned up when they go out of scope
      // due to the Drop implementation in Rust
      this.networks.delete(networkId);
    }
    return this.networkMetadata.delete(networkId);
  }

  /**
   * Get neural system stats.
   */
  getStats(): {
    totalNetworks: number;
    activeNetworks: number;
    trainingNetworks: number;
    gpuEnabled: boolean;
    wasmEnabled: boolean;
  } {
    const networks = Array.from(this.networkMetadata.values());

    return {
      totalNetworks: networks.length,
      activeNetworks: networks.filter((n) => n.status !== 'idle').length,
      trainingNetworks: networks.filter((n) => n.status === 'training').length,
      gpuEnabled: !!this.config.gpuAcceleration,
      wasmEnabled: !!this.wasmModule,
    };
  }

  private async loadWasmModule(): Promise<void> {
    this.foundationLogger.info('Loading WASM module...');

    try {
      // Dynamically import the WASM module generated by wasm-pack
      const wasmModule = await import(/* @vite-ignore */ `${this.config.wasmPath}/claude_zen_neural.js`);
      
      // Initialize the WASM module
      await wasmModule.default();
      
      // Store the module for later use
      this.wasmModule = wasmModule;
      
      this.foundationLogger.info('WASM module loaded and initialized successfully');
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      this.foundationLogger.error('Failed to load WASM module:', error);
      throw new Error(`WASM module loading failed: ${errorMessage}`);
    }
  }

  private async initializeGPU(): Promise<void> {
    // In a real implementation, this would initialize GPU acceleration
    // using the WebGPU components from the integrated system
    this.foundationLogger.info('Initializing GPU acceleration...');

    // Simulate GPU initialization
    await new Promise((resolve) => setTimeout(resolve, 200));

    this.foundationLogger.info('GPU acceleration initialized');
  }

  /**
   * Initialize database schema for neural networks using foundation storage.
   */
  private async initializeDatabaseSchema(): Promise<void> {
    if (!this.dbAccess) {
      this.foundationLogger.warn('Database access not available, skipping schema initialization');
      return;
    }

    try {
      this.foundationLogger.info('Initializing neural network database schema...');
      
      // Initialize any required database tables or collections
      // The foundation database layer handles the actual schema creation
      
      this.foundationLogger.info('Neural network database schema initialized successfully');
    } catch (error) {
      this.foundationLogger.error('Failed to initialize database schema:', error);
      throw error;
    }
  }

  /**
   * Generate neural embeddings using SmartNeuralCoordinator
   * 
   * @param text - Text to generate embeddings for
   * @param options - Optional embedding configuration
   * @returns Promise with embedding result
   */
  async generateEmbedding(
    text: string, 
    options?: {
      context?: string;
      priority?: 'low' | 'medium' | 'high';
      qualityLevel?: 'basic' | 'standard' | 'premium';
    }
  ): Promise<NeuralEmbeddingResult> {
    if (!this.smartNeuralCoordinator) {
      throw new Error('SmartNeuralCoordinator not initialized. Enable smartNeuralBackend in config.');
    }

    const request: NeuralEmbeddingRequest = {
      text,
      context: options?.context,
      priority: options?.priority || 'medium',
      qualityLevel: options?.qualityLevel || 'standard'
    };

    return await this.smartNeuralCoordinator.generateEmbedding(request);
  }

  /**
   * Get SmartNeuralCoordinator statistics
   */
  getSmartNeuralStats(): any {
    if (!this.smartNeuralCoordinator) {
      return {
        available: false,
        reason: 'SmartNeuralCoordinator not initialized'
      };
    }

    return {
      available: true,
      stats: this.smartNeuralCoordinator.getCoordinatorStats()
    };
  }

  /**
   * Clear SmartNeuralCoordinator cache
   */
  async clearSmartNeuralCache(): Promise<void> {
    if (!this.smartNeuralCoordinator) {
      this.foundationLogger.warn('SmartNeuralCoordinator not available for cache clearing');
      return;
    }

    await this.smartNeuralCoordinator.clearCache();
    this.foundationLogger.info('SmartNeuralCoordinator cache cleared');
  }

  /**
   * Shutdown neural bridge.
   */
  async shutdown(): Promise<void> {
    this.foundationLogger.info('Shutting down Neural Bridge...');

    // Shutdown SmartNeuralCoordinator
    if (this.smartNeuralCoordinator) {
      await this.smartNeuralCoordinator.shutdown();
      this.smartNeuralCoordinator = null;
    }

    // Stop all training processes by updating metadata
    for (const metadata of this.networkMetadata.values()) {
      if (metadata.status === 'training') {
        metadata.status = 'idle';
      }
    }

    // Clear WASM networks (will trigger Drop implementation in Rust)
    this.networks.clear();
    this.networkMetadata.clear();
    this.wasmModule = null;
    this.initialized = false;

    this.foundationLogger.info('Neural Bridge shutdown complete');
  }
}

// Export convenience functions
export async function createNeuralNetwork(
  id: string,
  type: NeuralNetwork['type'],
  layers: number[],
  config?: NeuralConfig
): Promise<string> {
  const logger = getLogger('Neural');
  const bridge = NeuralBridge.getInstance(logger, config);
  return await bridge.createNetwork(id, type, layers);
}

export async function trainNeuralNetwork(
  networkId: string,
  trainingData: TrainingData,
  epochs?: number
): Promise<boolean> {
  const logger = getLogger('Neural');
  const bridge = NeuralBridge.getInstance(logger);
  return await bridge.trainNetwork(networkId, trainingData, epochs);
}

export async function predictWithNetwork(
  networkId: string,
  inputs: number[]
): Promise<PredictionResult> {
  const logger = getLogger('Neural');
  const bridge = NeuralBridge.getInstance(logger);
  return await bridge.predict(networkId, inputs);
}
