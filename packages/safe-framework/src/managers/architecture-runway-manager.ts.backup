/**
 * @fileoverview Architecture Runway Manager - Comprehensive SAFe architecture management.
 * 
 * Provides enterprise-grade SAFe architecture runway management through specialized
 * workflow coordination, approval gates, and enterprise architecture governance.
 * 
 * Key Features:
 * - Architecture runway and backlog management
 * - Architectural epic and capability tracking  
 * - Architecture decision workflow with approval gates
 * - Technical debt management and tracking
 * - Integration with Program Increment and Value Stream management
 * 
 * Part of the @claude-zen/safe-framework package providing comprehensive
 * Scaled Agile Framework (SAFe) integration capabilities.
 */

import { EventEmitter } from 'eventemitter3';
import { nanoid } from 'nanoid';
import type { Logger, MemorySystem, TypeSafeEventBus } from '../types';
import { getLogger, createEvent, EventPriority, WorkflowHumanGateType } from '../types';
import type {
  AgileReleaseTrain,
  Feature,
  ProgramIncrement,
  SAFeIntegrationConfig,
} from '../types';

// ============================================================================
// ARCHITECTURE RUNWAY CONFIGURATION
// ============================================================================

/**
 * Architecture Runway Manager configuration
 */
export interface ArchitectureRunwayConfig {
  readonly enableAGUIIntegration: boolean;
  readonly enableAutomatedTracking: boolean;
  readonly enableTechnicalDebtManagement: boolean;
  readonly enableArchitectureGovernance: boolean;
  readonly enableRunwayPlanning: boolean;
  readonly enableCapabilityTracking: boolean;
  readonly maxRunwayItems: number;
  readonly runwayPlanningHorizon: number; // in days
  readonly technicalDebtThreshold: number;
  readonly governanceApprovalThreshold: number;
}

/**
 * Architecture Runway Item
 */
export interface ArchitectureRunwayItem {
  id: string;
  title: string;
  description: string;
  type: 'infrastructure' | 'platform' | 'enabler' | 'technical-debt';
  priority: 'critical' | 'high' | 'medium' | 'low';
  effort: number; // story points or hours
  dependencies: string[];
  status: 'backlog' | 'planned' | 'in-progress' | 'completed' | 'blocked';
  assignedTo?: string;
  targetPI?: string;
  createdAt: Date;
  updatedAt: Date;
}

/**
 * Technical Debt Item
 */
export interface TechnicalDebtItem {
  id: string;
  title: string;
  description: string;
  severity: 'critical' | 'high' | 'medium' | 'low';
  impact: string;
  effort: number;
  component: string;
  status: 'identified' | 'approved' | 'planned' | 'in-progress' | 'resolved';
  createdAt: Date;
  updatedAt: Date;
}

/**
 * Architecture Decision Record
 */
export interface ArchitectureDecisionRecord {
  id: string;
  title: string;
  status: 'proposed' | 'accepted' | 'deprecated' | 'superseded';
  context: string;
  decision: string;
  consequences: string[];
  alternatives: string[];
  createdAt: Date;
  updatedAt: Date;
  author: string;
  stakeholders: string[];
}

/**
 * Architecture Capability
 */
export interface ArchitectureCapability {
  id: string;
  name: string;
  description: string;
  category: 'business' | 'technology' | 'process';
  maturityLevel: number; // 1-5 scale
  status: 'developing' | 'active' | 'retiring' | 'deprecated';
  enablers: string[]; // References to runway items
  dependencies: string[];
  kpis: CapabilityKPI[];
  createdAt: Date;
  updatedAt: Date;
}

/**
 * Capability KPI
 */
export interface CapabilityKPI {
  id: string;
  name: string;
  description: string;
  metric: string;
  target: number;
  current: number;
  unit: string;
  trend: 'improving' | 'stable' | 'declining';
}

/**
 * Architecture Runway Manager - Comprehensive SAFe architecture management.
 * 
 * Manages architecture runway items, technical debt, and architectural decisions
 * within the SAFe framework, providing governance and planning capabilities.
 *
 * @example Basic usage
 * ```typescript
 * const runwayManager = new ArchitectureRunwayManager(memory, eventBus, config);
 * await runwayManager.initialize();
 * 
 * const item = await runwayManager.addRunwayItem({
 *   title: 'API Gateway Implementation',
 *   type: 'infrastructure',
 *   priority: 'high',
 *   effort: 13
 * });
 * ```
 */
export class ArchitectureRunwayManager extends EventEmitter {
  private logger: Logger;
  private memory: MemorySystem;
  private eventBus: TypeSafeEventBus;
  private config: ArchitectureRunwayConfig;
  
  // Internal state
  private runwayItems = new Map<string, ArchitectureRunwayItem>();
  private technicalDebtItems = new Map<string, TechnicalDebtItem>();
  private architecturalDecisions = new Map<string, ArchitectureDecisionRecord>();
  private capabilities = new Map<string, ArchitectureCapability>();
  private initialized = false;

  constructor(
    memory: MemorySystem,
    eventBus: TypeSafeEventBus,
    config: Partial<ArchitectureRunwayConfig> = {}
  ) {
    super();
    this.logger = getLogger('ArchitectureRunwayManager');
    this.memory = memory;
    this.eventBus = eventBus;
    
    this.config = {
      enableAGUIIntegration: true,
      enableAutomatedTracking: true,
      enableTechnicalDebtManagement: true,
      enableArchitectureGovernance: true,
      enableRunwayPlanning: true,
      enableCapabilityTracking: true,
      maxRunwayItems: 100,
      runwayPlanningHorizon: 180, // 6 months
      technicalDebtThreshold: 80, // 80% threshold
      governanceApprovalThreshold: 1000, // effort threshold
      ...config,
    };
  }

  /**
   * Initialize the Architecture Runway Manager
   */
  async initialize(): Promise<void> {
    if (this.initialized) return;

    try {
      this.logger.info('Initializing Architecture Runway Manager');

      // Emit initialization event
      this.eventBus.emit('architecture-runway:initialized', createEvent(
        'architecture-runway:initialized',
        { timestamp: Date.now() },
        EventPriority.NORMAL
      ));

      this.initialized = true;
      this.logger.info('Architecture Runway Manager initialized successfully');

    } catch (error) {
      this.logger.error('Failed to initialize Architecture Runway Manager:', error);
      throw error;
    }
  }

  /**
   * Add Runway Item
   */
  async addRunwayItem(
    item: Omit<ArchitectureRunwayItem, 'id' | 'createdAt' | 'updatedAt' | 'status'>
  ): Promise<ArchitectureRunwayItem> {
    if (!this.initialized) await this.initialize();

    try {
      const runwayItem: ArchitectureRunwayItem = {
        id: nanoid(),
        status: 'backlog',
        createdAt: new Date(),
        updatedAt: new Date(),
        ...item
      };

      // Check if governance approval is needed
      if (item.effort > this.config.governanceApprovalThreshold) {
        this.logger.warn(`High-effort runway item (${item.effort} points) requires governance review`);
        
        // In a real implementation, this would trigger AGUI approval flow
        // For now, we'll emit an event for governance attention
        this.eventBus.emit('architecture-runway:governance-required', createEvent(
          'architecture-runway:governance-required',
          { runwayItem, reason: 'high-effort-threshold' },
          EventPriority.HIGH
        ));
      }

      // Store the runway item
      this.runwayItems.set(runwayItem.id, runwayItem);
      await this.memory.store(`architecture-runway:item:${runwayItem.id}`, runwayItem);

      this.emit('runway-item:added', { item: runwayItem });
      this.eventBus.emit('architecture-runway:item:added', createEvent(
        'architecture-runway:item:added',
        { itemId: runwayItem.id, type: runwayItem.type, priority: runwayItem.priority }
      ));

      return runwayItem;

    } catch (error) {
      this.logger.error('Failed to add runway item:', error);
      throw error;
    }
  }

  /**
   * Update Runway Item Status
   */
  async updateRunwayItemStatus(
    itemId: string,
    status: ArchitectureRunwayItem['status'],
    context?: any
  ): Promise<ArchitectureRunwayItem | null> {
    if (!this.initialized) await this.initialize();

    try {
      const item = this.runwayItems.get(itemId);
      if (!item) return null;

      const updatedItem = {
        ...item,
        status,
        updatedAt: new Date()
      };

      this.runwayItems.set(itemId, updatedItem);
      await this.memory.store(`architecture-runway:item:${itemId}`, updatedItem);

      this.emit('runway-item:status-updated', { item: updatedItem, oldStatus: item.status });
      this.eventBus.emit('architecture-runway:item:status-updated', createEvent(
        'architecture-runway:item:status-updated',
        { itemId, oldStatus: item.status, newStatus: status }
      ));

      return updatedItem;

    } catch (error) {
      this.logger.error('Failed to update runway item status:', error);
      throw error;
    }
  }

  /**
   * Add Technical Debt Item
   */
  async addTechnicalDebtItem(
    item: Omit<TechnicalDebtItem, 'id' | 'createdAt' | 'updatedAt' | 'status'>
  ): Promise<TechnicalDebtItem> {
    if (!this.initialized) await this.initialize();
    if (!this.config.enableTechnicalDebtManagement) {
      throw new Error('Technical debt management is not enabled');
    }

    try {
      const debtItem: TechnicalDebtItem = {
        id: nanoid(),
        status: 'identified',
        createdAt: new Date(),
        updatedAt: new Date(),
        ...item
      };

      this.technicalDebtItems.set(debtItem.id, debtItem);
      await this.memory.store(`architecture-runway:debt:${debtItem.id}`, debtItem);

      this.emit('technical-debt:added', { item: debtItem });
      this.eventBus.emit('architecture-runway:debt:added', createEvent(
        'architecture-runway:debt:added',
        { itemId: debtItem.id, severity: debtItem.severity, component: debtItem.component }
      ));

      return debtItem;

    } catch (error) {
      this.logger.error('Failed to add technical debt item:', error);
      throw error;
    }
  }

  /**
   * Create Architecture Decision Record
   */
  async createArchitectureDecisionRecord(
    decision: Omit<ArchitectureDecisionRecord, 'id' | 'createdAt' | 'updatedAt' | 'status'>
  ): Promise<ArchitectureDecisionRecord> {
    if (!this.initialized) await this.initialize();

    try {
      const adr: ArchitectureDecisionRecord = {
        id: nanoid(),
        status: 'proposed',
        createdAt: new Date(),
        updatedAt: new Date(),
        ...decision
      };

      this.architecturalDecisions.set(adr.id, adr);
      await this.memory.store(`architecture-runway:adr:${adr.id}`, adr);

      this.emit('architecture-decision:created', { adr });
      this.eventBus.emit('architecture-runway:adr:created', createEvent(
        'architecture-runway:adr:created',
        { adrId: adr.id, title: adr.title, author: adr.author }
      ));

      return adr;

    } catch (error) {
      this.logger.error('Failed to create architecture decision record:', error);
      throw error;
    }
  }

  /**
   * Add Architecture Capability
   */
  async addCapability(
    capability: Omit<ArchitectureCapability, 'id' | 'createdAt' | 'updatedAt'>
  ): Promise<ArchitectureCapability> {
    if (!this.initialized) await this.initialize();
    if (!this.config.enableCapabilityTracking) {
      throw new Error('Capability tracking is not enabled');
    }

    try {
      const cap: ArchitectureCapability = {
        id: nanoid(),
        createdAt: new Date(),
        updatedAt: new Date(),
        ...capability
      };

      this.capabilities.set(cap.id, cap);
      await this.memory.store(`architecture-runway:capability:${cap.id}`, cap);

      this.emit('capability:added', { capability: cap });
      this.eventBus.emit('architecture-runway:capability:added', createEvent(
        'architecture-runway:capability:added',
        { capabilityId: cap.id, name: cap.name, category: cap.category }
      ));

      return cap;

    } catch (error) {
      this.logger.error('Failed to add capability:', error);
      throw error;
    }
  }

  /**
   * Get Runway Planning Dashboard
   */
  async getRunwayPlanningDashboard(): Promise<any> {
    if (!this.initialized) await this.initialize();

    try {
      const runwayMetrics = {
        total: this.runwayItems.size,
        byStatus: this.groupRunwayItemsByStatus(),
        byPriority: this.groupRunwayItemsByPriority(),
        byType: this.groupRunwayItemsByType()
      };

      const debtMetrics = {
        total: this.technicalDebtItems.size,
        bySeverity: this.groupTechnicalDebtBySeverity(),
        byStatus: this.groupTechnicalDebtByStatus(),
        totalEffort: this.calculateTotalDebtEffort()
      };

      const capabilityMetrics = {
        total: this.capabilities.size,
        byCategory: this.groupCapabilitiesByCategory(),
        byStatus: this.groupCapabilitiesByStatus(),
        avgMaturity: this.calculateAverageMaturity()
      };

      return {
        runwayItems: runwayMetrics,
        technicalDebt: debtMetrics,
        capabilities: capabilityMetrics,
        decisions: {
          total: this.architecturalDecisions.size,
          byStatus: this.groupDecisionsByStatus()
        },
        lastUpdated: new Date()
      };

    } catch (error) {
      this.logger.error('Failed to get runway planning dashboard:', error);
      throw error;
    }
  }

  /**
   * Request Architecture Decision
   */
  async requestArchitectureDecision(
    decision: {
      title: string;
      description: string;
      options: Array<{ title: string; description: string; pros: string[]; cons: string[] }>;
      impact: 'low' | 'medium' | 'high' | 'critical';
      deadline?: Date;
    }
  ): Promise<{ approved: boolean; selectedOption?: number; comments?: string }> {
    if (!this.initialized) await this.initialize();

    try {
      // In a real implementation, this would integrate with AGUI
      // For now, we'll simulate a decision process
      this.logger.info(`Architecture decision requested: ${decision.title}`);

      // Emit event for decision tracking
      this.eventBus.emit('architecture-runway:decision:requested', createEvent(
        'architecture-runway:decision:requested',
        { title: decision.title, impact: decision.impact, optionsCount: decision.options.length }
      ));

      // Simulate approval based on impact level
      const approved = decision.impact !== 'critical'; // Critical decisions need human approval
      
      return {
        approved,
        selectedOption: approved ? 0 : undefined, // Select first option if approved
        comments: approved ? 'Auto-approved for non-critical decision' : 'Requires governance review'
      };

    } catch (error) {
      this.logger.error('Failed to request architecture decision:', error);
      throw error;
    }
  }

  /**
   * Get Analytics
   */
  async getAnalytics(): Promise<any> {
    if (!this.initialized) await this.initialize();
    
    return {
      runway: {
        totalItems: this.runwayItems.size,
        itemsByStatus: this.groupRunwayItemsByStatus(),
        itemsByPriority: this.groupRunwayItemsByPriority()
      },
      technicalDebt: {
        totalDebt: this.technicalDebtItems.size,
        debtByStatus: this.groupTechnicalDebtByStatus(),
        debtBySeverity: this.groupTechnicalDebtBySeverity()
      },
      capabilities: {
        totalCapabilities: this.capabilities.size,
        capabilitiesByCategory: this.groupCapabilitiesByCategory()
      },
      decisions: {
        totalDecisions: this.architecturalDecisions.size,
        decisionsByStatus: this.groupDecisionsByStatus()
      }
    };
  }

  /**
   * Get runway item by ID
   */
  getRunwayItem(itemId: string): ArchitectureRunwayItem | undefined {
    return this.runwayItems.get(itemId);
  }

  /**
   * Get all runway items
   */
  getAllRunwayItems(): ArchitectureRunwayItem[] {
    return Array.from(this.runwayItems.values());
  }

  /**
   * Get technical debt item by ID
   */
  getTechnicalDebtItem(itemId: string): TechnicalDebtItem | undefined {
    return this.technicalDebtItems.get(itemId);
  }

  /**
   * Get all technical debt items
   */
  getAllTechnicalDebtItems(): TechnicalDebtItem[] {
    return Array.from(this.technicalDebtItems.values());
  }

  // ============================================================================
  // PRIVATE HELPER METHODS
  // ============================================================================

  private groupRunwayItemsByStatus(): Record<string, number> {
    const grouped: Record<string, number> = {};
    for (const item of this.runwayItems.values()) {
      grouped[item.status] = (grouped[item.status] || 0) + 1;
    }
    return grouped;
  }

  private groupRunwayItemsByPriority(): Record<string, number> {
    const grouped: Record<string, number> = {};
    for (const item of this.runwayItems.values()) {
      grouped[item.priority] = (grouped[item.priority] || 0) + 1;
    }
    return grouped;
  }

  private groupRunwayItemsByType(): Record<string, number> {
    const grouped: Record<string, number> = {};
    for (const item of this.runwayItems.values()) {
      grouped[item.type] = (grouped[item.type] || 0) + 1;
    }
    return grouped;
  }

  private groupTechnicalDebtBySeverity(): Record<string, number> {
    const grouped: Record<string, number> = {};
    for (const item of this.technicalDebtItems.values()) {
      grouped[item.severity] = (grouped[item.severity] || 0) + 1;
    }
    return grouped;
  }

  private groupTechnicalDebtByStatus(): Record<string, number> {
    const grouped: Record<string, number> = {};
    for (const item of this.technicalDebtItems.values()) {
      grouped[item.status] = (grouped[item.status] || 0) + 1;
    }
    return grouped;
  }

  private groupCapabilitiesByCategory(): Record<string, number> {
    const grouped: Record<string, number> = {};
    for (const cap of this.capabilities.values()) {
      grouped[cap.category] = (grouped[cap.category] || 0) + 1;
    }
    return grouped;
  }

  private groupCapabilitiesByStatus(): Record<string, number> {
    const grouped: Record<string, number> = {};
    for (const cap of this.capabilities.values()) {
      grouped[cap.status] = (grouped[cap.status] || 0) + 1;
    }
    return grouped;
  }

  private groupDecisionsByStatus(): Record<string, number> {
    const grouped: Record<string, number> = {};
    for (const decision of this.architecturalDecisions.values()) {
      grouped[decision.status] = (grouped[decision.status] || 0) + 1;
    }
    return grouped;
  }

  private calculateTotalDebtEffort(): number {
    let total = 0;
    for (const item of this.technicalDebtItems.values()) {
      total += item.effort;
    }
    return total;
  }

  private calculateAverageMaturity(): number {
    if (this.capabilities.size === 0) return 0;
    
    let total = 0;
    for (const cap of this.capabilities.values()) {
      total += cap.maturityLevel;
    }
    return total / this.capabilities.size;
  }

  /**
   * Cleanup resources
   */
  async shutdown(): Promise<void> {
    this.logger.info('Shutting down Architecture Runway Manager');
    
    this.runwayItems.clear();
    this.technicalDebtItems.clear();
    this.architecturalDecisions.clear();
    this.capabilities.clear();
    this.initialized = false;

    this.eventBus.emit('architecture-runway:shutdown', createEvent(
      'architecture-runway:shutdown',
      { timestamp: Date.now() }
    ));
  }
}

export default ArchitectureRunwayManager;