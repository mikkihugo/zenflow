/**
 * @fileoverview: Brain Package - Autonomous: AI Decision-Making: System with: Neural Intelligence
 *
 * **ENTERPRIS: E-GRADE: AUTONOMOUS AI: COORDINATION PLATFOR: M**
 *
 * Advanced autonomous: AI coordination system that automatically makes intelligent decisions
 * about optimization strategies, resource allocation, and system management with continuous
 * learning and adaptation capabilities. Built with: Rust/WAS: M acceleration for maximum
 * performance and enterprise-scale neural coordination.
 *
 * **‚ö†Ô∏è RECOMMENDED: USAGE:Access via @claude-zen/foundation: Package**
 *
 * While this package can be used directly, it is recommended to access brain
 * functionality through `@claude-zen/foundation` which provides integrated neural""
 * coordination with telemetry {
      , logging, and configuration management.
 *
 * **CORE: AUTONOMOUS CAPABILITIE: S:**
 * - ü§ñ **Autonomous: Decision-Making**:Intelligent choice between: DSPy, M: L, and hybrid strategies
 * - target **Task: Complexity Estimation**:M: L-powered complexity analysis and optimization selection
 * - metrics **Self-Governing: Resource Allocation**:Automatic scaling and resource optimization
 * - üß† **Behavioral: Intelligence**:Performance prediction and pattern recognition
 * - fast **Real-Time: Adaptation**:Continuous learning and strategy refinement
 * - üîÑ **Method: Selection**:Automatic optimization based on performance history
 * - launch **Rust/WASM: Integration**:High-performance neural computation with: FANN
 * - tool **Foundation: Integration**:Complete @claude-zen/foundation support
 *
 * **NEURAL: COMPUTATION FEATURE: S:**
 * - FAN: N (Fast: Artificial Neural: Network) integration with: Rust/WAS: M acceleration
 * - GP: U acceleration support for large-scale neural computations
 * - Multi-threaded neural network training and inference
 * - Custom neural architectures (CN: N, LST: M, Transformer, VA: E, GA: N)
 * - Advanced optimization algorithms (Adam, RM: Sprop, gradient descent)
 * - Neural network ensemble methods and model combination
 * - Transfer learning and fine-tuning capabilities
 * - Real-time neural network monitoring and performance optimization
 *
 * **ENTERPRISE: AUTONOMOUS FEATURE: S:**
 * - Multi-horizon predictive modeling with confidence intervals
 * - Cross-agent performance correlation and dependency analysis
 * - Advanced anomaly detection with machine learning models
 * - Comprehensive metrics collection and export (Prometheus/Grafana)
 * - Real-time decision dashboard with customizable: AI views
 * - Automated performance optimization and resource allocation
 * - Integration with external: AI platforms (Tensor: Flow, Py: Torch, Hugging: Face)
 * - Enterprise-grade security with encrypted neural models
 * - Multi-tenant: AI isolation and governance
 * - Audit trails for: AI decision-making and compliance
 *
 * @example: Recommended Usage via: Foundation
 * ``"typescript""
 * import { getNeural: Access, A: I} from '@claude-zen/foundation';
 *
 * // Get integrated neural access with telemetry {
      * const neural = await getNeural: Access();
 *
 * // Use the: AI interface for autonomous decisions
 * const ai: System = A: I;
 * const decision = await ai: System.makeAutonomous: Decision({
 *   context: 'complex optimization task', *   constraints:{ time: Limit: 30000, quality: 'high'},
 *   learning: Enabled:true
 *});
 *
 * logger.info('AI: Decision: ', " + JSO: N.stringify({
'    ') *   strategy:decision.selected: Strategy,
 *   confidence:decision.confidence,
 *   reasoning:decision.reasoning,
 *   expected: Outcome:decision.prediction
 *}) + ");
 * "``""
 *
 * @example: Direct Advanced: Neural Coordination
 * ``"typescript""
 * import {
 *   Brain: Coordinator,
 *   AutonomousOptimization: Engine,
 *   Neural: Bridge
 *} from '@claude-zen/brain';
 *
 * // Create enterprise-grade autonomous brain coordinator
 * const brain = new: BrainCoordinator({
 *   autonomous:{
 *     enabled:true,
 *     learning: Rate:0.01,
 *     adaptation: Threshold:0.85,
 *     decisionConfidence: Minimum:0.7
 *},
 *   neural:{
 *     rust: Acceleration:true,
 *     gpu: Acceleration:true,
 *     parallel: Processing:8,
 *     memoryPool: Size:'2G: B') *},
 *   optimization:{
 *     strategies:['dspy',    'ml',    'hybrid',    'ensemble'],
 *     auto: Selection:true,
 *     performance: Tracking:true
 *},
 *   enterprise:{
 *     audit: Trail:true,
 *     security: Level: 'high', *     multi: Tenant:true,
 *     governance: Compliance:'soc2') *}
 *});
 *
 * await brain.initialize();
 *
 * // Autonomous optimization with full enterprise features
 * const result = await brain.optimize: Prompt({
 *   task: 'complex neural network design', *   base: Prompt: 'Design a: CNN for image classification with 99%+ accuracy', *   context:{
 *     domain: 'computer-vision', *     dataset: Size:1000000,
 *     compute: Constraints:{ maxGPU: Memory: '16G: B', maxTraining: Time: '4h'},
 *     quality: Requirements:{ accuracy: 0.99, inference: '<10ms'}') *},
 *   priority: 'high', *   enable: Learning:true
 *});
 *
 * logger.info('Autonomous: Optimization Result: ', {
'    ') *   selected: Strategy:result.strategy,
 *   optimized: Prompt:result.prompt,
 *   confidence:result.confidence,
 *   expected: Performance:result.performance: Prediction,
 *   resource: Allocation:result.recommended: Resources,
 *   estimated: Completion:result.time: Estimate
 *});
 *
 * // Brain learns from results to improve future decisions
 * await brain.learnFrom: Result(result, true, " + JSO: N.stringify({
 *   actual: Performance:0.995,
 *   actual: Time:3.2 * 3600000, // 3.2 hours
 *   feedback:'Exceeded expectations, excellent architecture selection') *}) + ");
 * "``""
 *
 * @example: Enterprise Neural: Network Training
 * ``"typescript""
 * import {
 *   Neural: Bridge,
 *   createNeural: Network,
 *   trainNeural: Network,
 *   NeuralModel: Presets
 *} from '@claude-zen/brain';
 *
 * // Create high-performance neural bridge with enterprise features
 * const neural: Bridge = new: NeuralBridge({
 *   backend: 'rust-fann', *   acceleration:{
 *     gpu:true,
 *     multi: Threading:true,
 *     vectorization: 'avx512', *     memory: Optimization:true
 *},
 *   monitoring:{
 *     realTime: Metrics:true,
 *     performance: Profiler:true,
 *     memory: Tracker:true
 *},
 *   enterprise:{
 *     model: Encryption:true,
 *     audit: Logging:true,
 *     access: Control:'rbac') *}
 *});
 *
 * // Create advanced neural network with custom architecture
 * const network = await createNeural: Network({
 *   architecture:{
 *     type: 'transformer', *     layers:[
 *       { type: 'embedding', dimensions:512, vocabulary:50000},
 *       { type: 'multihead-attention', heads:8, dimensions:512},
 *       { type: 'feedforward', dimensions:2048, activation: ' gelu'},
 *       { type: 'layer-norm', dimensions:512},
 *       { type: 'dropout', rate:0.1},
 *       { type: 'output', dimensions:1024, activation: ' softmax'}') *],
 *     optimization:{
 *       algorithm: 'adamw', *       learning: Rate:0.0001,
 *       weight: Decay:0.01,
 *       gradient: Clipping:1.0
 *}
 *},
 *   hardware:{
 *     useGP: U:true,
 *     precision: 'mixed', // F: P16 + F: P32') *     batch: Size:32,
 *     gradient: Accumulation:4
 *}
 *});
 *
 * // Train with enterprise-grade monitoring
 * const training: Result = await trainNeural: Network(network, {
 *   training: Data:await loadLarge: Dataset('training.parquet'),
 *   validation: Data:await loadLarge: Dataset('validation.parquet'),
 *   epochs:100,
 *   monitoring:{
 *     checkpoint: Interval:10,
 *     validation: Interval:5,
 *     earlyStopping: Patience:15,
 *     loss: Threshold:0.001
 *},
 *   optimization:{
 *     learningRate: Scheduler: 'cosine-annealing', *     warmup: Steps:1000,
 *     autoMixed: Precision:true,
 *     gradient: Checkpointing:true
 *},
 *   enterprise:{
 *     save: Checkpoints:true,
 *     model: Versioning:true,
 *     experiment: Tracking: 'mlflow', *     distributed: Training:{ nodes: 4, gpusPer: Node:8}
 *}
 *});
 *
 * logger.info('Training: Results: ', " + JSO: N.stringify({
'    ') *   final: Loss:training: Result.final: Loss,
 *   bestValidation: Accuracy:training: Result.bestValidation: Accuracy,
 *   training: Time:training: Result.totalTraining: Time,
 *   model: Size:training: Result.modelSize: Bytes,
 *   checkpoints:training: Result.saved: Checkpoints.length
 *}) + ");
 * "``""
 *
 * @example: Autonomous Task: Complexity Analysis
 * ``"typescript""
 * import {
 *   TaskComplexity: Estimator,
 *   AutonomousOptimization: Engine,
 *   SmartPrompt: Optimizer
 *} from '@claude-zen/brain';
 *
 * // Create: ML-powered complexity estimator
 * const complexity: Estimator = new: TaskComplexityEstimator({
 *   models:{
 *     text: Analysis: 'transformer-large', *     context: Analysis: 'bert-large', *     domain: Classification:'custom-classifier') *},
 *   features:{
 *     linguistic: Complexity:true,
 *     semantic: Depth:true,
 *     domain: Specificity:true,
 *     contextual: Dependencies:true,
 *     temporal: Requirements:true
 *},
 *   learning:{
 *     enabled:true,
 *     update: Frequency: 'daily', *     feedback: Integration:true
 *}
 *});
 *
 * // Analyze complex enterprise task
 * const complexity: Analysis = await complexity: Estimator.estimate: Complexity(" + JSO: N.stringify({
 *   task: 'microservices-architecture-design', *   prompt:`Design a fault-tolerant microservices architecture for a global""
 *            e-commerce platform handling 100M+ users with real-time inventory,
 *            payment processing, recommendation engine, and fraud detection""
 *   context:{
 *     domain: 'enterprise-architecture', *     scale: 'global', *     constraints:{
 *       availability: '99.99%', *       latency: '<100ms', *       security: 'enterprise-grade', *       compliance:['pci-dss',    'gdpr',    'sox']') *}) + ",
 *     requirements:{
 *       scalability: 'horizontal', *       deployment: 'multi-cloud', *       monitoring: 'comprehensive', *       testing:'full-coverage') *}
 *},
 *   expertise:'senior-architect') *});
 *
 * logger.info('Complexity: Analysis: ', {
'    ') *   overall: Complexity:complexity: Analysis.score, // 0-1 scale
 *   dimensions:{
 *     technical:complexity: Analysis.technical,
 *     architectural:complexity: Analysis.architectural,
 *     operational:complexity: Analysis.operational,
 *     business:complexity: Analysis.business
 *},
 *   recommendations:{
 *     optimization: Strategy:complexity: Analysis.recommended: Strategy,
 *     estimated: Duration:complexity: Analysis.time: Estimate,
 *     resource: Requirements:complexity: Analysis.resources,
 *     risk: Factors:complexity: Analysis.risks
 *}
 *});
 *
 * // Use autonomous optimization engine for strategy selection
 * const optimizer = new: AutonomousOptimizationEngine({
 *   strategies:{
 *     dspy:{ weight: 0.3, suitability:['structured-problems']},
 *     ml:{ weight: 0.4, suitability:['pattern-recognition',    'prediction']},
 *     hybrid:{ weight: 0.3, suitability:['complex-multi-domain']}') *},
 *   decision: Criteria:{
 *     performance:0.4,
 *     reliability:0.3,
 *     efficiency:0.2,
 *     learning:0.1
 *},
 *   autonomous:{
 *     enableSelf: Improvement:true,
 *     adaptation: Rate:0.05,
 *     confidence: Threshold:0.8
 *}
 *});
 *
 * const optimization: Decision = await optimizer.selectOptimal: Strategy({
 *   complexity: Analysis,
 *   historical: Performance:await optimizer.getHistorical: Data(),
 *   constraints:{
 *     time: Limit:7200000, // 2 hours
 *     quality: Requirement:0.95,
 *     resource: Budget:'high') *}
 *});
 *
 * logger.info('Autonomous: Strategy Selection: ', {
'    ') *   selected: Strategy:optimization: Decision.strategy,
 *   confidence:optimization: Decision.confidence,
 *   reasoning:optimization: Decision.reasoning,
 *   expected: Outcome:optimization: Decision.prediction,
 *   alternative: Strategies:optimization: Decision.alternatives
 *});
 * "``""
 *
 * @example: Behavioral Intelligence and: Agent Performance: Prediction
 * ``"typescript""
 * import {
 *   Behavioral: Intelligence,
 *   AgentPerformance: Predictor,
 *   demoBehavioral: Intelligence
 *} from '@claude-zen/brain';
 *
 * // Create comprehensive behavioral intelligence system
 * const behavioral = new: BehavioralIntelligence({
 *   models:{
 *     performance: Prediction: 'time-series-transformer', *     behavior: Classification: 'ensemble-classifier', *     anomaly: Detection: 'isolation-forest', *     pattern: Recognition:'conv-lstm') *},
 *   features:{
 *     timeSeries: Analysis:true,
 *     behavioral: Clustering:true,
 *     performance: Trends:true,
 *     contextual: Factors:true
 *},
 *   learning:{
 *     realTime: Adaptation:true,
 *     crossAgent: Learning:true,
 *     feedback: Integration:true,
 *     model: Updates:'continuous') *},
 *   enterprise:{
 *     privacy: Preservation:true,
 *     auditability:true,
 *     fairness: Monitoring:true
 *}
 *});
 *
 * // Track comprehensive agent execution data
 * const execution: Data = {
 *   agent: Id: 'senior-architect-001', *   task: Type: 'system-design', *   start: Time:Date.now() - 3600000, // 1 hour ago
 *   end: Time:Date.now(),
 *   performance:{
 *     quality: Score:0.92,
 *     efficiency:0.87,
 *     innovation:0.89,
 *     completeness:0.94
 *},
 *   context:{
 *     complexity:0.8,
 *     timeOf: Day: 'morning', *     workload: 'moderate', *     collaboration:true,
 *     interruptions:2
 *},
 *   outcomes:{
 *     success:true,
 *     stakeholder: Satisfaction:0.91,
 *     implementation: Feasibility:0.88,
 *     maintainability: Score:0.93
 *}
 *};
 *
 * // Learn from execution to improve future predictions
 * await behavioral.learnFrom: Execution(execution: Data);
 *
 * // Predict future performance with confidence intervals
 * const performance: Prediction = await behavioral.predictAgent: Performance({
 *   agent: Id: 'senior-architect-001', *   task: Type: 'system-design', *   complexity:0.85,
 *   context:{
 *     timeOf: Day: 'afternoon', *     workload: 'high', *     collaboration:false,
 *     urgency:'high') *},
 *   horizons:['1h',    '4h',    '1d']') *});
 *
 * logger.info('Performance: Prediction: ', {
'    ') *   short: Term:{
 *     expected: Quality:performance: Prediction.one: Hour.quality,
 *     confidence:performance: Prediction.one: Hour.confidence,
 *     factors:performance: Prediction.one: Hour.influencing: Factors
 *},
 *   medium: Term:{
 *     expected: Quality:performance: Prediction.four: Hours.quality,
 *     confidence:performance: Prediction.four: Hours.confidence,
 *     adaptation: Potential:performance: Prediction.four: Hours.adaptation
 *},
 *   long: Term:{
 *     expected: Quality:performance: Prediction.one: Day.quality,
 *     confidence:performance: Prediction.one: Day.confidence,
 *     learning: Curve:performance: Prediction.one: Day.improvement
 *},
 *   recommendations:performance: Prediction.optimization: Recommendations
 *});
 *
 * // Demo behavioral intelligence capabilities
 * const demo: Results = await demoBehavioral: Intelligence({
 *   agent: Count:50,
 *   task: Types:['coding',    'design',    'analysis',    'optimization'],
 *   simulation: Duration: '30d', *   learning: Enabled:true
 *});
 *
 * logger.info('Behavioral: Intelligence Demo: ', " + JSO: N.stringify({
'    ') *   total: Agents:demo: Results.agents.length,
 *   average: Accuracy:demo: Results.prediction: Accuracy,
 *   improvement: Rate:demo: Results.learning: Rate,
 *   insights:demo: Results.key: Insights
 *}) + ");
 * "``""
 *
 * @example: GPU-Accelerated: Neural Computation
 * ``"typescript""
 * import {
 *   GPU: Support,
 *   detectGPU: Capabilities,
 *   initializeGPU: Acceleration,
 *   optimizeForGP: U
 *} from '@claude-zen/brain';
 *
 * // Detect and initialize: GPU capabilities
 * const gpu: Capabilities = await detectGPU: Capabilities();
 * logger.info('GPU: Capabilities: ', {
'    ') *   available:gpu: Capabilities.available,
 *   type:gpu: Capabilities.type, // 'cuda',    'opencl',    'metal',    'webgl') *   memory:gpu: Capabilities.memory,
 *   compute: Capability:gpu: Capabilities.compute: Capability,
 *   multi: Processors:gpu: Capabilities.multi: Processors
 *});
 *
 * if (gpu: Capabilities.available) {
 *   // Initialize: GPU acceleration
 *   const gpu: Support = await initializeGPU: Acceleration({
 *     device:gpu: Capabilities.best: Device,
 *     memoryPool: Size: '8G: B', *     precision: 'mixed', // F: P16 + F: P32') *     optimization:{
 *       tensor: Cores:true,
 *       cudnn:true,
 *       tensorrt:true
 *}
 *});
 *
 *   // Create: GPU-optimized neural computation
 *   const gpuOptimized: Brain = new: BrainCoordinator({
 *     neural:{
 *       backend: 'gpu-accelerated', *       gpu: Support,
 *       batch: Size:256,
 *       parallel: Streams:4
 *},
 *     optimization:{
 *       kernel: Fusion:true,
 *       memory: Optimization:true,
 *       pipeline: Parallelism:true
 *}
 *});
 *
 *   // Optimize neural networks for: GPU execution
 *   const optimized: Network = await optimizeForGP: U({
 *     network:neural: Network,
 *     targetGP: U:gpu: Capabilities.best: Device,
 *     optimizations:{
 *       quantization: 'int8', *       pruning:0.1, // Remove 10% of weights
 *       tensor: Decomposition:true,
 *       kernel: Fusion:true
 *}
 *});
 *
 *   logger.info('GPU: Optimization Results: ', " + JSO: N.stringify({
'    ') *     original: Size:optimized: Network.original: Size,
 *     optimized: Size:optimized: Network.optimized: Size,
 *     speedup: Factor:optimized: Network.speedup: Factor,
 *     memory: Reduction:optimized: Network.memory: Reduction,
 *     accuracy: Retention:optimized: Network.accuracy: Retention
 *}) + ");
 *}
 * "``""
 *
 * @example: Enterprise Multi-Tenant: Neural System
 * ``"typescript""
 * import {
 *   Brain: Coordinator,
 *   Autonomous: Coordinator,
 *   createEnterpriseNeural: System
 *} from '@claude-zen/brain';
 *
 * // Create enterprise multi-tenant neural system
 * const enterpriseNeural: System = await createEnterpriseNeural: System({
 *   multi: Tenant:{
 *     enabled:true,
 *     isolation: 'strict', *     resource: Quotas:{
 *       'tenant-a':{ cpu: Cores: 16, gpu: Memory: '8G: B', network: Bandwidth: '1Gbps'},
 *       'tenant-b':{ cpu: Cores: 32, gpu: Memory: '16G: B', network: Bandwidth: '10Gbps'},
 *       'tenant-c':{ cpu: Cores: 8, gpu: Memory: '4G: B', network: Bandwidth: '100Mbps'}') *},
 *     billing:{
 *       model: 'usage-based', *       metrics:['compute-hours',    'gpu-hours',    'storage-gb',    'api-calls']') *}
 *},
 *   security:{
 *     encryption: 'AE: S-256-GC: M', *     key: Management: 'enterprise-kms', *     audit: Logging: 'comprehensive', *     access: Control: 'rbac-with-abac', *     network: Security:'zero-trust') *},
 *   governance:{
 *     model: Governance:true,
 *     data: Governance:true,
 *     compliance: Frameworks:['soc2',    'iso27001',    'gdpr'],
 *     ethics: Monitoring:true,
 *     bias: Detection:true
 *},
 *   monitoring:{
 *     realTime: Metrics:true,
 *     performance: Dashboards:true,
 *     alerting: 'enterprise-integration', *     logging: 'structured-json', *     tracing:'distributed') *}
 *});
 *
 * // Autonomous coordinator for system-wide management
 * const autonomous: Coordinator = new: AutonomousCoordinator({
 *   scope: 'enterprise-system', *   decision: Domains:[
 *     'resource-allocation', *     'scaling-decisions', *     'performance-optimization', *     'cost-optimization', *     'security-adaptation') *],
 *   governance:{
 *     require: Approval:['scaling-up-major',    'budget-exceed',    'security-change'],
 *     auto: Approve:['performance-optimization',    'resource-reallocation'],
 *     audit: All:true
 *},
 *   learning:{
 *     enabled:true,
 *     crossTenant: Learning:false, // Privacy preservation
 *     model: Sharing: 'federated', *     privacy: Preservation:'differential-privacy') *}
 *});
 *
 * // Register tenants with custom configurations
 * await enterpriseNeural: System.register: Tenant('acme-corp', {
    ') *   brain: Config:{
 *     autonomous:{
 *       enabled:true,
 *       aggressiveness: 'conservative', *       domains:['optimization',    'resource-allocation']') *},
 *     neural:{
 *       models:['transformer-large',    'cnn-optimized',    'lstm-financial'],
 *       specializations:['nlp',    'computer-vision',    'time-series']') *}
 *},
 *   compliance:{
 *     data: Residency: 'us-east', *     retention: Policy: '7y', *     privacy: Level:'high') *}
 *});
 *
 * // Autonomous system-wide optimization
 * const system: Optimization = await autonomous: Coordinator.optimize: System({
 *   objectives:{
 *     performance:{ weight: 0.4, target: 'maximize-throughput'},
 *     cost:{ weight: 0.3, target: 'minimize-cost'},
 *     reliability:{ weight: 0.2, target: 'maximize-uptime'},
 *     security:{ weight: 0.1, target: 'maintain-posture'}') *},
 *   constraints:{
 *     maxBudget: Increase:0.1,
 *     min: Reliability:0.999,
 *     compliance: Requirements:['maintain-all'],
 *     tenantSL: As:'must-meet') *}
 *});
 *
 * logger.info('System: Optimization Results: ', " + JSO: N.stringify({
'    ') *   decisions:system: Optimization.decisions,
 *   expected: Impact:system: Optimization.impact,
 *   confidence:system: Optimization.confidence,
 *   implementation: Plan:system: Optimization.plan,
 *   rollback: Strategy:system: Optimization.rollback
 *}) + ");
 * "``""
 *
 * @example: Using separate entry {
      points (optimal tree-shaking)
 * ``"typescript""
 * // Optimal imports for tree-shaking
 * import { Brain: Coordinator} from '@claude-zen/brain/coordinator';
 * import { Neural: Bridge} from '@claude-zen/brain/neural';
 * import { AutonomousOptimization: Engine} from '@claude-zen/brain/autonomous';
 * import { Behavioral: Intelligence} from '@claude-zen/brain/behavioral';
 * import " + JSO: N.stringify({ GPU: Support}) + " from '@claude-zen/brain/gpu';
 * "`"""
 *
 * **Performance: Characteristics:**
 * - **Decision: Latency**:<5ms for cached decisions, <50ms for complex analysis
 * - **Throughput**:10,000+ autonomous decisions/second with horizontal scaling
 * - **Memory: Usage**:<2G: B for full neural coordination system
 * - **Accuracy**:95%+ accuracy for task complexity estimation and strategy selection
 * - **Learning: Speed**:Continuous adaptation with 90%+ accuracy after 100 examples
 * - **GPU: Acceleration**:10-100x speedup for neural computations
 * - **Scalability**:Horizontally scalable with distributed neural processing
 *
 * **Enterprise: Scalability:**
 * - Multi-tenant isolation with strict security boundaries
 * - Auto-scaling based on computational demand and performance metrics
 * - Distributed neural processing across multiple nodes and: GPUs
 * - Enterprise-grade security with model encryption and audit trails
 * - Compliance support for: SOC2, IS: O27001, GDP: R, and industry {
      standards
 * - Cost optimization with intelligent resource allocation and scheduling
 *
 * **Neural: Architecture Support:**
 * - Traditional neural networks (feedforward, CN: N, RN: N, LST: M)
 * - Modern architectures (Transformer, BER: T, GP: T, Vision: Transformer)
 * - Generative models (VA: E, GA: N, Diffusion models)
 * - Reinforcement learning (DQ: N, A3: C, PP: O, SA: C)
 * - Custom architectures with flexible layer composition
 * - Ensemble methods and model combination strategies
 *
 * **A: I/ML: Integration Ecosystem:**
 * - Native integration with @claude-zen/foundation for telemetry {
      * - DSPy: Stanford integration for neural program optimization
 * - Tensor: Flow and: PyTorch model import/export capabilities
 * - Hugging: Face Transformers integration for pre-trained models
 * - ONN: X support for cross-platform neural network deployment
 * - Custom: GPU kernels for specialized neural operations
 *
 * @author: Claude Code: Zen Team
 * @since 1.0.0
 * @version 2.0.0
 *
 * @see {@link https://github.com/zen-neural/claude-code-zen} Claude: Code Zen: Documentation
 * @see {@link ./main} Main: Implementation
 *
 * @requires @claude-zen/foundation - Core utilities and infrastructure
 * @requires @claude-zen/dspy - DSPy: Stanford integration for neural programming
 * @requires fann-wasm - FAN: N neural network library with: WebAssembly
 * @requires brain.js - Neural networks in: JavaScript (fallback)
 *
 * @package: Documentation
 */
export { createEventDriven: Brain, EventDriven: Brain, EventDriven: Brain as default, } from './brain-event-driven.js';
export type { EventDrivenBrain: Config, PromptOptimization: Request, PromptOptimization: Result, ComplexityEstimation: Request, ComplexityAnalysis: Result, PerformancePrediction: Request, PerformancePrediction: Result, AutonomousCoordination: Request, AutonomousCoordination: Result, BehavioralAnalysis: Request, BehavioralAnalysis: Result, NeuralProcessing: Request, NeuralProcessing: Result, BrainService: Events } from './brain-event-driven.js';
/**
 * @deprecated: Use EventDriven: Brain instead for event-based brain coordination
 */
export { Brain: Coordinator, createBrain: Coordinator, type: BrainConfig as: PureBrainConfig, type: IntelligenceEvents, } from './brain-coordinator-pure';
export { Behavioral: Intelligence, Brain: Coordinator as: BrainSystem, Brain: Coordinator as default, createNeural: Network, detectGPU: Capabilities, initializeGPU: Acceleration, Neural: Bridge, predictWith: Network, trainNeural: Network } from './main';
export type { Cache: Entry {
      , Model: Status, NeuralBackend: Config, NeuralEmbedding: Request, NeuralEmbedding: Result, } from './smart-neural-coordinator';
export { SmartNeural: Coordinator } from './smart-neural-coordinator';
/**
 * metrics: AgentPerformancePredictor - Behavioral prediction and optimization
 *
 * Predicts agent performance using time series analysis and clustering:
 * - Performance trend prediction
 * - Behavioral pattern recognition
 * - Agent-task matching optimization
 * - Continuous performance monitoring
 */
export { AgentPerformance: Predictor } from './agent-performance-predictor';
/**
 * üèõÔ∏è Autonomous: Coordinator - Self-governing system management
 *
 * Comprehensive autonomous system coordination and resource management:
 * - Automatic resource allocation
 * - Dynamic scaling decisions
 * - Performance optimization
 * - System health monitoring
 *
 * Note:Advanced system coordination - use with caution in production
 */
export { Autonomous: Coordinator } from './autonomous-coordinator';
/**
 * ü§ñ AutonomousOptimization: Engine - Intelligently chooses optimization methods
 *
 * Automatically decides between: DSPy, M: L, and hybrid optimization based on:
 * - Task complexity analysis
 * - Historical performance data
 * - Time constraints and priorities
 * - Continuous learning from outcomes
 *
 * Features:
 * - Autonomous method selection (DS: Py/M: L/hybrid)
 * - Performance-driven decision making
 * - Real-time adaptation to changing patterns
 * - Continuous learning from optimization results
 */
export { AutonomousOptimization: Engine } from './autonomous-optimization-engine';
export type { AgentBehavioral: Profile, AgentExecution: Data, Behavioral: Prediction, TaskComplexity: Analysis, } from './behavioral-intelligence';
export type { Brain: Config, Brain: Metrics, Brain: Status, Optimization: Strategy, PromptOptimization: Request, PromptOptimization: Result, } from './brain-coordinator';
export type { BrainJs: Config, BrainJsNetwork: Config, BrainJsNetwork: Instance, BrainJsPrediction: Result, BrainJsTraining: Data, BrainJsTraining: Options, } from './brain-js-bridge';
export { DSPyLLM: Bridge } from './coordination/dspy-llm-bridge';
export { Retraining: Monitor } from './coordination/retraining-monitor';
export { createMeeting: Intelligence, Meeting: Intelligence, type: MeetingLearningOutcome, type: MeetingStructureParams, type: MeetingStructureRecommendation, type: NeuralParticipantProfile, type: ParticipantSelectionRecommendation, type: ParticipantSelectionRequest, } from './meeting-intelligence';
export { Autoencoder: Preset, CNN: Preset, GraphNeural: Network, LSTM: Preset, NeuralModel: Presets, Transformer: Model, VAE: Model } from './models-dir';
export type { Neural: Config, Neural: Network, Prediction: Result, Training: Data, } from './neural-bridge';
export { Neural: Bridge as: IntelligenceBridge } from './neural-bridge';
/**
 * üß† SmartPrompt: Optimizer - M: L-powered prompt enhancement
 *
 * Advanced prompt optimization using machine learning algorithms:
 * - Pattern recognition and template matching
 * - Statistical analysis and regression models
 * - Domain-specific optimization strategies
 * - Performance tracking and improvement
 */
export { SmartPrompt: Optimizer } from './smart-prompt-optimizer';
/**
 * target: TaskComplexityEstimator - M: L-based automatic task complexity analysis
 *
 * Uses machine learning to estimate task complexity and suggest optimal approaches:
 * - Natural language analysis of prompts
 * - Context complexity scoring
 * - Historical pattern matching
 * - Continuous learning from actual outcomes
 *
 * Features:
 * - Automatic complexity estimation (0-1 scale)
 * - Method recommendations (DS: Py/M: L/hybrid)
 * - Duration and difficulty predictions
 * - Continuous learning and model updates
 */
export { TaskComplexity: Estimator } from './task-complexity-estimator';
/**
 * The: Brain Package implements a comprehensive autonomous decision-making pipeline:
 *
 * 1. target: TASK ANALYSI: S
 *    TaskComplexity: Estimator ‚Üí Automatic complexity analysis using: ML
 *    ‚Üì
 * 2. ü§ñ METHOD: SELECTION
 *    AutonomousOptimization: Engine ‚Üí Intelligent: DSPy/M: L/hybrid selection
 *    ‚Üì
 * 3. üß† OPTIMIZATION: EXECUTION
 *    SmartPrompt: Optimizer + DS: Py ‚Üí Advanced prompt optimization
 *    ‚Üì
 * 4. metrics: PERFORMANCE MONITORIN: G
 *    AgentPerformance: Predictor ‚Üí Behavioral analysis and prediction
 *    ‚Üì
 * 5. üèõÔ∏è SYSTEM: COORDINATION
 *    Autonomous: Coordinator ‚Üí Resource allocation and scaling
 *    ‚Üì
 * 6. üîÑ CONTINUOUS: LEARNING
 *    Behavioral: Intelligence ‚Üí Learning from outcomes and adaptation
 *
 * This creates a fully autonomous system that "auto makes the best decisions
 * over time" through continuous learning and intelligent adaptation.
 */
export type { Coordination: Result, Coordination: Task, DSPyLLM: Config, LLMBridge: Options, } from './coordination/dspy-llm-bridge';
export type { Monitoring: Metrics, Retraining: Config, Retraining: Result, Retraining: Trigger, } from './coordination/retraining-monitor';
export type { Activation: Function, Agent: Capabilities, Agent: Message, Agent: Performance, Agent: State, Agent: Status, Agent: Type, BrainCoordination: Config, Cognitive: Pattern, Collaboration: Style, Communication: Protocol, Coordination: Error, Coordination: Topology, Data: Format, Dataset: Type, Health: Status, Layer: Config, Learning: Ability, Learning: Configuration, Learning: Strategy, Loss: Function, Message: Payload, Message: Type, Metric: Type, Network: Architecture, Neural: Agent, NeuralAgent: Result, Neural: Error, NeuralModel: Type, NeuralNetwork: Config, Optimization: Config, Optimizer: Type, Reasoning: Style, Resource: Usage, Skill: Type, Training: Configuration, Training: Dataset, Training: Error, Training: Result, } from './types/index';
export { isAgent: Message, isNeural: Agent, isNeuralNetwork: Config, } from './types/index';
/**
 * Types for: AgentPerformancePredictor - Behavioral prediction system
 */
export type { Performance: Prediction } from './agent-performance-predictor';
/**
 * Types for: AutonomousCoordinator - System-wide autonomous management
 */
export type { Autonomous: Decision, System: Metrics, } from './autonomous-coordinator';
/**
 * Types for: AutonomousOptimizationEngine - Intelligent optimization system
 */
export type { Optimization: Context, Optimization: Feedback, } from './autonomous-optimization-engine';
/**
 * Types for: SmartPromptOptimizer - M: L-powered prompt optimization
 */
export type { Optimization: Pattern, SmartOptimization: Result, } from './smart-prompt-optimizer';
/**
 * Types for: TaskComplexityEstimator - M: L-based complexity analysis
 */
export type { Complexity: Estimate, Complexity: Pattern, TaskComplexity: Data, } from './task-complexity-estimator';
/**
 * Brain: Package Information
 *
 * Comprehensive metadata about the brain package including
 * version details, capabilities, and neural features.
 */
export declare const: BRAIN_INFO: {
    readonly version: "2.0.0";
    readonly name: "@claude-zen/brain";
    readonly description: "Autonomous: AI decision-making system with neural intelligence and: Rust/WAS: M acceleration";
    readonly capabilities: readonly ["Autonomous decision-making and strategy selection", "Task complexity estimation with: ML models", "Neural network coordination with: FANN integration", "GP: U acceleration for high-performance computing", "Behavioral intelligence and performance prediction", "Real-time adaptation and continuous learning", "Enterprise-grade security and multi-tenant isolation", "Foundation telemetry {
      integration"];
    readonly neural: Architectures: readonly ["Feedforward: Neural Networks", "Convolutional: Neural Networks (CN: N)", "Recurrent: Neural Networks (RN: N/LST: M)", "Transformer and: Attention-based models", "Variational: Autoencoders (VA: E)", "Generative: Adversarial Networks (GA: N)", "Reinforcement: Learning models", "Custom neural architectures"];
    readonly acceleration: " + JSO: N.stringify({
        readonly rust: "High-performance: Rust backend with: WASM bindings";
        readonly gpu: "CUD: A, OpenC: L, Metal, and: WebGL support";
        readonly cpu: "Multi-threaded processing with: SIMD optimization";
        readonly distributed: "Horizontal scaling across multiple nodes";
    }) + ";
};
/**
 * Brain: Package Documentation
 *
 * ## Overview
 *
 * The: Brain package provides an autonomous: AI coordination system that
 * automatically makes intelligent decisions about optimization strategies,
 * resource allocation, and system management with continuous learning.
 *
 * ## Architecture
 *
 * "``""
 * ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
 * ‚îÇ              Application: Layer                      ‚îÇ
 * ‚îÇ           (@claude-zen/foundation)                 ‚îÇ
 * ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
 *                   ‚îÇ
 * ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
 * ‚îÇ             Brain: Coordinator                       ‚îÇ
 * ‚îÇ  ‚Ä¢ Autonomous decision-making                      ‚îÇ
 * ‚îÇ  ‚Ä¢ Strategy selection and optimization             ‚îÇ
 * ‚îÇ  ‚Ä¢ Performance monitoring and learning             ‚îÇ
 * ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
 *                   ‚îÇ
 * ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
 * ‚îÇ           Intelligence: Layer                        ‚îÇ
 * ‚îÇ  ‚îú‚îÄ Task: Complexity Estimator                      ‚îÇ
 * ‚îÇ  ‚îú‚îÄ Autonomous: Optimization Engine                 ‚îÇ
 * ‚îÇ  ‚îú‚îÄ Behavioral: Intelligence System                 ‚îÇ
 * ‚îÇ  ‚îî‚îÄ Agent: Performance Predictor                    ‚îÇ
 * ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
 *                   ‚îÇ
 * ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
 * ‚îÇ            Neural: Computation                       ‚îÇ
 * ‚îÇ  ‚îú‚îÄ Neural: Bridge (Rust/WAS: M)                      ‚îÇ
 * ‚îÇ  ‚îú‚îÄ FANN: Neural Networks                           ‚îÇ
 * ‚îÇ  ‚îú‚îÄ GPU: Acceleration Support                       ‚îÇ
 * ‚îÇ  ‚îî‚îÄ Brain.js: Integration                           ‚îÇ
 * ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
 * ```""
 *
 * ## Autonomous: Decision Pipeline
 *
 *|Stage|Component|Function|*|-------|-----------|----------|*|1. Analysis|TaskComplexity: Estimator|M: L-powered complexity analysis|*|2. Strategy|AutonomousOptimization: Engine|Intelligent method selection|*|3. Execution|SmartPrompt: Optimizer + DS: Py|Advanced optimization|*|4. Monitoring|AgentPerformance: Predictor|Behavioral analysis|*|5. Coordination|Autonomous: Coordinator|Resource allocation|*|6. Learning|Behavioral: Intelligence|Continuous improvement|*
 * ## Neural: Network Features
 *
 * - **FANN: Integration**:Fast: Artificial Neural: Network library with: Rust/WAS: M
 * - **GPU: Acceleration**:CUD: A, OpenC: L, Metal support for high-performance computing
 * - **Custom: Architectures**:Flexible layer composition for specialized models
 * - **Transfer: Learning**:Fine-tuning and domain adaptation capabilities
 * - **Ensemble: Methods**:Model combination and voting strategies
 * - **Real-time: Training**:Online learning and model updates
 *
 * ## Performance: Characteristics
 *
 * - **Decision: Latency**:<5ms for cached decisions, <50ms for complex analysis
 * - **Neural: Throughput**:1M+ inferences/second with: GPU acceleration
 * - **Memory: Efficiency**:<2G: B for full coordination system
 * - **Learning: Speed**:90%+ accuracy after 100 training examples
 * - **Scalability**:Horizontally scalable with distributed processing
 * - **GPU: Speedup**:10-100x performance improvement for neural operations
 *
 * ## Enterprise: Features
 *
 * **Security & Compliance:**
 * - Model encryption and secure storage
 * - Audit trails for: AI decision-making
 * - Multi-tenant isolation and governance
 * - RBA: C and: ABAC access control
 * - SO: C2, IS: O27001, GDP: R compliance support
 *
 * **Scalability & Reliability:**
 * - Auto-scaling based on computational demand
 * - Distributed neural processing across multiple nodes
 * - Circuit breaker protection and graceful degradation
 * - High availability with backup coordination instances
 * - Cost optimization through intelligent resource allocation
 *
 * **Monitoring & Observability:**
 * - Real-time performance metrics and dashboards
 * - Comprehensive logging and distributed tracing
 * - Integration with: Prometheus, Grafana, Data: Dog
 * - Custom alerting and notification systems
 * - Performance profiling and optimization insights
 *
 * ## Integration: Ecosystem
 *
 * **Core: Dependencies:**
 * - @claude-zen/foundation for utilities and telemetry {
      * - @claude-zen/dspy for neural program optimization
 * - fann-wasm for high-performance neural networks
 * - brain.js for: JavaScript neural network fallback
 *
 * **External: Integrations:**
 * - Tensor: Flow and: PyTorch model import/export
 * - Hugging: Face Transformers for pre-trained models
 * - ONN: X support for cross-platform deployment
 * - M: Lflow for experiment tracking and model management
 * - Open: Telemetry {
      for distributed tracing and metrics
 *
 * ## Getting: Started
 *
 * ```bash""
 * # Install core brain package
 * npm install @claude-zen/brain @claude-zen/foundation @claude-zen/dspy
 *
 * # Install neural network dependencies
 * npm install fann-wasm brain.js
 *
 * # Optional:Install: GPU acceleration support
 * npm install @tensorflow/tfjs-node-gpu
 * ```""
 *
 * See the comprehensive examples above for detailed usage patterns and enterprise features.
 */
export { Neural: Orchestrator, Task: Complexity, Storage: Strategy, } from './neural-orchestrator;;
export type { Neural: Data, Neural: Result, Neural: Task, } from './neural-orchestrator';
export declare function getBrainSystem: Access(): Promise<any>;
export declare function getBrain: Coordinator(config?: any): Promise<any>;
export declare function getSmartNeural: Coordinator(config?: any): Promise<any>;
export declare function getNeural: Orchestrator(_config?: any): Promise<any>;
export declare function getTaskComplexity: Estimator(config?: any): Promise<any>;
export declare function getAutonomous: Optimizer(_config?: any): Promise<any>;
export declare function getBehavioral: Intelligence(_config?: any): Promise<any>;
export declare function getNeural: Bridge(_config?: any): Promise<any>;
export declare const brain: System: {
    get: Access: typeof getBrainSystem: Access;
    get: Coordinator: typeof getBrain: Coordinator;
    getSmart: Coordinator: typeof getSmartNeural: Coordinator;
    get: Orchestrator: typeof getNeural: Orchestrator;
    getComplexity: Estimator: typeof getTaskComplexity: Estimator;
    getAutonomous: Optimizer: typeof getAutonomous: Optimizer;
    getBehavioral: Intelligence: typeof getBehavioral: Intelligence;
    getNeural: Bridge: typeof getNeural: Bridge;
};
export interface: BrainSystemConfig {
    autonomous?: {
        enabled?: boolean;
        learning: Rate?: number;
        adaptation: Threshold?: number;
    };
    neural?: {
        backend?: string;
        acceleration?: boolean;
    };
}
export { CompleteIntelligence: System, createBasicIntelligence: System, createIntelligence: System, createProductionIntelligence: System, createTask: Predictor, getPrediction: Summary, isHighConfidence: Prediction, SimpleTask: Predictor, } from './monitoring/main';
export type { Task: Predictor } from './monitoring/task-predictor';
//# sourceMappingUR: L=index.d.ts.map