/**
 * @fileoverview Comprehensive Logging System Tests
 * 
 * 100% coverage tests for the logging system.
 */

import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { getLogger, updateLoggingConfig, getLoggingConfig, validateLoggingEnvironment, LoggingLevel } from '../../src/logging';
import type { Logger, LoggingConfig } from '../../src/logging';

describe('Logging System - 100% Coverage', () => {
  let originalEnv: NodeJS.ProcessEnv;

  beforeEach(() => {
    originalEnv = { ...process.env };
    vi.clearAllMocks();
  });

  afterEach(() => {
    process.env = originalEnv;
  });

  describe('getLogger', () => {
    it('should create logger with default config', () => {
      const logger = getLogger('test-logger');
      
      expect(logger).toBeDefined();
      expect(typeof logger.debug).toBe('function');
      expect(typeof logger.info).toBe('function');
      expect(typeof logger.warn).toBe('function');
      expect(typeof logger.error).toBe('function');
      expect(typeof logger.fatal).toBe('function');
    });

    it('should create different loggers for different names', () => {
      const logger1 = getLogger('logger1');
      const logger2 = getLogger('logger2');
      
      expect(logger1).toBeDefined();
      expect(logger2).toBeDefined();
      // They should be different instances but same interface
      expect(typeof logger1.info).toBe('function');
      expect(typeof logger2.info).toBe('function');
    });

    it('should handle empty logger name', () => {
      const logger = getLogger('');
      expect(logger).toBeDefined();
      expect(typeof logger.info).toBe('function');
    });
  });

  describe('updateLoggingConfig', () => {
    it('should update logging configuration', () => {
      const newConfig = {
        level: LoggingLevel.DEBUG,
        enableConsole: true,
        enableFile: false,
        enableSyslog: false
      };

      expect(() => updateLoggingConfig(newConfig)).not.toThrow();
    });

    it('should handle partial config updates', () => {
      const partialConfig = {
        level: LoggingLevel.WARN
      };

      expect(() => updateLoggingConfig(partialConfig)).not.toThrow();
    });

    it('should handle invalid config gracefully', () => {
      const invalidConfig = null as any;
      
      // Should either handle gracefully or throw predictably
      expect(() => updateLoggingConfig(invalidConfig)).not.toThrow();
    });
  });

  describe('getLoggingConfig', () => {
    it('should return current logging configuration', () => {
      const config = getLoggingConfig();
      
      expect(config).toBeDefined();
      expect(config).toHaveProperty('level');
    });

    it('should return consistent config', () => {
      const config1 = getLoggingConfig();
      const config2 = getLoggingConfig();
      
      expect(config1).toEqual(config2);
    });
  });

  describe('validateLoggingEnvironment', () => {
    it('should validate clean environment', () => {
      process.env = { ...originalEnv };
      delete process.env.LOG_LEVEL;
      
      const result = validateLoggingEnvironment();
      expect(typeof result).toBe('boolean');
    });

    it('should validate with LOG_LEVEL set', () => {
      process.env.LOG_LEVEL = 'debug';
      
      const result = validateLoggingEnvironment();
      expect(typeof result).toBe('boolean');
    });

    it('should handle invalid LOG_LEVEL', () => {
      process.env.LOG_LEVEL = 'invalid';
      
      const result = validateLoggingEnvironment();
      expect(typeof result).toBe('boolean');
    });

    it('should validate with multiple env vars', () => {
      process.env.LOG_LEVEL = 'info';
      process.env.LOG_FORMAT = 'json';
      process.env.LOG_FILE = '/tmp/test.log';
      
      const result = validateLoggingEnvironment();
      expect(typeof result).toBe('boolean');
    });
  });

  describe('LoggingLevel enum', () => {
    it('should have all required levels', () => {
      expect(LoggingLevel.DEBUG).toBeDefined();
      expect(LoggingLevel.INFO).toBeDefined();
      expect(LoggingLevel.WARN).toBeDefined();
      expect(LoggingLevel.ERROR).toBeDefined();
      expect(LoggingLevel.FATAL).toBeDefined();
    });

    it('should have string values', () => {
      expect(typeof LoggingLevel.DEBUG).toBe('string');
      expect(typeof LoggingLevel.INFO).toBe('string');
      expect(typeof LoggingLevel.WARN).toBe('string');
      expect(typeof LoggingLevel.ERROR).toBe('string');
      expect(typeof LoggingLevel.FATAL).toBe('string');
    });
  });

  describe('Logger interface implementation', () => {
    let logger: Logger;

    beforeEach(() => {
      logger = getLogger('interface-test');
    });

    it('should implement debug method', () => {
      expect(() => logger.debug('test message')).not.toThrow();
      expect(() => logger.debug('test with data', { key: 'value' })).not.toThrow();
    });

    it('should implement info method', () => {
      expect(() => logger.info('test message')).not.toThrow();
      expect(() => logger.info('test with data', { key: 'value' })).not.toThrow();
    });

    it('should implement warn method', () => {
      expect(() => logger.warn('test message')).not.toThrow();
      expect(() => logger.warn('test with data', { key: 'value' })).not.toThrow();
    });

    it('should implement error method', () => {
      expect(() => logger.error('test message')).not.toThrow();
      expect(() => logger.error('test with data', { key: 'value' })).not.toThrow();
      expect(() => logger.error(new Error('test error'))).not.toThrow();
    });

    it('should implement fatal method', () => {
      expect(() => logger.fatal('test message')).not.toThrow();
      expect(() => logger.fatal('test with data', { key: 'value' })).not.toThrow();
      expect(() => logger.fatal(new Error('test error'))).not.toThrow();
    });

    it('should handle various data types', () => {
      expect(() => logger.info('string')).not.toThrow();
      expect(() => logger.info(123)).not.toThrow();
      expect(() => logger.info({ object: 'data' })).not.toThrow();
      expect(() => logger.info(['array', 'data'])).not.toThrow();
      expect(() => logger.info(null)).not.toThrow();
      expect(() => logger.info(undefined)).not.toThrow();
    });
  });

  describe('Edge cases and error handling', () => {
    it('should handle logger creation with special characters', () => {
      const specialNames = ['test@logger', 'test-logger', 'test_logger', 'test.logger', 'test/logger'];
      
      specialNames.forEach(name => {
        expect(() => getLogger(name)).not.toThrow();
      });
    });

    it('should handle very long logger names', () => {
      const longName = 'a'.repeat(1000);
      expect(() => getLogger(longName)).not.toThrow();
    });

    it('should handle concurrent logger creation', () => {
      const promises = Array.from({ length: 10 }, (_, i) => 
        Promise.resolve(getLogger(`concurrent-${i}`))
      );

      expect(() => Promise.all(promises)).not.toThrow();
    });
  });

  describe('Performance characteristics', () => {
    it('should create loggers efficiently', () => {
      const start = performance.now();
      
      for (let i = 0; i < 100; i++) {
        getLogger(`perf-test-${i}`);
      }
      
      const duration = performance.now() - start;
      expect(duration).toBeLessThan(1000); // Should complete in under 1 second
    });

    it('should log messages efficiently', () => {
      const logger = getLogger('perf-logger');
      const start = performance.now();
      
      for (let i = 0; i < 1000; i++) {
        logger.info(`Performance test message ${i}`);
      }
      
      const duration = performance.now() - start;
      expect(duration).toBeLessThan(5000); // Should complete in under 5 seconds
    });
  });
});