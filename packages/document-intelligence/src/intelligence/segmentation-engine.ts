/**
 * Enhanced Segmentation Engine - DeepCode-style intelligent document segmentation
 * 
 * Provides vision-like document segmentation with advanced algorithm extraction,
 * block preservation, boundary detection, and adaptive strategies based on
 * document characteristics.
 * 
 * Enhanced with DeepCode patterns:
 * - Advanced algorithm extraction with mathematical formula recognition
 * - Multi-layer algorithm structure analysis (headers, steps, dependencies)
 * - Intelligent algorithm boundary detection with context preservation
 * - Mathematical notation and pseudocode pattern recognition
 * - Enhanced algorithm confidence scoring with complexity analysis
 */

import { TypedEventBase, getLogger } from '@claude-zen/foundation';
import type { DocumentClassification } from './semantic-classifier';

const logger = getLogger('SegmentationEngine');

/**
 * Document segment with metadata
 */
export interface DocumentSegment {
  id: string;
  content: string;
  startPosition: number;
  endPosition: number;
  segmentType: 'algorithm | concept' | 'implementation | context' | 'metadata';
  importance: number; // 0-1 importance score
  preserveIntegrity: boolean; // Whether to keep segment intact
  relatedSegments: string[]; // IDs of related segments
  confidenceScore: number; // 0-1 confidence in segmentation
  metadata: {
    title?: string;
    summary?: string;
    keywords: string[];
    algorithmDensity: number;
    conceptComplexity: number;
    characterCount: number;
    lineCount: number;
  };
}

/**
 * Segmentation result with strategy information
 */
export interface SegmentationResult {
  segments: DocumentSegment[];
  strategy: DocumentClassification['recommendedStrategy'];
  totalSegments: number;
  averageSegmentSize: number;
  preservedBlocks: number;
  qualityScore: number; // 0-1 overall segmentation quality
  processingTime: number;
  metadata: {
    documentType: string;
    originalLength: number;
    segmentationRatio: number; // segments per 1000 characters
    algorithmBlocksFound: number;
    conceptClustersFound: number;
  };
}

/**
 * Segmentation configuration
 */
export interface SegmentationConfig {
  strategy?: DocumentClassification['recommendedStrategy'];
  maxSegmentSize: number;
  minSegmentSize: number;
  algorithmPreservationThreshold: number;
  conceptClusteringThreshold: number;
  enableBoundaryDetection: boolean;
  enableContextExpansion: boolean;
  preserveAlgorithmBlocks: boolean;
  adaptiveCharacterLimits: boolean;
}

/**
 * Enhanced Algorithm block identification (DeepCode style)
 */
interface AlgorithmBlock {
  startIndex: number;
  endIndex: number;
  type: 'pseudocode | procedure' | 'mathematical | implementation' | 'formula | complexity-analysis';
  confidence: number;
  complexity: {
    cyclomaticComplexity: number; // Control flow complexity
    algorithmicComplexity: string; // Big O notation if detected
    mathematicalComplexity: number; // Mathematical formula complexity
    structuralDepth: number; // Nesting level
  };
  structure: {
    hasInputOutput: boolean;
    hasControlFlow: boolean;
    hasIterations: boolean;
    hasRecursion: boolean;
    hasPreconditions: boolean;
    hasPostconditions: boolean;
  };
  relatedDescription: {
    startIndex: number;
    endIndex: number;
    relationType: 'explanation | example' | 'proof | context';
  } | null;
  extractedElements: {
    variables: string[];
    functions: string[];
    constants: string[];
    operators: string[];
    keywords: string[];
  };
  qualityScore: number; // 0-1 based on completeness and clarity
}

/**
 * Intelligent document segmentation engine
 */
export class SegmentationEngine extends TypedEventBase {
  private config: SegmentationConfig;
  private algorithmPatterns: RegExp[];
  private boundaryPatterns: RegExp[];

  constructor(config: Partial<SegmentationConfig> = {}) {
    super();
    
    this.config = {
      maxSegmentSize: config.maxSegmentSize || 12000,
      minSegmentSize: config.minSegmentSize || 500,
      algorithmPreservationThreshold: config.algorithmPreservationThreshold || 0.3,
      conceptClusteringThreshold: config.conceptClusteringThreshold || 0.4,
      enableBoundaryDetection: config.enableBoundaryDetection !== false,
      enableContextExpansion: config.enableContextExpansion !== false,
      preserveAlgorithmBlocks: config.preserveAlgorithmBlocks !== false,
      adaptiveCharacterLimits: config.adaptiveCharacterLimits !== false,
      ...config
    };

    this.algorithmPatterns = this.initializeAlgorithmPatterns();
    this.boundaryPatterns = this.initializeBoundaryPatterns();
  }

  /**
   * Initialize enhanced algorithm detection patterns (DeepCode style)
   */
  private initializeAlgorithmPatterns(): RegExp[] {
    return [
      // Enhanced algorithm headers with complexity analysis
      /(algorithm\s+\d+|procedure\s+\d+|method\s+\d+|function\s+\w+|def\s+\w+)/gi,
      
      // Mathematical formulas and equations (LaTeX-style)
      /\$\$[\s\S]*?\$\$|\$[^$]+\$|\\begin\{equation\}[\s\S]*?\\end\{equation\}/g,
      
      // Input/Output patterns with enhanced detection
      /(input\s*:|output\s*:|returns?\s*:|require\s*:|ensure\s*:|precondition\s*:|postcondition\s*:|given\s*:|when\s*:|then\s*:)/gi,
      
      // Enhanced control flow patterns
      /(for\s+each|for\s+.*\s+in|while.*do|if.*then|else\s*if|else|repeat.*until|switch|case|loop|iterate|traverse)/gi,
      
      // Mathematical and computational operations
      /(compute|calculate|sum|product|maximum|minimum|sort|search|find|select|optimize|minimize|maximize|integrate|differentiate)/gi,
      
      // Algorithm structure indicators
      /(step\s+\d+|phase\s+\d+|\d+\.\s+|^\s*[-*+]\s+|begin|end|initialization|termination)/gm,
      
      // Pseudocode patterns
      /(let\s+\w+|set\s+\w+|assign|initialize|declare|define|call|invoke|execute)/gi,
      
      // Mathematical symbols and notation
      /[∀∃∈∉⊆⊇∪∩∑∏∫∂∇±×÷≤≥≠≈∞]/g,
      
      // Complexity analysis patterns
      /(o\(\w+\)|θ\(\w+\)|ω\(\w+\)|time\s+complexity|space\s+complexity|running\s+time)/gi,
      
      // Code blocks and implementation sections
      /```[\w]*\n[\s\S]*?\n```|`[^`]+`/g
    ];
  }

  /**
   * Initialize boundary detection patterns
   */
  private initializeBoundaryPatterns(): RegExp[] {
    return [
      // Section headers
      /^#+\s+.*/gm,
      
      // Paragraph boundaries
      /\n\s*\n/g,
      
      // List boundaries
      /^\s*[-*+]\s+/gm,
      /^\s*\d+\.\s+/gm,
      
      // Code block boundaries
      /```[\s\S]*?```/g,
      /`[^`]+`/g,
      
      // Formula boundaries
      /\$\$[\s\S]*?\$\$/g,
      /\$[^$]+\$/g
    ];
  }

  /**
   * Segment document using intelligent strategies
   */
  async segmentDocument(
    content: string, 
    classification: DocumentClassification
  ): Promise<SegmentationResult> {
    const startTime = performance.now();
    logger.info(`Starting document segmentation with strategy: ${classification.recommendedStrategy}`);

    try {
      // Adapt configuration based on classification
      const adaptedConfig = this.adaptConfigForClassification(classification);
      
      // Identify algorithm blocks first
      const algorithmBlocks = this.identifyAlgorithmBlocks(content);
      
      // Apply segmentation strategy
      const segments = await this.applySegmentationStrategy(
        content,
        classification.recommendedStrategy,
        algorithmBlocks,
        adaptedConfig
      );
      
      // Calculate quality metrics
      const qualityScore = this.calculateSegmentationQuality(segments, content);
      
      const endTime = performance.now();
      const processingTime = endTime - startTime;

      const result: SegmentationResult = {
        segments,
        strategy: classification.recommendedStrategy,
        totalSegments: segments.length,
        averageSegmentSize: this.calculateAverageSegmentSize(segments),
        preservedBlocks: algorithmBlocks.length,
        qualityScore,
        processingTime,
        metadata: {
          documentType: classification.documentType,
          originalLength: content.length,
          segmentationRatio: (segments.length / content.length) * 1000,
          algorithmBlocksFound: algorithmBlocks.length,
          conceptClustersFound: this.countConceptClusters(segments)
        }
      };

      this.emit('segmentation_complete', result);
      logger.info(`Document segmented into ${segments.length} segments (${processingTime.toFixed(2)}ms)`);

      return result;
    } catch (error) {
      logger.error('Error during document segmentation:', error);
      throw new Error(`Document segmentation failed: ${error}`);
    }
  }

  /**
   * Adapt configuration based on document classification
   */
  private adaptConfigForClassification(classification: DocumentClassification): SegmentationConfig {
    const adapted = { ...this.config };

    // Adjust segment sizes based on document type
    if (classification.documentType === 'algorithm' || classification.algorithmDensity > 0.5) {
      adapted.maxSegmentSize = Math.max(adapted.maxSegmentSize, 15000);
      adapted.algorithmPreservationThreshold = 0.2; // More sensitive
    }
    
    if (classification.documentType === 'research') {
      adapted.maxSegmentSize = Math.min(adapted.maxSegmentSize, 8000);
      adapted.conceptClusteringThreshold = 0.3; // More clustering
    }

    if (classification.conceptComplexity > 0.6) {
      adapted.enableContextExpansion = true;
      adapted.maxSegmentSize += 3000; // Allow larger segments for complex concepts
    }

    return adapted;
  }

  /**
   * Identify algorithm blocks in content
   */
  private identifyAlgorithmBlocks(content: string): AlgorithmBlock[] {
    const blocks: AlgorithmBlock[] = [];
    
    for (const pattern of this.algorithmPatterns) {
      let match;
      while ((match = pattern.exec(content)) !== null) {
        const startIndex = match.index;
        
        // Expand context to include complete algorithm description
        const expandedBoundary = this.findAlgorithmBoundaries(content, startIndex);
        
        const blockContent = content.substring(expandedBoundary.start, expandedBoundary.end);
        const block: AlgorithmBlock = {
          startIndex: expandedBoundary.start,
          endIndex: expandedBoundary.end,
          type: this.classifyAlgorithmType(match[0]),
          confidence: this.calculateAlgorithmConfidence(blockContent),
          complexity: this.analyzeComplexity(blockContent),
          structure: this.analyzeStructure(blockContent),
          relatedDescription: this.findRelatedDescription(content, expandedBoundary),
          extractedElements: this.extractAlgorithmElements(blockContent),
          qualityScore: this.calculateAlgorithmQuality(blockContent)
        };

        // Avoid duplicate blocks
        const overlaps = blocks.some(existing => 
          this.blocksOverlap(existing, block)
        );

        if (!overlaps && block.confidence > this.config.algorithmPreservationThreshold) {
          blocks.push(block);
        }
      }
    }

    return this.mergeOverlappingBlocks(blocks);
  }

  /**
   * Find algorithm boundaries using natural content breaks
   */
  private findAlgorithmBoundaries(content: string, startIndex: number): { start: number; end: number } {
    // Find natural boundaries - expand to include context
    let start = Math.max(0, startIndex - 300);
    let end = Math.min(content.length, startIndex + 500);

    // Find natural start boundary
    while (start > 0 && !this.isNaturalBoundary(content[start])) {
      start -= 1;
    }

    // Find natural end boundary
    while (end < content.length && !this.isNaturalBoundary(content[end])) {
      end += 1;
    }

    return { start, end };
  }

  /**
   * Check if character represents a natural content boundary
   */
  private isNaturalBoundary(char: string): boolean {
    return ['\n', '.', '!', '?', ';'].includes(char);
  }

  /**
   * Enhanced algorithm classification with complexity analysis (DeepCode style)
   */
  private classifyAlgorithmType(algorithmText: string): AlgorithmBlock['type'] {
    const text = algorithmText.toLowerCase();
    
    // Check for mathematical formulas and complexity analysis
    if (text.includes('o(') || text.includes('θ(') || text.includes('complexity')) {
      return 'complexity-analysis';
    }
    
    // Check for LaTeX formulas or mathematical notation
    if (text.includes('$$') || text.includes('\\begin{equation}') || /[∀∃∈∉⊆⊇∪∩∑∏∫∂∇]/.test(text)) {
      return 'formula';
    }
    
    // Check for traditional mathematical expressions
    if (text.includes('formula') || text.includes('equation') || text.includes('theorem')) {
      return 'mathematical';
    }
    
    // Check for procedure/function definitions
    if (text.includes('procedure') || text.includes('function') || text.includes('def ')) {
      return 'procedure';
    }
    
    // Check for code implementations
    if (text.includes('```') || text.includes('code') || text.includes('implementation')) {
      return 'implementation';
    }
    
    // Default to pseudocode
    return 'pseudocode';
  }

  /**
   * Enhanced algorithm confidence calculation with complexity analysis (DeepCode style)
   */
  private calculateAlgorithmConfidence(blockContent: string): number {
    const text = blockContent.toLowerCase();
    const words = text.split(/\s+/);
    
    // Enhanced algorithm keywords with weights
    const keywordWeights = {
      // Core algorithm indicators (high weight)
      'algorithm': 1.0, 'procedure': 1.0, 'method': 1.0, 'function': 1.0,
      
      // Structure indicators (medium-high weight)
      'input': 0.8, 'output': 0.8, 'return': 0.8, 'begin': 0.8, 'end': 0.8,
      
      // Control flow indicators (medium weight)  
      'for': 0.6, 'while': 0.6, 'if': 0.6, 'else': 0.6, 'loop': 0.6,
      
      // Mathematical indicators (high weight)
      'compute': 0.9, 'calculate': 0.9, 'sum': 0.7, 'maximum': 0.7, 'minimum': 0.7,
      
      // Complexity indicators (very high weight)
      'complexity': 1.2, 'optimization': 1.0, 'efficiency': 0.9
    };
    
    // Calculate weighted keyword score
    let keywordScore = 0;
    let keywordCount = 0;
    
    for (const word of words) {
      for (const [keyword, weight] of Object.entries(keywordWeights)) {
        if (word.includes(keyword)) {
          keywordScore += weight;
          keywordCount++;
          break; // Don't double-count words
        }
      }
    }
    
    // Mathematical notation bonus
    const mathNotationCount = (text.match(/[∀∃∈∉⊆⊇∪∩∑∏∫∂∇±×÷≤≥≠≈∞]/g) || []).length;
    const mathBonus = Math.min(mathNotationCount * 0.1, 0.3);
    
    // Formula detection bonus
    const formulaBonus = (text.includes('$$') || text.includes('\\begin{equation}')) ? 0.2 : 0;
    
    // Code block detection bonus  
    const codeBonus = text.includes('```') ? 0.15 : 0;
    
    // Structural completeness bonus
    const hasInputOutput = text.includes('input') && text.includes('output') ? 0.1 : 0;
    const hasControlFlow = /\b(for|while|if|loop)\b/.test(text) ? 0.1 : 0;
    const hasSteps = /\b(step|phase|\d+\.)\b/.test(text) ? 0.05 : 0;
    
    // Calculate final confidence
    const baseConfidence = keywordCount > 0 ? keywordScore / Math.max(words.length * 0.05, 1) : 0;
    const bonuses = mathBonus + formulaBonus + codeBonus + hasInputOutput + hasControlFlow + hasSteps;
    
    return Math.min(baseConfidence + bonuses, 1.0);
  }

  /**
   * Enhanced related description detection with relation typing (DeepCode style)
   */
  private findRelatedDescription(content: string, algorithmBoundary: { start: number; end: number }): AlgorithmBlock['relatedDescription'] | null {
    const searchRadius = 800; // Expanded search radius
    const beforeText = content.substring(Math.max(0, algorithmBoundary.start - searchRadius), algorithmBoundary.start).toLowerCase();
    const afterText = content.substring(algorithmBoundary.end, Math.min(content.length, algorithmBoundary.end + searchRadius)).toLowerCase();
    
    // Enhanced relation detection patterns
    const relationPatterns = {
      explanation: [
        'explains', 'describes', 'details', 'clarifies', 'elaborates', 'outlines',
        'this algorithm', 'the procedure', 'the method', 'works as follows', 'operates by'
      ],
      example: [
        'example', 'instance', 'demonstrates', 'illustrates', 'shows how', 
        'for example', 'consider the case', 'sample', 'typical usage'
      ],
      proof: [
        'proof', 'proves', 'verification', 'correctness', 'justification', 
        'theorem', 'lemma', 'invariant', 'mathematical proof'
      ],
      context: [
        'background', 'motivation', 'problem', 'application', 'used for',
        'solves', 'addresses', 'handles', 'context', 'scenario'
      ]
    };
    
    // Check before text for descriptions
    for (const [relationType, patterns] of Object.entries(relationPatterns)) {
      if (patterns.some(pattern => beforeText.includes(pattern))) {
        const startIndex = Math.max(0, algorithmBoundary.start - 400);
        const endIndex = algorithmBoundary.start;
        
        // Ensure we capture complete sentences
        const adjustedStart = this.findSentenceBoundary(content, startIndex, 'backward');
        
        return {
          startIndex: adjustedStart,
          endIndex,
          relationType: relationType as 'explanation | example' | 'proof | context'
        };
      }
    }
    
    // Check after text for descriptions  
    for (const [relationType, patterns] of Object.entries(relationPatterns)) {
      if (patterns.some(pattern => afterText.includes(pattern))) {
        const startIndex = algorithmBoundary.end;
        const endIndex = Math.min(content.length, algorithmBoundary.end + 400);
        
        // Ensure we capture complete sentences
        const adjustedEnd = this.findSentenceBoundary(content, endIndex, 'forward');
        
        return {
          startIndex,
          endIndex: adjustedEnd,
          relationType: relationType as 'explanation | example' | 'proof | context'
        };
      }
    }
    
    return null;
  }
  
  /**
   * Find sentence boundary for clean text extraction
   */
  private findSentenceBoundary(content: string, startPosition: number, direction: 'forward | backward'): number {
    const sentenceEnders = ['.', '!', '?', '\n\n'];
    
    if (direction === 'forward') {
      for (let i = startPosition; i < content.length; i++) {
        if (sentenceEnders.includes(content[i])) {
          return i + 1;
        }
      }
      return content.length;
    } else {
      for (let i = startPosition; i >= 0; i--) {
        if (sentenceEnders.includes(content[i])) {
          return i + 1;
        }
      }
      return 0;
    }
  }

  /**
   * Check if two algorithm blocks overlap
   */
  private blocksOverlap(block1: AlgorithmBlock, block2: AlgorithmBlock): boolean {
    return !(block1.endIndex <= block2.startIndex || block2.endIndex <= block1.startIndex);
  }

  /**
   * Merge overlapping algorithm blocks
   */
  private mergeOverlappingBlocks(blocks: AlgorithmBlock[]): AlgorithmBlock[] {
    if (blocks.length <= 1) return blocks;

    const sorted = blocks.sort((a, b) => a.startIndex - b.startIndex);
    const merged: AlgorithmBlock[] = [sorted[0]];

    for (let i = 1; i < sorted.length; i++) {
      const current = sorted[i];
      const last = merged[merged.length - 1];

      if (this.blocksOverlap(last, current)) {
        // Merge blocks
        last.endIndex = Math.max(last.endIndex, current.endIndex);
        last.confidence = Math.max(last.confidence, current.confidence);
      } else {
        merged.push(current);
      }
    }

    return merged;
  }

  /**
   * Apply segmentation strategy based on document classification
   */
  private async applySegmentationStrategy(
    content: string,
    strategy: DocumentClassification['recommendedStrategy'],
    algorithmBlocks: AlgorithmBlock[],
    config: SegmentationConfig
  ): Promise<DocumentSegment[]> {
    switch (strategy) {
      case 'semantic_research_focused':
        return this.segmentResearchFocused(content, algorithmBlocks, config);
      
      case 'algorithm_preserve_integrity':
        return this.segmentPreserveAlgorithms(content, algorithmBlocks, config);
      
      case 'concept_implementation_hybrid':
        return this.segmentConceptImplementation(content, algorithmBlocks, config);
      
      case 'strategic_vision_analysis':
        return this.segmentStrategicVision(content, config);
      
      default:
        return this.segmentConceptImplementation(content, algorithmBlocks, config);
    }
  }

  /**
   * Segment with research-focused approach
   */
  private segmentResearchFocused(
    content: string,
    algorithmBlocks: AlgorithmBlock[],
    config: SegmentationConfig
  ): DocumentSegment[] {
    const segments: DocumentSegment[] = [];
    const sectionHeaders = this.findSectionHeaders(content);
    
    // Segment by research sections while preserving algorithms
    let currentPosition = 0;
    
    for (const header of sectionHeaders) {
      if (header.index > currentPosition) {
        // Create segment up to header
        const segmentContent = content.substring(currentPosition, header.index);
        if (segmentContent.trim().length > config.minSegmentSize) {
          segments.push(this.createSegment(segmentContent, currentPosition, 'concept', algorithmBlocks));
        }
      }
      currentPosition = header.index;
    }
    
    // Handle remaining content
    if (currentPosition < content.length) {
      const remainingContent = content.substring(currentPosition);
      if (remainingContent.trim().length > config.minSegmentSize) {
        segments.push(this.createSegment(remainingContent, currentPosition, 'concept', algorithmBlocks));
      }
    }

    return segments;
  }

  /**
   * Segment while preserving algorithm integrity
   */
  private segmentPreserveAlgorithms(
    content: string,
    algorithmBlocks: AlgorithmBlock[],
    config: SegmentationConfig
  ): DocumentSegment[] {
    const segments: DocumentSegment[] = [];
    let currentPosition = 0;

    // Sort algorithm blocks by position
    const sortedBlocks = algorithmBlocks.sort((a, b) => a.startIndex - b.startIndex);

    for (const block of sortedBlocks) {
      // Create segment before algorithm block
      if (block.startIndex > currentPosition) {
        const preContent = content.substring(currentPosition, block.startIndex);
        if (preContent.trim().length > config.minSegmentSize) {
          segments.push(this.createSegment(preContent, currentPosition, 'context', algorithmBlocks));
        }
      }

      // Create algorithm segment (preserve integrity)
      const algorithmContent = content.substring(block.startIndex, block.endIndex);
      const algorithmSegment = this.createSegment(algorithmContent, block.startIndex, 'algorithm', algorithmBlocks);
      algorithmSegment.preserveIntegrity = true;
      algorithmSegment.importance = 0.9; // High importance
      segments.push(algorithmSegment);

      currentPosition = block.endIndex;
    }

    // Handle remaining content
    if (currentPosition < content.length) {
      const remainingContent = content.substring(currentPosition);
      if (remainingContent.trim().length > config.minSegmentSize) {
        segments.push(this.createSegment(remainingContent, currentPosition, 'context', algorithmBlocks));
      }
    }

    return segments;
  }

  /**
   * Segment with concept-implementation hybrid approach
   */
  private segmentConceptImplementation(
    content: string,
    algorithmBlocks: AlgorithmBlock[],
    config: SegmentationConfig
  ): DocumentSegment[] {
    const segments: DocumentSegment[] = [];
    
    // Use adaptive character limits
    const adaptiveLimit = this.calculateAdaptiveCharacterLimit(content, config);
    
    let currentPosition = 0;
    while (currentPosition < content.length) {
      const segmentEnd = Math.min(currentPosition + adaptiveLimit, content.length);
      
      // Find natural boundary near segment end
      const boundaryEnd = this.findNaturalBoundaryNear(content, segmentEnd, 200);
      
      const segmentContent = content.substring(currentPosition, boundaryEnd);
      const segmentType = this.determineSegmentType(segmentContent, algorithmBlocks, currentPosition);
      
      segments.push(this.createSegment(segmentContent, currentPosition, segmentType, algorithmBlocks));
      
      currentPosition = boundaryEnd;
    }

    return segments;
  }

  /**
   * Segment with strategic vision focus
   */
  private segmentStrategicVision(content: string, config: SegmentationConfig): DocumentSegment[] {
    const segments: DocumentSegment[] = [];
    const strategicSections = this.findStrategicSections(content);
    
    let currentPosition = 0;
    
    for (const section of strategicSections) {
      if (section.start > currentPosition) {
        // Non-strategic content
        const contextContent = content.substring(currentPosition, section.start);
        if (contextContent.trim().length > config.minSegmentSize) {
          segments.push(this.createSegment(contextContent, currentPosition, 'context', []));
        }
      }
      
      // Strategic content
      const strategicContent = content.substring(section.start, section.end);
      const strategicSegment = this.createSegment(strategicContent, section.start, 'concept', []);
      strategicSegment.importance = 0.95; // Very high importance for strategic content
      segments.push(strategicSegment);
      
      currentPosition = section.end;
    }
    
    // Handle remaining content
    if (currentPosition < content.length) {
      const remainingContent = content.substring(currentPosition);
      if (remainingContent.trim().length > config.minSegmentSize) {
        segments.push(this.createSegment(remainingContent, currentPosition, 'context', []));
      }
    }

    return segments;
  }

  /**
   * Create a document segment with metadata
   */
  private createSegment(
    content: string,
    startPosition: number,
    segmentType: DocumentSegment['segmentType'],
    algorithmBlocks: AlgorithmBlock[]
  ): DocumentSegment {
    const id = `segment_${startPosition}_${Date.now()}`;
    const endPosition = startPosition + content.length;
    
    // Check if this segment overlaps with algorithm blocks
    const hasAlgorithm = algorithmBlocks.some(block =>
      !(block.endIndex <= startPosition || block.startIndex >= endPosition)
    );

    return {
      id,
      content: content.trim(),
      startPosition,
      endPosition,
      segmentType: hasAlgorithm ? 'algorithm' : segmentType,
      importance: this.calculateSegmentImportance(content, segmentType),
      preserveIntegrity: hasAlgorithm || segmentType === 'algorithm',
      relatedSegments: [], // Will be populated by post-processing
      confidenceScore: this.calculateSegmentConfidence(content, segmentType),
      metadata: {
        keywords: this.extractKeywords(content),
        algorithmDensity: this.calculateLocalAlgorithmDensity(content),
        conceptComplexity: this.calculateLocalConceptComplexity(content),
        characterCount: content.length,
        lineCount: content.split('\n').length
      }
    };
  }

  // Helper methods for segment creation and analysis
  private findSectionHeaders(content: string): Array<{ index: number; level: number; text: string }> {
    const headers: Array<{ index: number; level: number; text: string }> = [];
    const headerPattern = /^(#{1,6})\s+(.+)$/gm;
    
    let match;
    while ((match = headerPattern.exec(content)) !== null) {
      headers.push({
        index: match.index,
        level: match[1].length,
        text: match[2].trim()
      });
    }
    
    return headers;
  }

  private findStrategicSections(content: string): Array<{ start: number; end: number; type: string }> {
    const strategicKeywords = ['vision', 'strategy', 'goal', 'objective', 'mission', 'roadmap'];
    const sections: Array<{ start: number; end: number; type: string }> = [];
    
    for (const keyword of strategicKeywords) {
      const regex = new RegExp(`\\b${keyword}\\b[\\s\\S]{0,500}`, 'gi');
      let match;
      
      while ((match = regex.exec(content)) !== null) {
        sections.push({
          start: match.index,
          end: match.index + match[0].length,
          type: keyword
        });
      }
    }
    
    return sections.sort((a, b) => a.start - b.start);
  }

  private calculateAdaptiveCharacterLimit(content: string, config: SegmentationConfig): number {
    if (!config.adaptiveCharacterLimits) {
      return config.maxSegmentSize;
    }
    
    const contentComplexity = this.calculateLocalConceptComplexity(content);
    const algorithmDensity = this.calculateLocalAlgorithmDensity(content);
    
    // Increase limit for complex content
    let adaptiveLimit = config.maxSegmentSize;
    
    if (contentComplexity > 0.5) {
      adaptiveLimit *= 1.3;
    }
    
    if (algorithmDensity > 0.4) {
      adaptiveLimit *= 1.5;
    }
    
    return Math.min(adaptiveLimit, config.maxSegmentSize * 2);
  }

  private findNaturalBoundaryNear(content: string, position: number, searchRadius: number): number {
    const searchStart = Math.max(0, position - searchRadius);
    const searchEnd = Math.min(content.length, position + searchRadius);
    
    // Look for paragraph breaks first
    for (let i = position; i < searchEnd; i++) {
      if (content.substring(i, i + 2) === '\n\n') {
        return i;
      }
    }
    
    // Look for sentence endings
    for (let i = position; i < searchEnd; i++) {
      if (['.', '!', '?'].includes(content[i]) && content[i + 1] === ' ') {
        return i + 1;
      }
    }
    
    // Fallback to original position
    return position;
  }

  private determineSegmentType(
    content: string,
    algorithmBlocks: AlgorithmBlock[],
    startPosition: number
  ): DocumentSegment['segmentType'] {
    // Check if segment overlaps with algorithm blocks
    const overlapsAlgorithm = algorithmBlocks.some(block =>
      !(block.endIndex <= startPosition || block.startIndex >= startPosition + content.length)
    );
    
    if (overlapsAlgorithm) {
      return 'algorithm';
    }
    
    // Analyze content for type determination
    const implementationKeywords = ['code', 'implementation', 'function', 'method', 'class'];
    const conceptKeywords = ['concept', 'theory', 'principle', 'approach', 'methodology'];
    
    const hasImplementation = implementationKeywords.some(keyword =>
      content.toLowerCase().includes(keyword)
    );
    
    const hasConcept = conceptKeywords.some(keyword =>
      content.toLowerCase().includes(keyword)
    );
    
    if (hasImplementation && hasConcept) {
      return 'implementation';
    } else if (hasImplementation) {
      return 'implementation';
    } else if (hasConcept) {
      return 'concept';
    }
    
    return 'context';
  }

  private calculateSegmentImportance(content: string, segmentType: DocumentSegment['segmentType']): number {
    const typeWeights = {
      algorithm: 0.9,
      concept: 0.8,
      implementation: 0.75,
      context: 0.6,
      metadata: 0.4
    };
    
    const baseImportance = typeWeights[segmentType];
    const algorithmDensity = this.calculateLocalAlgorithmDensity(content);
    const conceptComplexity = this.calculateLocalConceptComplexity(content);
    
    return Math.min(baseImportance + (algorithmDensity * 0.1) + (conceptComplexity * 0.1), 1.0);
  }

  private calculateSegmentConfidence(content: string, segmentType: DocumentSegment['segmentType']): number {
    // Simple confidence calculation based on content characteristics
    const wordCount = content.split(/\s+/).length;
    const sentenceCount = content.split(/[.!?]+/).length;
    
    let confidence = 0.7; // Base confidence
    
    // Adjust based on segment characteristics
    if (wordCount > 50 && wordCount < 500) {
      confidence += 0.1; // Good length
    }
    
    if (sentenceCount > 2) {
      confidence += 0.1; // Multiple sentences
    }
    
    if (segmentType === 'algorithm' && this.calculateLocalAlgorithmDensity(content) > 0.3) {
      confidence += 0.2; // High algorithm density matches type
    }
    
    return Math.min(confidence, 1.0);
  }

  private calculateLocalAlgorithmDensity(content: string): number {
    const algorithmKeywords = ['algorithm', 'procedure', 'method', 'function', 'compute', 'calculate'];
    const words = content.toLowerCase().split(/\s+/);
    const keywordCount = words.filter(word => 
      algorithmKeywords.some(keyword => word.includes(keyword))
    ).length;
    
    return Math.min(keywordCount / Math.max(words.length * 0.1, 1), 1.0);
  }

  private calculateLocalConceptComplexity(content: string): number {
    const complexityKeywords = ['complex', 'advanced', 'sophisticated', 'intricate', 'detailed'];
    const technicalKeywords = ['technical', 'specification', 'architecture', 'framework', 'system'];
    
    const words = content.toLowerCase().split(/\s+/);
    const complexityCount = words.filter(word =>
      complexityKeywords.some(keyword => word.includes(keyword))
    ).length;
    const technicalCount = words.filter(word =>
      technicalKeywords.some(keyword => word.includes(keyword))
    ).length;
    
    return Math.min((complexityCount + technicalCount) / Math.max(words.length * 0.05, 1), 1.0);
  }

  private extractKeywords(content: string): string[] {
    // Simple keyword extraction - in production, could use NLP libraries
    const words = content.toLowerCase()
      .replace(/[^\w\s]/g, '')
      .split(/\s+/)
      .filter(word => word.length > 3);
    
    // Count word frequency
    const wordCount = new Map<string, number>();
    for (const word of words) {
      wordCount.set(word, (wordCount.get(word) || 0) + 1);
    }
    
    // Return top keywords
    return Array.from(wordCount.entries())
      .sort((a, b) => b[1] - a[1])
      .slice(0, 10)
      .map(([word]) => word);
  }

  private calculateAverageSegmentSize(segments: DocumentSegment[]): number {
    if (segments.length === 0) return 0;
    const totalSize = segments.reduce((sum, segment) => sum + segment.content.length, 0);
    return totalSize / segments.length;
  }

  private countConceptClusters(segments: DocumentSegment[]): number {
    return segments.filter(segment => segment.segmentType === 'concept').length;
  }

  private calculateSegmentationQuality(segments: DocumentSegment[], originalContent: string): number {
    if (segments.length === 0) return 0;
    
    // Quality based on multiple factors
    const averageConfidence = segments.reduce((sum, seg) => sum + seg.confidenceScore, 0) / segments.length;
    const sizeVariation = this.calculateSizeVariation(segments);
    const preservationRatio = segments.filter(seg => seg.preserveIntegrity).length / segments.length;
    
    // Combine factors (weights can be adjusted)
    return (averageConfidence * 0.4) + ((1 - sizeVariation) * 0.3) + (preservationRatio * 0.3);
  }

  private calculateSizeVariation(segments: DocumentSegment[]): number {
    if (segments.length <= 1) return 0;
    
    const sizes = segments.map(seg => seg.content.length);
    const mean = sizes.reduce((sum, size) => sum + size, 0) / sizes.length;
    const variance = sizes.reduce((sum, size) => sum + Math.pow(size - mean, 2), 0) / sizes.length;
    const standardDeviation = Math.sqrt(variance);
    
    return Math.min(standardDeviation / mean, 1.0);
  }

  /**
   * Get segmentation engine configuration
   */
  public getConfig(): SegmentationConfig {
    return { ...this.config };
  }

  /**
   * Update segmentation engine configuration
   */
  public updateConfig(newConfig: Partial<SegmentationConfig>): void {
    this.config = { ...this.config, ...newConfig };
    logger.info('Segmentation engine configuration updated');
  }

  // ========================================================================
  // Enhanced Algorithm Analysis Methods (DeepCode Integration)
  // ========================================================================

  /**
   * Analyze algorithm complexity with multiple metrics
   */
  private analyzeComplexity(blockContent: string): AlgorithmBlock['complexity'] {
    const text = blockContent.toLowerCase();
    
    // Cyclomatic complexity (control flow analysis)
    const controlFlowKeywords = ['if', 'else', 'for', 'while', 'switch', 'case', 'try', 'catch'];
    const cyclomaticComplexity = controlFlowKeywords.reduce((count, keyword) => {
      const matches = text.match(new RegExp(`\\b${keyword}\\b`, 'g'));
      return count + (matches ? matches.length : 0);
    }, 1); // Base complexity is 1

    // Algorithmic complexity detection (Big O notation)
    let algorithmicComplexity = 'O(1)'; // Default
    if (text.includes('o(n²)') || text.includes('o(n^2)') || text.includes('nested loop')) {
      algorithmicComplexity = 'O(n²)';
    } else if (text.includes('o(n log n)') || text.includes('divide and conquer')) {
      algorithmicComplexity = 'O(n log n)';
    } else if (text.includes('o(n)') || text.includes('linear')) {
      algorithmicComplexity = 'O(n)';
    } else if (text.includes('o(log n)') || text.includes('logarithmic') || text.includes('binary search')) {
      algorithmicComplexity = 'O(log n)';
    } else if (text.includes('o(2^n)') || text.includes('exponential')) {
      algorithmicComplexity = 'O(2^n)';
    }

    // Mathematical complexity (formula density)
    const mathSymbols = (text.match(/[∀∃∈∉⊆⊇∪∩∑∏∫∂∇±×÷≤≥≠≈∞]/g) || []).length;
    const mathOperators = (text.match(/[\+\-\*\/\^\%]/g) || []).length;
    const mathFunctions = (text.match(/\b(sin|cos|tan|log|exp|sqrt|abs|max|min)\b/g) || []).length;
    const mathematicalComplexity = Math.min((mathSymbols + mathOperators + mathFunctions) / 10, 1.0);

    // Structural depth (nesting level estimation)
    const lines = blockContent.split('\n');
    let maxIndentation = 0;
    let currentIndentation = 0;
    
    for (const line of lines) {
      const leadingSpaces = line.match(/^ */)?.[0].length || 0;
      const indentLevel = Math.floor(leadingSpaces / 2);
      currentIndentation = indentLevel;
      maxIndentation = Math.max(maxIndentation, currentIndentation);
    }

    return {
      cyclomaticComplexity,
      algorithmicComplexity,
      mathematicalComplexity,
      structuralDepth: Math.min(maxIndentation, 10) // Cap at reasonable level
    };
  }

  /**
   * Analyze algorithm structural characteristics
   */
  private analyzeStructure(blockContent: string): AlgorithmBlock['structure'] {
    const text = blockContent.toLowerCase();

    return {
      hasInputOutput: /\b(input|output|parameter|return)\s*:/i.test(text),
      hasControlFlow: /\b(if|else|for|while|switch|case|loop)\b/.test(text),
      hasIterations: /\b(for|while|loop|iterate|repeat)\b/.test(text),
      hasRecursion: /\b(recursive|recursion|calls? itself|recurse)\b/.test(text),
      hasPreconditions: /\b(precondition|require|assume|given)\s*:/i.test(text),
      hasPostconditions: /\b(postcondition|ensure|guarantee|result)\s*:/i.test(text)
    };
  }

  /**
   * Extract algorithm elements for analysis
   */
  private extractAlgorithmElements(blockContent: string): AlgorithmBlock['extractedElements'] {
    const text = blockContent;

    // Extract variables (simple heuristic)
    const variableMatches = text.match(/\b[a-z][a-zA-Z0-9_]*\b/g) || [];
    const variables = [...new Set(variableMatches)].filter(v => v.length > 1).slice(0, 20);

    // Extract function names
    const functionMatches = text.match(/\b[a-zA-Z][a-zA-Z0-9_]*\s*\(/g) || [];
    const functions = [...new Set(functionMatches.map(f => f.replace(/\s*\($/, '')))].slice(0, 10);

    // Extract constants (numbers and UPPERCASE words)
    const constantMatches = text.match(/\b(\d+\.?\d*|[A-Z][A-Z_0-9]+)\b/g) || [];
    const constants = [...new Set(constantMatches)].slice(0, 10);

    // Extract operators
    const operatorMatches = text.match(/[+\-*/=<>!&|^%]+|∀|∃|∈|∉|⊆|⊇|∪|∩|∑|∏|∫/g) || [];
    const operators = [...new Set(operatorMatches)].slice(0, 15);

    // Extract keywords
    const algorithmKeywords = ['algorithm', 'procedure', 'function', 'method', 'input', 'output', 
                              'begin', 'end', 'if', 'then', 'else', 'for', 'while', 'do', 'return'];
    const keywords = algorithmKeywords.filter(keyword => 
      text.toLowerCase().includes(keyword)
    );

    return {
      variables: variables,
      functions: functions,
      constants: constants,
      operators: operators,
      keywords: keywords
    };
  }

  /**
   * Calculate algorithm quality score
   */
  private calculateAlgorithmQuality(blockContent: string): number {
    const text = blockContent.toLowerCase();
    let quality = 0.5; // Base quality

    // Completeness factors
    const hasInputOutput = /\b(input|output)\s*:/i.test(text) ? 0.15 : 0;
    const hasSteps = /\b(step|\d+\.)\s/.test(text) ? 0.1 : 0;
    const hasDescription = text.length > 200 ? 0.1 : 0;

    // Clarity factors
    const hasComments = text.includes('//') || text.includes('#') ? 0.05 : 0;
    const hasExamples = /\b(example|instance|case)\b/.test(text) ? 0.1 : 0;

    // Technical completeness
    const hasComplexity = /\b(complexity|time|space)\b/.test(text) ? 0.1 : 0;
    const hasProof = /\b(proof|correctness|verify)\b/.test(text) ? 0.05 : 0;

    // Readability (penalize if too terse or too verbose)
    const wordCount = text.split(/\s+/).length;
    const readabilityScore = wordCount > 50 && wordCount < 500 ? 0.05 : 0;

    quality += hasInputOutput + hasSteps + hasDescription + hasComments + 
               hasExamples + hasComplexity + hasProof + readabilityScore;

    return Math.min(quality, 1.0);
  }
}