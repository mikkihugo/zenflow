/**
 * @fileoverview ApprovalGateManager - Enterprise Approval Gate System with XState
 * 
 * Complete production-ready approval gate management with:
 * - XState-powered approval workflows
 * - Visual debugging and inspection
 * - Escalation and timeout handling
 * - Multi-level approval chains
 * - Audit trails and compliance
 * - Real-time notifications
 * - Performance tracking
 */

import { TypedEventBase } from '@claude-zen/foundation';
import { createActor, setup, assign, fromPromise, raise, sendTo } from 'xstate';
import { createInspector } from '@statelyai/inspect';
import { v4 as uuidv4 } from 'uuid';
import { produce } from 'immer';
import { addHours, isAfter } from 'date-fns';
import { getLogger } from '@claude-zen/foundation';
import { getDatabaseSystem, getEventSystem } from '@claude-zen/infrastructure';
import { getTelemetryManager } from '@claude-zen/operations';
import { LLMApprovalService } from '../services/llm-approval-service.js';
import { 
  LLMApprovalContext, 
  LLMApprovalResult, 
  EnhancedApprovalGate,
  HumanOverride 
} from '../types/llm-approval.js';

import type {
  ApprovalGateId,
  TaskId,
  UserId,
  TaskMetadata,
  ApprovalGateRequirement,
  ApprovalCondition,
  TaskMasterConfig,
  APIResponse,
  APIError,
  AuditLogEntry,
  TaskMasterEventMap,
  createApprovalGateId,
  createUserId
} from '../types/core/index.js';\n\n// =============================================================================\n// APPROVAL GATE TYPES\n// =============================================================================\n\n/**\n * Approval gate states for XState machine\n */\nexport enum ApprovalGateState {\n  PENDING = 'pending',\n  EVALUATING = 'evaluating', \n  APPROVED = 'approved',\n  REJECTED = 'rejected',\n  ESCALATED = 'escalated',\n  TIMED_OUT = 'timed_out',\n  CANCELLED = 'cancelled'\n}\n\n/**\n * Individual approval record\n */\nexport interface ApprovalRecord {\n  readonly id: string;\n  gateId: ApprovalGateId;\n  taskId: TaskId;\n  approverId: UserId;\n  decision: 'approved' | 'rejected' | 'pending';\n  reason?: string;\n  timestamp: Date;\n  metadata: Record<string, unknown>;\n}\n\n/**\n * Complete approval gate instance\n */\nexport interface ApprovalGateInstance {\n  readonly id: ApprovalGateId;\n  requirement: ApprovalGateRequirement;\n  taskId: TaskId;\n  state: ApprovalGateState;\n  approvals: ApprovalRecord[];\n  createdAt: Date;\n  updatedAt: Date;\n  timeoutAt?: Date;\n  escalatedAt?: Date;\n  completedAt?: Date;\n  metadata: Record<string, unknown>;\n}\n\n/**\n * Approval gate evaluation result\n */\nexport interface ApprovalEvaluationResult {\n  approved: boolean;\n  reason: string;\n  requiredApprovals: number;\n  receivedApprovals: number;\n  pendingApprovers: UserId[];\n  autoApprovalTriggered: boolean;\n  evaluationDetails: Record<string, unknown>;\n}\n\n/**\n * Escalation configuration\n */\nexport interface EscalationConfig {\n  enabled: boolean;\n  escalateAfterHours: number;\n  escalateTo: UserId[];\n  maxEscalationLevels: number;\n  notificationChannels: string[];\n}\n\n/**\n * Approval gate metrics\n */\nexport interface ApprovalGateMetrics {\n  totalGates: number;\n  pendingGates: number;\n  approvedGates: number;\n  rejectedGates: number;\n  escalatedGates: number;\n  timedOutGates: number;\n  averageApprovalTime: number;\n  averageEscalationTime: number;\n  autoApprovalRate: number;\n  rejectionRate: number;\n}\n\n// =============================================================================\n// APPROVAL GATE MANAGER - MAIN IMPLEMENTATION\n// =============================================================================\n\n/**\n * Enterprise ApprovalGateManager with complete XState integration\n * \n * @example\n * ```typescript\n * const manager = new ApprovalGateManager(config);\n * await manager.initialize();\n * \n * // Create approval gate\n * const gate = await manager.createApprovalGate({\n *   name: 'Production Deployment',\n *   requiredApprovers: [userId1, userId2],\n *   minimumApprovals: 2\n * }, taskId);\n * \n * // Request approval\n * await manager.requestApproval(gate.data!.id, approverId);\n * ```\n */\nexport class ApprovalGateManager {\n  private readonly logger = getLogger('ApprovalGateManager');\n  private readonly eventEmitter = new TypedEventBase<TaskMasterEventMap>();\n  \n  // Core components\n  private readonly config: TaskMasterConfig;\n  private database: any;\n  private redis: any;\n  private telemetryManager: any;\n  private xstateInspector?: any;\n  \n  // State management\n  private approvalGates = new Map<ApprovalGateId, ApprovalGateInstance>();\n  private gateStateMachines = new Map<ApprovalGateId, any>();\n  private escalationConfig: EscalationConfig;\n  \n  // Monitoring\n  private metrics: ApprovalGateMetrics;\n  private monitoringIntervals = new Map<string, NodeJS.Timeout>();\n  \n  constructor(config: TaskMasterConfig) {\n    this.config = config;\n    this.escalationConfig = this.initializeEscalationConfig();\n    this.metrics = this.initializeMetrics();\n    \n    this.logger.info('ApprovalGateManager initialized', {\n      escalationEnabled: this.escalationConfig.enabled\n    });\n  }\n  \n  // =============================================================================\n  // INITIALIZATION AND LIFECYCLE\n  // =============================================================================\n  \n  /**\n   * Initialize the ApprovalGateManager\n   */\n  async initialize(): Promise<void> {\n    try {\n      this.logger.info('Initializing ApprovalGateManager...');\n      \n      // Initialize infrastructure\n      await this.initializeInfrastructure();\n      \n      // Initialize XState visual debugging\n      if (process.env.NODE_ENV === 'development') {\n        this.initializeXStateInspector();\n      }\n      \n      // Load existing approval gates\n      await this.loadExistingGates();\n      \n      // Start monitoring\n      this.startMonitoring();\n      \n      this.logger.info('ApprovalGateManager initialization complete');\n      \n    } catch (error) {\n      this.logger.error('Failed to initialize ApprovalGateManager', error);\n      throw error;\n    }\n  }\n  \n  /**\n   * Shutdown the ApprovalGateManager\n   */\n  async shutdown(): Promise<void> {\n    try {\n      this.logger.info('Shutting down ApprovalGateManager...');\n      \n      // Stop monitoring\n      this.stopMonitoring();\n      \n      // Stop all state machines\n      for (const [gateId, actor] of this.gateStateMachines) {\n        actor.stop();\n        this.logger.debug(`Stopped state machine for gate ${gateId}`);\n      }\n      \n      // Persist current state\n      await this.persistState();\n      \n      this.logger.info('ApprovalGateManager shutdown complete');\n      \n    } catch (error) {\n      this.logger.error('Error during ApprovalGateManager shutdown', error);\n      throw error;\n    }\n  }\n  \n  // =============================================================================\n  // CORE APPROVAL GATE OPERATIONS\n  // =============================================================================\n  \n  /**\n   * Create a new approval gate instance\n   */\n  async createApprovalGate(\n    requirement: ApprovalGateRequirement,\n    taskId: TaskId\n  ): Promise<APIResponse<ApprovalGateInstance>> {\n    \n    const startTime = Date.now();\n    const requestId = uuidv4();\n    \n    try {\n      // Validate requirement\n      this.validateApprovalRequirement(requirement);\n      \n      // Create gate instance\n      const gateInstance: ApprovalGateInstance = {\n        id: requirement.id,\n        requirement,\n        taskId,\n        state: ApprovalGateState.PENDING,\n        approvals: [],\n        createdAt: new Date(),\n        updatedAt: new Date(),\n        timeoutAt: requirement.timeoutHours \n          ? addHours(new Date(), requirement.timeoutHours)\n          : undefined,\n        metadata: {}\n      };\n      \n      // Create and start state machine\n      const stateMachine = this.createApprovalGateStateMachine(gateInstance);\n      const actor = createActor(stateMachine, {\n        inspect: this.xstateInspector?.inspect\n      });\n      \n      // Store gate and state machine\n      this.approvalGates.set(requirement.id, gateInstance);\n      this.gateStateMachines.set(requirement.id, actor);\n      \n      // Start state machine\n      actor.start();\n      \n      // Persist to database\n      await this.persistApprovalGate(gateInstance);\n      \n      // Set up timeout handling\n      if (gateInstance.timeoutAt) {\n        this.scheduleTimeout(gateInstance);\n      }\n      \n      // Emit event\n      this.eventEmitter.emit('approval:requested', requirement.id, taskId);\n      \n      // Update metrics\n      this.updateMetrics();\n      \n      const processingTime = Date.now() - startTime;\n      \n      return {\n        success: true,\n        data: gateInstance,\n        metadata: {\n          timestamp: new Date(),\n          requestId,\n          version: '2.0.0',\n          processingTimeMs: processingTime\n        }\n      };\n      \n    } catch (error) {\n      this.logger.error('Failed to create approval gate', error, { requestId });\n      \n      const apiError: APIError = {\n        code: 'APPROVAL_GATE_CREATION_FAILED',\n        message: 'Failed to create approval gate',\n        details: error instanceof Error ? error.message : 'Unknown error',\n        correlationId: requestId,\n        metadata: { requestId }\n      };\n      \n      return {\n        success: false,\n        error: apiError,\n        metadata: {\n          timestamp: new Date(),\n          requestId,\n          version: '2.0.0',\n          processingTimeMs: Date.now() - startTime\n        }\n      };\n    }\n  }\n  \n  /**\n   * Process an approval decision\n   */\n  async processApproval(\n    gateId: ApprovalGateId,\n    approverId: UserId,\n    decision: 'approved' | 'rejected',\n    reason?: string\n  ): Promise<APIResponse<ApprovalRecord>> {\n    \n    const startTime = Date.now();\n    const requestId = uuidv4();\n    \n    try {\n      // Get gate instance\n      const gate = this.approvalGates.get(gateId);\n      if (!gate) {\n        throw new Error(`Approval gate ${gateId} not found`);\n      }\n      \n      // Validate approver\n      if (!gate.requirement.requiredApprovers.includes(approverId)) {\n        throw new Error(`User ${approverId} is not authorized to approve this gate`);\n      }\n      \n      // Check if already approved by this user\n      const existingApproval = gate.approvals.find(a => a.approverId === approverId);\n      if (existingApproval) {\n        throw new Error(`User ${approverId} has already provided approval for this gate`);\n      }\n      \n      // Create approval record\n      const approvalRecord: ApprovalRecord = {\n        id: uuidv4(),\n        gateId,\n        taskId: gate.taskId,\n        approverId,\n        decision,\n        reason,\n        timestamp: new Date(),\n        metadata: {}\n      };\n      \n      // Update gate instance\n      const updatedGate = produce(gate, (draft) => {\n        draft.approvals.push(approvalRecord);\n        draft.updatedAt = new Date();\n      });\n      \n      this.approvalGates.set(gateId, updatedGate);\n      \n      // Send event to state machine\n      const actor = this.gateStateMachines.get(gateId);\n      if (actor) {\n        actor.send({\n          type: decision === 'approved' ? 'APPROVE' : 'REJECT',\n          approver: approverId,\n          reason,\n          approval: approvalRecord\n        });\n      }\n      \n      // Persist changes\n      await this.persistApprovalGate(updatedGate);\n      await this.persistApprovalRecord(approvalRecord);\n      \n      // Evaluate if gate is complete\n      const evaluation = await this.evaluateApprovalGate(updatedGate);\n      \n      if (evaluation.approved) {\n        // Gate is approved\n        await this.completeApprovalGate(gateId, 'approved');\n        this.eventEmitter.emit('approval:granted', gateId, gate.taskId, approverId);\n      } else if (decision === 'rejected' && this.shouldRejectOnSingleRejection(updatedGate)) {\n        // Gate is rejected\n        await this.completeApprovalGate(gateId, 'rejected');\n        this.eventEmitter.emit('approval:rejected', gateId, gate.taskId, approverId, reason||'No reason provided');\n      }\n      \n      // Update metrics\n      this.updateMetrics();\n      \n      // Track telemetry\n      if (this.telemetryManager) {\n        this.telemetryManager.trackEvent('approval_processed', {\n          gateId,\n          decision,\n          approverId\n        });\n      }\n      \n      const processingTime = Date.now() - startTime;\n      \n      return {\n        success: true,\n        data: approvalRecord,\n        metadata: {\n          timestamp: new Date(),\n          requestId,\n          version: '2.0.0',\n          processingTimeMs: processingTime\n        }\n      };\n      \n    } catch (error) {\n      this.logger.error('Failed to process approval', error, { gateId, approverId, decision, requestId });\n      \n      const apiError: APIError = {\n        code: 'APPROVAL_PROCESSING_FAILED',\n        message: 'Failed to process approval',\n        details: error instanceof Error ? error.message : 'Unknown error',\n        correlationId: requestId,\n        metadata: { gateId, approverId, decision, requestId }\n      };\n      \n      return {\n        success: false,\n        error: apiError,\n        metadata: {\n          timestamp: new Date(),\n          requestId,\n          version: '2.0.0',\n          processingTimeMs: Date.now() - startTime\n        }\n      };\n    }\n  }\n  \n  /**\n   * Evaluate if approval gate conditions are met\n   */\n  async evaluateApprovalGate(gate: ApprovalGateInstance): Promise<ApprovalEvaluationResult> {\n    const approvedCount = gate.approvals.filter(a => a.decision === 'approved').length;\n    const rejectedCount = gate.approvals.filter(a => a.decision === 'rejected').length;\n    const pendingApprovers = gate.requirement.requiredApprovers.filter(\n      approverId => !gate.approvals.some(a => a.approverId === approverId)\n    );\n    \n    // Check auto-approval conditions\n    let autoApprovalTriggered = false;\n    if (gate.requirement.autoApprovalConditions) {\n      autoApprovalTriggered = await this.evaluateAutoApprovalConditions(\n        gate.requirement.autoApprovalConditions,\n        gate\n      );\n    }\n    \n    const approved = autoApprovalTriggered||\n      (approvedCount >= gate.requirement.minimumApprovals && rejectedCount === 0);\n    \n    return {\n      approved,\n      reason: approved \n        ? autoApprovalTriggered \n          ?'Auto-approval conditions met'\n          : `Required approvals received (${approvedCount}/${gate.requirement.minimumApprovals})`\n        : `Pending approvals (${approvedCount}/${gate.requirement.minimumApprovals})`,\n      requiredApprovals: gate.requirement.minimumApprovals,\n      receivedApprovals: approvedCount,\n      pendingApprovers,\n      autoApprovalTriggered,\n      evaluationDetails: {\n        approvedCount,\n        rejectedCount,\n        totalApprovers: gate.requirement.requiredApprovers.length,\n        evaluatedAt: new Date()\n      }\n    };\n  }\n  \n  // =============================================================================\n  // XSTATE MACHINE IMPLEMENTATION\n  // =============================================================================\n  \n  private createApprovalGateStateMachine(gateInstance: ApprovalGateInstance) {\n    return setup({\n      types: {\n        context: {} as {\n          gate: ApprovalGateInstance;\n          evaluationResult?: ApprovalEvaluationResult;\n          escalationLevel: number;\n        },\n        events: {} as\n|{ type:'APPROVE'; approver: UserId; reason?: string; approval: ApprovalRecord }\n|{ type:'REJECT'; approver: UserId; reason?: string; approval: ApprovalRecord }\n|{ type:'TIMEOUT'}\n|{ type:'ESCALATE'; level: number }\n|{ type:'CANCEL'; reason: string }\n|{ type:'EVALUATE' }\n      },\n      actors: {\n        evaluateGate: fromPromise(async ({ input }: { input: { gate: ApprovalGateInstance } }) => {\n          return await this.evaluateApprovalGate(input.gate);\n        }),\n        escalateGate: fromPromise(async ({ input }: { input: { gate: ApprovalGateInstance; level: number } }) => {\n          return await this.escalateApprovalGate(input.gate, input.level);\n        }),\n        notifyApprovers: fromPromise(async ({ input }: { input: { gate: ApprovalGateInstance } }) => {\n          return await this.notifyApprovers(input.gate);\n        })\n      },\n      actions: {\n        updateGateState: assign({\n          gate: ({ context, event }) => {\n            if (event.type === 'APPROVE'||event.type ==='REJECT') {\n              return produce(context.gate, (draft) => {\n                // Approval record already added in processApproval\n                draft.updatedAt = new Date();\n              });\n            }\n            return context.gate;\n          }\n        }),\n        setEvaluationResult: assign({\n          evaluationResult: ({ event }) => {\n            if (event.type === 'xstate.done.actor.evaluateGate') {\n              return event.output;\n            }\n            return undefined;\n          }\n        }),\n        incrementEscalationLevel: assign({\n          escalationLevel: ({ context }) => context.escalationLevel + 1\n        }),\n        logStateChange: ({ context, event }) => {\n          this.logger.info('Approval gate state change', {\n            gateId: context.gate.id,\n            taskId: context.gate.taskId,\n            event: event.type,\n            escalationLevel: context.escalationLevel\n          });\n        },\n        notifyTimeout: ({ context }) => {\n          this.eventEmitter.emit('approval:timeout', context.gate.id, context.gate.taskId);\n        },\n        completeGate: ({ context, event }) => {\n          const finalState = event.type === 'APPROVE' ? 'approved' : 'rejected';\n          this.completeApprovalGate(context.gate.id, finalState);\n        }\n      },\n      guards: {\n        isApproved: ({ context }) => {\n          return context.evaluationResult?.approved === true;\n        },\n        shouldEscalate: ({ context }) => {\n          return this.escalationConfig.enabled && \n                 context.escalationLevel < this.escalationConfig.maxEscalationLevels;\n        },\n        hasTimeout: ({ context }) => {\n          return context.gate.timeoutAt !== undefined;\n        },\n        isTimedOut: ({ context }) => {\n          return context.gate.timeoutAt ? isAfter(new Date(), context.gate.timeoutAt) : false;\n        }\n      },\n      delays: {\n        timeoutDelay: ({ context }) => {\n          if (!context.gate.timeoutAt) return 999999999; // Very large number if no timeout\n          return Math.max(0, context.gate.timeoutAt.getTime() - Date.now())();\n        },\n        escalationDelay: () => this.escalationConfig.escalateAfterHours * 60 * 60 * 1000\n      }\n    }).createMachine({\n      id: `approval-gate-${gateInstance.id}`,\n      initial: 'pending',\n      context: {\n        gate: gateInstance,\n        escalationLevel: 0\n      },\n      states: {\n        pending: {\n          entry: ['logStateChange'],\n          invoke: {\n            src: 'notifyApprovers',\n            input: ({ context }) => ({ gate: context.gate })\n          },\n          after: {\n            escalationDelay: {\n              target: 'escalating',\n              guard: 'shouldEscalate'\n            },\n            timeoutDelay: {\n              target: 'timed_out',\n              guard: 'hasTimeout'\n            }\n          },\n          on: {\n            APPROVE: {\n              target: 'evaluating',\n              actions: ['updateGateState', 'logStateChange']\n            },\n            REJECT: {\n              target: 'evaluating',\n              actions: ['updateGateState', 'logStateChange']\n            },\n            TIMEOUT: {\n              target: 'timed_out',\n              actions: ['logStateChange', 'notifyTimeout']\n            },\n            CANCEL: {\n              target: 'cancelled',\n              actions: ['logStateChange']\n            }\n          }\n        },\n        \n        evaluating: {\n          entry: ['logStateChange'],\n          invoke: {\n            src: 'evaluateGate',\n            input: ({ context }) => ({ gate: context.gate }),\n            onDone: {\n              actions: ['setEvaluationResult'],\n              target: 'checking_result'\n            },\n            onError: {\n              target: 'pending',\n              actions: ['logStateChange']\n            }\n          }\n        },\n        \n        checking_result: {\n          always: [\n            {\n              target: 'approved',\n              guard: 'isApproved',\n              actions: ['logStateChange', 'completeGate']\n            },\n            {\n              target: 'rejected',\n              guard: ({ context, event }) => {\n                // Check if rejection criteria is met\n                const gate = context.gate;\n                const rejections = gate.approvals.filter(a => a.decision === 'rejected');\n                return rejections.length > 0 && this.shouldRejectOnSingleRejection(gate);\n              },\n              actions: ['logStateChange', 'completeGate']\n            },\n            {\n              target: 'pending',\n              actions: ['logStateChange']\n            }\n          ]\n        },\n        \n        escalating: {\n          entry: ['logStateChange', 'incrementEscalationLevel'],\n          invoke: {\n            src: 'escalateGate',\n            input: ({ context }) => ({ gate: context.gate, level: context.escalationLevel }),\n            onDone: {\n              target: 'escalated',\n              actions: ['logStateChange']\n            },\n            onError: {\n              target: 'pending',\n              actions: ['logStateChange']\n            }\n          }\n        },\n        \n        escalated: {\n          entry: ['logStateChange'],\n          after: {\n            escalationDelay: {\n              target: 'escalating',\n              guard: 'shouldEscalate'\n            },\n            timeoutDelay: {\n              target: 'timed_out',\n              guard: 'hasTimeout'\n            }\n          },\n          on: {\n            APPROVE: {\n              target: 'evaluating',\n              actions: ['updateGateState', 'logStateChange']\n            },\n            REJECT: {\n              target: 'evaluating', \n              actions: ['updateGateState', 'logStateChange']\n            },\n            TIMEOUT: {\n              target: 'timed_out',\n              actions: ['logStateChange', 'notifyTimeout']\n            },\n            CANCEL: {\n              target: 'cancelled',\n              actions: ['logStateChange']\n            }\n          }\n        },\n        \n        approved: {\n          type: 'final',\n          entry: ['logStateChange']\n        },\n        \n        rejected: {\n          type: 'final',\n          entry: ['logStateChange']\n        },\n        \n        timed_out: {\n          type: 'final',\n          entry: ['logStateChange', 'notifyTimeout']\n        },\n        \n        cancelled: {\n          type: 'final',\n          entry: ['logStateChange']\n        }\n      }\n    });\n  }\n  \n  // =============================================================================\n  // PRIVATE IMPLEMENTATION METHODS\n  // =============================================================================\n  \n  private async initializeInfrastructure(): Promise<void> {\n    // Initialize database\n    const dbSystem = await getDatabaseSystem();\n    this.database = dbSystem.createProvider('postgresql');\n    \n    // Initialize Redis if enabled\n    if (this.config.integrations.redis.enabled) {\n      const eventSystem = await getEventSystem();\n      this.redis = eventSystem.createRedisClient(this.config.integrations.redis);\n    }\n    \n    // Initialize telemetry\n    this.telemetryManager = await getTelemetryManager();\n  }\n  \n  private initializeXStateInspector(): void {\n    try {\n      this.xstateInspector = createInspector({\n        url: 'https://stately.ai/viz?inspect',\n        iframe: false\n      });\n      \n      this.logger.info('XState visual debugging enabled for approval gates');\n    } catch (error) {\n      this.logger.warn('Failed to initialize XState inspector for approval gates', error);\n    }\n  }\n  \n  private startMonitoring(): void {\n    // Monitor for timeouts\n    this.monitoringIntervals.set('timeoutCheck',\n      setInterval(() => this.checkTimeouts(), 60000) // Every minute\n    );\n    \n    // Update metrics\n    this.monitoringIntervals.set('metricsUpdate',\n      setInterval(() => this.updateMetrics(), 300000) // Every 5 minutes\n    );\n    \n    this.logger.info('Approval gate monitoring started');\n  }\n  \n  private stopMonitoring(): void {\n    for (const [name, interval] of this.monitoringIntervals) {\n      clearInterval(interval);\n    }\n    this.monitoringIntervals.clear();\n  }\n  \n  private async loadExistingGates(): Promise<void> {\n    // Load from database and recreate state machines\n    // Implementation would depend on database schema\n  }\n  \n  private async persistState(): Promise<void> {\n    // Persist all approval gates to database\n    for (const gate of this.approvalGates.values()) {\n      await this.persistApprovalGate(gate);\n    }\n  }\n  \n  private validateApprovalRequirement(requirement: ApprovalGateRequirement): void {\n    if (!requirement.name||requirement.name.trim().length === 0) {\n      throw new Error('Approval gate name is required');\n    }\n    \n    if (!requirement.requiredApprovers||requirement.requiredApprovers.length === 0) {\n      throw new Error('At least one required approver must be specified');\n    }\n    \n    if (requirement.minimumApprovals < 1) {\n      throw new Error('Minimum approvals must be at least 1');\n    }\n    \n    if (requirement.minimumApprovals > requirement.requiredApprovers.length) {\n      throw new Error('Minimum approvals cannot exceed number of required approvers');\n    }\n  }\n  \n  private async evaluateAutoApprovalConditions(\n    conditions: ApprovalCondition[],\n    gate: ApprovalGateInstance\n  ): Promise<boolean> {\n    for (const condition of conditions) {\n      const result = await this.evaluateCondition(condition, gate);\n      if (result) {\n        return true; // Any condition can trigger auto-approval\n      }\n    }\n    return false;\n  }\n  \n  private async evaluateCondition(\n    condition: ApprovalCondition,\n    gate: ApprovalGateInstance\n  ): Promise<boolean> {\n    switch (condition.type) {\n      case 'user_role':\n        // Implement user role-based auto-approval\n        return false;\n      \n      case 'task_complexity':\n        // Implement task complexity-based auto-approval\n        return false;\n      \n      case 'time_based':\n        // Implement time-based auto-approval\n        return false;\n      \n      case 'custom':\n        // Implement custom evaluator\n        if (condition.evaluator) {\n          // Execute custom JavaScript evaluator safely\n          // Would need proper sandboxing in production\n          return false;\n        }\n        return false;\n      \n      default:\n        return false;\n    }\n  }\n  \n  private shouldRejectOnSingleRejection(gate: ApprovalGateInstance): boolean {\n    // Business logic for when a single rejection should reject the entire gate\n    // This could be configurable per gate type\n    return true; // Default: single rejection rejects the gate\n  }\n  \n  private async completeApprovalGate(\n    gateId: ApprovalGateId,\n    finalState: 'approved|rejected|timed_out'\n  ): Promise<void> {\n    const gate = this.approvalGates.get(gateId);\n    if (!gate) return;\n    \n    const updatedGate = produce(gate, (draft) => {\n      draft.state = finalState === 'approved' \n        ? ApprovalGateState.APPROVED\n        : finalState === 'rejected'\n          ? ApprovalGateState.REJECTED\n          : ApprovalGateState.TIMED_OUT;\n      draft.completedAt = new Date();\n      draft.updatedAt = new Date();\n    });\n    \n    this.approvalGates.set(gateId, updatedGate);\n    await this.persistApprovalGate(updatedGate);\n    \n    // Stop state machine\n    const actor = this.gateStateMachines.get(gateId);\n    if (actor) {\n      actor.stop();\n      this.gateStateMachines.delete(gateId);\n    }\n  }\n  \n  private async escalateApprovalGate(\n    gate: ApprovalGateInstance,\n    level: number\n  ): Promise<void> {\n    // Implement escalation logic\n    this.logger.info(`Escalating approval gate ${gate.id} to level ${level}`);\n    \n    // Notify escalation recipients\n    // Send to additional approvers\n    // Update gate with escalation timestamp\n    \n    const updatedGate = produce(gate, (draft) => {\n      draft.escalatedAt = new Date();\n      draft.updatedAt = new Date();\n      draft.metadata.escalationLevel = level;\n    });\n    \n    this.approvalGates.set(gate.id, updatedGate);\n    await this.persistApprovalGate(updatedGate);\n  }\n  \n  private async notifyApprovers(gate: ApprovalGateInstance): Promise<void> {\n    // Implement notification logic\n    this.logger.info(`Notifying approvers for gate ${gate.id}`, {\n      approvers: gate.requirement.requiredApprovers\n    });\n    \n    // Send notifications via configured channels\n    // Email, Slack, Teams, etc.\n  }\n  \n  private scheduleTimeout(gate: ApprovalGateInstance): void {\n    if (!gate.timeoutAt) return;\n    \n    const timeoutMs = gate.timeoutAt.getTime() - Date.now();\n    if (timeoutMs > 0) {\n      setTimeout(() => {\n        const actor = this.gateStateMachines.get(gate.id);\n        if (actor) {\n          actor.send({ type: 'TIMEOUT' });\n        }\n      }, timeoutMs);\n    }\n  }\n  \n  private checkTimeouts(): void {\n    const now = new Date();\n    for (const gate of this.approvalGates.values()) {\n      if (gate.timeoutAt && isAfter(now, gate.timeoutAt) && \n          gate.state === ApprovalGateState.PENDING) {\n        const actor = this.gateStateMachines.get(gate.id);\n        if (actor) {\n          actor.send({ type: 'TIMEOUT'});\n        }\n      }\n    }\n  }\n  \n  private updateMetrics(): void {\n    const gates = Array.from(this.approvalGates.values())();\n    \n    this.metrics = {\n      totalGates: gates.length,\n      pendingGates: gates.filter(g => g.state === ApprovalGateState.PENDING).length,\n      approvedGates: gates.filter(g => g.state === ApprovalGateState.APPROVED).length,\n      rejectedGates: gates.filter(g => g.state === ApprovalGateState.REJECTED).length,\n      escalatedGates: gates.filter(g => g.state === ApprovalGateState.ESCALATED).length,\n      timedOutGates: gates.filter(g => g.state === ApprovalGateState.TIMED_OUT).length,\n      averageApprovalTime: this.calculateAverageApprovalTime(gates),\n      averageEscalationTime: this.calculateAverageEscalationTime(gates),\n      autoApprovalRate: this.calculateAutoApprovalRate(gates),\n      rejectionRate: this.calculateRejectionRate(gates)\n    };\n  }\n  \n  private calculateAverageApprovalTime(gates: ApprovalGateInstance[]): number {\n    const completedGates = gates.filter(g => \n      g.completedAt && (g.state === ApprovalGateState.APPROVED||g.state === ApprovalGateState.REJECTED)\n    );\n    \n    if (completedGates.length === 0) return 0;\n    \n    const totalTime = completedGates.reduce((sum, gate) => {\n      return sum + (gate.completedAt!.getTime() - gate.createdAt.getTime())();\n    }, 0);\n    \n    return totalTime / completedGates.length / (1000 * 60 * 60); // Convert to hours\n  }\n  \n  private calculateAverageEscalationTime(gates: ApprovalGateInstance[]): number {\n    const escalatedGates = gates.filter(g => g.escalatedAt);\n    \n    if (escalatedGates.length === 0) return 0;\n    \n    const totalTime = escalatedGates.reduce((sum, gate) => {\n      return sum + (gate.escalatedAt!.getTime() - gate.createdAt.getTime())();\n    }, 0);\n    \n    return totalTime / escalatedGates.length / (1000 * 60 * 60); // Convert to hours\n  }\n  \n  private calculateAutoApprovalRate(gates: ApprovalGateInstance[]): number {\n    const completedGates = gates.filter(g => g.state === ApprovalGateState.APPROVED);\n    if (completedGates.length === 0) return 0;\n    \n    const autoApprovedGates = completedGates.filter(g => \n      g.metadata.autoApprovalTriggered === true\n    );\n    \n    return autoApprovedGates.length / completedGates.length;\n  }\n  \n  private calculateRejectionRate(gates: ApprovalGateInstance[]): number {\n    const totalGates = gates.length;\n    if (totalGates === 0) return 0;\n    \n    const rejectedGates = gates.filter(g => g.state === ApprovalGateState.REJECTED);\n    return rejectedGates.length / totalGates;\n  }\n  \n  private initializeEscalationConfig(): EscalationConfig {\n    return {\n      enabled: true,\n      escalateAfterHours: 24,\n      escalateTo: [],\n      maxEscalationLevels: 3,\n      notificationChannels: ['email', 'slack']\n    };\n  }\n  \n  private initializeMetrics(): ApprovalGateMetrics {\n    return {\n      totalGates: 0,\n      pendingGates: 0,\n      approvedGates: 0,\n      rejectedGates: 0,\n      escalatedGates: 0,\n      timedOutGates: 0,\n      averageApprovalTime: 0,\n      averageEscalationTime: 0,\n      autoApprovalRate: 0,\n      rejectionRate: 0\n    };\n  }\n  \n  private async persistApprovalGate(gate: ApprovalGateInstance): Promise<void> {\n    // Persist to database\n    if (this.database) {\n      await this.database('approval_gates')\n        .insert({\n          id: gate.id,\n          requirement: JSON.stringify(gate.requirement),\n          task_id: gate.taskId,\n          state: gate.state,\n          created_at: gate.createdAt,\n          updated_at: gate.updatedAt,\n          timeout_at: gate.timeoutAt,\n          escalated_at: gate.escalatedAt,\n          completed_at: gate.completedAt,\n          metadata: JSON.stringify(gate.metadata)\n        })\n        .onConflict('id')\n        .merge();\n    }\n  }\n  \n  private async persistApprovalRecord(record: ApprovalRecord): Promise<void> {\n    // Persist to database\n    if (this.database) {\n      await this.database('approval_records')\n        .insert({\n          id: record.id,\n          gate_id: record.gateId,\n          task_id: record.taskId,\n          approver_id: record.approverId,\n          decision: record.decision,\n          reason: record.reason,\n          timestamp: record.timestamp,\n          metadata: JSON.stringify(record.metadata)\n        });\n    }\n  }\n  \n  // =============================================================================\n  // PUBLIC API METHODS\n  // =============================================================================\n  \n  /**\n   * Get approval gate metrics\n   */\n  getMetrics(): ApprovalGateMetrics {\n    return { ...this.metrics };\n  }\n  \n  /**\n   * Get approval gate by ID\n   */\n  getApprovalGate(gateId: ApprovalGateId): ApprovalGateInstance|undefined {\n    return this.approvalGates.get(gateId);\n  }\n  \n  /**\n   * Get all approval gates for a task\n   */\n  getApprovalGatesForTask(taskId: TaskId): ApprovalGateInstance[] {\n    return Array.from(this.approvalGates.values())\n      .filter(gate => gate.taskId === taskId);\n  }\n  \n  /**\n   * Cancel an approval gate\n   */\n  async cancelApprovalGate(\n    gateId: ApprovalGateId,\n    reason: string\n  ): Promise<APIResponse<void>> {\n    const startTime = Date.now();\n    const requestId = uuidv4();\n    \n    try {\n      const actor = this.gateStateMachines.get(gateId);\n      if (actor) {\n        actor.send({ type:'CANCEL', reason });\n      }\n      \n      return {\n        success: true,\n        metadata: {\n          timestamp: new Date(),\n          requestId,\n          version: '2.0.0',\n          processingTimeMs: Date.now() - startTime\n        }\n      };\n      \n    } catch (error) {\n      const apiError: APIError = {\n        code: 'APPROVAL_GATE_CANCELLATION_FAILED',\n        message: 'Failed to cancel approval gate',\n        details: error instanceof Error ? error.message : 'Unknown error',\n        correlationId: requestId,\n        metadata: { gateId, requestId }\n      };\n      \n      return {\n        success: false,\n        error: apiError,\n        metadata: {\n          timestamp: new Date(),\n          requestId,\n          version: '2.0.0',\n          processingTimeMs: Date.now() - startTime\n        }\n      };\n    }\n  }\n}'