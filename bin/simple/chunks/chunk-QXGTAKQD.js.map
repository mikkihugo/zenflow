{
  "version": 3,
  "sources": ["../../src/database/dao/relational.dao.ts"],
  "sourcesContent": ["/**\n * Relational Database DAO Implementation.\n *\n * @file Comprehensive relational database DAO implementation supporting PostgreSQL,\n * MySQL, SQLite and other SQL-based databases. Provides standardized CRUD operations,\n * advanced query building, transaction management, and database-specific optimizations.\n *\n * Features:\n * - Automatic data type conversion and mapping\n * - SQL injection prevention with parameterized queries\n * - Advanced query operations (JOINs, aggregations, batch operations)\n * - Date range queries and full-text search\n * - Batch insert/update/delete operations.\n * - Schema-aware field type detection.\n * @author Claude-Zen DAL Team\n * @version 2.0.0\n * @since 1.0.0\n * @example Basic Relational DAO Usage\n * ```typescript\n * import { RelationalDao } from './dao/relational.dao';\n *\n * interface User {\n *   id: string;\n *   name: string;\n *   email: string;\n *   profile: { age: number; location: string };\n *   createdAt: Date;\n *   active: boolean;\n * }\n *\n * const userDao = new RelationalDao<User>(\n *   pgAdapter,\n *   logger,\n *   'users',\n *   {\n *     id: { type: 'uuid', primaryKey: true },\n *     name: { type: 'string', required: true },\n *     email: { type: 'string', unique: true },\n *     profile: { type: 'json' },\n *     createdAt: { type: 'datetime', default: 'now' },\n *     active: { type: 'boolean', default: true }\n *   }\n * );\n *\n * // CRUD operations with automatic type conversion\n * const user = await userDao.create({\n *   name: 'John Doe',\n *   email: 'john@example.com',\n *   profile: { age: 30, location: 'New York' },\n *   active: true\n * });\n *\n * const users = await userDao.findAll({ limit: 10, sort: [{ field: 'createdAt', direction: 'desc' }] });\n * ```\n */\n\nimport { BaseDao } from '../base.dao.ts';\nimport type { IDao } from '../interfaces.ts';\n\n/**\n * Relational Database DAO Implementation Class.\n *\n * Provides comprehensive relational database operations with automatic type conversion,\n * query optimization, and SQL database-specific features. Extends BaseDao with\n * relational-specific operations like JOINs, aggregations, and batch operations.\n *\n * @template T The entity type this DAO manages.\n * @class RelationalDao\n * @augments BaseDao<T>\n * @implements IDao<T>\n * @since 1.0.0\n * @example PostgreSQL User DAO\n * ```typescript\n * interface User {\n *   id: string;\n *   username: string;\n *   email: string;\n *   profile: UserProfile;\n *   createdAt: Date;\n *   updatedAt: Date;\n *   isActive: boolean;\n * }\n *\n * const userDao = new RelationalDao<User>(\n *   postgresAdapter,\n *   logger,\n *   'app_users',\n *   {\n *     id: { type: 'uuid', primaryKey: true },\n *     username: { type: 'string', unique: true },\n *     email: { type: 'string', unique: true },\n *     profile: { type: 'json' },\n *     createdAt: { type: 'datetime', default: 'now' },\n *     updatedAt: { type: 'datetime', default: 'now', onUpdate: 'now' },\n *     isActive: { type: 'boolean', default: true }\n *   }\n * );\n *\n * // Advanced relational operations\n * const activeUsers = await userDao.findByDateRange(\n *   'createdAt',\n *   new Date('2024-01-01'),\n *   new Date('2024-12-31'),\n *   { sort: [{ field: 'username', direction: 'asc' }] }\n * );\n *\n * const userCount = await userDao.aggregate('COUNT', '*', { isActive: true });\n * ```\n */\nexport class RelationalDao<T> extends BaseDao<T> implements IDao<T> {\n  /**\n   * Map Database Row to Entity Object.\n   *\n   * Converts a raw database row to a properly typed entity object, handling.\n   * SQL-specific data type conversions including JSON columns, boolean values,\n   * date/time fields, and numeric types. Uses schema information for intelligent\n   * type detection and conversion.\n   *\n   * @protected\n   * @param {any} row - Raw database row object.\n   * @returns {T} Mapped entity object with proper types.\n   * @throws {Error} When row is null or undefined.\n   * @throws {Error} When JSON parsing fails for JSON columns.\n   * @throws {Error} When date conversion fails for date columns.\n   * @example Row to Entity Mapping\n   * ```typescript\n   * // Database row (raw data)\n   * const dbRow = {\n   *   id: 'user-123',\n   *   name: 'John Doe',\n   *   email: 'john@example.com',\n   *   profile: '{\"age\": 30, \"location\": \"NYC\"}', // JSON string\n   *   created_at: '2024-01-15T10:30:00Z',       // ISO string\n   *   is_active: 1,                             // SQLite boolean as integer\n   *   login_count: '42'                         // String number\n   * };\n   *\n   * // Mapped entity (typed object)\n   * const user = mapRowToEntity(dbRow);\n   * // Result:\n   * // {\n   * //   id: 'user-123',\n   * //   name: 'John Doe',\n   * //   email: 'john@example.com',\n   * //   profile: { age: 30, location: 'NYC' },  // Parsed JSON object\n   * //   createdAt: Date('2024-01-15T10:30:00Z'), // Date object\n   * //   isActive: true,                          // Boolean\n   * //   loginCount: 42                           // Number\n   * // }\n   * ```\n   */\n  protected mapRowToEntity(row: any): T {\n    if (!row) {\n      throw new Error('Cannot map null/undefined row to entity');\n    }\n\n    const entity = {} as Record<string, any>;\n\n    // Handle common SQL data type conversions\n    for (const [key, value] of Object.entries(row)) {\n      if (value === null || value === undefined) {\n        entity[key] = value;\n        continue;\n      }\n\n      // Handle JSON columns\n      if (typeof value === 'string' && this.isJsonColumn(key)) {\n        try {\n          entity[key] = JSON.parse(value);\n        } catch {\n          entity[key] = value;\n        }\n        continue;\n      }\n\n      // Handle boolean columns (SQLite stores as 0/1)\n      if (this.isBooleanColumn(key)) {\n        entity[key] = Boolean(value);\n        continue;\n      }\n\n      // Handle date columns\n      if (this.isDateColumn(key)) {\n        if (value instanceof Date) {\n          entity[key] = value;\n        } else if (typeof value === 'string' || typeof value === 'number') {\n          entity[key] = new Date(value);\n        } else {\n          entity[key] = value;\n        }\n        continue;\n      }\n\n      // Handle number columns\n      if (this.isNumberColumn(key) && typeof value === 'string') {\n        const numValue = Number(value);\n        entity[key] = Number.isNaN(numValue) ? value : numValue;\n        continue;\n      }\n\n      // Default: use value as-is\n      entity[key] = value;\n    }\n\n    return entity as T;\n  }\n\n  /**\n   * Map Entity Object to Database Row.\n   *\n   * Converts a typed entity object to a database row format suitable for SQL storage,\n   * handling type conversions including object serialization to JSON, date formatting,\n   * and boolean conversion for different SQL databases.\n   *\n   * @protected\n   * @param {Partial<T>} entity - Entity object to convert.\n   * @returns {Record<string, any>} Database row object ready for SQL operations.\n   * @example Entity to Row Mapping\n   * ```typescript\n   * // Entity object (typed)\n   * const user: User = {\n   *   id: 'user-123',\n   *   name: 'John Doe',\n   *   profile: { age: 30, location: 'NYC' },    // Object\n   *   createdAt: new Date('2024-01-15'),        // Date object\n   *   isActive: true,                           // Boolean\n   *   tags: ['developer', 'manager']            // Array\n   * };\n   *\n   * // Mapped row (database format)\n   * const dbRow = mapEntityToRow(user);\n   * // Result:\n   * // {\n   * //   id: 'user-123',\n   * //   name: 'John Doe',\n   * //   profile: '{\"age\":30,\"location\":\"NYC\"}', // JSON string\n   * //   created_at: '2024-01-15T00:00:00.000Z',  // ISO string\n   * //   is_active: true,                          // Boolean (or 1 for SQLite)\n   * //   tags: '[\"developer\",\"manager\"]'          // JSON array string\n   * // }\n   * ```\n   */\n  protected mapEntityToRow(entity: Partial<T>): Record<string, any> {\n    if (!entity) {\n      return {};\n    }\n\n    const row = {} as Record<string, any>;\n\n    for (const [key, value] of Object.entries(entity)) {\n      if (value === null || value === undefined) {\n        row[key] = value;\n        continue;\n      }\n\n      // Handle JSON columns - serialize objects/arrays\n      if (this.isJsonColumn(key) && (typeof value === 'object' || Array.isArray(value))) {\n        row[key] = JSON.stringify(value);\n        continue;\n      }\n\n      // Handle date columns - ensure proper format\n      if (this.isDateColumn(key)) {\n        if (value instanceof Date) {\n          row[key] = value.toISOString();\n        } else if (typeof value === 'string' || typeof value === 'number') {\n          row[key] = new Date(value).toISOString();\n        } else {\n          row[key] = value;\n        }\n        continue;\n      }\n\n      // Handle boolean columns\n      if (this.isBooleanColumn(key)) {\n        row[key] = Boolean(value);\n        continue;\n      }\n\n      // Default: use value as-is\n      row[key] = value;\n    }\n\n    return row;\n  }\n\n  /**\n   * Enhanced Query Methods for SQL-Specific Operations.\n   *\n   * The following methods provide advanced SQL operations beyond basic CRUD,\n   * including JOINs, aggregations, batch operations, and specialized queries.\n   */\n\n  /**\n   * Find Entities with SQL JOIN Operations.\n   *\n   * Performs SQL JOIN queries to retrieve entities with related data from other tables.\n   * Supports INNER JOINs with custom join conditions and optional filtering criteria.\n   *\n   * @param {string} joinTable - Name of the table to join with.\n   * @param {string} joinCondition - SQL join condition (e.g., 'users.id = profiles.user_id').\n   * @param {Partial<T>} [criteria] - Optional filtering criteria for the main table.\n   * @param {any} [options] - Optional query options (sort, limit, offset).\n   * @returns {Promise<T[]>} Array of entities with joined data.\n   * @throws {Error} When JOIN query construction fails.\n   * @throws {Error} When SQL execution fails.\n   * @throws {Error} When join condition is invalid.\n   * @example User Profile JOIN Query\n   * ```typescript\n   * // Find users with their profile information\n   * const usersWithProfiles = await userDao.findWithJoin(\n   *   'user_profiles',\n   *   'users.id = user_profiles.user_id',\n   *   { isActive: true }, // Only active users\n   *   {\n   *     sort: [{ field: 'users.created_at', direction: 'desc' }],\n   *     limit: 50\n   *   }\n   * );\n   *\n   * // Generated SQL:\n   * // SELECT users.*\n   * // FROM users\n   * // JOIN user_profiles ON users.id = user_profiles.user_id\n   * // WHERE users.is_active = $1\n   * // ORDER BY users.created_at DESC\n   * // LIMIT 50\n   * ```\n   * @example Order Items JOIN Query\n   * ```typescript\n   * interface OrderItem {\n   *   id: string;\n   *   productId: string;\n   *   quantity: number;\n   *   price: number;\n   * }\n   *\n   * // Find order items with product details\n   * const itemsWithProducts = await orderItemDao.findWithJoin(\n   *   'products',\n   *   'order_items.product_id = products.id',\n   *   { quantity: { $gte: 2 } }, // Quantity >= 2\n   *   {\n   *     sort: [{ field: 'products.name', direction: 'asc' }]\n   *   }\n   * );\n   * ```\n   */\n  async findWithJoin(\n    joinTable: string,\n    joinCondition: string,\n    criteria?: Partial<T>,\n    options?: any\n  ): Promise<T[]> {\n    this.logger.debug(`Finding entities with JOIN: ${this.tableName} JOIN ${joinTable}`);\n\n    try {\n      const whereClause = criteria ? this.buildWhereClause(this.mapEntityToRow(criteria)) : '';\n      const orderClause = this.buildOrderClause(options?.['sort']);\n      const limitClause = this.buildLimitClause(options?.['limit'], options?.['offset']);\n\n      const sql = `\n        SELECT ${this.tableName}.* \n        FROM ${this.tableName} \n        JOIN ${joinTable} ON ${joinCondition} \n        ${whereClause} \n        ${orderClause} \n        ${limitClause}\n      `.trim();\n\n      const params = criteria ? Object.values(this.mapEntityToRow(criteria)) : [];\n      const result = await this.adapter.query(sql, params);\n\n      return result?.rows?.map((row) => this.mapRowToEntity(row));\n    } catch (error) {\n      this.logger.error(`JOIN query failed: ${error}`);\n      throw new Error(\n        `JOIN query failed: ${error instanceof Error ? error.message : 'Unknown error'}`\n      );\n    }\n  }\n\n  /**\n   * Execute SQL Aggregate Queries.\n   *\n   * Performs SQL aggregate functions including COUNT, SUM, AVG, MIN, and MAX operations.\n   * On specified columns with optional filtering criteria. Returns numeric results for\n   * statistical analysis and reporting..\n   *\n   * @param {('COUNT'|'SUM'|'AVG'|'MIN'|'MAX')} aggregateFunction - SQL aggregate function to execute.\n   * @param {string} [column='*'] - Column name to aggregate (default: '*' for COUNT).\n   * @param {Partial<T>} [criteria] - Optional filtering criteria.\n   * @returns {Promise<number>} Numeric result of the aggregate function.\n   * @throws {Error} When aggregate function is invalid.\n   * @throws {Error} When column does not exist.\n   * @throws {Error} When SQL execution fails.\n   * @example User Statistics\n   * ```typescript\n   * // Count total active users\n   * const activeUserCount = await userDao.aggregate(\n   *   'COUNT',\n   *   '*',\n   *   { isActive: true }\n   * );\n   *\n   * // Average user age\n   * const averageAge = await userDao.aggregate(\n   *   'AVG',\n   *   'age',\n   *   { isActive: true }\n   * );\n   *\n   * // Find oldest user\n   * const maxAge = await userDao.aggregate(\n   *   'MAX',\n   *   'age'\n   * );\n   *\n   * console.log(`${activeUserCount} active users, average age: ${averageAge}, oldest: ${maxAge}`);\n   * ```\n   * @example Sales Analytics\n   * ```typescript\n   * interface Order {\n   *   id: string;\n   *   total: number;\n   *   status: 'pending' | 'completed' | 'cancelled';\n   *   createdAt: Date;\n   * }\n   *\n   * // Total revenue from completed orders\n   * const totalRevenue = await orderDao.aggregate(\n   *   'SUM',\n   *   'total',\n   *   { status: 'completed' }\n   * );\n   *\n   * // Number of pending orders\n   * const pendingCount = await orderDao.aggregate(\n   *   'COUNT',\n   *   '*',\n   *   { status: 'pending' }\n   * );\n   *\n   * // Minimum and maximum order values\n   * const minOrder = await orderDao.aggregate('MIN', 'total', { status: 'completed' });\n   * const maxOrder = await orderDao.aggregate('MAX', 'total', { status: 'completed' });\n   * ```\n   */\n  async aggregate(\n    aggregateFunction: 'COUNT' | 'SUM' | 'AVG' | 'MIN' | 'MAX',\n    column: string = '*',\n    criteria?: Partial<T>\n  ): Promise<number> {\n    this.logger.debug(`Executing aggregate ${aggregateFunction}(${column}) on ${this.tableName}`);\n\n    try {\n      const whereClause = criteria ? this.buildWhereClause(this.mapEntityToRow(criteria)) : '';\n      const sql = `SELECT ${aggregateFunction}(${column}) as result FROM ${this.tableName} ${whereClause}`;\n      const params = criteria ? Object.values(this.mapEntityToRow(criteria)) : [];\n\n      const result = await this.adapter.query(sql, params);\n      return Number(result?.rows?.[0]?.result || 0);\n    } catch (error) {\n      this.logger.error(`Aggregate query failed: ${error}`);\n      throw new Error(\n        `Aggregate query failed: ${error instanceof Error ? error.message : 'Unknown error'}`\n      );\n    }\n  }\n\n  /**\n   * Batch Insert Multiple Entities.\n   *\n   * Performs efficient batch insertion of multiple entities in a single SQL statement.\n   * Uses parameterized queries to prevent SQL injection and optimize database performance.\n   * By reducing round-trips to the database server..\n   *\n   * @param {Omit<T, 'id'>[]} entities - Array of entities to insert (without ID field).\n   * @returns {Promise<T[]>} Array of created entities with generated IDs.\n   * @throws {Error} When entities array is empty.\n   * @throws {Error} When batch insert SQL execution fails.\n   * @throws {Error} When entity validation fails.\n   * @example Batch User Creation\n   * ```typescript\n   * const newUsers = [\n   *   {\n   *     name: 'Alice Johnson',\n   *     email: 'alice@example.com',\n   *     profile: { age: 28, department: 'Engineering' },\n   *     isActive: true\n   *   },\n   *   {\n   *     name: 'Bob Smith',\n   *     email: 'bob@example.com',\n   *     profile: { age: 35, department: 'Marketing' },\n   *     isActive: true\n   *   },\n   *   {\n   *     name: 'Carol Davis',\n   *     email: 'carol@example.com',\n   *     profile: { age: 42, department: 'Sales' },\n   *     isActive: false\n   *   }\n   * ];\n   *\n   * // Insert all users in a single database operation\n   * const createdUsers = await userDao.batchInsert(newUsers);\n   *\n   * console.log(`Successfully created ${createdUsers.length} users`);\n   * createdUsers.forEach(user => {\n   *   console.log(`Created user: ${user.name} (ID: ${user.id})`);\n   * });\n   * ```\n   * @example Batch Product Import\n   * ```typescript\n   * interface Product {\n   *   id: string;\n   *   sku: string;\n   *   name: string;\n   *   price: number;\n   *   categoryId: string;\n   *   metadata: { weight: number; dimensions: string };\n   * }\n   *\n   * const importProducts = [\n   *   {\n   *     sku: 'LAPTOP-001',\n   *     name: 'Gaming Laptop',\n   *     price: 1299.99,\n   *     categoryId: 'cat-electronics',\n   *     metadata: { weight: 2.5, dimensions: '15.6x10.2x0.8 inches' }\n   *   }\n   *   // ... more products\n   * ];\n   *\n   * // Efficient batch insertion\n   * const insertedProducts = await productDao.batchInsert(importProducts);\n   * ```\n   */\n  async batchInsert(entities: Omit<T, 'id'>[]): Promise<T[]> {\n    if (entities.length === 0) return [];\n\n    this.logger.debug(`Batch inserting ${entities.length} entities into ${this.tableName}`);\n\n    try {\n      const mappedEntities = entities.map((entity) => this.mapEntityToRow(entity as Partial<T>));\n\n      if (mappedEntities.length === 0 || !mappedEntities[0]) {\n        throw new Error('No valid entities to insert');\n      }\n\n      const columns = Object.keys(mappedEntities[0]);\n      const columnsList = columns.join(', ');\n\n      // Build VALUES clause with placeholders\n      const valuesPlaceholders = mappedEntities\n        .map(() => `(${columns.map(() => '?').join(', ')})`)\n        .join(', ');\n\n      const sql = `INSERT INTO ${this.tableName} (${columnsList}) VALUES ${valuesPlaceholders}`;\n\n      // Flatten all parameters\n      const params = mappedEntities.flatMap((entity) => Object.values(entity));\n\n      await this.adapter.query(sql, params);\n\n      // Return the created entities (approximation since we can't get all IDs easily)\n      return entities.map((entity, index) => ({\n        ...entity,\n        id: `batch_${Date.now()}_${index}`,\n      })) as T[];\n    } catch (error) {\n      this.logger.error(`Batch insert failed: ${error}`);\n      throw new Error(\n        `Batch insert failed: ${error instanceof Error ? error.message : 'Unknown error'}`\n      );\n    }\n  }\n\n  /**\n   * Update Multiple Entities Matching Criteria.\n   *\n   * Performs bulk update operations on all entities matching the specified criteria.\n   * Uses parameterized queries for security and returns the count of affected rows.\n   * Efficient for updating large numbers of records in a single operation.\n   *\n   * @param {Partial<T>} criteria - Filter criteria to select entities for update.\n   * @param {Partial<T>} updates - Field updates to apply to matching entities.\n   * @returns {Promise<number>} Number of entities updated.\n   * @throws {Error} When update criteria is empty (safety check).\n   * @throws {Error} When update SQL execution fails.\n   * @throws {Error} When field validation fails.\n   * @example Bulk User Status Update\n   * ```typescript\n   * // Deactivate all users from a specific department\n   * const updatedCount = await userDao.updateMany(\n   *   { 'profile.department': 'Sales' }, // Criteria: users in Sales dept\n   *   {\n   *     isActive: false,                  // Update: set inactive\n   *     updatedAt: new Date()            // Update timestamp\n   *   }\n   * );\n   *\n   * console.log(`Deactivated ${updatedCount} users from Sales department`);\n   * ```\n   * @example Price Adjustment\n   * ```typescript\n   * interface Product {\n   *   id: string;\n   *   categoryId: string;\n   *   price: number;\n   *   discountPercent: number;\n   *   updatedAt: Date;\n   * }\n   *\n   * // Apply 10% discount to all electronics products\n   * const affectedProducts = await productDao.updateMany(\n   *   { categoryId: 'electronics' },\n   *   {\n   *     discountPercent: 10,\n   *     updatedAt: new Date()\n   *   }\n   * );\n   *\n   * console.log(`Applied discount to ${affectedProducts} electronics products`);\n   * ```\n   * @example User Notification Settings\n   * ```typescript\n   * // Enable email notifications for all active premium users\n   * const notificationUpdates = await userDao.updateMany(\n   *   {\n   *     isActive: true,\n   *     subscriptionTier: 'premium'\n   *   },\n   *   {\n   *     'settings.emailNotifications': true,\n   *     'settings.updatedAt': new Date()\n   *   }\n   * );\n   * ```\n   */\n  async updateMany(criteria: Partial<T>, updates: Partial<T>): Promise<number> {\n    this.logger.debug(`Updating multiple entities in ${this.tableName}`, { criteria, updates });\n\n    try {\n      const mappedCriteria = this.mapEntityToRow(criteria);\n      const mappedUpdates = this.mapEntityToRow(updates);\n\n      const setClause = Object.keys(mappedUpdates)\n        .map((column) => `${column} = ?`)\n        .join(', ');\n      const whereClause = this.buildWhereClause(mappedCriteria);\n\n      const sql = `UPDATE ${this.tableName} SET ${setClause} ${whereClause}`;\n      const params = [...Object.values(mappedUpdates), ...Object.values(mappedCriteria)];\n\n      const result = await this.adapter.query(sql, params);\n      return result?.rowCount || 0;\n    } catch (error) {\n      this.logger.error(`Update many failed: ${error}`);\n      throw new Error(\n        `Update many failed: ${error instanceof Error ? error.message : 'Unknown error'}`\n      );\n    }\n  }\n\n  /**\n   * Delete Multiple Entities Matching Criteria.\n   *\n   * Performs bulk deletion of entities matching the specified criteria. Includes safety\n   * checks to prevent accidental deletion of all records. Returns the count of deleted rows.\n   *\n   * @param {Partial<T>} criteria - Filter criteria to select entities for deletion.\n   * @returns {Promise<number>} Number of entities deleted.\n   * @throws {Error} When criteria is empty (prevents accidental full table deletion).\n   * @throws {Error} When delete SQL execution fails.\n   * @throws {Error} When foreign key constraints are violated.\n   * @example Delete Inactive Users\n   * ```typescript\n   * // Remove all inactive users older than 1 year\n   * const oneYearAgo = new Date();\n   * oneYearAgo.setFullYear(oneYearAgo.getFullYear() - 1);\n   *\n   * const deletedCount = await userDao.deleteMany({\n   *   isActive: false,\n   *   lastLoginAt: { $lt: oneYearAgo } // Custom query operator\n   * });\n   *\n   * console.log(`Deleted ${deletedCount} inactive users`);\n   * ```\n   * @example Clean Up Test Data\n   * ```typescript\n   * // Remove all test orders created during development\n   * const testOrdersDeleted = await orderDao.deleteMany({\n   *   status: 'test',\n   *   createdBy: 'test-user'\n   * });\n   *\n   * console.log(`Cleaned up ${testOrdersDeleted} test orders`);\n   * ```\n   * @example Archive Old Sessions\n   * ```typescript\n   * interface UserSession {\n   *   id: string;\n   *   userId: string;\n   *   expiresAt: Date;\n   *   isActive: boolean;\n   * }\n   *\n   * // Delete expired and inactive sessions\n   * const expiredSessionsDeleted = await sessionDao.deleteMany({\n   *   isActive: false,\n   *   expiresAt: { $lt: new Date() } // Sessions that have expired\n   * });\n   *\n   * console.log(`Deleted ${expiredSessionsDeleted} expired sessions`);\n   * ```\n   */\n  async deleteMany(criteria: Partial<T>): Promise<number> {\n    this.logger.debug(`Deleting multiple entities from ${this.tableName}`, { criteria });\n\n    try {\n      const mappedCriteria = this.mapEntityToRow(criteria);\n      const whereClause = this.buildWhereClause(mappedCriteria);\n\n      if (!whereClause) {\n        throw new Error('DELETE without WHERE clause is not allowed for safety');\n      }\n\n      const sql = `DELETE FROM ${this.tableName} ${whereClause}`;\n      const params = Object.values(mappedCriteria);\n\n      const result = await this.adapter.query(sql, params);\n      return result?.rowCount || 0;\n    } catch (error) {\n      this.logger.error(`Delete many failed: ${error}`);\n      throw new Error(\n        `Delete many failed: ${error instanceof Error ? error.message : 'Unknown error'}`\n      );\n    }\n  }\n\n  /**\n   * Search Using SQL LIKE Operator.\n   *\n   * Performs text-based search using SQL LIKE operator with wildcard matching.\n   * Supports partial string matching and is useful for implementing search functionality.\n   * Across text fields..\n   *\n   * @param {string} field - Database field name to search in.\n   * @param {string} searchTerm - Search term to match (automatically wrapped with %).\n   * @param {any} [options] - Optional query options (limit, sort, etc.).\n   * @returns {Promise<T[]>} Array of entities matching the search term.\n   * @throws {Error} When field name is invalid.\n   * @throws {Error} When search SQL execution fails.\n   * @example User Name Search\n   * ```typescript\n   * // Find all users with names containing 'john'\n   * const johnUsers = await userDao.search('name', 'john');\n   *\n   * // Case-insensitive search for emails containing 'gmail'\n   * const gmailUsers = await userDao.search('email', 'gmail', {\n   *   limit: 20,\n   *   sort: [{ field: 'name', direction: 'asc' }]\n   * });\n   *\n   * console.log(`Found ${johnUsers.length} users named John`);\n   * console.log(`Found ${gmailUsers.length} Gmail users`);\n   * ```\n   * @example Product Search\n   * ```typescript\n   * interface Product {\n   *   id: string;\n   *   name: string;\n   *   description: string;\n   *   sku: string;\n   *   category: string;\n   * }\n   *\n   * // Search products by name\n   * const laptopProducts = await productDao.search('name', 'laptop', {\n   *   limit: 10\n   * });\n   *\n   * // Search by description\n   * const gamingProducts = await productDao.search('description', 'gaming');\n   *\n   * // Search by SKU partial match\n   * const electronicsSkus = await productDao.search('sku', 'ELEC-');\n   * ```\n   * @example Content Search with Ranking\n   * ```typescript\n   * // Search articles by title and description\n   * const searchResults = await articleDao.search('title', searchQuery, {\n   *   sort: [\n   *     { field: 'publishedAt', direction: 'desc' },\n   *     { field: 'viewCount', direction: 'desc' }\n   *   ],\n   *   limit: 50\n   * });\n   *\n   * // Multiple field search (would require custom implementation)\n   * const contentResults = await Promise.all([\n   *   articleDao.search('title', searchQuery),\n   *   articleDao.search('content', searchQuery)\n   * ]).then(results => {\n   *   // Combine and deduplicate results\n   *   return [...new Set([...results[0], ...results[1]])];\n   * });\n   * ```\n   */\n  async search(field: string, searchTerm: string, _options?: any): Promise<T[]> {\n    this.logger.debug(`Searching in ${this.tableName}.${field} for: ${searchTerm}`);\n\n    try {\n      const sql = `SELECT * FROM ${this.tableName} WHERE ${field} LIKE ?`;\n      const params = [`%${searchTerm}%`];\n\n      const result = await this.adapter.query(sql, params);\n      return result?.rows?.map((row) => this.mapRowToEntity(row));\n    } catch (error) {\n      this.logger.error(`Search failed: ${error}`);\n      throw new Error(`Search failed: ${error instanceof Error ? error.message : 'Unknown error'}`);\n    }\n  }\n\n  /**\n   * Find Entities by Date Range.\n   *\n   * Retrieves entities where a specified date field falls within the given date range.\n   * Useful for time-based queries, reporting, and data analysis. Supports sorting\n   * and pagination options.\n   *\n   * @param {string} dateField - Name of the date field to filter on.\n   * @param {Date} startDate - Start of the date range (inclusive).\n   * @param {Date} endDate - End of the date range (inclusive).\n   * @param {any} [options] - Optional query options (sort, limit, offset).\n   * @returns {Promise<T[]>} Array of entities within the date range.\n   * @throws {Error} When date field is invalid.\n   * @throws {Error} When start date is after end date.\n   * @throws {Error} When date range query execution fails.\n   * @example Monthly User Registrations\n   * ```typescript\n   * // Get all users registered in January 2024\n   * const januaryUsers = await userDao.findByDateRange(\n   *   'createdAt',\n   *   new Date('2024-01-01T00:00:00Z'),\n   *   new Date('2024-01-31T23:59:59Z'),\n   *   {\n   *     sort: [{ field: 'createdAt', direction: 'asc' }],\n   *     limit: 1000\n   *   }\n   * );\n   *\n   * console.log(`${januaryUsers.length} users registered in January 2024`);\n   * ```\n   * @example Sales Report Date Range\n   * ```typescript\n   * interface Order {\n   *   id: string;\n   *   customerId: string;\n   *   total: number;\n   *   status: string;\n   *   createdAt: Date;\n   *   completedAt?: Date;\n   * }\n   *\n   * // Get completed orders from last quarter\n   * const lastQuarterStart = new Date('2024-10-01');\n   * const lastQuarterEnd = new Date('2024-12-31');\n   *\n   * const quarterlyOrders = await orderDao.findByDateRange(\n   *   'completedAt',\n   *   lastQuarterStart,\n   *   lastQuarterEnd,\n   *   {\n   *     sort: [{ field: 'total', direction: 'desc' }]\n   *   }\n   * );\n   *\n   * const totalRevenue = quarterlyOrders.reduce((sum, order) => sum + order.total, 0);\n   * console.log(`Q4 2024 Revenue: $${totalRevenue.toFixed(2)} from ${quarterlyOrders.length} orders`);\n   * ```\n   * @example Activity Log Analysis\n   * ```typescript\n   * // Get user activity logs from the past 7 days\n   * const sevenDaysAgo = new Date();\n   * sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);\n   *\n   * const recentActivity = await activityLogDao.findByDateRange(\n   *   'timestamp',\n   *   sevenDaysAgo,\n   *   new Date(),\n   *   {\n   *     sort: [{ field: 'timestamp', direction: 'desc' }],\n   *     limit: 500\n   *   }\n   * );\n   *\n   * // Group by day for trending analysis\n   * const activityByDay = recentActivity.reduce((acc, log) => {\n   *   const day = log.timestamp.toISOString().split('T')[0];\n   *   acc[day] = (acc[day] || 0) + 1;\n   *   return acc;\n   * }, {} as Record<string, number>);\n   * ```\n   */\n  async findByDateRange(\n    dateField: string,\n    startDate: Date,\n    endDate: Date,\n    options?: any\n  ): Promise<T[]> {\n    this.logger.debug(\n      `Finding entities by date range: ${dateField} between ${startDate} and ${endDate}`\n    );\n\n    try {\n      const orderClause = this.buildOrderClause(options?.['sort']);\n      const limitClause = this.buildLimitClause(options?.['limit'], options?.['offset']);\n\n      const sql = `\n        SELECT * FROM ${this.tableName} \n        WHERE ${dateField} >= ? AND ${dateField} <= ? \n        ${orderClause} \n        ${limitClause}\n      `.trim();\n\n      const params = [startDate.toISOString(), endDate.toISOString()];\n      const result = await this.adapter.query(sql, params);\n\n      return result?.rows?.map((row) => this.mapRowToEntity(row));\n    } catch (error) {\n      this.logger.error(`Date range query failed: ${error}`);\n      throw new Error(\n        `Date range query failed: ${error instanceof Error ? error.message : 'Unknown error'}`\n      );\n    }\n  }\n\n  /**\n   * Helper methods for type checking based on schema.\n   */\n  private isJsonColumn(columnName: string): boolean {\n    return (\n      this.entitySchema?.[columnName]?.type === 'json' ||\n      columnName.endsWith('_json') ||\n      columnName === 'metadata' ||\n      columnName === 'properties' ||\n      columnName === 'data'\n    );\n  }\n\n  private isBooleanColumn(columnName: string): boolean {\n    return (\n      this.entitySchema?.[columnName]?.type === 'boolean' ||\n      columnName.startsWith('is_') ||\n      columnName.startsWith('has_') ||\n      columnName.endsWith('_flag') ||\n      ['active', 'enabled', 'visible', 'deleted'].includes(columnName)\n    );\n  }\n\n  private isDateColumn(columnName: string): boolean {\n    return (\n      this.entitySchema?.[columnName]?.type === 'date' ||\n      this.entitySchema?.[columnName]?.type === 'datetime' ||\n      columnName.endsWith('_at') ||\n      columnName.endsWith('_date') ||\n      columnName.endsWith('_time') ||\n      ['created', 'updated', 'deleted', 'timestamp'].includes(columnName)\n    );\n  }\n\n  private isNumberColumn(columnName: string): boolean {\n    return (\n      this.entitySchema?.[columnName]?.type === 'number' ||\n      this.entitySchema?.[columnName]?.type === 'integer' ||\n      this.entitySchema?.[columnName]?.type === 'float' ||\n      columnName.endsWith('_id') ||\n      columnName.endsWith('_count') ||\n      columnName.endsWith('_size') ||\n      ['id', 'count', 'size', 'length', 'duration'].includes(columnName)\n    );\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
