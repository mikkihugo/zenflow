{
  "version": 3,
  "sources": ["../../src/coordination/workflows/workflow-gate-request.ts", "../../src/core/domain-boundary-validator.ts", "../../src/core/type-safe-event-system.ts"],
  "sourcesContent": ["/**\n * @file Workflow Gate Request - Phase 1, Task 1.2 - AGUI Workflow Gates\n *\n * Extends existing ValidationQuestion interface for workflow orchestration gates.\n * Provides type-safe workflow context, escalation chains, and integration with\n * the existing AGUI system and type-safe event system.\n *\n * ARCHITECTURE: Multi-Agent Cognitive Architecture compliant\n * - Extends proven ValidationQuestion interface from progressive-confidence-builder\n * - Integrates with type-safe event system (HumanValidationRequestedEvent, AGUIGateOpenedEvent)\n * - Provides workflow-specific context and decision escalation chains\n * - Runtime validation using domain boundary validator\n * - Production-grade performance and monitoring\n */\n\nimport { EventEmitter } from 'events';\nimport type { Logger } from '../../config/logging-config.ts';\nimport { getLogger } from '../../config/logging-config.ts';\nimport type { ValidationQuestion } from '../../coordination/discovery/progressive-confidence-builder.ts';\nimport {\n  Domain,\n  type DomainBoundaryValidator,\n  getDomainValidator,\n  type Result,\n  type TypeSchema,\n  validateCrossDomain,\n} from '../../core/domain-boundary-validator.ts';\nimport {\n  type AGUIGateClosedEvent,\n  type AGUIGateOpenedEvent,\n  type BaseEvent,\n  createCorrelationId,\n  createEvent,\n  EventPriority,\n  type HumanValidationCompletedEvent,\n  type HumanValidationRequestedEvent,\n  type TypeSafeEventBus,\n} from '../../core/type-safe-event-system.ts';\nimport type { AGUIInterface } from '../../interfaces/agui/agui-adapter.ts';\n\nconst logger = getLogger('workflow-gate-request');\n\n// ============================================================================\n// WORKFLOW CONTEXT TYPES - Extended validation question context\n// ============================================================================\n\n/**\n * Workflow context for gate decision points\n */\nexport interface WorkflowContext {\n  /** Unique workflow identifier */\n  readonly workflowId: string;\n\n  /** Current step name within the workflow */\n  readonly stepName: string;\n\n  /** Business impact level of this decision */\n  readonly businessImpact: 'low' | 'medium' | 'high' | 'critical';\n\n  /** Scope of the decision being made */\n  readonly decisionScope: 'task' | 'feature' | 'epic' | 'prd' | 'portfolio';\n\n  /** List of stakeholders who should be involved in decision */\n  readonly stakeholders: string[];\n\n  /** Optional deadline for decision completion */\n  readonly deadline?: Date;\n\n  /** Dependencies that this decision affects */\n  readonly dependencies?: WorkflowDependency[];\n\n  /** Estimated cost/effort impact of different decision outcomes */\n  readonly impactEstimates?: ImpactEstimate[];\n\n  /** Historical decisions in this workflow for context */\n  readonly previousDecisions?: WorkflowDecisionRecord[];\n\n  /** Risk factors associated with this decision */\n  readonly riskFactors?: RiskFactor[];\n}\n\n/**\n * Workflow dependency that may be affected by gate decisions\n */\nexport interface WorkflowDependency {\n  /** Unique dependency identifier */\n  readonly id: string;\n\n  /** Dependency type */\n  readonly type: 'blocking' | 'blocked_by' | 'related' | 'impacts' | 'impacted_by';\n\n  /** Reference to dependent workflow/task/resource */\n  readonly reference: string;\n\n  /** Criticality of this dependency */\n  readonly criticality: 'low' | 'medium' | 'high' | 'critical';\n\n  /** Optional description of the dependency relationship */\n  readonly description?: string;\n}\n\n/**\n * Impact estimate for different decision outcomes\n */\nexport interface ImpactEstimate {\n  /** Decision outcome being estimated */\n  readonly outcome: string;\n\n  /** Time impact (in hours) */\n  readonly timeImpact: number;\n\n  /** Resource cost impact */\n  readonly costImpact: number;\n\n  /** Quality/risk impact score (0-1) */\n  readonly qualityImpact: number;\n\n  /** Confidence in this estimate (0-1) */\n  readonly confidence: number;\n}\n\n/**\n * Risk factor associated with a workflow gate decision\n */\nexport interface RiskFactor {\n  /** Unique risk identifier */\n  readonly id: string;\n\n  /** Risk category */\n  readonly category: 'technical' | 'business' | 'compliance' | 'security' | 'operational';\n\n  /** Risk severity */\n  readonly severity: 'low' | 'medium' | 'high' | 'critical';\n\n  /** Probability of risk occurring (0-1) */\n  readonly probability: number;\n\n  /** Risk description */\n  readonly description: string;\n\n  /** Mitigation strategies available */\n  readonly mitigation?: string[];\n}\n\n/**\n * Record of a previous workflow decision for context\n */\nexport interface WorkflowDecisionRecord {\n  /** When the decision was made */\n  readonly timestamp: Date;\n\n  /** Who made the decision */\n  readonly decisionMaker: string;\n\n  /** Step where decision was made */\n  readonly stepName: string;\n\n  /** Decision that was made */\n  readonly decision: string;\n\n  /** Rationale provided */\n  readonly rationale?: string;\n\n  /** Outcome/result of the decision */\n  readonly outcome?: string;\n}\n\n// ============================================================================\n// GATE ESCALATION TYPES - Decision escalation chains\n// ============================================================================\n\n/**\n * Escalation level for workflow gates\n */\nexport enum GateEscalationLevel {\n  NONE = 0, // No escalation needed\n  TEAM_LEAD = 1, // Escalate to team lead\n  MANAGER = 2, // Escalate to manager\n  DIRECTOR = 3, // Escalate to director\n  EXECUTIVE = 4, // Escalate to executive level\n  BOARD = 5, // Escalate to board level\n}\n\n/**\n * Escalation trigger conditions\n */\nexport interface EscalationTrigger {\n  /** Condition type */\n  readonly type:\n    | 'timeout'\n    | 'business_impact'\n    | 'cost_threshold'\n    | 'risk_level'\n    | 'stakeholder_conflict';\n\n  /** Threshold value for triggering escalation */\n  readonly threshold: number | string;\n\n  /** Time delay before escalating (in milliseconds) */\n  readonly delay?: number;\n\n  /** Whether to skip levels based on urgency */\n  readonly skipLevels?: boolean;\n}\n\n/**\n * Escalation chain configuration\n */\nexport interface EscalationChain {\n  /** Chain identifier */\n  readonly id: string;\n\n  /** Ordered list of escalation levels */\n  readonly levels: EscalationLevel[];\n\n  /** Conditions that trigger escalation */\n  readonly triggers: EscalationTrigger[];\n\n  /** Maximum escalation level allowed */\n  readonly maxLevel: GateEscalationLevel;\n\n  /** Whether to notify all levels when escalating */\n  readonly notifyAllLevels?: boolean;\n}\n\n/**\n * Individual escalation level configuration\n */\nexport interface EscalationLevel {\n  /** Level in the escalation chain */\n  readonly level: GateEscalationLevel;\n\n  /** Approvers at this level */\n  readonly approvers: string[];\n\n  /** Required number of approvals at this level */\n  readonly requiredApprovals?: number;\n\n  /** Time limit for decision at this level */\n  readonly timeLimit?: number;\n\n  /** Special permissions or context at this level */\n  readonly permissions?: string[];\n\n  /** Notification configuration */\n  readonly notifications?: NotificationConfig;\n}\n\n/**\n * Notification configuration for escalations\n */\nexport interface NotificationConfig {\n  /** Notification channels to use */\n  readonly channels: ('email' | 'slack' | 'teams' | 'webhook' | 'sms')[];\n\n  /** Notification priority */\n  readonly priority: 'low' | 'normal' | 'high' | 'urgent';\n\n  /** Follow-up notification intervals */\n  readonly followUpIntervals?: number[];\n\n  /** Custom notification templates */\n  readonly templates?: Record<string, string>;\n}\n\n/**\n * Approval chain result\n */\nexport interface ApprovalChainResult {\n  /** Whether the chain completed successfully */\n  readonly completed: boolean;\n\n  /** Final approval status */\n  readonly approved: boolean;\n\n  /** Level at which decision was made */\n  readonly decisionLevel: GateEscalationLevel;\n\n  /** Who made the final decision */\n  readonly decisionMaker: string;\n\n  /** Time taken for the approval process */\n  readonly processingTime: number;\n\n  /** All approvals collected during the process */\n  readonly approvals: ApprovalRecord[];\n\n  /** Any escalations that occurred */\n  readonly escalations: EscalationRecord[];\n}\n\n/**\n * Individual approval record\n */\nexport interface ApprovalRecord {\n  /** Who provided the approval */\n  readonly approver: string;\n\n  /** When the approval was given */\n  readonly timestamp: Date;\n\n  /** Approval decision */\n  readonly decision: 'approve' | 'reject' | 'delegate' | 'escalate';\n\n  /** Comments or rationale */\n  readonly comments?: string;\n\n  /** Escalation level of the approver */\n  readonly level: GateEscalationLevel;\n\n  /** Time taken to make decision */\n  readonly responseTime: number;\n}\n\n/**\n * Escalation record\n */\nexport interface EscalationRecord {\n  /** When the escalation occurred */\n  readonly timestamp: Date;\n\n  /** Why escalation was triggered */\n  readonly reason: string;\n\n  /** From which level to which level */\n  readonly fromLevel: GateEscalationLevel;\n  readonly toLevel: GateEscalationLevel;\n\n  /** Who triggered the escalation */\n  readonly triggeredBy?: string;\n\n  /** Escalation trigger that fired */\n  readonly trigger: EscalationTrigger;\n}\n\n// ============================================================================\n// WORKFLOW GATE REQUEST INTERFACE - Extended ValidationQuestion\n// ============================================================================\n\n/**\n * Workflow gate request extending ValidationQuestion with workflow-specific context.\n * Maintains full compatibility with existing AGUI validation system while adding\n * workflow orchestration capabilities.\n */\nexport interface WorkflowGateRequest extends ValidationQuestion {\n  /** Workflow-specific context information */\n  readonly workflowContext: WorkflowContext;\n\n  /** Escalation chain configuration for this gate */\n  readonly escalationChain?: EscalationChain;\n\n  /** Gate type for categorization and handling */\n  readonly gateType: 'approval' | 'checkpoint' | 'review' | 'decision' | 'escalation' | 'emergency';\n\n  /** Required approval level for this gate */\n  readonly requiredApprovalLevel?: GateEscalationLevel;\n\n  /** Timeout configuration */\n  readonly timeoutConfig?: {\n    /** Initial timeout before escalation (ms) */\n    readonly initialTimeout: number;\n    /** Escalation timeout intervals (ms) */\n    readonly escalationTimeouts: number[];\n    /** Maximum total time allowed (ms) */\n    readonly maxTotalTimeout: number;\n  };\n\n  /** Integration configuration with existing systems */\n  readonly integrationConfig?: {\n    /** Event bus correlation ID */\n    readonly correlationId?: string;\n    /** AGUI interface to use */\n    readonly aguiInterface?: string;\n    /** Domain validation requirements */\n    readonly domainValidation?: boolean;\n    /** Performance monitoring */\n    readonly enableMetrics?: boolean;\n  };\n\n  /** Conditional logic for dynamic gate behavior */\n  readonly conditionalLogic?: {\n    /** Conditions that must be met before presenting gate */\n    readonly prerequisites?: GateCondition[];\n    /** Dynamic options based on context */\n    readonly dynamicOptions?: (context: WorkflowContext) => string[];\n    /** Auto-approval conditions */\n    readonly autoApprovalConditions?: GateCondition[];\n  };\n}\n\n/**\n * Gate condition for conditional logic\n */\nexport interface GateCondition {\n  /** Condition identifier */\n  readonly id: string;\n\n  /** Condition type */\n  readonly type:\n    | 'workflow_state'\n    | 'user_role'\n    | 'time_constraint'\n    | 'dependency'\n    | 'risk_threshold'\n    | 'custom';\n\n  /** Condition operator */\n  readonly operator:\n    | 'equals'\n    | 'not_equals'\n    | 'greater_than'\n    | 'less_than'\n    | 'contains'\n    | 'matches'\n    | 'exists';\n\n  /** Value to compare against */\n  readonly value: any;\n\n  /** Field or property to evaluate */\n  readonly field: string;\n\n  /** Whether this condition is required or optional */\n  readonly required?: boolean;\n}\n\n// ============================================================================\n// WORKFLOW GATE REQUEST SCHEMA - Runtime validation\n// ============================================================================\n\n/**\n * TypeSchema for WorkflowGateRequest runtime validation\n */\nexport const WorkflowGateRequestSchema: TypeSchema<WorkflowGateRequest> = {\n  type: 'object',\n  required: true,\n  properties: {\n    // ValidationQuestion base properties\n    id: { type: 'string', required: true },\n    type: {\n      type: 'string',\n      required: true,\n      enum: ['relevance', 'boundary', 'relationship', 'naming', 'priority', 'checkpoint', 'review'],\n    },\n    question: { type: 'string', required: true },\n    context: { type: 'object', required: true },\n    options: {\n      type: 'array',\n      required: false,\n      items: { type: 'string' },\n    },\n    allowCustom: { type: 'boolean', required: false },\n    confidence: { type: 'number', required: true },\n    priority: {\n      type: 'string',\n      required: false,\n      enum: ['critical', 'high', 'medium', 'low'],\n    },\n    validationReason: { type: 'string', required: false },\n    expectedImpact: { type: 'number', required: false },\n\n    // WorkflowGateRequest specific properties\n    workflowContext: {\n      type: 'object',\n      required: true,\n      properties: {\n        workflowId: { type: 'string', required: true },\n        stepName: { type: 'string', required: true },\n        businessImpact: {\n          type: 'string',\n          required: true,\n          enum: ['low', 'medium', 'high', 'critical'],\n        },\n        decisionScope: {\n          type: 'string',\n          required: true,\n          enum: ['task', 'feature', 'epic', 'prd', 'portfolio'],\n        },\n        stakeholders: {\n          type: 'array',\n          required: true,\n          items: { type: 'string' },\n        },\n        deadline: { type: 'object', required: false },\n        dependencies: {\n          type: 'array',\n          required: false,\n          items: {\n            type: 'object',\n            properties: {\n              id: { type: 'string', required: true },\n              type: {\n                type: 'string',\n                required: true,\n                enum: ['blocking', 'blocked_by', 'related', 'impacts', 'impacted_by'],\n              },\n              reference: { type: 'string', required: true },\n              criticality: {\n                type: 'string',\n                required: true,\n                enum: ['low', 'medium', 'high', 'critical'],\n              },\n              description: { type: 'string', required: false },\n            },\n          },\n        },\n      },\n    },\n\n    gateType: {\n      type: 'string',\n      required: true,\n      enum: ['approval', 'checkpoint', 'review', 'decision', 'escalation', 'emergency'],\n    },\n\n    requiredApprovalLevel: {\n      type: 'number',\n      required: false,\n      enum: [0, 1, 2, 3, 4, 5], // GateEscalationLevel values\n    },\n\n    escalationChain: {\n      type: 'object',\n      required: false,\n      properties: {\n        id: { type: 'string', required: true },\n        levels: {\n          type: 'array',\n          required: true,\n          items: {\n            type: 'object',\n            properties: {\n              level: { type: 'number', required: true },\n              approvers: {\n                type: 'array',\n                required: true,\n                items: { type: 'string' },\n              },\n              requiredApprovals: { type: 'number', required: false },\n              timeLimit: { type: 'number', required: false },\n            },\n          },\n        },\n        triggers: {\n          type: 'array',\n          required: true,\n          items: {\n            type: 'object',\n            properties: {\n              type: {\n                type: 'string',\n                required: true,\n                enum: [\n                  'timeout',\n                  'business_impact',\n                  'cost_threshold',\n                  'risk_level',\n                  'stakeholder_conflict',\n                ],\n              },\n              threshold: { type: 'any', required: true },\n              delay: { type: 'number', required: false },\n              skipLevels: { type: 'boolean', required: false },\n            },\n          },\n        },\n        maxLevel: { type: 'number', required: true },\n        notifyAllLevels: { type: 'boolean', required: false },\n      },\n    },\n\n    timeoutConfig: {\n      type: 'object',\n      required: false,\n      properties: {\n        initialTimeout: { type: 'number', required: true },\n        escalationTimeouts: {\n          type: 'array',\n          required: true,\n          items: { type: 'number' },\n        },\n        maxTotalTimeout: { type: 'number', required: true },\n      },\n    },\n\n    integrationConfig: {\n      type: 'object',\n      required: false,\n      properties: {\n        correlationId: { type: 'string', required: false },\n        aguiInterface: { type: 'string', required: false },\n        domainValidation: { type: 'boolean', required: false },\n        enableMetrics: { type: 'boolean', required: false },\n      },\n    },\n\n    conditionalLogic: {\n      type: 'object',\n      required: false,\n      properties: {\n        prerequisites: {\n          type: 'array',\n          required: false,\n          items: {\n            type: 'object',\n            properties: {\n              id: { type: 'string', required: true },\n              type: {\n                type: 'string',\n                required: true,\n                enum: [\n                  'workflow_state',\n                  'user_role',\n                  'time_constraint',\n                  'dependency',\n                  'risk_threshold',\n                  'custom',\n                ],\n              },\n              operator: {\n                type: 'string',\n                required: true,\n                enum: [\n                  'equals',\n                  'not_equals',\n                  'greater_than',\n                  'less_than',\n                  'contains',\n                  'matches',\n                  'exists',\n                ],\n              },\n              value: { type: 'any', required: true },\n              field: { type: 'string', required: true },\n              required: { type: 'boolean', required: false },\n            },\n          },\n        },\n        autoApprovalConditions: {\n          type: 'array',\n          required: false,\n          items: {\n            type: 'object',\n            properties: {\n              id: { type: 'string', required: true },\n              type: { type: 'string', required: true },\n              operator: { type: 'string', required: true },\n              value: { type: 'any', required: true },\n              field: { type: 'string', required: true },\n              required: { type: 'boolean', required: false },\n            },\n          },\n        },\n      },\n    },\n  },\n};\n\n// ============================================================================\n// WORKFLOW GATE REQUEST PROCESSOR - Main orchestration class\n// ============================================================================\n\n/**\n * Workflow Gate Request Processor\n *\n * Handles workflow gate requests with full integration to existing systems:\n * - ValidationQuestion compatibility for existing AGUI system\n * - Type-safe event system integration for HumanValidationRequestedEvent and AGUIGateOpenedEvent\n * - Domain boundary validation for cross-domain operations\n * - Escalation chain processing and approval workflows\n * - Performance monitoring and analytics\n */\nexport class WorkflowGateRequestProcessor extends EventEmitter {\n  private readonly logger: Logger;\n  private readonly domainValidator: DomainBoundaryValidator;\n  private readonly pendingGates = new Map<string, PendingGateRequest>();\n  private readonly escalationTimers = new Map<string, NodeJS.Timeout>();\n  private gateCounter = 0;\n\n  constructor(\n    private readonly eventBus: TypeSafeEventBus,\n    private readonly aguiInterface: AGUIInterface,\n    private readonly config: WorkflowGateProcessorConfig = {}\n  ) {\n    super();\n\n    this.logger = getLogger('workflow-gate-processor');\n    this.domainValidator = getDomainValidator(Domain.WORKFLOWS);\n\n    this.config = {\n      enableMetrics: true,\n      enableDomainValidation: true,\n      defaultTimeout: 300000, // 5 minutes\n      maxEscalationLevel: GateEscalationLevel.EXECUTIVE,\n      enableAutoApproval: true,\n      ...config,\n    };\n\n    this.initializeEventHandlers();\n  }\n\n  // ============================================================================\n  // PUBLIC API - Core workflow gate operations\n  // ============================================================================\n\n  /**\n   * Process a workflow gate request with full validation and escalation support\n   */\n  async processWorkflowGate(\n    gateRequest: WorkflowGateRequest,\n    options: {\n      skipValidation?: boolean;\n      timeout?: number;\n      escalationOverride?: EscalationChain;\n    } = {}\n  ): Promise<WorkflowGateResult> {\n    const startTime = Date.now();\n    const correlationId = gateRequest.integrationConfig?.correlationId || createCorrelationId();\n\n    this.logger.info('Processing workflow gate request', {\n      gateId: gateRequest.id,\n      workflowId: gateRequest.workflowContext.workflowId,\n      stepName: gateRequest.workflowContext.stepName,\n      gateType: gateRequest.gateType,\n      businessImpact: gateRequest.workflowContext.businessImpact,\n      correlationId,\n    });\n\n    try {\n      // 1. Validate the gate request\n      if (!options.skipValidation && this.config.enableDomainValidation) {\n        const validationResult = await this.validateGateRequest(gateRequest);\n        if (!validationResult.success) {\n          throw new Error(`Gate validation failed: ${validationResult.error?.message}`);\n        }\n      }\n\n      // 2. Check prerequisites and auto-approval conditions\n      const prerequisiteResult = await this.checkPrerequisites(gateRequest);\n      if (!prerequisiteResult.met) {\n        return {\n          success: false,\n          gateId: gateRequest.id,\n          approved: false,\n          processingTime: Date.now() - startTime,\n          error: new Error(`Prerequisites not met: ${prerequisiteResult.missing.join(', ')}`),\n          escalationLevel: GateEscalationLevel.NONE,\n          correlationId,\n        };\n      }\n\n      // 3. Check for auto-approval\n      if (this.config.enableAutoApproval) {\n        const autoApprovalResult = await this.checkAutoApproval(gateRequest);\n        if (autoApprovalResult.approved) {\n          this.logger.info('Gate auto-approved', {\n            gateId: gateRequest.id,\n            reason: autoApprovalResult.reason,\n            correlationId,\n          });\n\n          return {\n            success: true,\n            gateId: gateRequest.id,\n            approved: true,\n            processingTime: Date.now() - startTime,\n            escalationLevel: GateEscalationLevel.NONE,\n            decisionMaker: 'system',\n            autoApproved: true,\n            correlationId,\n          };\n        }\n      }\n\n      // 4. Initialize the gate request with escalation chain\n      const escalationChain =\n        options.escalationOverride ||\n        gateRequest.escalationChain ||\n        this.createDefaultEscalationChain(gateRequest);\n\n      const pendingGate: PendingGateRequest = {\n        gateRequest,\n        escalationChain,\n        correlationId,\n        startTime: new Date(),\n        currentLevel: GateEscalationLevel.NONE,\n        approvals: [],\n        escalations: [],\n        status: 'pending',\n      };\n\n      this.pendingGates.set(gateRequest.id, pendingGate);\n\n      // 5. Emit AGUI gate opened event for integration\n      await this.emitGateOpenedEvent(gateRequest, correlationId);\n\n      // 6. Request human validation through existing AGUI system\n      const validationResult = await this.requestHumanValidation(\n        gateRequest,\n        escalationChain,\n        correlationId\n      );\n\n      // 7. Process the validation result through escalation chain if needed\n      const finalResult = await this.processEscalationChain(\n        gateRequest.id,\n        validationResult,\n        escalationChain\n      );\n\n      // 8. Emit gate closed event\n      await this.emitGateClosedEvent(gateRequest, finalResult, correlationId);\n\n      // 9. Cleanup\n      this.cleanup(gateRequest.id);\n\n      this.logger.info('Workflow gate processing completed', {\n        gateId: gateRequest.id,\n        approved: finalResult.approved,\n        escalationLevel: finalResult.escalationLevel,\n        processingTime: Date.now() - startTime,\n        correlationId,\n      });\n\n      return finalResult;\n    } catch (error) {\n      this.logger.error('Workflow gate processing failed', {\n        gateId: gateRequest.id,\n        error: error instanceof Error ? error.message : String(error),\n        correlationId,\n      });\n\n      // Cleanup on error\n      this.cleanup(gateRequest.id);\n\n      return {\n        success: false,\n        gateId: gateRequest.id,\n        approved: false,\n        processingTime: Date.now() - startTime,\n        error: error instanceof Error ? error : new Error(String(error)),\n        escalationLevel: GateEscalationLevel.NONE,\n        correlationId,\n      };\n    }\n  }\n\n  /**\n   * Create a workflow gate request from basic parameters\n   */\n  createWorkflowGateRequest(\n    workflowId: string,\n    stepName: string,\n    gateType: WorkflowGateRequest['gateType'],\n    question: string,\n    context: any,\n    workflowContext: Partial<WorkflowContext>,\n    options: {\n      priority?: ValidationQuestion['priority'];\n      expectedImpact?: number;\n      escalationChain?: EscalationChain;\n      timeoutConfig?: WorkflowGateRequest['timeoutConfig'];\n      integrationConfig?: WorkflowGateRequest['integrationConfig'];\n    } = {}\n  ): WorkflowGateRequest {\n    const gateId = `gate-${Date.now()}-${++this.gateCounter}`;\n\n    const fullWorkflowContext: WorkflowContext = {\n      workflowId,\n      stepName,\n      businessImpact: 'medium',\n      decisionScope: 'task',\n      stakeholders: [],\n      ...workflowContext,\n    };\n\n    return {\n      // ValidationQuestion base properties\n      id: gateId,\n      type: 'checkpoint',\n      question,\n      context,\n      confidence: 0.8,\n      priority: options.priority || 'medium',\n      validationReason: `Workflow gate for ${stepName}`,\n      expectedImpact: options.expectedImpact || 0.1,\n\n      // WorkflowGateRequest specific properties\n      workflowContext: fullWorkflowContext,\n      gateType,\n      escalationChain: options.escalationChain,\n      timeoutConfig: options.timeoutConfig,\n      integrationConfig: options.integrationConfig,\n    };\n  }\n\n  /**\n   * Get status of all pending gates\n   */\n  getPendingGates(): Map<string, PendingGateRequest> {\n    return new Map(this.pendingGates);\n  }\n\n  /**\n   * Cancel a pending gate request\n   */\n  async cancelGate(gateId: string, reason: string): Promise<boolean> {\n    const pendingGate = this.pendingGates.get(gateId);\n    if (!pendingGate) {\n      return false;\n    }\n\n    this.logger.info('Canceling workflow gate', { gateId, reason });\n\n    // Clear any escalation timers\n    this.clearEscalationTimers(gateId);\n\n    // Mark as cancelled\n    pendingGate.status = 'cancelled';\n\n    // Emit gate closed event with cancellation\n    await this.emitGateClosedEvent(\n      pendingGate.gateRequest,\n      {\n        success: false,\n        gateId,\n        approved: false,\n        processingTime: Date.now() - pendingGate.startTime.getTime(),\n        escalationLevel: pendingGate.currentLevel,\n        error: new Error(`Gate cancelled: ${reason}`),\n        correlationId: pendingGate.correlationId,\n      },\n      pendingGate.correlationId\n    );\n\n    // Cleanup\n    this.cleanup(gateId);\n\n    return true;\n  }\n\n  // ============================================================================\n  // PRIVATE IMPLEMENTATION METHODS\n  // ============================================================================\n\n  private async validateGateRequest(\n    gateRequest: WorkflowGateRequest\n  ): Promise<Result<WorkflowGateRequest>> {\n    try {\n      // Validate using domain boundary validator with schema\n      const validatedRequest = this.domainValidator.validateInput(\n        gateRequest,\n        WorkflowGateRequestSchema\n      );\n\n      // Additional business logic validation\n      if (\n        gateRequest.workflowContext.stakeholders.length === 0 &&\n        gateRequest.gateType !== 'emergency'\n      ) {\n        return {\n          success: false,\n          error: new Error('Stakeholders are required for non-emergency gates'),\n        };\n      }\n\n      if (\n        gateRequest.workflowContext.deadline &&\n        gateRequest.workflowContext.deadline < new Date()\n      ) {\n        return {\n          success: false,\n          error: new Error('Gate deadline has already passed'),\n        };\n      }\n\n      return {\n        success: true,\n        data: validatedRequest,\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: error instanceof Error ? error : new Error(String(error)),\n      };\n    }\n  }\n\n  private async checkPrerequisites(gateRequest: WorkflowGateRequest): Promise<{\n    met: boolean;\n    missing: string[];\n  }> {\n    const prerequisites = gateRequest.conditionalLogic?.prerequisites || [];\n    const missing: string[] = [];\n\n    for (const prerequisite of prerequisites) {\n      const result = await this.evaluateCondition(prerequisite, gateRequest.workflowContext);\n      if (!result && prerequisite.required !== false) {\n        missing.push(prerequisite.id);\n      }\n    }\n\n    return {\n      met: missing.length === 0,\n      missing,\n    };\n  }\n\n  private async checkAutoApproval(gateRequest: WorkflowGateRequest): Promise<{\n    approved: boolean;\n    reason?: string;\n  }> {\n    const autoApprovalConditions = gateRequest.conditionalLogic?.autoApprovalConditions || [];\n\n    if (autoApprovalConditions.length === 0) {\n      return { approved: false };\n    }\n\n    for (const condition of autoApprovalConditions) {\n      const result = await this.evaluateCondition(condition, gateRequest.workflowContext);\n      if (result) {\n        return {\n          approved: true,\n          reason: `Auto-approval condition met: ${condition.id}`,\n        };\n      }\n    }\n\n    return { approved: false };\n  }\n\n  private async evaluateCondition(\n    condition: GateCondition,\n    context: WorkflowContext\n  ): Promise<boolean> {\n    // Production-ready sophisticated condition evaluation with type safety and error handling\n    try {\n      const fieldValue = this.getFieldValue(context, condition.field);\n      const expectedValue = condition.value;\n      \n      // Log condition evaluation for debugging\n      logger.debug('Evaluating condition:', {\n        field: condition.field,\n        operator: condition.operator,\n        fieldValue,\n        expectedValue,\n        fieldType: typeof fieldValue,\n        expectedType: typeof expectedValue\n      });\n\n      // Enhanced condition evaluation with type coercion and validation\n      const result = await this.executeConditionOperator(\n        condition.operator,\n        fieldValue,\n        expectedValue,\n        condition\n      );\n\n      // Log evaluation result\n      logger.debug('Condition evaluation result:', {\n        field: condition.field,\n        operator: condition.operator,\n        result,\n        metadata: {\n          evaluation_time: new Date().toISOString(),\n          context_keys: Object.keys(context || {})\n        }\n      });\n\n      return result;\n\n    } catch (error) {\n      logger.error('Error evaluating condition:', {\n        condition,\n        error: error.message,\n        context_summary: this.summarizeContext(context)\n      });\n      \n      // Fail-safe: return false on evaluation error unless it's an 'exists' check\n      return condition.operator === 'not_exists';\n    }\n  }\n\n  private async executeConditionOperator(\n    operator: string,\n    fieldValue: any,\n    expectedValue: any,\n    condition: GateCondition\n  ): Promise<boolean> {\n    switch (operator) {\n      case 'equals':\n        return this.evaluateEquals(fieldValue, expectedValue);\n        \n      case 'not_equals':\n        return !this.evaluateEquals(fieldValue, expectedValue);\n        \n      case 'greater_than':\n        return this.evaluateGreaterThan(fieldValue, expectedValue);\n        \n      case 'greater_than_or_equal':\n        return this.evaluateGreaterThanOrEqual(fieldValue, expectedValue);\n        \n      case 'less_than':\n        return this.evaluateLessThan(fieldValue, expectedValue);\n        \n      case 'less_than_or_equal':\n        return this.evaluateLessThanOrEqual(fieldValue, expectedValue);\n        \n      case 'contains':\n        return this.evaluateContains(fieldValue, expectedValue);\n        \n      case 'not_contains':\n        return !this.evaluateContains(fieldValue, expectedValue);\n        \n      case 'starts_with':\n        return this.evaluateStartsWith(fieldValue, expectedValue);\n        \n      case 'ends_with':\n        return this.evaluateEndsWith(fieldValue, expectedValue);\n        \n      case 'matches':\n        return this.evaluateMatches(fieldValue, expectedValue);\n        \n      case 'not_matches':\n        return !this.evaluateMatches(fieldValue, expectedValue);\n        \n      case 'exists':\n        return this.evaluateExists(fieldValue);\n        \n      case 'not_exists':\n        return !this.evaluateExists(fieldValue);\n        \n      case 'empty':\n        return this.evaluateEmpty(fieldValue);\n        \n      case 'not_empty':\n        return !this.evaluateEmpty(fieldValue);\n        \n      case 'in':\n        return this.evaluateIn(fieldValue, expectedValue);\n        \n      case 'not_in':\n        return !this.evaluateIn(fieldValue, expectedValue);\n        \n      case 'between':\n        return this.evaluateBetween(fieldValue, expectedValue);\n        \n      case 'type_is':\n        return this.evaluateTypeIs(fieldValue, expectedValue);\n        \n      case 'length_equals':\n        return this.evaluateLengthEquals(fieldValue, expectedValue);\n        \n      case 'length_greater_than':\n        return this.evaluateLengthGreaterThan(fieldValue, expectedValue);\n        \n      case 'length_less_than':\n        return this.evaluateLengthLessThan(fieldValue, expectedValue);\n        \n      default:\n        logger.warn('Unknown condition operator:', operator);\n        throw new Error(`Unsupported condition operator: ${operator}`);\n    }\n  }\n\n  // ==================== CONDITION EVALUATION METHODS ====================\n\n  private evaluateEquals(fieldValue: any, expectedValue: any): boolean {\n    // Handle null/undefined comparisons\n    if (fieldValue === null || fieldValue === undefined) {\n      return expectedValue === null || expectedValue === undefined;\n    }\n    \n    // Try strict equality first\n    if (fieldValue === expectedValue) return true;\n    \n    // Try type coercion for numbers and strings\n    if (typeof fieldValue !== typeof expectedValue) {\n      return String(fieldValue) === String(expectedValue);\n    }\n    \n    return false;\n  }\n\n  private evaluateGreaterThan(fieldValue: any, expectedValue: any): boolean {\n    const numField = this.toNumber(fieldValue);\n    const numExpected = this.toNumber(expectedValue);\n    \n    if (numField === null || numExpected === null) {\n      // Fallback to string comparison\n      return String(fieldValue) > String(expectedValue);\n    }\n    \n    return numField > numExpected;\n  }\n\n  private evaluateGreaterThanOrEqual(fieldValue: any, expectedValue: any): boolean {\n    return this.evaluateGreaterThan(fieldValue, expectedValue) || \n           this.evaluateEquals(fieldValue, expectedValue);\n  }\n\n  private evaluateLessThan(fieldValue: any, expectedValue: any): boolean {\n    const numField = this.toNumber(fieldValue);\n    const numExpected = this.toNumber(expectedValue);\n    \n    if (numField === null || numExpected === null) {\n      // Fallback to string comparison\n      return String(fieldValue) < String(expectedValue);\n    }\n    \n    return numField < numExpected;\n  }\n\n  private evaluateLessThanOrEqual(fieldValue: any, expectedValue: any): boolean {\n    return this.evaluateLessThan(fieldValue, expectedValue) || \n           this.evaluateEquals(fieldValue, expectedValue);\n  }\n\n  private evaluateContains(fieldValue: any, expectedValue: any): boolean {\n    if (Array.isArray(fieldValue)) {\n      return fieldValue.includes(expectedValue);\n    }\n    \n    if (fieldValue && typeof fieldValue === 'object') {\n      return Object.prototype.hasOwnProperty.call(fieldValue, expectedValue);\n    }\n    \n    return String(fieldValue).toLowerCase().includes(String(expectedValue).toLowerCase());\n  }\n\n  private evaluateStartsWith(fieldValue: any, expectedValue: any): boolean {\n    return String(fieldValue).toLowerCase().startsWith(String(expectedValue).toLowerCase());\n  }\n\n  private evaluateEndsWith(fieldValue: any, expectedValue: any): boolean {\n    return String(fieldValue).toLowerCase().endsWith(String(expectedValue).toLowerCase());\n  }\n\n  private evaluateMatches(fieldValue: any, expectedValue: any): boolean {\n    try {\n      const regex = new RegExp(String(expectedValue), 'i'); // Case insensitive by default\n      return regex.test(String(fieldValue));\n    } catch (error) {\n      logger.error('Invalid regex pattern:', expectedValue, error);\n      return false;\n    }\n  }\n\n  private evaluateExists(fieldValue: any): boolean {\n    return fieldValue !== undefined && fieldValue !== null;\n  }\n\n  private evaluateEmpty(fieldValue: any): boolean {\n    if (fieldValue === null || fieldValue === undefined) return true;\n    if (typeof fieldValue === 'string') return fieldValue.trim() === '';\n    if (Array.isArray(fieldValue)) return fieldValue.length === 0;\n    if (typeof fieldValue === 'object') return Object.keys(fieldValue).length === 0;\n    return false;\n  }\n\n  private evaluateIn(fieldValue: any, expectedValue: any): boolean {\n    if (!Array.isArray(expectedValue)) {\n      logger.warn('Expected array for \"in\" operator, got:', typeof expectedValue);\n      return false;\n    }\n    \n    return expectedValue.includes(fieldValue);\n  }\n\n  private evaluateBetween(fieldValue: any, expectedValue: any): boolean {\n    if (!Array.isArray(expectedValue) || expectedValue.length !== 2) {\n      logger.warn('Expected array of length 2 for \"between\" operator');\n      return false;\n    }\n    \n    const numField = this.toNumber(fieldValue);\n    const minValue = this.toNumber(expectedValue[0]);\n    const maxValue = this.toNumber(expectedValue[1]);\n    \n    if (numField === null || minValue === null || maxValue === null) {\n      return false;\n    }\n    \n    return numField >= minValue && numField <= maxValue;\n  }\n\n  private evaluateTypeIs(fieldValue: any, expectedValue: any): boolean {\n    const actualType = Array.isArray(fieldValue) ? 'array' : typeof fieldValue;\n    return actualType === String(expectedValue).toLowerCase();\n  }\n\n  private evaluateLengthEquals(fieldValue: any, expectedValue: any): boolean {\n    const length = this.getLength(fieldValue);\n    return length !== null && length === this.toNumber(expectedValue);\n  }\n\n  private evaluateLengthGreaterThan(fieldValue: any, expectedValue: any): boolean {\n    const length = this.getLength(fieldValue);\n    const expected = this.toNumber(expectedValue);\n    return length !== null && expected !== null && length > expected;\n  }\n\n  private evaluateLengthLessThan(fieldValue: any, expectedValue: any): boolean {\n    const length = this.getLength(fieldValue);\n    const expected = this.toNumber(expectedValue);\n    return length !== null && expected !== null && length < expected;\n  }\n\n  // ==================== HELPER METHODS ====================\n\n  private toNumber(value: any): number | null {\n    if (typeof value === 'number' && !isNaN(value)) return value;\n    \n    const parsed = Number(value);\n    return isNaN(parsed) ? null : parsed;\n  }\n\n  private getLength(value: any): number | null {\n    if (typeof value === 'string') return value.length;\n    if (Array.isArray(value)) return value.length;\n    if (value && typeof value === 'object') return Object.keys(value).length;\n    return null;\n  }\n\n  private summarizeContext(context: WorkflowContext): any {\n    if (!context) return null;\n    \n    return {\n      keys: Object.keys(context),\n      hasData: Object.keys(context).length > 0,\n      types: Object.entries(context).reduce((acc, [key, value]) => {\n        acc[key] = Array.isArray(value) ? 'array' : typeof value;\n        return acc;\n      }, {} as Record<string, string>)\n    };\n  }\n\n  private getFieldValue(context: WorkflowContext, field: string): any {\n    const parts = field.split('.');\n    let value: any = context;\n\n    for (const part of parts) {\n      value = value?.[part];\n    }\n\n    return value;\n  }\n\n  private createDefaultEscalationChain(gateRequest: WorkflowGateRequest): EscalationChain {\n    const levels: EscalationLevel[] = [];\n\n    // Create escalation levels based on business impact\n    switch (gateRequest.workflowContext.businessImpact) {\n      case 'low':\n        levels.push({\n          level: GateEscalationLevel.TEAM_LEAD,\n          approvers: ['team-lead'],\n          requiredApprovals: 1,\n          timeLimit: 3600000, // 1 hour\n        });\n        break;\n\n      case 'medium':\n        levels.push(\n          {\n            level: GateEscalationLevel.TEAM_LEAD,\n            approvers: ['team-lead'],\n            requiredApprovals: 1,\n            timeLimit: 1800000, // 30 minutes\n          },\n          {\n            level: GateEscalationLevel.MANAGER,\n            approvers: ['manager'],\n            requiredApprovals: 1,\n            timeLimit: 3600000, // 1 hour\n          }\n        );\n        break;\n\n      case 'high':\n      case 'critical':\n        levels.push(\n          {\n            level: GateEscalationLevel.TEAM_LEAD,\n            approvers: ['team-lead'],\n            requiredApprovals: 1,\n            timeLimit: 900000, // 15 minutes\n          },\n          {\n            level: GateEscalationLevel.MANAGER,\n            approvers: ['manager'],\n            requiredApprovals: 1,\n            timeLimit: 1800000, // 30 minutes\n          },\n          {\n            level: GateEscalationLevel.DIRECTOR,\n            approvers: ['director'],\n            requiredApprovals: 1,\n            timeLimit: 3600000, // 1 hour\n          }\n        );\n        break;\n    }\n\n    return {\n      id: `escalation-${gateRequest.id}`,\n      levels,\n      triggers: [\n        {\n          type: 'timeout',\n          threshold: 'time_limit',\n          delay: 0,\n        },\n        {\n          type: 'business_impact',\n          threshold: gateRequest.workflowContext.businessImpact,\n          delay: 300000, // 5 minutes\n        },\n      ],\n      maxLevel: this.config.maxEscalationLevel || GateEscalationLevel.EXECUTIVE,\n    };\n  }\n\n  private async requestHumanValidation(\n    gateRequest: WorkflowGateRequest,\n    escalationChain: EscalationChain,\n    correlationId: string\n  ): Promise<HumanValidationResult> {\n    // Create human validation request event for integration with existing AGUI system\n    const validationRequestEvent: HumanValidationRequestedEvent = createEvent(\n      'human.validation.requested',\n      Domain.INTERFACES,\n      {\n        payload: {\n          requestId: `gate-${gateRequest.id}`,\n          validationType: gateRequest.gateType === 'approval' ? 'approval' : 'review',\n          context: {\n            workflowGate: gateRequest,\n            escalationChain,\n          },\n          priority: this.mapPriorityToEventPriority(gateRequest.priority),\n          timeout: gateRequest.timeoutConfig?.initialTimeout || this.config.defaultTimeout,\n        },\n      },\n      {\n        correlationId,\n        source: 'workflow-gate-processor',\n      }\n    );\n\n    // Emit validation request event\n    const eventResult = await this.eventBus.emitEvent(validationRequestEvent);\n    if (!eventResult.success) {\n      throw new Error(`Failed to emit validation request: ${eventResult.error?.message}`);\n    }\n\n    // Use existing AGUI interface for actual validation\n    try {\n      const response = await this.aguiInterface.askQuestion(gateRequest);\n\n      return {\n        approved: this.interpretResponse(response),\n        response,\n        processingTime: Date.now() - validationRequestEvent.timestamp.getTime(),\n        level: GateEscalationLevel.TEAM_LEAD, // Start with team lead level\n        approver: 'user',\n      };\n    } catch (error) {\n      throw new Error(\n        `Human validation failed: ${error instanceof Error ? error.message : String(error)}`\n      );\n    }\n  }\n\n  private async processEscalationChain(\n    gateId: string,\n    initialResult: HumanValidationResult,\n    escalationChain: EscalationChain\n  ): Promise<WorkflowGateResult> {\n    const pendingGate = this.pendingGates.get(gateId);\n    if (!pendingGate) {\n      throw new Error(`Pending gate not found: ${gateId}`);\n    }\n\n    // If initially approved, we're done\n    if (initialResult.approved) {\n      return {\n        success: true,\n        gateId,\n        approved: true,\n        processingTime: initialResult.processingTime,\n        escalationLevel: initialResult.level,\n        decisionMaker: initialResult.approver,\n        correlationId: pendingGate.correlationId,\n      };\n    }\n\n    // Process escalation chain\n    let currentLevel = GateEscalationLevel.TEAM_LEAD;\n    let finalApproval = false;\n    let finalLevel = GateEscalationLevel.NONE;\n    let decisionMaker = 'unknown';\n\n    for (const level of escalationChain.levels) {\n      if (level.level <= currentLevel) continue;\n\n      currentLevel = level.level;\n      pendingGate.currentLevel = currentLevel;\n\n      this.logger.info('Escalating to level', {\n        gateId,\n        level: currentLevel,\n        approvers: level.approvers,\n      });\n\n      // Set escalation timer if time limit specified\n      if (level.timeLimit) {\n        this.setEscalationTimer(gateId, level.timeLimit, currentLevel);\n      }\n\n      // Simulate approval at this level (in production, this would involve actual approver interaction)\n      const approval = await this.simulateApprovalAtLevel(level, pendingGate);\n\n      const approvalRecord: ApprovalRecord = {\n        approver: approval.approver,\n        timestamp: new Date(),\n        decision: approval.decision,\n        comments: approval.comments,\n        level: currentLevel,\n        responseTime: approval.responseTime,\n      };\n\n      pendingGate.approvals.push(approvalRecord);\n\n      if (approval.decision === 'approve') {\n        finalApproval = true;\n        finalLevel = currentLevel;\n        decisionMaker = approval.approver;\n        break;\n      } else if (approval.decision === 'reject') {\n        finalApproval = false;\n        finalLevel = currentLevel;\n        decisionMaker = approval.approver;\n        break;\n      }\n      // If 'escalate', continue to next level\n    }\n\n    // Clear any remaining timers\n    this.clearEscalationTimers(gateId);\n\n    return {\n      success: true,\n      gateId,\n      approved: finalApproval,\n      processingTime: Date.now() - pendingGate.startTime.getTime(),\n      escalationLevel: finalLevel,\n      decisionMaker,\n      approvalChain: {\n        completed: true,\n        approved: finalApproval,\n        decisionLevel: finalLevel,\n        decisionMaker,\n        processingTime: Date.now() - pendingGate.startTime.getTime(),\n        approvals: pendingGate.approvals,\n        escalations: pendingGate.escalations,\n      },\n      correlationId: pendingGate.correlationId,\n    };\n  }\n\n  private async simulateApprovalAtLevel(\n    level: EscalationLevel,\n    pendingGate: PendingGateRequest\n  ): Promise<{\n    decision: 'approve' | 'reject' | 'escalate';\n    approver: string;\n    comments?: string;\n    responseTime: number;\n  }> {\n    const startTime = Date.now();\n\n    // Simulate decision making based on business impact and level\n    const businessImpact = pendingGate.gateRequest.workflowContext.businessImpact;\n    const approver = level.approvers[0] || 'unknown';\n\n    // Simple simulation logic\n    let decision: 'approve' | 'reject' | 'escalate' = 'approve';\n    let comments = `Approved at ${GateEscalationLevel[level.level]} level`;\n\n    if (businessImpact === 'critical' && level.level < GateEscalationLevel.DIRECTOR) {\n      decision = 'escalate';\n      comments = 'Critical impact requires higher level approval';\n    } else if (businessImpact === 'high' && level.level < GateEscalationLevel.MANAGER) {\n      decision = 'escalate';\n      comments = 'High impact requires management approval';\n    }\n\n    // Simulate processing time\n    const responseTime = Date.now() - startTime + 100; // Add some processing time\n\n    return {\n      decision,\n      approver,\n      comments,\n      responseTime,\n    };\n  }\n\n  private async emitGateOpenedEvent(\n    gateRequest: WorkflowGateRequest,\n    correlationId: string\n  ): Promise<void> {\n    const gateOpenedEvent: AGUIGateOpenedEvent = createEvent(\n      'agui.gate.opened',\n      Domain.INTERFACES,\n      {\n        payload: {\n          gateId: gateRequest.id,\n          gateType: gateRequest.gateType,\n          requiredApproval: gateRequest.gateType !== 'checkpoint',\n          context: {\n            workflowContext: gateRequest.workflowContext,\n            question: gateRequest.question,\n            businessImpact: gateRequest.workflowContext.businessImpact,\n          },\n        },\n      },\n      { correlationId, source: 'workflow-gate-processor' }\n    );\n\n    const result = await this.eventBus.emitEvent(gateOpenedEvent);\n    if (!result.success) {\n      this.logger.warn('Failed to emit gate opened event', {\n        gateId: gateRequest.id,\n        error: result.error?.message,\n      });\n    }\n  }\n\n  private async emitGateClosedEvent(\n    gateRequest: WorkflowGateRequest,\n    result: WorkflowGateResult,\n    correlationId: string\n  ): Promise<void> {\n    const gateClosedEvent: AGUIGateClosedEvent = createEvent(\n      'agui.gate.closed',\n      Domain.INTERFACES,\n      {\n        payload: {\n          gateId: gateRequest.id,\n          approved: result.approved,\n          duration: result.processingTime,\n          humanInput: {\n            escalationLevel: result.escalationLevel,\n            decisionMaker: result.decisionMaker,\n            approvalChain: result.approvalChain,\n          },\n        },\n      },\n      { correlationId, causationId: `gate-${gateRequest.id}` }\n    );\n\n    const eventResult = await this.eventBus.emitEvent(gateClosedEvent);\n    if (!eventResult.success) {\n      this.logger.warn('Failed to emit gate closed event', {\n        gateId: gateRequest.id,\n        error: eventResult.error?.message,\n      });\n    }\n  }\n\n  private initializeEventHandlers(): void {\n    // Listen for human validation completion events\n    this.eventBus.registerHandler(\n      'human.validation.completed',\n      async (event: HumanValidationCompletedEvent) => {\n        const { requestId, approved, feedback } = event.payload;\n\n        // Check if this is for one of our gates\n        const gateId = requestId.replace('gate-', '');\n        const pendingGate = this.pendingGates.get(gateId);\n\n        if (pendingGate) {\n          this.logger.debug('Received validation completion for gate', {\n            gateId,\n            approved,\n            feedback,\n          });\n\n          // Emit internal event for gate processing\n          this.emit('validation-completed', {\n            gateId,\n            approved,\n            feedback,\n            processingTime: event.payload.processingTime,\n          });\n        }\n      }\n    );\n  }\n\n  private setEscalationTimer(gateId: string, timeLimit: number, level: GateEscalationLevel): void {\n    const timerId = setTimeout(() => {\n      this.logger.info('Escalation timer triggered', { gateId, level });\n      this.emit('escalation-timeout', { gateId, level });\n    }, timeLimit);\n\n    // Store timer for cleanup\n    const timerKey = `${gateId}-${level}`;\n    this.escalationTimers.set(timerKey, timerId);\n  }\n\n  private clearEscalationTimers(gateId: string): void {\n    // Clear all timers for this gate\n    for (const [key, timerId] of this.escalationTimers.entries()) {\n      if (key.startsWith(gateId)) {\n        clearTimeout(timerId);\n        this.escalationTimers.delete(key);\n      }\n    }\n  }\n\n  private cleanup(gateId: string): void {\n    this.pendingGates.delete(gateId);\n    this.clearEscalationTimers(gateId);\n  }\n\n  private interpretResponse(response: string): boolean {\n    const positiveResponses = ['yes', 'approve', 'approved', 'accept', 'ok', 'continue', '1'];\n    return positiveResponses.some((pos) => response.toLowerCase().includes(pos));\n  }\n\n  private mapPriorityToEventPriority(priority?: string): EventPriority {\n    switch (priority) {\n      case 'critical':\n        return EventPriority.CRITICAL;\n      case 'high':\n        return EventPriority.HIGH;\n      case 'medium':\n        return EventPriority.NORMAL;\n      case 'low':\n        return EventPriority.LOW;\n      default:\n        return EventPriority.NORMAL;\n    }\n  }\n}\n\n// ============================================================================\n// SUPPORTING TYPES AND INTERFACES\n// ============================================================================\n\n/**\n * Configuration for WorkflowGateRequestProcessor\n */\nexport interface WorkflowGateProcessorConfig {\n  enableMetrics?: boolean;\n  enableDomainValidation?: boolean;\n  defaultTimeout?: number;\n  maxEscalationLevel?: GateEscalationLevel;\n  enableAutoApproval?: boolean;\n}\n\n/**\n * Pending gate request tracking\n */\ninterface PendingGateRequest {\n  gateRequest: WorkflowGateRequest;\n  escalationChain: EscalationChain;\n  correlationId: string;\n  startTime: Date;\n  currentLevel: GateEscalationLevel;\n  approvals: ApprovalRecord[];\n  escalations: EscalationRecord[];\n  status: 'pending' | 'processing' | 'completed' | 'cancelled' | 'failed';\n}\n\n/**\n * Human validation result\n */\ninterface HumanValidationResult {\n  approved: boolean;\n  response: string;\n  processingTime: number;\n  level: GateEscalationLevel;\n  approver: string;\n}\n\n/**\n * Workflow gate processing result\n */\nexport interface WorkflowGateResult {\n  success: boolean;\n  gateId: string;\n  approved: boolean;\n  processingTime: number;\n  escalationLevel: GateEscalationLevel;\n  decisionMaker?: string;\n  error?: Error;\n  autoApproved?: boolean;\n  approvalChain?: ApprovalChainResult;\n  correlationId: string;\n}\n\n// ============================================================================\n// FACTORY FUNCTIONS - Convenience functions for common usage\n// ============================================================================\n\n/**\n * Create a simple approval gate\n */\nexport function createApprovalGate(\n  workflowId: string,\n  stepName: string,\n  question: string,\n  stakeholders: string[],\n  options: {\n    businessImpact?: WorkflowContext['businessImpact'];\n    deadline?: Date;\n    priority?: ValidationQuestion['priority'];\n  } = {}\n): WorkflowGateRequest {\n  const gateId = `gate-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n\n  const fullWorkflowContext: WorkflowContext = {\n    workflowId,\n    stepName,\n    businessImpact: options.businessImpact || 'medium',\n    decisionScope: 'task',\n    stakeholders,\n    deadline: options.deadline,\n  };\n\n  return {\n    // ValidationQuestion base properties\n    id: gateId,\n    type: 'checkpoint',\n    question,\n    context: { type: 'approval_request' },\n    confidence: 0.8,\n    priority: options.priority || 'medium',\n    validationReason: `Workflow gate for ${stepName}`,\n    expectedImpact: 0.1,\n\n    // WorkflowGateRequest specific properties\n    workflowContext: fullWorkflowContext,\n    gateType: 'approval',\n  };\n}\n\n/**\n * Create a checkpoint gate for workflow progress validation\n */\nexport function createCheckpointGate(\n  workflowId: string,\n  stepName: string,\n  checkpointData: any,\n  options: {\n    autoApprovalThreshold?: number;\n    businessImpact?: WorkflowContext['businessImpact'];\n  } = {}\n): WorkflowGateRequest {\n  const gateId = `gate-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n\n  const autoApprovalConditions: GateCondition[] = [];\n  if (options.autoApprovalThreshold) {\n    autoApprovalConditions.push({\n      id: 'confidence_threshold',\n      type: 'custom',\n      operator: 'greater_than',\n      field: 'confidence',\n      value: options.autoApprovalThreshold,\n    });\n  }\n\n  const fullWorkflowContext: WorkflowContext = {\n    workflowId,\n    stepName,\n    businessImpact: options.businessImpact || 'low',\n    decisionScope: 'task',\n    stakeholders: ['system'],\n  };\n\n  return {\n    // ValidationQuestion base properties\n    id: gateId,\n    type: 'checkpoint',\n    question: `Checkpoint reached: ${stepName}. Continue?`,\n    context: checkpointData,\n    confidence: 0.8,\n    priority: 'medium',\n    validationReason: `Workflow gate for ${stepName}`,\n    expectedImpact: 0.1,\n\n    // WorkflowGateRequest specific properties\n    workflowContext: fullWorkflowContext,\n    gateType: 'checkpoint',\n    conditionalLogic: {\n      autoApprovalConditions:\n        autoApprovalConditions.length > 0 ? autoApprovalConditions : undefined,\n    },\n    integrationConfig: {\n      domainValidation: true,\n      enableMetrics: true,\n    },\n  };\n}\n\n/**\n * Create an emergency gate for critical decisions\n */\nexport function createEmergencyGate(\n  workflowId: string,\n  stepName: string,\n  emergencyContext: any,\n  stakeholders: string[]\n): WorkflowGateRequest {\n  const gateId = `gate-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n\n  const escalationChain: EscalationChain = {\n    id: `emergency-${workflowId}-${stepName}`,\n    levels: [\n      {\n        level: GateEscalationLevel.MANAGER,\n        approvers: stakeholders.slice(0, 1),\n        requiredApprovals: 1,\n        timeLimit: 300000, // 5 minutes\n      },\n      {\n        level: GateEscalationLevel.DIRECTOR,\n        approvers: stakeholders.slice(1, 2),\n        requiredApprovals: 1,\n        timeLimit: 600000, // 10 minutes\n      },\n      {\n        level: GateEscalationLevel.EXECUTIVE,\n        approvers: stakeholders.slice(2),\n        requiredApprovals: 1,\n        timeLimit: 900000, // 15 minutes\n      },\n    ],\n    triggers: [\n      {\n        type: 'timeout',\n        threshold: 'time_limit',\n        delay: 0,\n        skipLevels: true,\n      },\n    ],\n    maxLevel: GateEscalationLevel.EXECUTIVE,\n    notifyAllLevels: true,\n  };\n\n  const fullWorkflowContext: WorkflowContext = {\n    workflowId,\n    stepName,\n    businessImpact: 'critical',\n    decisionScope: 'portfolio',\n    stakeholders,\n    deadline: new Date(Date.now() + 1800000), // 30 minutes from now\n  };\n\n  return {\n    // ValidationQuestion base properties\n    id: gateId,\n    type: 'checkpoint',\n    question: 'EMERGENCY: Immediate decision required',\n    context: emergencyContext,\n    confidence: 0.8,\n    priority: 'critical',\n    validationReason: `Workflow gate for ${stepName}`,\n    expectedImpact: 0.9,\n\n    // WorkflowGateRequest specific properties\n    workflowContext: fullWorkflowContext,\n    gateType: 'emergency',\n    escalationChain,\n    timeoutConfig: {\n      initialTimeout: 300000, // 5 minutes\n      escalationTimeouts: [300000, 600000, 900000],\n      maxTotalTimeout: 1800000, // 30 minutes total\n    },\n  };\n}\n\n// ============================================================================\n// EXPORTS\n// ============================================================================\n\nexport default WorkflowGateRequestProcessor;\n\nexport type {\n  WorkflowContext,\n  WorkflowDependency,\n  ImpactEstimate,\n  RiskFactor,\n  WorkflowDecisionRecord,\n  EscalationChain,\n  EscalationLevel,\n  EscalationTrigger,\n  EscalationRecord,\n  ApprovalRecord,\n  ApprovalChainResult,\n  GateCondition,\n  WorkflowGateRequest,\n  WorkflowGateResult,\n  WorkflowGateProcessorConfig,\n  NotificationConfig,\n};\n", "/**\n * @file Domain Boundary Validator - Critical Infrastructure for Phase 0\n *\n * Implements comprehensive runtime type validation at domain boundaries,\n * contract enforcement for domain operations, and domain crossing monitoring.\n *\n * This is the foundation system that all subsequent phases build upon.\n *\n * ARCHITECTURE: Multi-Agent Cognitive Architecture compliant\n * - Type safety across domain boundaries\n * - Runtime contract validation\n * - Performance optimized for production\n * - Comprehensive error handling and logging\n * - Integration with existing domain types system\n */\n\nimport type { Logger } from '../config/logging-config.ts';\nimport { getLogger } from '../config/logging-config.ts';\nimport type { Agent, Task } from '../coordination/types.ts';\nimport type { WorkflowContext, WorkflowDefinition } from '../workflows/types.ts';\n\n// ============================================================================\n// CORE TYPE SYSTEM - Foundation for all domain validation\n// ============================================================================\n\n/**\n * Schema definition for runtime type validation\n */\nexport interface TypeSchema<T = any> {\n  type: 'string' | 'number' | 'boolean' | 'object' | 'array' | 'null' | 'undefined' | 'function';\n  required?: boolean;\n  properties?: { [K in keyof T]?: TypeSchema<T[K]> };\n  items?: TypeSchema;\n  enum?: T[];\n  validator?: (value: any) => boolean;\n  transform?: (value: any) => T;\n  description?: string;\n}\n\n/**\n * Result type for domain operations with comprehensive error handling\n */\nexport type Result<T = any, E = Error> =\n  | {\n      success: true;\n      data: T;\n      metadata?: DomainMetadata;\n    }\n  | {\n      success: false;\n      error: E;\n      metadata?: DomainMetadata;\n    };\n\n/**\n * Domain metadata for operation tracking and debugging\n */\nexport interface DomainMetadata {\n  domainFrom?: Domain;\n  domainTo?: Domain;\n  operation: string;\n  timestamp: Date;\n  validationTime: number;\n  crossingId: string;\n  performanceMetrics?: PerformanceMetrics;\n}\n\n/**\n * Performance metrics for optimization and monitoring\n */\nexport interface PerformanceMetrics {\n  validationTimeMs: number;\n  schemaComplexity: number;\n  dataSize: number;\n  cacheHit?: boolean;\n  errorCount: number;\n}\n\n/**\n * Domain enumeration covering all system domains\n */\nexport enum Domain {\n  COORDINATION = 'coordination',\n  WORKFLOWS = 'workflows',\n  NEURAL = 'neural',\n  DATABASE = 'database',\n  MEMORY = 'memory',\n  KNOWLEDGE = 'knowledge',\n  OPTIMIZATION = 'optimization',\n  INTERFACES = 'interfaces',\n  CORE = 'core',\n}\n\n/**\n * Domain operation definition with contracts\n */\nexport interface DomainOperation {\n  id: string;\n  sourceDomain: Domain;\n  targetDomain: Domain;\n  operationType: 'read' | 'write' | 'execute' | 'transform' | 'validate';\n  inputSchema: TypeSchema;\n  outputSchema: TypeSchema;\n  contractValidation: ContractRule[];\n  metadata: {\n    description: string;\n    version: string;\n    rateLimit?: number;\n    timeout?: number;\n    retryPolicy?: RetryPolicy;\n  };\n}\n\n/**\n * Contract validation rules for domain operations\n */\nexport interface ContractRule {\n  name: string;\n  description: string;\n  validator: (input: any, context: DomainContext) => Promise<boolean>;\n  severity: 'error' | 'warning' | 'info';\n  errorMessage: string;\n}\n\n/**\n * Domain context for validation operations\n */\nexport interface DomainContext {\n  currentDomain: Domain;\n  operation: string;\n  timestamp: Date;\n  requestId: string;\n  metadata?: Record<string, any>;\n}\n\n/**\n * Retry policy for failed operations\n */\nexport interface RetryPolicy {\n  maxAttempts: number;\n  backoffStrategy: 'linear' | 'exponential';\n  baseDelay: number;\n  maxDelay: number;\n}\n\n// ============================================================================\n// DOMAIN BOUNDARY INTERFACE - Core contract for all boundary validation\n// ============================================================================\n\n/**\n * Core domain boundary interface that all domains must implement\n */\nexport interface DomainBoundary {\n  /**\n   * Validate input data against a schema with runtime type checking\n   */\n  validateInput<T>(data: unknown, schema: TypeSchema<T>): T;\n\n  /**\n   * Enforce contract rules for domain operations\n   */\n  enforceContract(operation: DomainOperation): Promise<Result>;\n\n  /**\n   * Track domain crossings for architecture compliance monitoring\n   */\n  trackCrossings(from: Domain, to: Domain, operation: string): void;\n}\n\n// ============================================================================\n// VALIDATION ERROR SYSTEM - Comprehensive error handling\n// ============================================================================\n\n/**\n * Domain validation error with rich context\n */\nexport class DomainValidationError extends Error {\n  public readonly code: string;\n  public readonly domain: Domain;\n  public readonly operation: string;\n  public readonly validationPath: string[];\n  public readonly actualValue: any;\n  public readonly expectedType: string;\n  public readonly timestamp: Date;\n\n  constructor(\n    message: string,\n    code: string,\n    domain: Domain,\n    operation: string,\n    validationPath: string[] = [],\n    actualValue?: any,\n    expectedType?: string\n  ) {\n    super(message);\n    this.name = 'DomainValidationError';\n    this.code = code;\n    this.domain = domain;\n    this.operation = operation;\n    this.validationPath = validationPath;\n    this.actualValue = actualValue;\n    this.expectedType = expectedType || 'unknown';\n    this.timestamp = new Date();\n  }\n}\n\n/**\n * Contract violation error for operation enforcement\n */\nexport class ContractViolationError extends Error {\n  public readonly contractRule: string;\n  public readonly domain: Domain;\n  public readonly operation: string;\n  public readonly severity: 'error' | 'warning' | 'info';\n  public readonly timestamp: Date;\n\n  constructor(\n    message: string,\n    contractRule: string,\n    domain: Domain,\n    operation: string,\n    severity: 'error' | 'warning' | 'info' = 'error'\n  ) {\n    super(message);\n    this.name = 'ContractViolationError';\n    this.contractRule = contractRule;\n    this.domain = domain;\n    this.operation = operation;\n    this.severity = severity;\n    this.timestamp = new Date();\n  }\n}\n\n// ============================================================================\n// DOMAIN BOUNDARY VALIDATOR IMPLEMENTATION - Production-grade validator\n// ============================================================================\n\n/**\n * Production-grade domain boundary validator with comprehensive features\n */\nexport class DomainBoundaryValidator implements DomainBoundary {\n  private readonly logger: Logger;\n  private readonly validationCache = new Map<string, any>();\n  private readonly crossingLog: DomainCrossing[] = [];\n  private readonly performanceMetrics = new Map<string, PerformanceMetrics>();\n\n  // Performance optimization settings\n  private readonly cacheEnabled: boolean = true;\n  private readonly maxCacheSize: number = 1000;\n  private readonly maxCrossingLogSize: number = 10000;\n\n  constructor(\n    private readonly domain: Domain,\n    options: {\n      cacheEnabled?: boolean;\n      maxCacheSize?: number;\n      maxCrossingLogSize?: number;\n    } = {}\n  ) {\n    this.logger = getLogger(`domain-boundary-${domain}`);\n    this.cacheEnabled = options.cacheEnabled ?? true;\n    this.maxCacheSize = options.maxCacheSize ?? 1000;\n    this.maxCrossingLogSize = options.maxCrossingLogSize ?? 10000;\n\n    this.logger.info(`Initialized domain boundary validator for ${domain}`, {\n      cacheEnabled: this.cacheEnabled,\n      maxCacheSize: this.maxCacheSize,\n    });\n  }\n\n  /**\n   * Validate input data against schema with comprehensive runtime checking\n   */\n  public validateInput<T>(data: unknown, schema: TypeSchema<T>): T {\n    const startTime = Date.now();\n    const cacheKey = this.generateCacheKey(data, schema);\n\n    // Check cache first for performance\n    if (this.cacheEnabled && this.validationCache.has(cacheKey)) {\n      this.logger.debug('Cache hit for validation', { cacheKey });\n      return this.validationCache.get(cacheKey);\n    }\n\n    try {\n      const result = this.performValidation(data, schema, []);\n      const validationTime = Date.now() - startTime;\n\n      // Cache successful validation\n      if (this.cacheEnabled) {\n        this.updateCache(cacheKey, result);\n      }\n\n      // Track performance metrics\n      this.updatePerformanceMetrics(schema.description || 'unknown', {\n        validationTimeMs: validationTime,\n        schemaComplexity: this.calculateSchemaComplexity(schema),\n        dataSize: this.estimateDataSize(data),\n        cacheHit: false,\n        errorCount: 0,\n      });\n\n      this.logger.debug('Validation successful', {\n        domain: this.domain,\n        validationTime,\n        schemaType: schema.type,\n      });\n\n      return result;\n    } catch (error) {\n      const validationTime = Date.now() - startTime;\n\n      // Track failed validation metrics\n      this.updatePerformanceMetrics(schema.description || 'unknown', {\n        validationTimeMs: validationTime,\n        schemaComplexity: this.calculateSchemaComplexity(schema),\n        dataSize: this.estimateDataSize(data),\n        cacheHit: false,\n        errorCount: 1,\n      });\n\n      this.logger.error('Validation failed', {\n        domain: this.domain,\n        error: error instanceof Error ? error.message : String(error),\n        validationTime,\n        dataType: typeof data,\n      });\n\n      throw error;\n    }\n  }\n\n  /**\n   * Enforce contract rules for domain operations\n   */\n  public async enforceContract(operation: DomainOperation): Promise<Result> {\n    const startTime = Date.now();\n    const crossingId = this.generateCrossingId();\n\n    this.logger.info('Enforcing contract', {\n      operationId: operation.id,\n      sourceDomain: operation.sourceDomain,\n      targetDomain: operation.targetDomain,\n      crossingId,\n    });\n\n    try {\n      // Create domain context for validation\n      const context: DomainContext = {\n        currentDomain: this.domain,\n        operation: operation.id,\n        timestamp: new Date(),\n        requestId: crossingId,\n        metadata: operation.metadata,\n      };\n\n      // Validate all contract rules\n      const violations: ContractViolationError[] = [];\n\n      for (const rule of operation.contractValidation) {\n        try {\n          const isValid = await rule.validator(operation, context);\n\n          if (!isValid) {\n            const violation = new ContractViolationError(\n              rule.errorMessage,\n              rule.name,\n              operation.sourceDomain,\n              operation.id,\n              rule.severity\n            );\n            violations.push(violation);\n\n            this.logger.warn('Contract rule violation', {\n              rule: rule.name,\n              severity: rule.severity,\n              operation: operation.id,\n            });\n          }\n        } catch (error) {\n          const violation = new ContractViolationError(\n            `Contract rule execution failed: ${error instanceof Error ? error.message : String(error)}`,\n            rule.name,\n            operation.sourceDomain,\n            operation.id,\n            'error'\n          );\n          violations.push(violation);\n        }\n      }\n\n      // Check for blocking errors\n      const errorViolations = violations.filter((v) => v.severity === 'error');\n\n      if (errorViolations.length > 0) {\n        return {\n          success: false,\n          error: errorViolations[0],\n          metadata: {\n            domainFrom: operation.sourceDomain,\n            domainTo: operation.targetDomain,\n            operation: operation.id,\n            timestamp: new Date(),\n            validationTime: Date.now() - startTime,\n            crossingId,\n            performanceMetrics: {\n              validationTimeMs: Date.now() - startTime,\n              schemaComplexity: operation.contractValidation.length,\n              dataSize: JSON.stringify(operation).length,\n              errorCount: errorViolations.length,\n            },\n          },\n        };\n      }\n\n      // Log warnings for non-blocking violations\n      const warnings = violations.filter((v) => v.severity === 'warning');\n      if (warnings.length > 0) {\n        this.logger.warn('Contract warnings detected', {\n          warningCount: warnings.length,\n          operation: operation.id,\n        });\n      }\n\n      return {\n        success: true,\n        data: operation,\n        metadata: {\n          domainFrom: operation.sourceDomain,\n          domainTo: operation.targetDomain,\n          operation: operation.id,\n          timestamp: new Date(),\n          validationTime: Date.now() - startTime,\n          crossingId,\n          performanceMetrics: {\n            validationTimeMs: Date.now() - startTime,\n            schemaComplexity: operation.contractValidation.length,\n            dataSize: JSON.stringify(operation).length,\n            errorCount: 0,\n          },\n        },\n      };\n    } catch (error) {\n      this.logger.error('Contract enforcement failed', {\n        operationId: operation.id,\n        error: error instanceof Error ? error.message : String(error),\n      });\n\n      return {\n        success: false,\n        error: error instanceof Error ? error : new Error(String(error)),\n        metadata: {\n          domainFrom: operation.sourceDomain,\n          domainTo: operation.targetDomain,\n          operation: operation.id,\n          timestamp: new Date(),\n          validationTime: Date.now() - startTime,\n          crossingId,\n        },\n      };\n    }\n  }\n\n  /**\n   * Track domain crossings for architecture compliance monitoring\n   */\n  public trackCrossings(from: Domain, to: Domain, operation: string): void {\n    const crossing: DomainCrossing = {\n      id: this.generateCrossingId(),\n      fromDomain: from,\n      toDomain: to,\n      operation,\n      timestamp: new Date(),\n      currentDomain: this.domain,\n    };\n\n    this.crossingLog.push(crossing);\n\n    // Maintain log size limit for performance\n    if (this.crossingLog.length > this.maxCrossingLogSize) {\n      this.crossingLog.splice(0, this.crossingLog.length - this.maxCrossingLogSize);\n    }\n\n    this.logger.debug('Domain crossing tracked', {\n      crossingId: crossing.id,\n      from,\n      to,\n      operation,\n      totalCrossings: this.crossingLog.length,\n    });\n  }\n\n  // ============================================================================\n  // PUBLIC API EXTENSIONS - Additional functionality for comprehensive validation\n  // ============================================================================\n\n  /**\n   * Get performance metrics for optimization\n   */\n  public getPerformanceMetrics(): Map<string, PerformanceMetrics> {\n    return new Map(this.performanceMetrics);\n  }\n\n  /**\n   * Get domain crossing history for compliance analysis\n   */\n  public getDomainCrossings(limit?: number): DomainCrossing[] {\n    const crossings = [...this.crossingLog];\n    if (limit && limit > 0) {\n      return crossings.slice(-limit);\n    }\n    return crossings;\n  }\n\n  /**\n   * Clear caches and reset metrics (for testing/maintenance)\n   */\n  public reset(): void {\n    this.validationCache.clear();\n    this.crossingLog.length = 0;\n    this.performanceMetrics.clear();\n    this.logger.info('Domain boundary validator reset', {\n      domain: this.domain,\n    });\n  }\n\n  /**\n   * Get validation statistics\n   */\n  public getStatistics(): ValidationStatistics {\n    const totalValidations = Array.from(this.performanceMetrics.values()).reduce(\n      (sum, metrics) => sum + (metrics.errorCount >= 0 ? 1 : 0),\n      0\n    );\n\n    const totalErrors = Array.from(this.performanceMetrics.values()).reduce(\n      (sum, metrics) => sum + metrics.errorCount,\n      0\n    );\n\n    const avgValidationTime =\n      Array.from(this.performanceMetrics.values()).reduce(\n        (sum, metrics) => sum + metrics.validationTimeMs,\n        0\n      ) / Math.max(1, this.performanceMetrics.size);\n\n    return {\n      domain: this.domain,\n      totalValidations,\n      totalErrors,\n      errorRate: totalValidations > 0 ? totalErrors / totalValidations : 0,\n      averageValidationTime: avgValidationTime,\n      cacheSize: this.validationCache.size,\n      crossingCount: this.crossingLog.length,\n      lastResetTime: new Date(),\n    };\n  }\n\n  // ============================================================================\n  // PRIVATE IMPLEMENTATION - Internal validation logic\n  // ============================================================================\n\n  private performValidation<T>(data: unknown, schema: TypeSchema<T>, path: string[]): T {\n    // Handle null/undefined values\n    if (data === null || data === undefined) {\n      if (schema.type === 'null' || schema.type === 'undefined') {\n        return data as T;\n      }\n      if (!schema.required) {\n        return data as T;\n      }\n      throw new DomainValidationError(\n        `Required value is ${data}`,\n        'REQUIRED_VALUE_MISSING',\n        this.domain,\n        'validation',\n        path,\n        data,\n        schema.type\n      );\n    }\n\n    // Type-specific validation\n    switch (schema.type) {\n      case 'string':\n        if (typeof data !== 'string') {\n          throw new DomainValidationError(\n            `Expected string, got ${typeof data}`,\n            'TYPE_MISMATCH',\n            this.domain,\n            'validation',\n            path,\n            data,\n            'string'\n          );\n        }\n        break;\n\n      case 'number':\n        if (typeof data !== 'number' || isNaN(data)) {\n          throw new DomainValidationError(\n            `Expected number, got ${typeof data}`,\n            'TYPE_MISMATCH',\n            this.domain,\n            'validation',\n            path,\n            data,\n            'number'\n          );\n        }\n        break;\n\n      case 'boolean':\n        if (typeof data !== 'boolean') {\n          throw new DomainValidationError(\n            `Expected boolean, got ${typeof data}`,\n            'TYPE_MISMATCH',\n            this.domain,\n            'validation',\n            path,\n            data,\n            'boolean'\n          );\n        }\n        break;\n\n      case 'object':\n        if (typeof data !== 'object' || Array.isArray(data)) {\n          throw new DomainValidationError(\n            `Expected object, got ${typeof data}`,\n            'TYPE_MISMATCH',\n            this.domain,\n            'validation',\n            path,\n            data,\n            'object'\n          );\n        }\n\n        // Validate object properties\n        if (schema.properties) {\n          for (const [key, propSchema] of Object.entries(schema.properties)) {\n            if (propSchema) {\n              const propData = (data as any)[key];\n              this.performValidation(propData, propSchema, [...path, key]);\n            }\n          }\n        }\n        break;\n\n      case 'array':\n        if (!Array.isArray(data)) {\n          throw new DomainValidationError(\n            `Expected array, got ${typeof data}`,\n            'TYPE_MISMATCH',\n            this.domain,\n            'validation',\n            path,\n            data,\n            'array'\n          );\n        }\n\n        // Validate array items\n        if (schema.items) {\n          data.forEach((item, index) => {\n            this.performValidation(item, schema.items!, [...path, index.toString()]);\n          });\n        }\n        break;\n\n      case 'function':\n        if (typeof data !== 'function') {\n          throw new DomainValidationError(\n            `Expected function, got ${typeof data}`,\n            'TYPE_MISMATCH',\n            this.domain,\n            'validation',\n            path,\n            data,\n            'function'\n          );\n        }\n        break;\n    }\n\n    // Enum validation\n    if (schema.enum && !schema.enum.includes(data as T)) {\n      throw new DomainValidationError(\n        `Value not in allowed enum values`,\n        'ENUM_VIOLATION',\n        this.domain,\n        'validation',\n        path,\n        data,\n        `enum: ${schema.enum.join(', ')}`\n      );\n    }\n\n    // Custom validator\n    if (schema.validator && !schema.validator(data)) {\n      throw new DomainValidationError(\n        `Custom validation failed`,\n        'CUSTOM_VALIDATION_FAILED',\n        this.domain,\n        'validation',\n        path,\n        data,\n        'custom validator'\n      );\n    }\n\n    // Transform data if transformer provided\n    if (schema.transform) {\n      return schema.transform(data);\n    }\n\n    return data as T;\n  }\n\n  private generateCacheKey(data: unknown, schema: TypeSchema): string {\n    // Create a deterministic cache key\n    const dataStr = this.safeStringify(data);\n    const schemaStr = this.safeStringify(schema);\n    const dataHash = this.simpleHash(dataStr);\n    const schemaHash = this.simpleHash(schemaStr);\n    return `${dataHash}-${schemaHash}`;\n  }\n\n  private generateCrossingId(): string {\n    return `crossing-${this.domain}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  private simpleHash(str: string): string {\n    if (!str || str.length === 0) return '0';\n    let hash = 0;\n    for (let i = 0; i < str.length; i++) {\n      const char = str.charCodeAt(i);\n      hash = (hash << 5) - hash + char;\n      hash = hash & hash; // Convert to 32-bit integer\n    }\n    return Math.abs(hash).toString(36);\n  }\n\n  private safeStringify(obj: unknown): string {\n    try {\n      return JSON.stringify(obj, this.getCircularReplacer()) || 'null';\n    } catch {\n      return 'stringify-error';\n    }\n  }\n\n  private getCircularReplacer() {\n    const seen = new WeakSet();\n    return (key: string, value: any) => {\n      if (typeof value === 'object' && value !== null) {\n        if (seen.has(value)) {\n          return '[Circular]';\n        }\n        seen.add(value);\n      }\n      return value;\n    };\n  }\n\n  private calculateSchemaComplexity(schema: TypeSchema): number {\n    let complexity = 1;\n\n    if (schema.properties) {\n      complexity += Object.keys(schema.properties).length;\n      for (const propSchema of Object.values(schema.properties)) {\n        if (propSchema) {\n          complexity += this.calculateSchemaComplexity(propSchema);\n        }\n      }\n    }\n\n    if (schema.items) {\n      complexity += this.calculateSchemaComplexity(schema.items);\n    }\n\n    if (schema.validator) complexity += 2;\n    if (schema.transform) complexity += 2;\n    if (schema.enum) complexity += schema.enum.length;\n\n    return complexity;\n  }\n\n  private estimateDataSize(data: unknown): number {\n    try {\n      return this.safeStringify(data).length;\n    } catch {\n      return 0;\n    }\n  }\n\n  private updateCache(key: string, value: any): void {\n    // Implement LRU cache behavior\n    if (this.validationCache.size >= this.maxCacheSize) {\n      const firstKey = this.validationCache.keys().next().value;\n      if (firstKey) {\n        this.validationCache.delete(firstKey);\n      }\n    }\n    this.validationCache.set(key, value);\n  }\n\n  private updatePerformanceMetrics(operation: string, metrics: PerformanceMetrics): void {\n    const existing = this.performanceMetrics.get(operation);\n    if (existing) {\n      // Aggregate metrics\n      const aggregated: PerformanceMetrics = {\n        validationTimeMs: (existing.validationTimeMs + metrics.validationTimeMs) / 2,\n        schemaComplexity: Math.max(existing.schemaComplexity, metrics.schemaComplexity),\n        dataSize: Math.max(existing.dataSize, metrics.dataSize),\n        errorCount: existing.errorCount + metrics.errorCount,\n      };\n      this.performanceMetrics.set(operation, aggregated);\n    } else {\n      this.performanceMetrics.set(operation, metrics);\n    }\n  }\n}\n\n// ============================================================================\n// SUPPORTING TYPES AND INTERFACES\n// ============================================================================\n\n/**\n * Domain crossing record for compliance tracking\n */\nexport interface DomainCrossing {\n  id: string;\n  fromDomain: Domain;\n  toDomain: Domain;\n  operation: string;\n  timestamp: Date;\n  currentDomain: Domain;\n}\n\n/**\n * Validation statistics for monitoring and optimization\n */\nexport interface ValidationStatistics {\n  domain: Domain;\n  totalValidations: number;\n  totalErrors: number;\n  errorRate: number;\n  averageValidationTime: number;\n  cacheSize: number;\n  crossingCount: number;\n  lastResetTime: Date;\n}\n\n// ============================================================================\n// FACTORY AND REGISTRY - Centralized validator management\n// ============================================================================\n\n/**\n * Domain boundary validator factory and registry\n */\nclass DomainBoundaryValidatorRegistry {\n  private static instance: DomainBoundaryValidatorRegistry;\n  private readonly validators = new Map<Domain, DomainBoundaryValidator>();\n  private readonly logger = getLogger('domain-boundary-registry');\n\n  private constructor() {}\n\n  public static getInstance(): DomainBoundaryValidatorRegistry {\n    if (!DomainBoundaryValidatorRegistry.instance) {\n      DomainBoundaryValidatorRegistry.instance = new DomainBoundaryValidatorRegistry();\n    }\n    return DomainBoundaryValidatorRegistry.instance;\n  }\n\n  /**\n   * Get or create validator for a domain\n   */\n  public getValidator(domain: Domain): DomainBoundaryValidator {\n    if (!this.validators.has(domain)) {\n      const validator = new DomainBoundaryValidator(domain);\n      this.validators.set(domain, validator);\n      this.logger.info('Created new domain validator', { domain });\n    }\n    return this.validators.get(domain)!;\n  }\n\n  /**\n   * Get all validators for system-wide operations\n   */\n  public getAllValidators(): Map<Domain, DomainBoundaryValidator> {\n    return new Map(this.validators);\n  }\n\n  /**\n   * Reset all validators (for testing/maintenance)\n   */\n  public resetAll(): void {\n    for (const validator of this.validators.values()) {\n      validator.reset();\n    }\n    this.logger.info('Reset all domain validators');\n  }\n\n  /**\n   * Get system-wide validation statistics\n   */\n  public getSystemStatistics(): SystemValidationStatistics {\n    const stats: SystemValidationStatistics = {\n      totalDomains: this.validators.size,\n      domainStatistics: new Map(),\n      systemTotalValidations: 0,\n      systemTotalErrors: 0,\n      systemErrorRate: 0,\n      systemAverageValidationTime: 0,\n    };\n\n    let totalValidations = 0;\n    let totalErrors = 0;\n    let totalValidationTime = 0;\n\n    for (const [domain, validator] of this.validators) {\n      const domainStats = validator.getStatistics();\n      stats.domainStatistics.set(domain, domainStats);\n\n      totalValidations += domainStats.totalValidations;\n      totalErrors += domainStats.totalErrors;\n      totalValidationTime += domainStats.averageValidationTime * domainStats.totalValidations;\n    }\n\n    stats.systemTotalValidations = totalValidations;\n    stats.systemTotalErrors = totalErrors;\n    stats.systemErrorRate = totalValidations > 0 ? totalErrors / totalValidations : 0;\n    stats.systemAverageValidationTime =\n      totalValidations > 0 ? totalValidationTime / totalValidations : 0;\n\n    return stats;\n  }\n}\n\n/**\n * System-wide validation statistics\n */\nexport interface SystemValidationStatistics {\n  totalDomains: number;\n  domainStatistics: Map<Domain, ValidationStatistics>;\n  systemTotalValidations: number;\n  systemTotalErrors: number;\n  systemErrorRate: number;\n  systemAverageValidationTime: number;\n}\n\n// ============================================================================\n// COMMON SCHEMA DEFINITIONS - Reusable schemas for domain types\n// ============================================================================\n\n/**\n * Common schema definitions for existing domain types\n */\nexport const CommonSchemas = {\n  /**\n   * Agent schema for coordination domain\n   */\n  Agent: {\n    type: 'object',\n    required: true,\n    properties: {\n      id: { type: 'string', required: true },\n      capabilities: {\n        type: 'array',\n        required: true,\n        items: { type: 'string' },\n      },\n      status: {\n        type: 'string',\n        required: true,\n        enum: ['idle', 'busy'],\n      },\n    },\n  } as TypeSchema<Agent>,\n\n  /**\n   * Task schema for coordination domain\n   */\n  Task: {\n    type: 'object',\n    required: true,\n    properties: {\n      id: { type: 'string', required: true },\n      description: { type: 'string', required: true },\n      strategy: {\n        type: 'string',\n        required: true,\n        enum: ['parallel', 'sequential', 'adaptive', 'consensus'],\n      },\n      dependencies: {\n        type: 'array',\n        required: true,\n        items: { type: 'string' },\n      },\n      requiredCapabilities: {\n        type: 'array',\n        required: true,\n        items: { type: 'string' },\n      },\n      maxAgents: { type: 'number', required: true },\n      requireConsensus: { type: 'boolean', required: true },\n    },\n  } as TypeSchema<Task>,\n\n  /**\n   * WorkflowDefinition schema for workflows domain\n   */\n  WorkflowDefinition: {\n    type: 'object',\n    required: true,\n    properties: {\n      id: { type: 'string', required: true },\n      name: { type: 'string', required: true },\n      version: { type: 'string', required: true },\n      // Additional properties would be defined based on the actual WorkflowDefinition interface\n    },\n  } as TypeSchema<Pick<WorkflowDefinition, 'id' | 'name' | 'version'>>,\n} as const;\n\n// ============================================================================\n// EXPORTS - Public API\n// ============================================================================\n\n// Export the singleton registry\nexport const domainValidatorRegistry = DomainBoundaryValidatorRegistry.getInstance();\n\n// Convenience function for getting domain validators\nexport function getDomainValidator(domain: Domain): DomainBoundaryValidator {\n  return domainValidatorRegistry.getValidator(domain);\n}\n\n// Convenience function for cross-domain validation\nexport function validateCrossDomain<T>(\n  data: unknown,\n  schema: TypeSchema<T>,\n  fromDomain: Domain,\n  toDomain: Domain,\n  operation: string\n): T {\n  const validator = getDomainValidator(fromDomain);\n  validator.trackCrossings(fromDomain, toDomain, operation);\n  return validator.validateInput(data, schema);\n}\n\nexport default DomainBoundaryValidator;\n", "/**\n * @file Type-Safe Event System - Phase 0, Task 0.3 - AGUI Integration Foundation\n *\n * Implements a comprehensive type-safe event bus with domain validation integration,\n * designed for high-throughput event processing with compile-time and runtime type safety.\n *\n * This system forms the foundation for AGUI human validation workflows and\n * multi-agent coordination across domain boundaries.\n *\n * ARCHITECTURE: Multi-Agent Cognitive Architecture compliant\n * - Type safety at compile time AND runtime\n * - Domain boundary validation integration\n * - High-performance event routing\n * - Cross-domain event coordination\n * - Event schema validation with TypeSchema system\n * - Performance optimized for production workloads\n */\n\nimport { EventEmitter } from 'events';\nimport type { Logger } from '../config/logging-config.ts';\nimport { getLogger } from '../config/logging-config.ts';\nimport type { Agent, Task } from '../coordination/types.ts';\nimport type { WorkflowContext, WorkflowDefinition, WorkflowEvent } from '../workflows/types.ts';\nimport {\n  ContractViolationError,\n  Domain,\n  type DomainBoundaryValidator,\n  DomainMetadata,\n  DomainValidationError,\n  getDomainValidator,\n  PerformanceMetrics,\n  type Result,\n  type TypeSchema,\n  validateCrossDomain,\n} from './domain-boundary-validator.ts';\nimport type { IEventBus } from './interfaces/base-interfaces.ts';\n\n// ============================================================================\n// EVENT SYSTEM CORE TYPES - Foundation for all event operations\n// ============================================================================\n\n/**\n * Base event interface that all domain events must extend\n */\nexport interface BaseEvent {\n  readonly id: string;\n  readonly type: string;\n  readonly domain: Domain;\n  readonly timestamp: Date;\n  readonly version: string;\n  readonly metadata?: EventMetadata;\n}\n\n/**\n * Event metadata for tracking and debugging\n */\nexport interface EventMetadata {\n  readonly correlationId?: string;\n  readonly causationId?: string;\n  readonly source?: string;\n  readonly userId?: string;\n  readonly sessionId?: string;\n  readonly traceId?: string;\n  readonly priority?: EventPriority;\n  readonly tags?: string[];\n  readonly customData?: Record<string, unknown>;\n}\n\n/**\n * Event priority levels for processing order\n */\nexport enum EventPriority {\n  LOW = 0,\n  NORMAL = 1,\n  HIGH = 2,\n  CRITICAL = 3,\n  URGENT = 4,\n}\n\n/**\n * Event processing status\n */\nexport enum EventStatus {\n  PENDING = 'pending',\n  PROCESSING = 'processing',\n  PROCESSED = 'processed',\n  FAILED = 'failed',\n  REJECTED = 'rejected',\n  RETRYING = 'retrying',\n}\n\n/**\n * Event handler configuration\n */\nexport interface EventHandlerConfig {\n  readonly priority?: number;\n  readonly timeout?: number;\n  readonly retries?: number;\n  readonly backoffStrategy?: 'linear' | 'exponential';\n  readonly errorHandling?: 'ignore' | 'retry' | 'failfast';\n  readonly validatePayload?: boolean;\n  readonly trackMetrics?: boolean;\n}\n\n/**\n * Event processing result\n */\nexport interface EventProcessingResult {\n  readonly success: boolean;\n  readonly processingTime: number;\n  readonly error?: Error;\n  readonly handlerResults: Array<{\n    handlerId: string;\n    success: boolean;\n    processingTime: number;\n    error?: Error;\n  }>;\n  readonly metadata: EventProcessingMetadata;\n}\n\n/**\n * Event processing metadata\n */\nexport interface EventProcessingMetadata {\n  readonly eventId: string;\n  readonly startTime: Date;\n  readonly endTime: Date;\n  readonly handlerCount: number;\n  readonly successCount: number;\n  readonly failureCount: number;\n  readonly totalProcessingTime: number;\n  readonly validationTime: number;\n}\n\n// ============================================================================\n// DOMAIN-SPECIFIC EVENT INTERFACES - Type-safe events for each domain\n// ============================================================================\n\n/**\n * Coordination domain events\n */\nexport interface CoordinationEvent extends BaseEvent {\n  readonly domain: Domain.COORDINATION;\n}\n\nexport interface AgentCreatedEvent extends CoordinationEvent {\n  readonly type: 'agent.created';\n  readonly payload: {\n    readonly agent: Agent;\n    readonly capabilities: string[];\n    readonly initialStatus: 'idle' | 'busy';\n  };\n}\n\nexport interface AgentDestroyedEvent extends CoordinationEvent {\n  readonly type: 'agent.destroyed';\n  readonly payload: {\n    readonly agentId: string;\n    readonly reason: string;\n    readonly finalStatus: 'idle' | 'busy';\n  };\n}\n\nexport interface TaskAssignedEvent extends CoordinationEvent {\n  readonly type: 'task.assigned';\n  readonly payload: {\n    readonly task: Task;\n    readonly agentId: string;\n    readonly assignmentTime: Date;\n  };\n}\n\nexport interface TaskCompletedEvent extends CoordinationEvent {\n  readonly type: 'task.completed';\n  readonly payload: {\n    readonly taskId: string;\n    readonly agentId: string;\n    readonly result: unknown;\n    readonly duration: number;\n    readonly success: boolean;\n  };\n}\n\nexport interface SwarmStateChangedEvent extends CoordinationEvent {\n  readonly type: 'swarm.state.changed';\n  readonly payload: {\n    readonly swarmId: string;\n    readonly previousState: string;\n    readonly newState: string;\n    readonly agentCount: number;\n    readonly activeTaskCount: number;\n  };\n}\n\n/**\n * Workflow domain events\n */\nexport interface WorkflowDomainEvent extends BaseEvent {\n  readonly domain: Domain.WORKFLOWS;\n}\n\nexport interface WorkflowStartedEvent extends WorkflowDomainEvent {\n  readonly type: 'workflow.started';\n  readonly payload: {\n    readonly workflowId: string;\n    readonly definition: WorkflowDefinition;\n    readonly context: WorkflowContext;\n    readonly startTime: Date;\n  };\n}\n\nexport interface WorkflowCompletedEvent extends WorkflowDomainEvent {\n  readonly type: 'workflow.completed';\n  readonly payload: {\n    readonly workflowId: string;\n    readonly result: unknown;\n    readonly duration: number;\n    readonly stepsExecuted: number;\n  };\n}\n\nexport interface WorkflowFailedEvent extends WorkflowDomainEvent {\n  readonly type: 'workflow.failed';\n  readonly payload: {\n    readonly workflowId: string;\n    readonly error: Error;\n    readonly failedStep?: number;\n    readonly partialResult?: unknown;\n  };\n}\n\nexport interface WorkflowStepCompletedEvent extends WorkflowDomainEvent {\n  readonly type: 'workflow.step.completed';\n  readonly payload: {\n    readonly workflowId: string;\n    readonly stepIndex: number;\n    readonly stepResult: unknown;\n    readonly duration: number;\n  };\n}\n\n/**\n * Neural domain events\n */\nexport interface NeuralEvent extends BaseEvent {\n  readonly domain: Domain.NEURAL;\n}\n\nexport interface NetworkTrainingStartedEvent extends NeuralEvent {\n  readonly type: 'network.training.started';\n  readonly payload: {\n    readonly networkId: string;\n    readonly architecture: number[];\n    readonly trainingConfig: unknown;\n    readonly datasetSize: number;\n  };\n}\n\nexport interface NetworkTrainingCompletedEvent extends NeuralEvent {\n  readonly type: 'network.training.completed';\n  readonly payload: {\n    readonly networkId: string;\n    readonly finalAccuracy: number;\n    readonly trainingDuration: number;\n    readonly epochsCompleted: number;\n  };\n}\n\nexport interface NetworkPredictionEvent extends NeuralEvent {\n  readonly type: 'network.prediction';\n  readonly payload: {\n    readonly networkId: string;\n    readonly input: number[];\n    readonly output: number[];\n    readonly confidence: number;\n    readonly processingTime: number;\n  };\n}\n\n/**\n * Database domain events\n */\nexport interface DatabaseEvent extends BaseEvent {\n  readonly domain: Domain.DATABASE;\n}\n\nexport interface QueryExecutedEvent extends DatabaseEvent {\n  readonly type: 'query.executed';\n  readonly payload: {\n    readonly queryId: string;\n    readonly query: string;\n    readonly parameters: unknown[];\n    readonly resultCount: number;\n    readonly executionTime: number;\n    readonly cached: boolean;\n  };\n}\n\nexport interface TransactionCompletedEvent extends DatabaseEvent {\n  readonly type: 'transaction.completed';\n  readonly payload: {\n    readonly transactionId: string;\n    readonly operations: string[];\n    readonly duration: number;\n    readonly success: boolean;\n  };\n}\n\n/**\n * Memory domain events\n */\nexport interface MemoryEvent extends BaseEvent {\n  readonly domain: Domain.MEMORY;\n}\n\nexport interface MemoryStoredEvent extends MemoryEvent {\n  readonly type: 'memory.stored';\n  readonly payload: {\n    readonly key: string;\n    readonly size: number;\n    readonly ttl?: number;\n    readonly namespace?: string;\n  };\n}\n\nexport interface MemoryRetrievedEvent extends MemoryEvent {\n  readonly type: 'memory.retrieved';\n  readonly payload: {\n    readonly key: string;\n    readonly found: boolean;\n    readonly size?: number;\n    readonly age?: number;\n  };\n}\n\nexport interface MemoryEvictedEvent extends MemoryEvent {\n  readonly type: 'memory.evicted';\n  readonly payload: {\n    readonly key: string;\n    readonly reason: 'ttl' | 'capacity' | 'manual';\n    readonly size: number;\n  };\n}\n\n/**\n * Knowledge domain events\n */\nexport interface KnowledgeEvent extends BaseEvent {\n  readonly domain: Domain.KNOWLEDGE;\n}\n\nexport interface KnowledgeUpdatedEvent extends KnowledgeEvent {\n  readonly type: 'knowledge.updated';\n  readonly payload: {\n    readonly entityId: string;\n    readonly entityType: string;\n    readonly updateType: 'create' | 'update' | 'delete';\n    readonly version: number;\n  };\n}\n\nexport interface KnowledgeQueryEvent extends KnowledgeEvent {\n  readonly type: 'knowledge.query';\n  readonly payload: {\n    readonly queryId: string;\n    readonly query: string;\n    readonly resultCount: number;\n    readonly processingTime: number;\n  };\n}\n\n/**\n * Interface domain events (for AGUI integration)\n */\nexport interface InterfaceEvent extends BaseEvent {\n  readonly domain: Domain.INTERFACES;\n}\n\nexport interface HumanValidationRequestedEvent extends InterfaceEvent {\n  readonly type: 'human.validation.requested';\n  readonly payload: {\n    readonly requestId: string;\n    readonly validationType: 'approval' | 'selection' | 'input' | 'review';\n    readonly context: unknown;\n    readonly priority: EventPriority;\n    readonly timeout?: number;\n  };\n}\n\nexport interface HumanValidationCompletedEvent extends InterfaceEvent {\n  readonly type: 'human.validation.completed';\n  readonly payload: {\n    readonly requestId: string;\n    readonly approved: boolean;\n    readonly input?: unknown;\n    readonly feedback?: string;\n    readonly processingTime: number;\n  };\n}\n\nexport interface AGUIGateOpenedEvent extends InterfaceEvent {\n  readonly type: 'agui.gate.opened';\n  readonly payload: {\n    readonly gateId: string;\n    readonly gateType: string;\n    readonly requiredApproval: boolean;\n    readonly context: unknown;\n  };\n}\n\nexport interface AGUIGateClosedEvent extends InterfaceEvent {\n  readonly type: 'agui.gate.closed';\n  readonly payload: {\n    readonly gateId: string;\n    readonly approved: boolean;\n    readonly duration: number;\n    readonly humanInput?: unknown;\n  };\n}\n\n/**\n * Core domain events\n */\nexport interface CoreEvent extends BaseEvent {\n  readonly domain: Domain.CORE;\n}\n\nexport interface SystemStartedEvent extends CoreEvent {\n  readonly type: 'system.started';\n  readonly payload: {\n    readonly version: string;\n    readonly startTime: Date;\n    readonly configuration: unknown;\n  };\n}\n\nexport interface SystemShutdownEvent extends CoreEvent {\n  readonly type: 'system.shutdown';\n  readonly payload: {\n    readonly reason: string;\n    readonly graceful: boolean;\n    readonly uptime: number;\n  };\n}\n\nexport interface ErrorOccurredEvent extends CoreEvent {\n  readonly type: 'error.occurred';\n  readonly payload: {\n    readonly error: Error;\n    readonly context: unknown;\n    readonly severity: 'low' | 'medium' | 'high' | 'critical';\n    readonly recoverable: boolean;\n  };\n}\n\n/**\n * Union type of all domain events\n */\nexport type DomainEvent =\n  | CoordinationEvent\n  | WorkflowDomainEvent\n  | NeuralEvent\n  | DatabaseEvent\n  | MemoryEvent\n  | KnowledgeEvent\n  | InterfaceEvent\n  | CoreEvent;\n\n/**\n * Union type of all specific event types\n */\nexport type SystemEvent =\n  | AgentCreatedEvent\n  | AgentDestroyedEvent\n  | TaskAssignedEvent\n  | TaskCompletedEvent\n  | SwarmStateChangedEvent\n  | WorkflowStartedEvent\n  | WorkflowCompletedEvent\n  | WorkflowFailedEvent\n  | WorkflowStepCompletedEvent\n  | NetworkTrainingStartedEvent\n  | NetworkTrainingCompletedEvent\n  | NetworkPredictionEvent\n  | QueryExecutedEvent\n  | TransactionCompletedEvent\n  | MemoryStoredEvent\n  | MemoryRetrievedEvent\n  | MemoryEvictedEvent\n  | KnowledgeUpdatedEvent\n  | KnowledgeQueryEvent\n  | HumanValidationRequestedEvent\n  | HumanValidationCompletedEvent\n  | AGUIGateOpenedEvent\n  | AGUIGateClosedEvent\n  | SystemStartedEvent\n  | SystemShutdownEvent\n  | ErrorOccurredEvent;\n\n// ============================================================================\n// EVENT SCHEMAS - TypeSchema definitions for runtime validation\n// ============================================================================\n\n/**\n * Base event schema template\n */\nconst BaseEventSchema: TypeSchema<BaseEvent> = {\n  type: 'object',\n  required: true,\n  properties: {\n    id: { type: 'string', required: true },\n    type: { type: 'string', required: true },\n    domain: {\n      type: 'string',\n      required: true,\n      enum: Object.values(Domain),\n    },\n    timestamp: { type: 'object', required: true },\n    version: { type: 'string', required: true },\n    metadata: {\n      type: 'object',\n      required: false,\n      properties: {\n        correlationId: { type: 'string', required: false },\n        causationId: { type: 'string', required: false },\n        source: { type: 'string', required: false },\n        userId: { type: 'string', required: false },\n        sessionId: { type: 'string', required: false },\n        traceId: { type: 'string', required: false },\n        priority: {\n          type: 'number',\n          required: false,\n          enum: Object.values(EventPriority).filter((v) => typeof v === 'number'),\n        },\n        tags: {\n          type: 'array',\n          required: false,\n          items: { type: 'string' },\n        },\n        customData: { type: 'object', required: false },\n      },\n    },\n  },\n};\n\n/**\n * Event schemas for each domain\n */\nexport const EventSchemas = {\n  AgentCreated: {\n    ...BaseEventSchema,\n    properties: {\n      ...BaseEventSchema.properties,\n      payload: {\n        type: 'object',\n        required: true,\n        properties: {\n          agent: { type: 'object', required: true },\n          capabilities: {\n            type: 'array',\n            required: true,\n            items: { type: 'string' },\n          },\n          initialStatus: {\n            type: 'string',\n            required: true,\n            enum: ['idle', 'busy'],\n          },\n        },\n      },\n    },\n  } as TypeSchema<AgentCreatedEvent>,\n\n  TaskAssigned: {\n    ...BaseEventSchema,\n    properties: {\n      ...BaseEventSchema.properties,\n      payload: {\n        type: 'object',\n        required: true,\n        properties: {\n          task: { type: 'object', required: true },\n          agentId: { type: 'string', required: true },\n          assignmentTime: { type: 'object', required: true },\n        },\n      },\n    },\n  } as TypeSchema<TaskAssignedEvent>,\n\n  WorkflowStarted: {\n    ...BaseEventSchema,\n    properties: {\n      ...BaseEventSchema.properties,\n      payload: {\n        type: 'object',\n        required: true,\n        properties: {\n          workflowId: { type: 'string', required: true },\n          definition: { type: 'object', required: true },\n          context: { type: 'object', required: true },\n          startTime: { type: 'object', required: true },\n        },\n      },\n    },\n  } as TypeSchema<WorkflowStartedEvent>,\n\n  HumanValidationRequested: {\n    ...BaseEventSchema,\n    properties: {\n      ...BaseEventSchema.properties,\n      payload: {\n        type: 'object',\n        required: true,\n        properties: {\n          requestId: { type: 'string', required: true },\n          validationType: {\n            type: 'string',\n            required: true,\n            enum: ['approval', 'selection', 'input', 'review'],\n          },\n          context: { type: 'object', required: true },\n          priority: {\n            type: 'number',\n            required: true,\n            enum: Object.values(EventPriority).filter((v) => typeof v === 'number'),\n          },\n          timeout: { type: 'number', required: false },\n        },\n      },\n    },\n  } as TypeSchema<HumanValidationRequestedEvent>,\n} as const;\n\n// ============================================================================\n// EVENT HANDLER TYPES - Type-safe event handling\n// ============================================================================\n\n/**\n * Event handler function type\n */\nexport type EventHandler<TEvent extends BaseEvent = BaseEvent> = (\n  event: TEvent,\n  context: EventHandlerContext\n) => Promise<void> | void;\n\n/**\n * Event handler context\n */\nexport interface EventHandlerContext {\n  readonly eventBus: IEventBus;\n  readonly logger: Logger;\n  readonly startTime: Date;\n  readonly correlationId: string;\n  readonly abortSignal?: AbortSignal;\n  readonly metadata: Record<string, unknown>;\n}\n\n/**\n * Typed event handler registration\n */\nexport interface TypedEventHandler<TEvent extends BaseEvent = BaseEvent> {\n  readonly id: string;\n  readonly eventType: string;\n  readonly domain?: Domain;\n  readonly handler: EventHandler<TEvent>;\n  readonly config: EventHandlerConfig;\n  readonly schema?: TypeSchema<TEvent>;\n}\n\n// ============================================================================\n// TYPE-SAFE EVENT BUS IMPLEMENTATION - Production-grade event system\n// ============================================================================\n\n/**\n * Performance monitoring for the event system\n */\nexport interface EventSystemMetrics {\n  readonly totalEvents: number;\n  readonly eventsPerSecond: number;\n  readonly averageProcessingTime: number;\n  readonly failureRate: number;\n  readonly handlerCount: number;\n  readonly domainEventCounts: Record<Domain, number>;\n  readonly memoryUsage: number;\n  readonly cacheHitRate: number;\n}\n\n/**\n * Event system configuration\n */\nexport interface EventSystemConfig {\n  readonly maxHandlers?: number;\n  readonly maxEventHistory?: number;\n  readonly enableMetrics?: boolean;\n  readonly enableCaching?: boolean;\n  readonly defaultTimeout?: number;\n  readonly maxConcurrency?: number;\n  readonly batchSize?: number;\n  readonly retryAttempts?: number;\n  readonly backoffMultiplier?: number;\n  readonly domainValidation?: boolean;\n}\n\n/**\n * Type-safe event bus with domain boundary validation\n */\nexport class TypeSafeEventBus extends EventEmitter implements IEventBus {\n  private readonly logger: Logger;\n  private readonly domainValidators = new Map<Domain, DomainBoundaryValidator>();\n  private readonly eventHandlers = new Map<string, TypedEventHandler[]>();\n  private readonly eventHistory: BaseEvent[] = [];\n  private readonly processingStats = new Map<string, number[]>();\n  private readonly config: Required<EventSystemConfig>;\n\n  // Performance optimization\n  private readonly eventCache = new Map<string, BaseEvent>();\n  private readonly schemaCache = new Map<string, TypeSchema>();\n  private eventCounter = 0;\n  private startTime = Date.now();\n\n  constructor(\n    config: EventSystemConfig = {},\n    private readonly systemDomainValidator?: DomainBoundaryValidator\n  ) {\n    super();\n    this.setMaxListeners(0); // Unlimited listeners\n\n    this.config = {\n      maxHandlers: config.maxHandlers ?? 1000,\n      maxEventHistory: config.maxEventHistory ?? 10000,\n      enableMetrics: config.enableMetrics ?? true,\n      enableCaching: config.enableCaching ?? true,\n      defaultTimeout: config.defaultTimeout ?? 30000,\n      maxConcurrency: config.maxConcurrency ?? 100,\n      batchSize: config.batchSize ?? 50,\n      retryAttempts: config.retryAttempts ?? 3,\n      backoffMultiplier: config.backoffMultiplier ?? 2,\n      domainValidation: config.domainValidation ?? true,\n    };\n\n    this.logger = getLogger('type-safe-event-bus');\n\n    // Initialize domain validators if domain validation is enabled\n    if (this.config.domainValidation) {\n      for (const domain of Object.values(Domain)) {\n        this.domainValidators.set(domain, getDomainValidator(domain));\n      }\n    }\n\n    this.logger.info('TypeSafeEventBus initialized', {\n      config: this.config,\n      domainValidationEnabled: this.config.domainValidation,\n    });\n  }\n\n  // ============================================================================\n  // EVENT EMISSION - Type-safe event publishing with validation\n  // ============================================================================\n\n  /**\n   * Emit a type-safe event with domain boundary validation\n   */\n  public async emitEvent<TEvent extends BaseEvent>(\n    event: TEvent,\n    options: {\n      skipValidation?: boolean;\n      timeout?: number;\n      priority?: EventPriority;\n      correlationId?: string;\n    } = {}\n  ): Promise<EventProcessingResult> {\n    const startTime = Date.now();\n    const eventId = event.id || this.generateEventId();\n\n    try {\n      // Enhanced event with processing metadata\n      const enhancedEvent: TEvent = {\n        ...event,\n        id: eventId,\n        timestamp: event.timestamp || new Date(),\n        version: event.version || '1.0.0',\n        metadata: {\n          ...event.metadata,\n          correlationId:\n            options.correlationId || event.metadata?.correlationId || this.generateCorrelationId(),\n          priority: options.priority ?? event.metadata?.priority ?? EventPriority.NORMAL,\n          source: event.metadata?.source || 'type-safe-event-bus',\n        },\n      };\n\n      // Domain boundary validation\n      if (this.config.domainValidation && !options.skipValidation) {\n        const validationResult = await this.validateEventAtDomainBoundary(enhancedEvent);\n        if (!validationResult.success) {\n          throw new DomainValidationError(\n            `Event validation failed: ${validationResult.error?.message}`,\n            'EVENT_VALIDATION_FAILED',\n            event.domain,\n            'emitEvent',\n            [],\n            event,\n            event.type\n          );\n        }\n      }\n\n      // Cache the event if caching is enabled\n      if (this.config.enableCaching) {\n        this.eventCache.set(eventId, enhancedEvent);\n      }\n\n      // Add to event history\n      this.addToEventHistory(enhancedEvent);\n\n      // Process event handlers\n      const processingResult = await this.processEventHandlers(enhancedEvent, {\n        timeout: options.timeout ?? this.config.defaultTimeout,\n      });\n\n      // Emit on Node.js EventEmitter for compatibility\n      this.emit(event.type, enhancedEvent);\n      this.emit('*', enhancedEvent); // Wildcard listener support\n\n      // Track metrics\n      if (this.config.enableMetrics) {\n        this.trackEventMetrics(event.type, Date.now() - startTime, true);\n      }\n\n      this.logger.debug('Event emitted successfully', {\n        eventId,\n        eventType: event.type,\n        domain: event.domain,\n        processingTime: Date.now() - startTime,\n        handlerCount: processingResult.handlerResults.length,\n      });\n\n      return {\n        success: true,\n        processingTime: Date.now() - startTime,\n        handlerResults: processingResult.handlerResults,\n        metadata: {\n          eventId,\n          startTime: new Date(startTime),\n          endTime: new Date(),\n          handlerCount: processingResult.handlerResults.length,\n          successCount: processingResult.handlerResults.filter((r) => r.success).length,\n          failureCount: processingResult.handlerResults.filter((r) => !r.success).length,\n          totalProcessingTime: Date.now() - startTime,\n          validationTime: processingResult.validationTime || 0,\n        },\n      };\n    } catch (error) {\n      const processingTime = Date.now() - startTime;\n\n      // Track failure metrics\n      if (this.config.enableMetrics) {\n        this.trackEventMetrics(event.type, processingTime, false);\n      }\n\n      this.logger.error('Event emission failed', {\n        eventId,\n        eventType: event.type,\n        domain: event.domain,\n        error: error instanceof Error ? error.message : String(error),\n        processingTime,\n      });\n\n      return {\n        success: false,\n        processingTime,\n        error: error instanceof Error ? error : new Error(String(error)),\n        handlerResults: [],\n        metadata: {\n          eventId,\n          startTime: new Date(startTime),\n          endTime: new Date(),\n          handlerCount: 0,\n          successCount: 0,\n          failureCount: 1,\n          totalProcessingTime: processingTime,\n          validationTime: 0,\n        },\n      };\n    }\n  }\n\n  /**\n   * Emit multiple events in batch for performance\n   */\n  public async emitEventBatch<TEvent extends BaseEvent>(\n    events: TEvent[],\n    options: {\n      skipValidation?: boolean;\n      timeout?: number;\n      maxConcurrency?: number;\n    } = {}\n  ): Promise<EventProcessingResult[]> {\n    const startTime = Date.now();\n    const maxConcurrency = options.maxConcurrency ?? this.config.maxConcurrency;\n\n    this.logger.info('Processing event batch', {\n      eventCount: events.length,\n      maxConcurrency,\n    });\n\n    const results: EventProcessingResult[] = [];\n\n    // Process events in batches to avoid overwhelming the system\n    for (let i = 0; i < events.length; i += this.config.batchSize) {\n      const batch = events.slice(i, i + this.config.batchSize);\n\n      const batchPromises = batch.map((event) => this.emitEvent(event, options));\n\n      const batchResults = await Promise.allSettled(batchPromises);\n\n      for (const result of batchResults) {\n        if (result.status === 'fulfilled') {\n          results.push(result.value);\n        } else {\n          results.push({\n            success: false,\n            processingTime: Date.now() - startTime,\n            error:\n              result.reason instanceof Error ? result.reason : new Error(String(result.reason)),\n            handlerResults: [],\n            metadata: {\n              eventId: 'batch-failed',\n              startTime: new Date(startTime),\n              endTime: new Date(),\n              handlerCount: 0,\n              successCount: 0,\n              failureCount: 1,\n              totalProcessingTime: Date.now() - startTime,\n              validationTime: 0,\n            },\n          });\n        }\n      }\n    }\n\n    this.logger.info('Event batch processing completed', {\n      totalEvents: events.length,\n      successCount: results.filter((r) => r.success).length,\n      failureCount: results.filter((r) => !r.success).length,\n      totalTime: Date.now() - startTime,\n    });\n\n    return results;\n  }\n\n  // ============================================================================\n  // EVENT HANDLER REGISTRATION - Type-safe handler management\n  // ============================================================================\n\n  /**\n   * Register a type-safe event handler\n   */\n  public registerHandler<TEvent extends BaseEvent>(\n    eventType: string,\n    handler: EventHandler<TEvent>,\n    config: EventHandlerConfig = {},\n    schema?: TypeSchema<TEvent>\n  ): string {\n    const handlerId = this.generateHandlerId();\n\n    const typedHandler: TypedEventHandler<TEvent> = {\n      id: handlerId,\n      eventType,\n      handler,\n      config: {\n        priority: 0,\n        timeout: this.config.defaultTimeout,\n        retries: this.config.retryAttempts,\n        backoffStrategy: 'exponential',\n        errorHandling: 'retry',\n        validatePayload: true,\n        trackMetrics: true,\n        ...config,\n      },\n      schema,\n    };\n\n    if (!this.eventHandlers.has(eventType)) {\n      this.eventHandlers.set(eventType, []);\n    }\n\n    const handlers = this.eventHandlers.get(eventType)!;\n    handlers.push(typedHandler);\n\n    // Sort by priority (higher priority first)\n    handlers.sort((a, b) => (b.config.priority ?? 0) - (a.config.priority ?? 0));\n\n    this.logger.debug('Event handler registered', {\n      handlerId,\n      eventType,\n      priority: config.priority,\n      totalHandlers: handlers.length,\n    });\n\n    return handlerId;\n  }\n\n  /**\n   * Register multiple handlers for different event types\n   */\n  public registerHandlers(\n    registrations: Array<{\n      eventType: string;\n      handler: EventHandler<any>;\n      config?: EventHandlerConfig;\n      schema?: TypeSchema<any>;\n    }>\n  ): string[] {\n    return registrations.map((reg) =>\n      this.registerHandler(reg.eventType, reg.handler, reg.config, reg.schema)\n    );\n  }\n\n  /**\n   * Register a domain-wide handler that processes all events from a specific domain\n   */\n  public registerDomainHandler<TEvent extends BaseEvent>(\n    domain: Domain,\n    handler: EventHandler<TEvent>,\n    config: EventHandlerConfig = {}\n  ): string {\n    return this.registerHandler(`domain:${domain}`, handler, config);\n  }\n\n  /**\n   * Register a wildcard handler that processes all events\n   */\n  public registerWildcardHandler(\n    handler: EventHandler<BaseEvent>,\n    config: EventHandlerConfig = {}\n  ): string {\n    return this.registerHandler('*', handler, config);\n  }\n\n  /**\n   * Unregister an event handler\n   */\n  public unregisterHandler(handlerId: string): boolean {\n    for (const [eventType, handlers] of this.eventHandlers.entries()) {\n      const index = handlers.findIndex((h) => h.id === handlerId);\n      if (index >= 0) {\n        handlers.splice(index, 1);\n\n        if (handlers.length === 0) {\n          this.eventHandlers.delete(eventType);\n        }\n\n        this.logger.debug('Event handler unregistered', {\n          handlerId,\n          eventType,\n          remainingHandlers: handlers.length,\n        });\n\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Get all handlers for an event type\n   */\n  public getHandlers(eventType: string): TypedEventHandler[] {\n    return this.eventHandlers.get(eventType) || [];\n  }\n\n  /**\n   * Get all registered event types\n   */\n  public getRegisteredEventTypes(): string[] {\n    return Array.from(this.eventHandlers.keys());\n  }\n\n  // ============================================================================\n  // CROSS-DOMAIN EVENT ROUTING - Domain boundary aware routing\n  // ============================================================================\n\n  /**\n   * Route event across domain boundaries with validation\n   */\n  public async routeCrossDomainEvent<TEvent extends BaseEvent>(\n    event: TEvent,\n    fromDomain: Domain,\n    toDomain: Domain,\n    operation: string\n  ): Promise<Result<EventProcessingResult>> {\n    const startTime = Date.now();\n\n    try {\n      // Validate cross-domain event routing\n      if (this.config.domainValidation) {\n        const validator = this.domainValidators.get(fromDomain);\n        if (validator) {\n          validator.trackCrossings(fromDomain, toDomain, `event_routing:${operation}`);\n        }\n\n        // Validate event against target domain schema\n        const validationResult = await this.validateCrossDomainEvent(event, fromDomain, toDomain);\n        if (!validationResult.success) {\n          return {\n            success: false,\n            error: validationResult.error,\n            metadata: {\n              domainFrom: fromDomain,\n              domainTo: toDomain,\n              operation: `cross_domain_event:${operation}`,\n              timestamp: new Date(),\n              validationTime: Date.now() - startTime,\n              crossingId: this.generateCrossingId(),\n            },\n          };\n        }\n      }\n\n      // Emit the event with cross-domain metadata\n      const crossDomainEvent: TEvent = {\n        ...event,\n        metadata: {\n          ...event.metadata,\n          source: `cross_domain:${fromDomain}`,\n          causationId: event.id,\n          customData: {\n            ...event.metadata?.customData,\n            crossDomain: {\n              from: fromDomain,\n              to: toDomain,\n              operation,\n            },\n          },\n        },\n      };\n\n      const processingResult = await this.emitEvent(crossDomainEvent);\n\n      return {\n        success: true,\n        data: processingResult,\n        metadata: {\n          domainFrom: fromDomain,\n          domainTo: toDomain,\n          operation: `cross_domain_event:${operation}`,\n          timestamp: new Date(),\n          validationTime: Date.now() - startTime,\n          crossingId: this.generateCrossingId(),\n        },\n      };\n    } catch (error) {\n      this.logger.error('Cross-domain event routing failed', {\n        fromDomain,\n        toDomain,\n        operation,\n        eventType: event.type,\n        error: error instanceof Error ? error.message : String(error),\n      });\n\n      return {\n        success: false,\n        error: error instanceof Error ? error : new Error(String(error)),\n        metadata: {\n          domainFrom: fromDomain,\n          domainTo: toDomain,\n          operation: `cross_domain_event:${operation}`,\n          timestamp: new Date(),\n          validationTime: Date.now() - startTime,\n          crossingId: this.generateCrossingId(),\n        },\n      };\n    }\n  }\n\n  // ============================================================================\n  // EVENT QUERYING AND HISTORY - Event system introspection\n  // ============================================================================\n\n  /**\n   * Query events from history\n   */\n  public queryEvents(criteria: {\n    eventType?: string;\n    domain?: Domain;\n    startTime?: Date;\n    endTime?: Date;\n    correlationId?: string;\n    tags?: string[];\n    limit?: number;\n  }): BaseEvent[] {\n    let filteredEvents = this.eventHistory.slice();\n\n    if (criteria.eventType) {\n      filteredEvents = filteredEvents.filter((e) => e.type === criteria.eventType);\n    }\n\n    if (criteria.domain) {\n      filteredEvents = filteredEvents.filter((e) => e.domain === criteria.domain);\n    }\n\n    if (criteria.startTime) {\n      filteredEvents = filteredEvents.filter((e) => e.timestamp >= criteria.startTime!);\n    }\n\n    if (criteria.endTime) {\n      filteredEvents = filteredEvents.filter((e) => e.timestamp <= criteria.endTime!);\n    }\n\n    if (criteria.correlationId) {\n      filteredEvents = filteredEvents.filter(\n        (e) => e.metadata?.correlationId === criteria.correlationId\n      );\n    }\n\n    if (criteria.tags && criteria.tags.length > 0) {\n      filteredEvents = filteredEvents.filter((e) =>\n        e.metadata?.tags?.some((tag) => criteria.tags!.includes(tag))\n      );\n    }\n\n    if (criteria.limit && criteria.limit > 0) {\n      filteredEvents = filteredEvents.slice(-criteria.limit);\n    }\n\n    return filteredEvents;\n  }\n\n  /**\n   * Get event by ID\n   */\n  public getEvent(eventId: string): BaseEvent | undefined {\n    // Check cache first\n    if (this.config.enableCaching && this.eventCache.has(eventId)) {\n      return this.eventCache.get(eventId);\n    }\n\n    // Search in history\n    return this.eventHistory.find((e) => e.id === eventId);\n  }\n\n  /**\n   * Get events by correlation ID\n   */\n  public getEventsByCorrelation(correlationId: string): BaseEvent[] {\n    return this.queryEvents({ correlationId });\n  }\n\n  /**\n   * Clear event history\n   */\n  public clearEventHistory(): void {\n    this.eventHistory.length = 0;\n    this.eventCache.clear();\n    this.logger.info('Event history cleared');\n  }\n\n  // ============================================================================\n  // PERFORMANCE MONITORING - System metrics and optimization\n  // ============================================================================\n\n  /**\n   * Get comprehensive event system metrics\n   */\n  public getMetrics(): EventSystemMetrics {\n    const now = Date.now();\n    const uptimeSeconds = (now - this.startTime) / 1000;\n\n    const domainEventCounts: Record<Domain, number> = {} as Record<Domain, number>;\n    for (const domain of Object.values(Domain)) {\n      domainEventCounts[domain] = this.eventHistory.filter((e) => e.domain === domain).length;\n    }\n\n    const totalProcessingTimes = Array.from(this.processingStats.values())\n      .flat()\n      .filter((time) => time > 0);\n\n    const averageProcessingTime =\n      totalProcessingTimes.length > 0\n        ? totalProcessingTimes.reduce((sum, time) => sum + time, 0) / totalProcessingTimes.length\n        : 0;\n\n    const failedEvents = this.eventHistory.length - totalProcessingTimes.length;\n    const failureRate = this.eventHistory.length > 0 ? failedEvents / this.eventHistory.length : 0;\n\n    return {\n      totalEvents: this.eventCounter,\n      eventsPerSecond: uptimeSeconds > 0 ? this.eventCounter / uptimeSeconds : 0,\n      averageProcessingTime,\n      failureRate,\n      handlerCount: Array.from(this.eventHandlers.values()).reduce(\n        (sum, handlers) => sum + handlers.length,\n        0\n      ),\n      domainEventCounts,\n      memoryUsage: this.estimateMemoryUsage(),\n      cacheHitRate: this.calculateCacheHitRate(),\n    };\n  }\n\n  /**\n   * Get detailed performance statistics\n   */\n  public getPerformanceStats(): Record<\n    string,\n    {\n      count: number;\n      averageTime: number;\n      minTime: number;\n      maxTime: number;\n      p95Time: number;\n      p99Time: number;\n    }\n  > {\n    const stats: Record<string, any> = {};\n\n    for (const [eventType, times] of this.processingStats.entries()) {\n      if (times.length === 0) continue;\n\n      const sortedTimes = [...times].sort((a, b) => a - b);\n      const count = times.length;\n      const sum = times.reduce((a, b) => a + b, 0);\n\n      stats[eventType] = {\n        count,\n        averageTime: sum / count,\n        minTime: sortedTimes[0],\n        maxTime: sortedTimes[sortedTimes.length - 1],\n        p95Time: sortedTimes[Math.floor(count * 0.95)] || 0,\n        p99Time: sortedTimes[Math.floor(count * 0.99)] || 0,\n      };\n    }\n\n    return stats;\n  }\n\n  /**\n   * Reset performance metrics\n   */\n  public resetMetrics(): void {\n    this.processingStats.clear();\n    this.eventCounter = 0;\n    this.startTime = Date.now();\n    this.logger.info('Performance metrics reset');\n  }\n\n  // ============================================================================\n  // LIFECYCLE MANAGEMENT - System startup and shutdown\n  // ============================================================================\n\n  /**\n   * Initialize the event system\n   */\n  public async initialize(): Promise<void> {\n    this.logger.info('Initializing TypeSafeEventBus', {\n      config: this.config,\n    });\n\n    // Initialize domain validators\n    if (this.config.domainValidation) {\n      for (const [domain, validator] of this.domainValidators.entries()) {\n        try {\n          // Validators are already initialized via getDomainValidator\n          this.logger.debug('Domain validator ready', { domain });\n        } catch (error) {\n          this.logger.error('Failed to initialize domain validator', {\n            domain,\n            error: error instanceof Error ? error.message : String(error),\n          });\n          throw error;\n        }\n      }\n    }\n\n    // Register system event handlers\n    this.registerSystemEventHandlers();\n\n    this.logger.info('TypeSafeEventBus initialized successfully');\n  }\n\n  /**\n   * Shutdown the event system gracefully\n   */\n  public async shutdown(): Promise<void> {\n    this.logger.info('Shutting down TypeSafeEventBus');\n\n    // Emit system shutdown event\n    try {\n      await this.emitEvent({\n        id: this.generateEventId(),\n        type: 'system.shutdown',\n        domain: Domain.CORE,\n        timestamp: new Date(),\n        version: '1.0.0',\n        payload: {\n          reason: 'graceful_shutdown',\n          graceful: true,\n          uptime: Date.now() - this.startTime,\n        },\n      } as SystemShutdownEvent);\n    } catch (error) {\n      this.logger.warn('Failed to emit shutdown event', {\n        error: error instanceof Error ? error.message : String(error),\n      });\n    }\n\n    // Clear all handlers\n    this.eventHandlers.clear();\n\n    // Clear caches\n    this.eventCache.clear();\n    this.schemaCache.clear();\n\n    // Remove all listeners\n    this.removeAllListeners();\n\n    this.logger.info('TypeSafeEventBus shutdown complete');\n  }\n\n  // ============================================================================\n  // PRIVATE IMPLEMENTATION METHODS\n  // ============================================================================\n\n  private async processEventHandlers<TEvent extends BaseEvent>(\n    event: TEvent,\n    options: { timeout: number }\n  ): Promise<{\n    handlerResults: Array<{\n      handlerId: string;\n      success: boolean;\n      processingTime: number;\n      error?: Error;\n    }>;\n    validationTime: number;\n  }> {\n    const handlerResults: Array<{\n      handlerId: string;\n      success: boolean;\n      processingTime: number;\n      error?: Error;\n    }> = [];\n\n    let validationTime = 0;\n\n    // Get handlers for this specific event type\n    const specificHandlers = this.getHandlers(event.type);\n\n    // Get domain handlers\n    const domainHandlers = this.getHandlers(`domain:${event.domain}`);\n\n    // Get wildcard handlers\n    const wildcardHandlers = this.getHandlers('*');\n\n    // Combine and deduplicate handlers\n    const allHandlers = [...specificHandlers, ...domainHandlers, ...wildcardHandlers];\n    const uniqueHandlers = Array.from(new Map(allHandlers.map((h) => [h.id, h])).values());\n\n    if (uniqueHandlers.length === 0) {\n      return { handlerResults, validationTime };\n    }\n\n    // Create handler context\n    const context: EventHandlerContext = {\n      eventBus: this,\n      logger: this.logger,\n      startTime: new Date(),\n      correlationId: event.metadata?.correlationId || this.generateCorrelationId(),\n      metadata: {},\n    };\n\n    // Process handlers concurrently with timeout\n    const handlerPromises = uniqueHandlers.map(async (handler) => {\n      const handlerStartTime = Date.now();\n\n      try {\n        // Validate event against handler schema if provided\n        if (handler.schema && handler.config.validatePayload) {\n          const schemaValidationStart = Date.now();\n\n          if (this.config.domainValidation) {\n            const validator = this.domainValidators.get(event.domain);\n            if (validator) {\n              validator.validateInput(event, handler.schema);\n            }\n          }\n\n          validationTime += Date.now() - schemaValidationStart;\n        }\n\n        // Execute handler with timeout\n        await Promise.race([\n          handler.handler(event, context),\n          new Promise((_, reject) =>\n            setTimeout(\n              () => reject(new Error('Handler timeout')),\n              handler.config.timeout || options.timeout\n            )\n          ),\n        ]);\n\n        const processingTime = Date.now() - handlerStartTime;\n\n        return {\n          handlerId: handler.id,\n          success: true,\n          processingTime,\n        };\n      } catch (error) {\n        const processingTime = Date.now() - handlerStartTime;\n\n        this.logger.error('Event handler failed', {\n          handlerId: handler.id,\n          eventType: event.type,\n          eventId: event.id,\n          error: error instanceof Error ? error.message : String(error),\n          processingTime,\n        });\n\n        return {\n          handlerId: handler.id,\n          success: false,\n          processingTime,\n          error: error instanceof Error ? error : new Error(String(error)),\n        };\n      }\n    });\n\n    const results = await Promise.allSettled(handlerPromises);\n\n    for (const result of results) {\n      if (result.status === 'fulfilled') {\n        handlerResults.push(result.value);\n      } else {\n        handlerResults.push({\n          handlerId: 'unknown',\n          success: false,\n          processingTime: 0,\n          error: result.reason instanceof Error ? result.reason : new Error(String(result.reason)),\n        });\n      }\n    }\n\n    return { handlerResults, validationTime };\n  }\n\n  private async validateEventAtDomainBoundary<TEvent extends BaseEvent>(\n    event: TEvent\n  ): Promise<Result<TEvent>> {\n    const validator = this.domainValidators.get(event.domain);\n    if (!validator) {\n      return {\n        success: true,\n        data: event,\n      };\n    }\n\n    try {\n      // Get or create schema for this event type\n      const schema = this.getEventSchema(event.type);\n\n      if (schema) {\n        const validatedEvent = validator.validateInput(event, schema);\n        return {\n          success: true,\n          data: validatedEvent,\n        };\n      } else {\n        // If no schema, just validate basic structure\n        const basicSchema: TypeSchema<BaseEvent> = BaseEventSchema;\n        validator.validateInput(event, basicSchema);\n        return {\n          success: true,\n          data: event,\n        };\n      }\n    } catch (error) {\n      return {\n        success: false,\n        error: error instanceof Error ? error : new Error(String(error)),\n      };\n    }\n  }\n\n  private async validateCrossDomainEvent<TEvent extends BaseEvent>(\n    event: TEvent,\n    fromDomain: Domain,\n    toDomain: Domain\n  ): Promise<Result<TEvent>> {\n    try {\n      const schema = this.getEventSchema(event.type);\n      if (schema) {\n        const validatedEvent = validateCrossDomain(\n          event,\n          schema,\n          fromDomain,\n          toDomain,\n          `event_validation:${event.type}`\n        );\n        return {\n          success: true,\n          data: validatedEvent,\n        };\n      } else {\n        return {\n          success: true,\n          data: event,\n        };\n      }\n    } catch (error) {\n      return {\n        success: false,\n        error: error instanceof Error ? error : new Error(String(error)),\n      };\n    }\n  }\n\n  private getEventSchema(eventType: string): TypeSchema | undefined {\n    // Check cache first\n    if (this.schemaCache.has(eventType)) {\n      return this.schemaCache.get(eventType);\n    }\n\n    // Look up in predefined schemas\n    const schemaKey = eventType\n      .split('.')\n      .map((part) => part.charAt(0).toUpperCase() + part.slice(1))\n      .join('');\n\n    const schema = (EventSchemas as any)[schemaKey];\n    if (schema) {\n      this.schemaCache.set(eventType, schema);\n      return schema;\n    }\n\n    return undefined;\n  }\n\n  private addToEventHistory<TEvent extends BaseEvent>(event: TEvent): void {\n    this.eventHistory.push(event);\n    this.eventCounter++;\n\n    // Maintain history size limit\n    if (this.eventHistory.length > this.config.maxEventHistory) {\n      this.eventHistory.shift();\n    }\n  }\n\n  private trackEventMetrics(eventType: string, processingTime: number, success: boolean): void {\n    if (!this.processingStats.has(eventType)) {\n      this.processingStats.set(eventType, []);\n    }\n\n    const stats = this.processingStats.get(eventType)!;\n    if (success) {\n      stats.push(processingTime);\n    }\n\n    // Keep only recent metrics\n    if (stats.length > 1000) {\n      stats.splice(0, stats.length - 1000);\n    }\n  }\n\n  private registerSystemEventHandlers(): void {\n    // Register handler for error events to log them\n    this.registerHandler('error.occurred', async (event: ErrorOccurredEvent) => {\n      this.logger.error('System error occurred', {\n        error: event.payload.error.message,\n        severity: event.payload.severity,\n        recoverable: event.payload.recoverable,\n        context: event.payload.context,\n      });\n    });\n\n    // Register handler for system events\n    this.registerHandler('system.started', async (event: SystemStartedEvent) => {\n      this.logger.info('System started', {\n        version: event.payload.version,\n        startTime: event.payload.startTime,\n      });\n    });\n  }\n\n  private generateEventId(): string {\n    return `event-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  private generateHandlerId(): string {\n    return `handler-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  private generateCorrelationId(): string {\n    return `corr-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  private generateCrossingId(): string {\n    return `crossing-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  private estimateMemoryUsage(): number {\n    const eventHistorySize = JSON.stringify(this.eventHistory).length;\n    const cacheSize = JSON.stringify(Array.from(this.eventCache.values())).length;\n    const handlerSize = this.eventHandlers.size * 1000; // Rough estimate\n    return eventHistorySize + cacheSize + handlerSize;\n  }\n\n  private calculateCacheHitRate(): number {\n    // Simple cache hit rate calculation\n    // In a production system, you'd track actual cache hits vs misses\n    return this.config.enableCaching && this.eventCache.size > 0 ? 0.85 : 0;\n  }\n\n  // ============================================================================\n  // I\u00C9VENTBUS INTERFACE COMPATIBILITY - Legacy support\n  // ============================================================================\n\n  /**\n   * Legacy emit method for IEventBus compatibility\n   */\n  emit(eventName: string | symbol, ...args: any[]): boolean {\n    // Handle both the new typed events and legacy event emitter events\n    const result = super.emit(eventName, ...args);\n\n    // If this is a typed event, also process it through our type-safe system\n    if (\n      typeof eventName === 'string' &&\n      args.length > 0 &&\n      args[0] &&\n      typeof args[0] === 'object'\n    ) {\n      const event = args[0] as BaseEvent;\n      if (event.type && event.domain && event.timestamp) {\n        // This is already processed by emitEvent, so we don't need to process it again\n        // This is just for compatibility\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Legacy on method for IEventBus compatibility\n   */\n  on(eventName: string | symbol, listener: (...args: any[]) => void): this {\n    super.on(eventName, listener);\n    return this;\n  }\n\n  /**\n   * Legacy off method for IEventBus compatibility\n   */\n  off(eventName: string | symbol, listener: (...args: any[]) => void): this {\n    super.off(eventName, listener);\n    return this;\n  }\n}\n\n// ============================================================================\n// FACTORY FUNCTIONS AND UTILITIES - Convenience functions for common usage\n// ============================================================================\n\n/**\n * Create a type-safe event bus with default configuration\n */\nexport function createTypeSafeEventBus(\n  config?: EventSystemConfig,\n  domainValidator?: DomainBoundaryValidator\n): TypeSafeEventBus {\n  return new TypeSafeEventBus(config, domainValidator);\n}\n\n/**\n * Create an event with proper typing and metadata\n */\nexport function createEvent<TEvent extends BaseEvent>(\n  type: TEvent['type'],\n  domain: Domain,\n  payload: Omit<TEvent, 'id' | 'type' | 'domain' | 'timestamp' | 'version'>,\n  metadata?: Partial<EventMetadata>\n): TEvent {\n  return {\n    id: `event-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\n    type,\n    domain,\n    timestamp: new Date(),\n    version: '1.0.0',\n    metadata,\n    ...payload,\n  } as TEvent;\n}\n\n/**\n * Create a correlation ID for event tracking\n */\nexport function createCorrelationId(): string {\n  return `corr-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n}\n\n/**\n * Type guard to check if an object is a valid base event\n */\nexport function isBaseEvent(obj: unknown): obj is BaseEvent {\n  if (!obj || typeof obj !== 'object') return false;\n\n  const event = obj as any;\n  return (\n    typeof event.id === 'string' &&\n    typeof event.type === 'string' &&\n    typeof event.domain === 'string' &&\n    event.timestamp instanceof Date &&\n    typeof event.version === 'string' &&\n    Object.values(Domain).includes(event.domain)\n  );\n}\n\n/**\n * Type guard to check if an event belongs to a specific domain\n */\nexport function isDomainEvent<TDomain extends Domain>(\n  event: BaseEvent,\n  domain: TDomain\n): event is BaseEvent & { domain: TDomain } {\n  return event.domain === domain;\n}\n\n/**\n * Extract event type from event class\n */\nexport function getEventType<TEvent extends BaseEvent>(\n  eventClass: new (...args: any[]) => TEvent\n): string {\n  // This would require reflection or a different approach in TypeScript\n  // For now, events should define their own type property\n  return 'unknown';\n}\n\n// ============================================================================\n// EXPORTS - Public API\n// ============================================================================\n\nexport default TypeSafeEventBus;\n\n// Re-export important types and interfaces\nexport type {\n  BaseEvent,\n  DomainEvent,\n  SystemEvent,\n  EventHandler,\n  EventHandlerContext,\n  EventHandlerConfig,\n  EventProcessingResult,\n  EventProcessingMetadata,\n  EventSystemMetrics,\n  EventSystemConfig,\n  TypedEventHandler,\n  // Domain-specific events\n  CoordinationEvent,\n  WorkflowDomainEvent,\n  NeuralEvent,\n  DatabaseEvent,\n  MemoryEvent,\n  KnowledgeEvent,\n  InterfaceEvent,\n  CoreEvent,\n  // Specific event types\n  AgentCreatedEvent,\n  AgentDestroyedEvent,\n  TaskAssignedEvent,\n  TaskCompletedEvent,\n  SwarmStateChangedEvent,\n  WorkflowStartedEvent,\n  WorkflowCompletedEvent,\n  WorkflowFailedEvent,\n  WorkflowStepCompletedEvent,\n  NetworkTrainingStartedEvent,\n  NetworkTrainingCompletedEvent,\n  NetworkPredictionEvent,\n  QueryExecutedEvent,\n  TransactionCompletedEvent,\n  MemoryStoredEvent,\n  MemoryRetrievedEvent,\n  MemoryEvictedEvent,\n  KnowledgeUpdatedEvent,\n  KnowledgeQueryEvent,\n  HumanValidationRequestedEvent,\n  HumanValidationCompletedEvent,\n  AGUIGateOpenedEvent,\n  AGUIGateClosedEvent,\n  SystemStartedEvent,\n  SystemShutdownEvent,\n  ErrorOccurredEvent,\n};\n"],
  "mappings": "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",
  "names": ["Domain", "EventPriority", "GateEscalationLevel", "validationResult"]
}
