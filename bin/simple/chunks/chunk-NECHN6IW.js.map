{
  "version": 3,
  "sources": ["../../node_modules/@logtape/logtape/level.ts", "../../node_modules/@logtape/logtape/logger.ts", "../../src/config/logging-config.ts"],
  "sourcesContent": ["const logLevels = [\n  \"trace\",\n  \"debug\",\n  \"info\",\n  \"warning\",\n  \"error\",\n  \"fatal\",\n] as const;\n\n/**\n * The severity level of a {@link LogRecord}.\n */\nexport type LogLevel = typeof logLevels[number];\n\n/**\n * Lists all available log levels with the order of their severity.\n * The `\"trace\"` level goes first, and the `\"fatal\"` level goes last.\n * @returns A new copy of the array of log levels.\n * @since 1.0.0\n */\nexport function getLogLevels(): readonly LogLevel[] {\n  return [...logLevels];\n}\n\n/**\n * Parses a log level from a string.\n *\n * @param level The log level as a string.  This is case-insensitive.\n * @returns The log level.\n * @throws {TypeError} If the log level is invalid.\n */\nexport function parseLogLevel(level: string): LogLevel {\n  level = level.toLowerCase();\n  switch (level) {\n    case \"trace\":\n    case \"debug\":\n    case \"info\":\n    case \"warning\":\n    case \"error\":\n    case \"fatal\":\n      return level;\n    default:\n      throw new TypeError(`Invalid log level: ${level}.`);\n  }\n}\n\n/**\n * Checks if a string is a valid log level.  This function can be used as\n * as a type guard to narrow the type of a string to a {@link LogLevel}.\n *\n * @param level The log level as a string.  This is case-sensitive.\n * @returns `true` if the string is a valid log level.\n */\nexport function isLogLevel(level: string): level is LogLevel {\n  switch (level) {\n    case \"trace\":\n    case \"debug\":\n    case \"info\":\n    case \"warning\":\n    case \"error\":\n    case \"fatal\":\n      return true;\n    default:\n      return false;\n  }\n}\n\n/**\n * Compares two log levels.\n * @param a The first log level.\n * @param b The second log level.\n * @returns A negative number if `a` is less than `b`, a positive number if `a`\n *          is greater than `b`, or zero if they are equal.\n * @since 0.8.0\n */\nexport function compareLogLevel(a: LogLevel, b: LogLevel): number {\n  const aIndex = logLevels.indexOf(a);\n  if (aIndex < 0) {\n    throw new TypeError(`Invalid log level: ${JSON.stringify(a)}.`);\n  }\n  const bIndex = logLevels.indexOf(b);\n  if (bIndex < 0) {\n    throw new TypeError(`Invalid log level: ${JSON.stringify(b)}.`);\n  }\n  return aIndex - bIndex;\n}\n", "import type { ContextLocalStorage } from \"./context.ts\";\nimport type { Filter } from \"./filter.ts\";\nimport { compareLogLevel, type LogLevel } from \"./level.ts\";\nimport type { LogRecord } from \"./record.ts\";\nimport type { Sink } from \"./sink.ts\";\n\n/**\n * A logger interface.  It provides methods to log messages at different\n * severity levels.\n *\n * ```typescript\n * const logger = getLogger(\"category\");\n * logger.trace `A trace message with ${value}`\n * logger.debug `A debug message with ${value}.`;\n * logger.info `An info message with ${value}.`;\n * logger.warn `A warning message with ${value}.`;\n * logger.error `An error message with ${value}.`;\n * logger.fatal `A fatal error message with ${value}.`;\n * ```\n */\nexport interface Logger {\n  /**\n   * The category of the logger.  It is an array of strings.\n   */\n  readonly category: readonly string[];\n\n  /**\n   * The logger with the supercategory of the current logger.  If the current\n   * logger is the root logger, this is `null`.\n   */\n  readonly parent: Logger | null;\n\n  /**\n   * Get a child logger with the given subcategory.\n   *\n   * ```typescript\n   * const logger = getLogger(\"category\");\n   * const subLogger = logger.getChild(\"sub-category\");\n   * ```\n   *\n   * The above code is equivalent to:\n   *\n   * ```typescript\n   * const logger = getLogger(\"category\");\n   * const subLogger = getLogger([\"category\", \"sub-category\"]);\n   * ```\n   *\n   * @param subcategory The subcategory.\n   * @returns The child logger.\n   */\n  getChild(\n    subcategory: string | readonly [string] | readonly [string, ...string[]],\n  ): Logger;\n\n  /**\n   * Get a logger with contextual properties.  This is useful for\n   * log multiple messages with the shared set of properties.\n   *\n   * ```typescript\n   * const logger = getLogger(\"category\");\n   * const ctx = logger.with({ foo: 123, bar: \"abc\" });\n   * ctx.info(\"A message with {foo} and {bar}.\");\n   * ctx.warn(\"Another message with {foo}, {bar}, and {baz}.\", { baz: true });\n   * ```\n   *\n   * The above code is equivalent to:\n   *\n   * ```typescript\n   * const logger = getLogger(\"category\");\n   * logger.info(\"A message with {foo} and {bar}.\", { foo: 123, bar: \"abc\" });\n   * logger.warn(\n   *   \"Another message with {foo}, {bar}, and {baz}.\",\n   *   { foo: 123, bar: \"abc\", baz: true },\n   * );\n   * ```\n   *\n   * @param properties\n   * @returns\n   * @since 0.5.0\n   */\n  with(properties: Record<string, unknown>): Logger;\n\n  /**\n   * Log a trace message.  Use this as a template string prefix.\n   *\n   * ```typescript\n   * logger.trace `A trace message with ${value}.`;\n   * ```\n   *\n   * @param message The message template strings array.\n   * @param values The message template values.\n   * @since 0.12.0\n   */\n  trace(message: TemplateStringsArray, ...values: readonly unknown[]): void;\n\n  /**\n   * Log a trace message with properties.\n   *\n   * ```typescript\n   * logger.trace('A trace message with {value}.', { value });\n   * ```\n   *\n   * If the properties are expensive to compute, you can pass a callback that\n   * returns the properties:\n   *\n   * ```typescript\n   * logger.trace(\n   *   'A trace message with {value}.',\n   *   () => ({ value: expensiveComputation() })\n   * );\n   * ```\n   *\n   * @param message The message template.  Placeholders to be replaced with\n   *                `values` are indicated by keys in curly braces (e.g.,\n   *                `{value}`).\n   * @param properties The values to replace placeholders with.  For lazy\n   *                   evaluation, this can be a callback that returns the\n   *                   properties.\n   * @since 0.12.0\n   */\n  trace(\n    message: string,\n    properties?: Record<string, unknown> | (() => Record<string, unknown>),\n  ): void;\n\n  /**\n   * Log a trace values with no message.  This is useful when you\n   * want to log properties without a message, e.g., when you want to log\n   * the context of a request or an operation.\n   *\n   * ```typescript\n   * logger.trace({ method: 'GET', url: '/api/v1/resource' });\n   * ```\n   *\n   * Note that this is a shorthand for:\n   *\n   * ```typescript\n   * logger.trace('{*}', { method: 'GET', url: '/api/v1/resource' });\n   * ```\n   *\n   * If the properties are expensive to compute, you cannot use this shorthand\n   * and should use the following syntax instead:\n   *\n   * ```typescript\n   * logger.trace('{*}', () => ({\n   *   method: expensiveMethod(),\n   *   url: expensiveUrl(),\n   * }));\n   * ```\n   *\n   * @param properties The values to log.  Note that this does not take\n   *                   a callback.\n   * @since 0.12.0\n   */\n  trace(properties: Record<string, unknown>): void;\n\n  /**\n   * Lazily log a trace message.  Use this when the message values are expensive\n   * to compute and should only be computed if the message is actually logged.\n   *\n   * ```typescript\n   * logger.trace(l => l`A trace message with ${expensiveValue()}.`);\n   * ```\n   *\n   * @param callback A callback that returns the message template prefix.\n   * @throws {TypeError} If no log record was made inside the callback.\n   * @since 0.12.0\n   */\n  trace(callback: LogCallback): void;\n\n  /**\n   * Log a debug message.  Use this as a template string prefix.\n   *\n   * ```typescript\n   * logger.debug `A debug message with ${value}.`;\n   * ```\n   *\n   * @param message The message template strings array.\n   * @param values The message template values.\n   */\n  debug(message: TemplateStringsArray, ...values: readonly unknown[]): void;\n\n  /**\n   * Log a debug message with properties.\n   *\n   * ```typescript\n   * logger.debug('A debug message with {value}.', { value });\n   * ```\n   *\n   * If the properties are expensive to compute, you can pass a callback that\n   * returns the properties:\n   *\n   * ```typescript\n   * logger.debug(\n   *   'A debug message with {value}.',\n   *   () => ({ value: expensiveComputation() })\n   * );\n   * ```\n   *\n   * @param message The message template.  Placeholders to be replaced with\n   *                `values` are indicated by keys in curly braces (e.g.,\n   *                `{value}`).\n   * @param properties The values to replace placeholders with.  For lazy\n   *                   evaluation, this can be a callback that returns the\n   *                   properties.\n   */\n  debug(\n    message: string,\n    properties?: Record<string, unknown> | (() => Record<string, unknown>),\n  ): void;\n\n  /**\n   * Log a debug values with no message.  This is useful when you\n   * want to log properties without a message, e.g., when you want to log\n   * the context of a request or an operation.\n   *\n   * ```typescript\n   * logger.debug({ method: 'GET', url: '/api/v1/resource' });\n   * ```\n   *\n   * Note that this is a shorthand for:\n   *\n   * ```typescript\n   * logger.debug('{*}', { method: 'GET', url: '/api/v1/resource' });\n   * ```\n   *\n   * If the properties are expensive to compute, you cannot use this shorthand\n   * and should use the following syntax instead:\n   *\n   * ```typescript\n   * logger.debug('{*}', () => ({\n   *   method: expensiveMethod(),\n   *   url: expensiveUrl(),\n   * }));\n   * ```\n   *\n   * @param properties The values to log.  Note that this does not take\n   *                   a callback.\n   * @since 0.11.0\n   */\n  debug(properties: Record<string, unknown>): void;\n\n  /**\n   * Lazily log a debug message.  Use this when the message values are expensive\n   * to compute and should only be computed if the message is actually logged.\n   *\n   * ```typescript\n   * logger.debug(l => l`A debug message with ${expensiveValue()}.`);\n   * ```\n   *\n   * @param callback A callback that returns the message template prefix.\n   * @throws {TypeError} If no log record was made inside the callback.\n   */\n  debug(callback: LogCallback): void;\n\n  /**\n   * Log an informational message.  Use this as a template string prefix.\n   *\n   * ```typescript\n   * logger.info `An info message with ${value}.`;\n   * ```\n   *\n   * @param message The message template strings array.\n   * @param values The message template values.\n   */\n  info(message: TemplateStringsArray, ...values: readonly unknown[]): void;\n\n  /**\n   * Log an informational message with properties.\n   *\n   * ```typescript\n   * logger.info('An info message with {value}.', { value });\n   * ```\n   *\n   * If the properties are expensive to compute, you can pass a callback that\n   * returns the properties:\n   *\n   * ```typescript\n   * logger.info(\n   *   'An info message with {value}.',\n   *   () => ({ value: expensiveComputation() })\n   * );\n   * ```\n   *\n   * @param message The message template.  Placeholders to be replaced with\n   *                `values` are indicated by keys in curly braces (e.g.,\n   *                `{value}`).\n   * @param properties The values to replace placeholders with.  For lazy\n   *                   evaluation, this can be a callback that returns the\n   *                   properties.\n   */\n  info(\n    message: string,\n    properties?: Record<string, unknown> | (() => Record<string, unknown>),\n  ): void;\n\n  /**\n   * Log an informational values with no message.  This is useful when you\n   * want to log properties without a message, e.g., when you want to log\n   * the context of a request or an operation.\n   *\n   * ```typescript\n   * logger.info({ method: 'GET', url: '/api/v1/resource' });\n   * ```\n   *\n   * Note that this is a shorthand for:\n   *\n   * ```typescript\n   * logger.info('{*}', { method: 'GET', url: '/api/v1/resource' });\n   * ```\n   *\n   * If the properties are expensive to compute, you cannot use this shorthand\n   * and should use the following syntax instead:\n   *\n   * ```typescript\n   * logger.info('{*}', () => ({\n   *   method: expensiveMethod(),\n   *   url: expensiveUrl(),\n   * }));\n   * ```\n   *\n   * @param properties The values to log.  Note that this does not take\n   *                   a callback.\n   * @since 0.11.0\n   */\n  info(properties: Record<string, unknown>): void;\n\n  /**\n   * Lazily log an informational message.  Use this when the message values are\n   * expensive to compute and should only be computed if the message is actually\n   * logged.\n   *\n   * ```typescript\n   * logger.info(l => l`An info message with ${expensiveValue()}.`);\n   * ```\n   *\n   * @param callback A callback that returns the message template prefix.\n   * @throws {TypeError} If no log record was made inside the callback.\n   */\n  info(callback: LogCallback): void;\n\n  /**\n   * Log a warning message.  Use this as a template string prefix.\n   *\n   * ```typescript\n   * logger.warn `A warning message with ${value}.`;\n   * ```\n   *\n   * @param message The message template strings array.\n   * @param values The message template values.\n   */\n  warn(message: TemplateStringsArray, ...values: readonly unknown[]): void;\n\n  /**\n   * Log a warning message with properties.\n   *\n   * ```typescript\n   * logger.warn('A warning message with {value}.', { value });\n   * ```\n   *\n   * If the properties are expensive to compute, you can pass a callback that\n   * returns the properties:\n   *\n   * ```typescript\n   * logger.warn(\n   *   'A warning message with {value}.',\n   *   () => ({ value: expensiveComputation() })\n   * );\n   * ```\n   *\n   * @param message The message template.  Placeholders to be replaced with\n   *                `values` are indicated by keys in curly braces (e.g.,\n   *                `{value}`).\n   * @param properties The values to replace placeholders with.  For lazy\n   *                   evaluation, this can be a callback that returns the\n   *                   properties.\n   */\n  warn(\n    message: string,\n    properties?: Record<string, unknown> | (() => Record<string, unknown>),\n  ): void;\n\n  /**\n   * Log a warning values with no message.  This is useful when you\n   * want to log properties without a message, e.g., when you want to log\n   * the context of a request or an operation.\n   *\n   * ```typescript\n   * logger.warn({ method: 'GET', url: '/api/v1/resource' });\n   * ```\n   *\n   * Note that this is a shorthand for:\n   *\n   * ```typescript\n   * logger.warn('{*}', { method: 'GET', url: '/api/v1/resource' });\n   * ```\n   *\n   * If the properties are expensive to compute, you cannot use this shorthand\n   * and should use the following syntax instead:\n   *\n   * ```typescript\n   * logger.warn('{*}', () => ({\n   *   method: expensiveMethod(),\n   *   url: expensiveUrl(),\n   * }));\n   * ```\n   *\n   * @param properties The values to log.  Note that this does not take\n   *                   a callback.\n   * @since 0.11.0\n   */\n  warn(properties: Record<string, unknown>): void;\n\n  /**\n   * Lazily log a warning message.  Use this when the message values are\n   * expensive to compute and should only be computed if the message is actually\n   * logged.\n   *\n   * ```typescript\n   * logger.warn(l => l`A warning message with ${expensiveValue()}.`);\n   * ```\n   *\n   * @param callback A callback that returns the message template prefix.\n   * @throws {TypeError} If no log record was made inside the callback.\n   */\n  warn(callback: LogCallback): void;\n\n  /**\n   * Log a warning message.  Use this as a template string prefix.\n   *\n   * ```typescript\n   * logger.warning `A warning message with ${value}.`;\n   * ```\n   *\n   * @param message The message template strings array.\n   * @param values The message template values.\n   * @since 0.12.0\n   */\n  warning(message: TemplateStringsArray, ...values: readonly unknown[]): void;\n\n  /**\n   * Log a warning message with properties.\n   *\n   * ```typescript\n   * logger.warning('A warning message with {value}.', { value });\n   * ```\n   *\n   * If the properties are expensive to compute, you can pass a callback that\n   * returns the properties:\n   *\n   * ```typescript\n   * logger.warning(\n   *   'A warning message with {value}.',\n   *   () => ({ value: expensiveComputation() })\n   * );\n   * ```\n   *\n   * @param message The message template.  Placeholders to be replaced with\n   *                `values` are indicated by keys in curly braces (e.g.,\n   *                `{value}`).\n   * @param properties The values to replace placeholders with.  For lazy\n   *                   evaluation, this can be a callback that returns the\n   *                   properties.\n   * @since 0.12.0\n   */\n  warning(\n    message: string,\n    properties?: Record<string, unknown> | (() => Record<string, unknown>),\n  ): void;\n\n  /**\n   * Log a warning values with no message.  This is useful when you\n   * want to log properties without a message, e.g., when you want to log\n   * the context of a request or an operation.\n   *\n   * ```typescript\n   * logger.warning({ method: 'GET', url: '/api/v1/resource' });\n   * ```\n   *\n   * Note that this is a shorthand for:\n   *\n   * ```typescript\n   * logger.warning('{*}', { method: 'GET', url: '/api/v1/resource' });\n   * ```\n   *\n   * If the properties are expensive to compute, you cannot use this shorthand\n   * and should use the following syntax instead:\n   *\n   * ```typescript\n   * logger.warning('{*}', () => ({\n   *   method: expensiveMethod(),\n   *   url: expensiveUrl(),\n   * }));\n   * ```\n   *\n   * @param properties The values to log.  Note that this does not take\n   *                   a callback.\n   * @since 0.12.0\n   */\n  warning(properties: Record<string, unknown>): void;\n\n  /**\n   * Lazily log a warning message.  Use this when the message values are\n   * expensive to compute and should only be computed if the message is actually\n   * logged.\n   *\n   * ```typescript\n   * logger.warning(l => l`A warning message with ${expensiveValue()}.`);\n   * ```\n   *\n   * @param callback A callback that returns the message template prefix.\n   * @throws {TypeError} If no log record was made inside the callback.\n   * @since 0.12.0\n   */\n  warning(callback: LogCallback): void;\n\n  /**\n   * Log an error message.  Use this as a template string prefix.\n   *\n   * ```typescript\n   * logger.error `An error message with ${value}.`;\n   * ```\n   *\n   * @param message The message template strings array.\n   * @param values The message template values.\n   */\n  error(message: TemplateStringsArray, ...values: readonly unknown[]): void;\n\n  /**\n   * Log an error message with properties.\n   *\n   * ```typescript\n   * logger.warn('An error message with {value}.', { value });\n   * ```\n   *\n   * If the properties are expensive to compute, you can pass a callback that\n   * returns the properties:\n   *\n   * ```typescript\n   * logger.error(\n   *   'An error message with {value}.',\n   *   () => ({ value: expensiveComputation() })\n   * );\n   * ```\n   *\n   * @param message The message template.  Placeholders to be replaced with\n   *                `values` are indicated by keys in curly braces (e.g.,\n   *                `{value}`).\n   * @param properties The values to replace placeholders with.  For lazy\n   *                   evaluation, this can be a callback that returns the\n   *                   properties.\n   */\n  error(\n    message: string,\n    properties?: Record<string, unknown> | (() => Record<string, unknown>),\n  ): void;\n\n  /**\n   * Log an error values with no message.  This is useful when you\n   * want to log properties without a message, e.g., when you want to log\n   * the context of a request or an operation.\n   *\n   * ```typescript\n   * logger.error({ method: 'GET', url: '/api/v1/resource' });\n   * ```\n   *\n   * Note that this is a shorthand for:\n   *\n   * ```typescript\n   * logger.error('{*}', { method: 'GET', url: '/api/v1/resource' });\n   * ```\n   *\n   * If the properties are expensive to compute, you cannot use this shorthand\n   * and should use the following syntax instead:\n   *\n   * ```typescript\n   * logger.error('{*}', () => ({\n   *   method: expensiveMethod(),\n   *   url: expensiveUrl(),\n   * }));\n   * ```\n   *\n   * @param properties The values to log.  Note that this does not take\n   *                   a callback.\n   * @since 0.11.0\n   */\n  error(properties: Record<string, unknown>): void;\n\n  /**\n   * Lazily log an error message.  Use this when the message values are\n   * expensive to compute and should only be computed if the message is actually\n   * logged.\n   *\n   * ```typescript\n   * logger.error(l => l`An error message with ${expensiveValue()}.`);\n   * ```\n   *\n   * @param callback A callback that returns the message template prefix.\n   * @throws {TypeError} If no log record was made inside the callback.\n   */\n  error(callback: LogCallback): void;\n\n  /**\n   * Log a fatal error message.  Use this as a template string prefix.\n   *\n   * ```typescript\n   * logger.fatal `A fatal error message with ${value}.`;\n   * ```\n   *\n   * @param message The message template strings array.\n   * @param values The message template values.\n   */\n  fatal(message: TemplateStringsArray, ...values: readonly unknown[]): void;\n\n  /**\n   * Log a fatal error message with properties.\n   *\n   * ```typescript\n   * logger.warn('A fatal error message with {value}.', { value });\n   * ```\n   *\n   * If the properties are expensive to compute, you can pass a callback that\n   * returns the properties:\n   *\n   * ```typescript\n   * logger.fatal(\n   *   'A fatal error message with {value}.',\n   *   () => ({ value: expensiveComputation() })\n   * );\n   * ```\n   *\n   * @param message The message template.  Placeholders to be replaced with\n   *                `values` are indicated by keys in curly braces (e.g.,\n   *                `{value}`).\n   * @param properties The values to replace placeholders with.  For lazy\n   *                   evaluation, this can be a callback that returns the\n   *                   properties.\n   */\n  fatal(\n    message: string,\n    properties?: Record<string, unknown> | (() => Record<string, unknown>),\n  ): void;\n\n  /**\n   * Log a fatal error values with no message.  This is useful when you\n   * want to log properties without a message, e.g., when you want to log\n   * the context of a request or an operation.\n   *\n   * ```typescript\n   * logger.fatal({ method: 'GET', url: '/api/v1/resource' });\n   * ```\n   *\n   * Note that this is a shorthand for:\n   *\n   * ```typescript\n   * logger.fatal('{*}', { method: 'GET', url: '/api/v1/resource' });\n   * ```\n   *\n   * If the properties are expensive to compute, you cannot use this shorthand\n   * and should use the following syntax instead:\n   *\n   * ```typescript\n   * logger.fatal('{*}', () => ({\n   *   method: expensiveMethod(),\n   *   url: expensiveUrl(),\n   * }));\n   * ```\n   *\n   * @param properties The values to log.  Note that this does not take\n   *                   a callback.\n   * @since 0.11.0\n   */\n  fatal(properties: Record<string, unknown>): void;\n\n  /**\n   * Lazily log a fatal error message.  Use this when the message values are\n   * expensive to compute and should only be computed if the message is actually\n   * logged.\n   *\n   * ```typescript\n   * logger.fatal(l => l`A fatal error message with ${expensiveValue()}.`);\n   * ```\n   *\n   * @param callback A callback that returns the message template prefix.\n   * @throws {TypeError} If no log record was made inside the callback.\n   */\n  fatal(callback: LogCallback): void;\n}\n\n/**\n * A logging callback function.  It is used to defer the computation of a\n * message template until it is actually logged.\n * @param prefix The message template prefix.\n * @returns The rendered message array.\n */\nexport type LogCallback = (prefix: LogTemplatePrefix) => unknown[];\n\n/**\n * A logging template prefix function.  It is used to log a message in\n * a {@link LogCallback} function.\n * @param message The message template strings array.\n * @param values The message template values.\n * @returns The rendered message array.\n */\nexport type LogTemplatePrefix = (\n  message: TemplateStringsArray,\n  ...values: unknown[]\n) => unknown[];\n\n/**\n * A function type for logging methods in the {@link Logger} interface.\n * @since 1.0.0\n */\nexport interface LogMethod {\n  /**\n   * Log a message with the given level using a template string.\n   * @param message The message template strings array.\n   * @param values The message template values.\n   */\n  (\n    message: TemplateStringsArray,\n    ...values: readonly unknown[]\n  ): void;\n\n  /**\n   * Log a message with the given level with properties.\n   * @param message The message template.  Placeholders to be replaced with\n   *                `values` are indicated by keys in curly braces (e.g.,\n   *                `{value}`).\n   * @param properties The values to replace placeholders with.  For lazy\n   *                   evaluation, this can be a callback that returns the\n   *                   properties.\n   */\n  (\n    message: string,\n    properties?: Record<string, unknown> | (() => Record<string, unknown>),\n  ): void;\n\n  /**\n   * Log a message with the given level with no message.\n   * @param properties The values to log.  Note that this does not take\n   *                   a callback.\n   */\n  (properties: Record<string, unknown>): void;\n\n  /**\n   * Lazily log a message with the given level.\n   * @param callback A callback that returns the message template prefix.\n   * @throws {TypeError} If no log record was made inside the callback.\n   */\n  (callback: LogCallback): void;\n}\n\n/**\n * Get a logger with the given category.\n *\n * ```typescript\n * const logger = getLogger([\"my-app\"]);\n * ```\n *\n * @param category The category of the logger.  It can be a string or an array\n *                 of strings.  If it is a string, it is equivalent to an array\n *                 with a single element.\n * @returns The logger.\n */\nexport function getLogger(category: string | readonly string[] = []): Logger {\n  return LoggerImpl.getLogger(category);\n}\n\n/**\n * The symbol for the global root logger.\n */\nconst globalRootLoggerSymbol = Symbol.for(\"logtape.rootLogger\");\n\n/**\n * The global root logger registry.\n */\ninterface GlobalRootLoggerRegistry {\n  [globalRootLoggerSymbol]?: LoggerImpl;\n}\n\n/**\n * A logger implementation.  Do not use this directly; use {@link getLogger}\n * instead.  This class is exported for testing purposes.\n */\nexport class LoggerImpl implements Logger {\n  readonly parent: LoggerImpl | null;\n  readonly children: Record<string, LoggerImpl | WeakRef<LoggerImpl>>;\n  readonly category: readonly string[];\n  readonly sinks: Sink[];\n  parentSinks: \"inherit\" | \"override\" = \"inherit\";\n  readonly filters: Filter[];\n  lowestLevel: LogLevel | null = \"trace\";\n  contextLocalStorage?: ContextLocalStorage<Record<string, unknown>>;\n\n  static getLogger(category: string | readonly string[] = []): LoggerImpl {\n    let rootLogger: LoggerImpl | null = globalRootLoggerSymbol in globalThis\n      ? ((globalThis as GlobalRootLoggerRegistry)[globalRootLoggerSymbol] ??\n        null)\n      : null;\n    if (rootLogger == null) {\n      rootLogger = new LoggerImpl(null, []);\n      (globalThis as GlobalRootLoggerRegistry)[globalRootLoggerSymbol] =\n        rootLogger;\n    }\n    if (typeof category === \"string\") return rootLogger.getChild(category);\n    if (category.length === 0) return rootLogger;\n    return rootLogger.getChild(category as readonly [string, ...string[]]);\n  }\n\n  private constructor(parent: LoggerImpl | null, category: readonly string[]) {\n    this.parent = parent;\n    this.children = {};\n    this.category = category;\n    this.sinks = [];\n    this.filters = [];\n  }\n\n  getChild(\n    subcategory:\n      | string\n      | readonly [string]\n      | readonly [string, ...(readonly string[])],\n  ): LoggerImpl {\n    const name = typeof subcategory === \"string\" ? subcategory : subcategory[0];\n    const childRef = this.children[name];\n    let child: LoggerImpl | undefined = childRef instanceof LoggerImpl\n      ? childRef\n      : childRef?.deref();\n    if (child == null) {\n      child = new LoggerImpl(this, [...this.category, name]);\n      this.children[name] = \"WeakRef\" in globalThis\n        ? new WeakRef(child)\n        : child;\n    }\n    if (typeof subcategory === \"string\" || subcategory.length === 1) {\n      return child;\n    }\n    return child.getChild(\n      subcategory.slice(1) as [string, ...(readonly string[])],\n    );\n  }\n\n  /**\n   * Reset the logger.  This removes all sinks and filters from the logger.\n   */\n  reset(): void {\n    while (this.sinks.length > 0) this.sinks.shift();\n    this.parentSinks = \"inherit\";\n    while (this.filters.length > 0) this.filters.shift();\n    this.lowestLevel = \"trace\";\n  }\n\n  /**\n   * Reset the logger and all its descendants.  This removes all sinks and\n   * filters from the logger and all its descendants.\n   */\n  resetDescendants(): void {\n    for (const child of Object.values(this.children)) {\n      const logger = child instanceof LoggerImpl ? child : child.deref();\n      if (logger != null) logger.resetDescendants();\n    }\n    this.reset();\n  }\n\n  with(properties: Record<string, unknown>): Logger {\n    return new LoggerCtx(this, { ...properties });\n  }\n\n  filter(record: LogRecord): boolean {\n    for (const filter of this.filters) {\n      if (!filter(record)) return false;\n    }\n    if (this.filters.length < 1) return this.parent?.filter(record) ?? true;\n    return true;\n  }\n\n  *getSinks(level: LogLevel): Iterable<Sink> {\n    if (\n      this.lowestLevel === null || compareLogLevel(level, this.lowestLevel) < 0\n    ) {\n      return;\n    }\n    if (this.parent != null && this.parentSinks === \"inherit\") {\n      for (const sink of this.parent.getSinks(level)) yield sink;\n    }\n    for (const sink of this.sinks) yield sink;\n  }\n\n  emit(record: LogRecord, bypassSinks?: Set<Sink>): void {\n    if (\n      this.lowestLevel === null ||\n      compareLogLevel(record.level, this.lowestLevel) < 0 ||\n      !this.filter(record)\n    ) {\n      return;\n    }\n    for (const sink of this.getSinks(record.level)) {\n      if (bypassSinks?.has(sink)) continue;\n      try {\n        sink(record);\n      } catch (error) {\n        const bypassSinks2 = new Set(bypassSinks);\n        bypassSinks2.add(sink);\n        metaLogger.log(\n          \"fatal\",\n          \"Failed to emit a log record to sink {sink}: {error}\",\n          { sink, error, record },\n          bypassSinks2,\n        );\n      }\n    }\n  }\n\n  log(\n    level: LogLevel,\n    rawMessage: string,\n    properties: Record<string, unknown> | (() => Record<string, unknown>),\n    bypassSinks?: Set<Sink>,\n  ): void {\n    const implicitContext =\n      LoggerImpl.getLogger().contextLocalStorage?.getStore() ?? {};\n    let cachedProps: Record<string, unknown> | undefined = undefined;\n    const record: LogRecord = typeof properties === \"function\"\n      ? {\n        category: this.category,\n        level,\n        timestamp: Date.now(),\n        get message() {\n          return parseMessageTemplate(rawMessage, this.properties);\n        },\n        rawMessage,\n        get properties() {\n          if (cachedProps == null) {\n            cachedProps = {\n              ...implicitContext,\n              ...properties(),\n            };\n          }\n          return cachedProps;\n        },\n      }\n      : {\n        category: this.category,\n        level,\n        timestamp: Date.now(),\n        message: parseMessageTemplate(rawMessage, {\n          ...implicitContext,\n          ...properties,\n        }),\n        rawMessage,\n        properties: { ...implicitContext, ...properties },\n      };\n    this.emit(record, bypassSinks);\n  }\n\n  logLazily(\n    level: LogLevel,\n    callback: LogCallback,\n    properties: Record<string, unknown> = {},\n  ): void {\n    const implicitContext =\n      LoggerImpl.getLogger().contextLocalStorage?.getStore() ?? {};\n    let rawMessage: TemplateStringsArray | undefined = undefined;\n    let msg: unknown[] | undefined = undefined;\n    function realizeMessage(): [unknown[], TemplateStringsArray] {\n      if (msg == null || rawMessage == null) {\n        msg = callback((tpl, ...values) => {\n          rawMessage = tpl;\n          return renderMessage(tpl, values);\n        });\n        if (rawMessage == null) throw new TypeError(\"No log record was made.\");\n      }\n      return [msg, rawMessage];\n    }\n    this.emit({\n      category: this.category,\n      level,\n      get message() {\n        return realizeMessage()[0];\n      },\n      get rawMessage() {\n        return realizeMessage()[1];\n      },\n      timestamp: Date.now(),\n      properties: { ...implicitContext, ...properties },\n    });\n  }\n\n  logTemplate(\n    level: LogLevel,\n    messageTemplate: TemplateStringsArray,\n    values: unknown[],\n    properties: Record<string, unknown> = {},\n  ): void {\n    const implicitContext =\n      LoggerImpl.getLogger().contextLocalStorage?.getStore() ?? {};\n    this.emit({\n      category: this.category,\n      level,\n      message: renderMessage(messageTemplate, values),\n      rawMessage: messageTemplate,\n      timestamp: Date.now(),\n      properties: { ...implicitContext, ...properties },\n    });\n  }\n\n  trace(\n    message:\n      | TemplateStringsArray\n      | string\n      | LogCallback\n      | Record<string, unknown>,\n    ...values: unknown[]\n  ): void {\n    if (typeof message === \"string\") {\n      this.log(\"trace\", message, (values[0] ?? {}) as Record<string, unknown>);\n    } else if (typeof message === \"function\") {\n      this.logLazily(\"trace\", message);\n    } else if (!Array.isArray(message)) {\n      this.log(\"trace\", \"{*}\", message as Record<string, unknown>);\n    } else {\n      this.logTemplate(\"trace\", message as TemplateStringsArray, values);\n    }\n  }\n\n  debug(\n    message:\n      | TemplateStringsArray\n      | string\n      | LogCallback\n      | Record<string, unknown>,\n    ...values: unknown[]\n  ): void {\n    if (typeof message === \"string\") {\n      this.log(\"debug\", message, (values[0] ?? {}) as Record<string, unknown>);\n    } else if (typeof message === \"function\") {\n      this.logLazily(\"debug\", message);\n    } else if (!Array.isArray(message)) {\n      this.log(\"debug\", \"{*}\", message as Record<string, unknown>);\n    } else {\n      this.logTemplate(\"debug\", message as TemplateStringsArray, values);\n    }\n  }\n\n  info(\n    message:\n      | TemplateStringsArray\n      | string\n      | LogCallback\n      | Record<string, unknown>,\n    ...values: unknown[]\n  ): void {\n    if (typeof message === \"string\") {\n      this.log(\"info\", message, (values[0] ?? {}) as Record<string, unknown>);\n    } else if (typeof message === \"function\") {\n      this.logLazily(\"info\", message);\n    } else if (!Array.isArray(message)) {\n      this.log(\"info\", \"{*}\", message as Record<string, unknown>);\n    } else {\n      this.logTemplate(\"info\", message as TemplateStringsArray, values);\n    }\n  }\n\n  warn(\n    message:\n      | TemplateStringsArray\n      | string\n      | LogCallback\n      | Record<string, unknown>,\n    ...values: unknown[]\n  ): void {\n    if (typeof message === \"string\") {\n      this.log(\n        \"warning\",\n        message,\n        (values[0] ?? {}) as Record<string, unknown>,\n      );\n    } else if (typeof message === \"function\") {\n      this.logLazily(\"warning\", message);\n    } else if (!Array.isArray(message)) {\n      this.log(\"warning\", \"{*}\", message as Record<string, unknown>);\n    } else {\n      this.logTemplate(\"warning\", message as TemplateStringsArray, values);\n    }\n  }\n\n  warning(\n    message:\n      | TemplateStringsArray\n      | string\n      | LogCallback\n      | Record<string, unknown>,\n    ...values: unknown[]\n  ): void {\n    this.warn(message, ...values);\n  }\n\n  error(\n    message:\n      | TemplateStringsArray\n      | string\n      | LogCallback\n      | Record<string, unknown>,\n    ...values: unknown[]\n  ): void {\n    if (typeof message === \"string\") {\n      this.log(\"error\", message, (values[0] ?? {}) as Record<string, unknown>);\n    } else if (typeof message === \"function\") {\n      this.logLazily(\"error\", message);\n    } else if (!Array.isArray(message)) {\n      this.log(\"error\", \"{*}\", message as Record<string, unknown>);\n    } else {\n      this.logTemplate(\"error\", message as TemplateStringsArray, values);\n    }\n  }\n\n  fatal(\n    message:\n      | TemplateStringsArray\n      | string\n      | LogCallback\n      | Record<string, unknown>,\n    ...values: unknown[]\n  ): void {\n    if (typeof message === \"string\") {\n      this.log(\"fatal\", message, (values[0] ?? {}) as Record<string, unknown>);\n    } else if (typeof message === \"function\") {\n      this.logLazily(\"fatal\", message);\n    } else if (!Array.isArray(message)) {\n      this.log(\"fatal\", \"{*}\", message as Record<string, unknown>);\n    } else {\n      this.logTemplate(\"fatal\", message as TemplateStringsArray, values);\n    }\n  }\n}\n\n/**\n * A logger implementation with contextual properties.  Do not use this\n * directly; use {@link Logger.with} instead.  This class is exported\n * for testing purposes.\n */\nexport class LoggerCtx implements Logger {\n  logger: LoggerImpl;\n  properties: Record<string, unknown>;\n\n  constructor(logger: LoggerImpl, properties: Record<string, unknown>) {\n    this.logger = logger;\n    this.properties = properties;\n  }\n\n  get category(): readonly string[] {\n    return this.logger.category;\n  }\n\n  get parent(): Logger | null {\n    return this.logger.parent;\n  }\n\n  getChild(\n    subcategory: string | readonly [string] | readonly [string, ...string[]],\n  ): Logger {\n    return this.logger.getChild(subcategory).with(this.properties);\n  }\n\n  with(properties: Record<string, unknown>): Logger {\n    return new LoggerCtx(this.logger, { ...this.properties, ...properties });\n  }\n\n  log(\n    level: LogLevel,\n    message: string,\n    properties: Record<string, unknown> | (() => Record<string, unknown>),\n    bypassSinks?: Set<Sink>,\n  ): void {\n    this.logger.log(\n      level,\n      message,\n      typeof properties === \"function\"\n        ? () => ({\n          ...this.properties,\n          ...properties(),\n        })\n        : { ...this.properties, ...properties },\n      bypassSinks,\n    );\n  }\n\n  logLazily(level: LogLevel, callback: LogCallback): void {\n    this.logger.logLazily(level, callback, this.properties);\n  }\n\n  logTemplate(\n    level: LogLevel,\n    messageTemplate: TemplateStringsArray,\n    values: unknown[],\n  ): void {\n    this.logger.logTemplate(level, messageTemplate, values, this.properties);\n  }\n\n  trace(\n    message:\n      | TemplateStringsArray\n      | string\n      | LogCallback\n      | Record<string, unknown>,\n    ...values: unknown[]\n  ): void {\n    if (typeof message === \"string\") {\n      this.log(\"trace\", message, (values[0] ?? {}) as Record<string, unknown>);\n    } else if (typeof message === \"function\") {\n      this.logLazily(\"trace\", message);\n    } else if (!Array.isArray(message)) {\n      this.log(\"trace\", \"{*}\", message as Record<string, unknown>);\n    } else {\n      this.logTemplate(\"trace\", message as TemplateStringsArray, values);\n    }\n  }\n\n  debug(\n    message:\n      | TemplateStringsArray\n      | string\n      | LogCallback\n      | Record<string, unknown>,\n    ...values: unknown[]\n  ): void {\n    if (typeof message === \"string\") {\n      this.log(\"debug\", message, (values[0] ?? {}) as Record<string, unknown>);\n    } else if (typeof message === \"function\") {\n      this.logLazily(\"debug\", message);\n    } else if (!Array.isArray(message)) {\n      this.log(\"debug\", \"{*}\", message as Record<string, unknown>);\n    } else {\n      this.logTemplate(\"debug\", message as TemplateStringsArray, values);\n    }\n  }\n\n  info(\n    message:\n      | TemplateStringsArray\n      | string\n      | LogCallback\n      | Record<string, unknown>,\n    ...values: unknown[]\n  ): void {\n    if (typeof message === \"string\") {\n      this.log(\"info\", message, (values[0] ?? {}) as Record<string, unknown>);\n    } else if (typeof message === \"function\") {\n      this.logLazily(\"info\", message);\n    } else if (!Array.isArray(message)) {\n      this.log(\"info\", \"{*}\", message as Record<string, unknown>);\n    } else {\n      this.logTemplate(\"info\", message as TemplateStringsArray, values);\n    }\n  }\n\n  warn(\n    message:\n      | TemplateStringsArray\n      | string\n      | LogCallback\n      | Record<string, unknown>,\n    ...values: unknown[]\n  ): void {\n    if (typeof message === \"string\") {\n      this.log(\n        \"warning\",\n        message,\n        (values[0] ?? {}) as Record<string, unknown>,\n      );\n    } else if (typeof message === \"function\") {\n      this.logLazily(\"warning\", message);\n    } else if (!Array.isArray(message)) {\n      this.log(\"warning\", \"{*}\", message as Record<string, unknown>);\n    } else {\n      this.logTemplate(\"warning\", message as TemplateStringsArray, values);\n    }\n  }\n\n  warning(\n    message:\n      | TemplateStringsArray\n      | string\n      | LogCallback\n      | Record<string, unknown>,\n    ...values: unknown[]\n  ): void {\n    this.warn(message, ...values);\n  }\n\n  error(\n    message:\n      | TemplateStringsArray\n      | string\n      | LogCallback\n      | Record<string, unknown>,\n    ...values: unknown[]\n  ): void {\n    if (typeof message === \"string\") {\n      this.log(\"error\", message, (values[0] ?? {}) as Record<string, unknown>);\n    } else if (typeof message === \"function\") {\n      this.logLazily(\"error\", message);\n    } else if (!Array.isArray(message)) {\n      this.log(\"error\", \"{*}\", message as Record<string, unknown>);\n    } else {\n      this.logTemplate(\"error\", message as TemplateStringsArray, values);\n    }\n  }\n\n  fatal(\n    message:\n      | TemplateStringsArray\n      | string\n      | LogCallback\n      | Record<string, unknown>,\n    ...values: unknown[]\n  ): void {\n    if (typeof message === \"string\") {\n      this.log(\"fatal\", message, (values[0] ?? {}) as Record<string, unknown>);\n    } else if (typeof message === \"function\") {\n      this.logLazily(\"fatal\", message);\n    } else if (!Array.isArray(message)) {\n      this.log(\"fatal\", \"{*}\", message as Record<string, unknown>);\n    } else {\n      this.logTemplate(\"fatal\", message as TemplateStringsArray, values);\n    }\n  }\n}\n\n/**\n * The meta logger.  It is a logger with the category `[\"logtape\", \"meta\"]`.\n */\nconst metaLogger = LoggerImpl.getLogger([\"logtape\", \"meta\"]);\n\n/**\n * Parse a message template into a message template array and a values array.\n * @param template The message template.\n * @param properties The values to replace placeholders with.\n * @returns The message template array and the values array.\n */\nexport function parseMessageTemplate(\n  template: string,\n  properties: Record<string, unknown>,\n): readonly unknown[] {\n  const length = template.length;\n  if (length === 0) return [\"\"];\n\n  // Fast path: no placeholders\n  if (!template.includes(\"{\")) return [template];\n\n  const message: unknown[] = [];\n  let startIndex = 0;\n\n  for (let i = 0; i < length; i++) {\n    const char = template[i];\n\n    if (char === \"{\") {\n      const nextChar = i + 1 < length ? template[i + 1] : \"\";\n\n      if (nextChar === \"{\") {\n        // Escaped { character - skip and continue\n        i++; // Skip the next {\n        continue;\n      }\n\n      // Find the closing }\n      const closeIndex = template.indexOf(\"}\", i + 1);\n      if (closeIndex === -1) {\n        // No closing } found, treat as literal text\n        continue;\n      }\n\n      // Add text before placeholder\n      const beforeText = template.slice(startIndex, i);\n      message.push(beforeText.replace(/{{/g, \"{\").replace(/}}/g, \"}\"));\n\n      // Extract and process placeholder key\n      const key = template.slice(i + 1, closeIndex);\n\n      // Resolve property value\n      let prop: unknown;\n\n      // Check for wildcard patterns\n      const trimmedKey = key.trim();\n      if (trimmedKey === \"*\") {\n        // This is a wildcard pattern\n        prop = key in properties\n          ? properties[key]\n          : \"*\" in properties\n          ? properties[\"*\"]\n          : properties;\n      } else {\n        // Regular property lookup with possible whitespace handling\n        if (key !== trimmedKey) {\n          // Key has leading/trailing whitespace\n          prop = key in properties ? properties[key] : properties[trimmedKey];\n        } else {\n          // Key has no leading/trailing whitespace\n          prop = properties[key];\n        }\n      }\n\n      message.push(prop);\n      i = closeIndex; // Move to the }\n      startIndex = i + 1;\n    } else if (char === \"}\" && i + 1 < length && template[i + 1] === \"}\") {\n      // Escaped } character - skip\n      i++; // Skip the next }\n    }\n  }\n\n  // Add remaining text\n  const remainingText = template.slice(startIndex);\n  message.push(remainingText.replace(/{{/g, \"{\").replace(/}}/g, \"}\"));\n\n  return message;\n}\n\n/**\n * Render a message template with values.\n * @param template The message template.\n * @param values The message template values.\n * @returns The message template values interleaved between the substitution\n *          values.\n */\nexport function renderMessage(\n  template: TemplateStringsArray,\n  values: readonly unknown[],\n): unknown[] {\n  const args = [];\n  for (let i = 0; i < template.length; i++) {\n    args.push(template[i]);\n    if (i < values.length) args.push(values[i]);\n  }\n  return args;\n}\n", "/**\n * @file Centralized Logging Configuration\n * Provides unified logging configuration and factory methods for the entire application.\n */\n\nimport { getLogger as getLogTapeLogger } from '@logtape/logtape';\nimport type { ILogger } from '../core/bootstrap-logger.ts';\n\nexport enum LoggingLevel {\n  DEBUG = 'debug',\n  INFO = 'info',\n  WARN = 'warn',\n  ERROR = 'error',\n}\n\nexport interface LoggingConfig {\n  level: LoggingLevel;\n  enableConsole: boolean;\n  enableFile: boolean;\n  timestamp: boolean;\n  format: 'json' | 'text';\n  components: Record<string, LoggingLevel>;\n}\n\nexport interface Logger extends ILogger {\n  success?(message: string, meta?: any): void;\n  progress?(message: string, meta?: any): void;\n}\n\nclass LoggingConfigurationManager {\n  private static instance: LoggingConfigurationManager;\n  private config: LoggingConfig;\n  private loggers: Map<string, Logger> = new Map();\n\n  private constructor() {\n    this.config = this.loadConfiguration();\n  }\n\n  static getInstance(): LoggingConfigurationManager {\n    if (!LoggingConfigurationManager.instance) {\n      LoggingConfigurationManager.instance = new LoggingConfigurationManager();\n    }\n    return LoggingConfigurationManager.instance;\n  }\n\n  private loadConfiguration(): LoggingConfig {\n    // Load from environment variables with sensible defaults\n    const nodeEnv = process.env['NODE_ENV'] || 'development';\n    const defaultLevel = nodeEnv === 'development' ? LoggingLevel.DEBUG : LoggingLevel.INFO;\n\n    return {\n      level: (process.env['LOG_LEVEL'] as LoggingLevel) || defaultLevel,\n      enableConsole: process.env['LOG_DISABLE_CONSOLE'] !== 'true',\n      enableFile: process.env['LOG_ENABLE_FILE'] === 'true',\n      timestamp: process.env['LOG_DISABLE_TIMESTAMP'] !== 'true',\n      format: (process.env['LOG_FORMAT'] as 'json' | 'text') || 'text',\n      components: {\n        // Override levels for specific components\n        'swarm-coordinator': (process.env['LOG_LEVEL_SWARM'] as LoggingLevel) || defaultLevel,\n        'neural-network': (process.env['LOG_LEVEL_NEURAL'] as LoggingLevel) || defaultLevel,\n        'mcp-server': (process.env['LOG_LEVEL_MCP'] as LoggingLevel) || defaultLevel,\n        database: (process.env['LOG_LEVEL_DB'] as LoggingLevel) || defaultLevel,\n      },\n    };\n  }\n\n  /**\n   * Get logging configuration.\n   */\n  getConfig(): LoggingConfig {\n    return { ...this.config };\n  }\n\n  /**\n   * Update logging configuration.\n   *\n   * @param updates\n   */\n  updateConfig(updates: Partial<LoggingConfig>): void {\n    this.config = { ...this.config, ...updates };\n    // Clear cached loggers to force recreation with new config\n    this.loggers.clear();\n  }\n\n  /**\n   * Create or get cached logger for a component.\n   *\n   * @param component\n   */\n  getLogger(component: string): Logger {\n    if (this.loggers.has(component)) {\n      return this.loggers.get(component)!;\n    }\n\n    const logger = this.createLoggerForComponent(component);\n    this.loggers.set(component, logger);\n    return logger;\n  }\n\n  private createLoggerForComponent(component: string): Logger {\n    // Use component-specific log level if configured\n    const componentLevel = this.config.components[component] || this.config.level;\n\n    // Set environment variable for the component so existing loggers pick it up\n    const originalLevel = process.env['LOG_LEVEL'];\n    process.env['LOG_LEVEL'] = componentLevel;\n\n    try {\n      // Create logger using logtape (no circular deps since we import directly)\n      const coreLogger = getLogTapeLogger(component);\n\n      // Enhance with additional methods compatible with existing interfaces\n      const enhancedLogger: Logger = {\n        debug: (message: string, meta?: any) => coreLogger.debug(message, meta),\n        info: (message: string, meta?: any) => coreLogger.info(message, meta),\n        warn: (message: string, meta?: any) => coreLogger.warn(message, meta),\n        error: (message: string, meta?: any) => coreLogger.error(message, meta),\n      };\n\n      // Add success and progress methods\n      enhancedLogger.success = (message: string, meta?: any) => {\n        coreLogger.info(`\u2705 ${message}`, meta);\n      };\n\n      enhancedLogger.progress = (message: string, meta?: any) => {\n        coreLogger.info(`\uD83D\uDD04 ${message}`, meta);\n      };\n\n      return enhancedLogger;\n    } finally {\n      // Restore original log level\n      if (originalLevel !== undefined) {\n        process.env['LOG_LEVEL'] = originalLevel;\n      } else {\n        delete process.env['LOG_LEVEL'];\n      }\n    }\n  }\n\n  /**\n   * Create logger specifically for console.log replacement\n   * This creates a logger optimized for CLI output and user-facing messages.\n   *\n   * @param component\n   */\n  createConsoleReplacementLogger(component: string): Logger {\n    const logger = this.getLogger(component);\n\n    return {\n      debug: (message: string, meta?: any) => logger.debug(message, meta),\n      // For console.log replacement, use info level\n      info: (message: string, meta?: any) => logger.info(message, meta),\n      warn: (message: string, meta?: any) => logger.warn(message, meta),\n      error: (message: string, meta?: any) => logger.error(message, meta),\n      success: logger.success || ((message: string, meta?: any) => logger.info(message, meta)),\n      progress: logger.progress || ((message: string, meta?: any) => logger.info(message, meta)),\n    };\n  }\n\n  /**\n   * Enable debug logging for development.\n   */\n  enableDebugMode(): void {\n    this.updateConfig({\n      level: LoggingLevel.DEBUG,\n      components: Object.fromEntries(\n        Object.keys(this.config.components).map((key) => [key, LoggingLevel.DEBUG])\n      ),\n    });\n  }\n\n  /**\n   * Set production logging (INFO and above).\n   */\n  setProductionMode(): void {\n    this.updateConfig({\n      level: LoggingLevel.INFO,\n      components: Object.fromEntries(\n        Object.keys(this.config.components).map((key) => [key, LoggingLevel.INFO])\n      ),\n    });\n  }\n\n  /**\n   * Silence all logging except errors.\n   */\n  setSilentMode(): void {\n    this.updateConfig({\n      level: LoggingLevel.ERROR,\n      components: Object.fromEntries(\n        Object.keys(this.config.components).map((key) => [key, LoggingLevel.ERROR])\n      ),\n    });\n  }\n}\n\n// Export singleton instance\nexport const loggingConfigManager = LoggingConfigurationManager.getInstance();\n\n/**\n * Convenience function to get a logger for a component.\n *\n * @param component\n * @example\n */\nexport function getLogger(component: string): Logger {\n  return loggingConfigManager?.getLogger(component);\n}\n\n/**\n * Convenience function for console.log replacement.\n *\n * @param component\n * @example\n */\nexport function getConsoleReplacementLogger(component: string): Logger {\n  return loggingConfigManager?.createConsoleReplacementLogger(component);\n}\n\n/**\n * Convenience functions for common logging needs.\n */\nexport const logger = {\n  // Default system logger\n  system: getLogger('system'),\n  // CLI output logger\n  cli: getConsoleReplacementLogger('cli'),\n  // Swarm coordination logger\n  swarm: getLogger('swarm-coordinator'),\n  // Neural network logger\n  neural: getLogger('neural-network'),\n  // MCP server logger\n  mcp: getLogger('mcp-server'),\n  // Database logger\n  database: getLogger('database'),\n};\n\n// Simple in-memory log storage for TUI display\nconst logEntries: any[] = [];\n\n/**\n * Add log entry for TUI display\n */\nexport function addLogEntry(entry: {\n  level: 'debug' | 'info' | 'warn' | 'error' | 'trace';\n  component: string;\n  message: string;\n  metadata?: Record<string, any>;\n}) {\n  logEntries.push({\n    id: `log-${Date.now()}-${Math.random()}`,\n    timestamp: new Date(),\n    ...entry,\n  });\n  \n  // Keep only last 1000 entries\n  if (logEntries.length > 1000) {\n    logEntries.splice(0, logEntries.length - 1000);\n  }\n}\n\n/**\n * Get log entries for TUI display\n */\nexport function getLogEntries() {\n  return [...logEntries];\n}\n\n// Add some system startup logs\naddLogEntry({\n  level: 'info',\n  component: 'system',\n  message: 'Claude Code Zen TUI initialized',\n});\n\naddLogEntry({\n  level: 'info',\n  component: 'terminal',\n  message: 'Terminal interface ready',\n});\n\nexport default loggingConfigManager;\n"],
  "mappings": "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",
  "names": ["a: LogLevel", "b: LogLevel", "category: string | readonly string[]", "LoggerImpl", "rootLogger: LoggerImpl | null", "parent: LoggerImpl | null", "category: readonly string[]", "subcategory:\n      | string\n      | readonly [string]\n      | readonly [string, ...(readonly string[])]", "child: LoggerImpl | undefined", "logger", "properties: Record<string, unknown>", "record: LogRecord", "level: LogLevel", "bypassSinks?: Set<Sink>", "rawMessage: string", "properties: Record<string, unknown> | (() => Record<string, unknown>)", "cachedProps: Record<string, unknown> | undefined", "callback: LogCallback", "rawMessage: TemplateStringsArray | undefined", "msg: unknown[] | undefined", "messageTemplate: TemplateStringsArray", "values: unknown[]", "message:\n      | TemplateStringsArray\n      | string\n      | LogCallback\n      | Record<string, unknown>", "LoggerCtx", "logger: LoggerImpl", "subcategory: string | readonly [string] | readonly [string, ...string[]]", "message: string", "template: string", "message: unknown[]", "prop: unknown", "template: TemplateStringsArray", "values: readonly unknown[]", "logger", "getLogger"]
}
