{
  "version": 3,
  "sources": ["../../node_modules/nanoid/index.js", "../../node_modules/nanoid/url-alphabet/index.js", "../../src/database/managers/document-manager.ts"],
  "sourcesContent": ["import { webcrypto as crypto } from 'node:crypto'\nimport { urlAlphabet as scopedUrlAlphabet } from './url-alphabet/index.js'\nexport { urlAlphabet } from './url-alphabet/index.js'\nconst POOL_SIZE_MULTIPLIER = 128\nlet pool, poolOffset\nfunction fillPool(bytes) {\n  if (!pool || pool.length < bytes) {\n    pool = Buffer.allocUnsafe(bytes * POOL_SIZE_MULTIPLIER)\n    crypto.getRandomValues(pool)\n    poolOffset = 0\n  } else if (poolOffset + bytes > pool.length) {\n    crypto.getRandomValues(pool)\n    poolOffset = 0\n  }\n  poolOffset += bytes\n}\nexport function random(bytes) {\n  fillPool((bytes |= 0))\n  return pool.subarray(poolOffset - bytes, poolOffset)\n}\nexport function customRandom(alphabet, defaultSize, getRandom) {\n  let mask = (2 << (31 - Math.clz32((alphabet.length - 1) | 1))) - 1\n  let step = Math.ceil((1.6 * mask * defaultSize) / alphabet.length)\n  return (size = defaultSize) => {\n    let id = ''\n    while (true) {\n      let bytes = getRandom(step)\n      let i = step\n      while (i--) {\n        id += alphabet[bytes[i] & mask] || ''\n        if (id.length >= size) return id\n      }\n    }\n  }\n}\nexport function customAlphabet(alphabet, size = 21) {\n  return customRandom(alphabet, size, random)\n}\nexport function nanoid(size = 21) {\n  fillPool((size |= 0))\n  let id = ''\n  for (let i = poolOffset - size; i < poolOffset; i++) {\n    id += scopedUrlAlphabet[pool[i] & 63]\n  }\n  return id\n}\n", "export const urlAlphabet =\n  'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict'\n", "/**\n * @file Document Manager - Pure DAL Implementation.\n *\n * Complete rewrite using unified DAL patterns only.\n * Replaces file-based operations with database entities.\n */\n\nimport { createLogger } from '../../core/logger.ts';\n\nconst logger = createLogger('database-managers-document-manager');\n\nimport { nanoid } from 'nanoid';\nimport type { DocumentType } from '../../workflows/types.ts';\nimport { createDao, EntityTypeValues as EntityTypes } from '../core/dao-factory.ts';\nimport type {\n  ADRDocumentEntity,\n  BaseDocumentEntity,\n  DocumentRelationshipEntity,\n  DocumentWorkflowStateEntity,\n  EpicDocumentEntity,\n  FeatureDocumentEntity,\n  PRDDocumentEntity,\n  ProjectEntity,\n  TaskDocumentEntity,\n  VisionDocumentEntity,\n} from '../entities/document-entities.ts';\nimport type { IRepository } from '../interfaces.ts';\n\nexport interface DocumentCreateOptions {\n  autoGenerateRelationships?: boolean;\n  startWorkflow?: string;\n  notifyListeners?: boolean;\n  generateSearchIndex?: boolean;\n}\n\nexport interface DocumentQueryOptions {\n  includeContent?: boolean;\n  includeRelationships?: boolean;\n  includeWorkflowState?: boolean;\n  limit?: number;\n  offset?: number;\n  sortBy?: 'created_at' | 'updated_at' | 'title' | 'priority' | 'completion_percentage';\n  sortOrder?: 'asc' | 'desc';\n}\n\nexport interface DocumentSearchOptions extends DocumentQueryOptions {\n  searchType: 'fulltext' | 'semantic' | 'keyword' | 'combined';\n  query: string;\n  documentTypes?: DocumentType[];\n  projectId?: string;\n  status?: string[];\n  priority?: string[];\n  dateRange?: {\n    start: Date;\n    end: Date;\n    field: 'created_at' | 'updated_at';\n  };\n}\n\n/**\n * Pure DAL-Based Document Manager.\n * Uses unified DAL for all database operations.\n *\n * @example\n */\nexport class DocumentManager {\n  private documentRepository!: IRepository<BaseDocumentEntity>;\n  private projectRepository!: IRepository<ProjectEntity>;\n  private relationshipRepository!: IRepository<DocumentRelationshipEntity>;\n  private workflowRepository!: IRepository<DocumentWorkflowStateEntity>;\n\n  constructor(private databaseType: 'postgresql' | 'sqlite' | 'mysql' = 'postgresql') {}\n\n  /**\n   * Initialize document manager and all DAL repositories.\n   */\n  async initialize(): Promise<void> {\n    // Initialize all repositories using DAL factory\n    this.documentRepository = await createDao<BaseDocumentEntity>(\n      EntityTypes.Document,\n      this.databaseType\n    );\n\n    this.projectRepository = await createDao<ProjectEntity>('Project', this.databaseType);\n\n    this.relationshipRepository = await createDao<DocumentRelationshipEntity>(\n      'DocumentRelationship',\n      this.databaseType\n    );\n\n    this.workflowRepository = await createDao<DocumentWorkflowStateEntity>(\n      'DocumentWorkflowState',\n      this.databaseType\n    );\n\n    // DAOs already initialized above as repositories\n  }\n\n  // ==================== DOCUMENT CRUD OPERATIONS ====================\n\n  /**\n   * Create a new document using DAL.\n   *\n   * @param document\n   * @param options\n   */\n  async createDocument<T extends BaseDocumentEntity>(\n    document: Omit<T, 'id' | 'created_at' | 'updated_at' | 'checksum'>,\n    options: DocumentCreateOptions = {}\n  ): Promise<T> {\n    const id = nanoid();\n    const now = new Date();\n    const checksum = this.generateChecksum(document.content);\n\n    const fullDocument: T = {\n      ...document,\n      id,\n      created_at: now,\n      updated_at: now,\n      checksum,\n    } as T;\n\n    // Create document using DAL repository\n    const created = await this.documentRepository.create(fullDocument as any);\n\n    // Auto-generate relationships if requested\n    if (options?.autoGenerateRelationships) {\n      await this.generateDocumentRelationships(created as T);\n    }\n\n    // Start workflow if specified\n    if (options?.startWorkflow) {\n      await this.startDocumentWorkflow(id, options?.startWorkflow);\n    }\n\n    // Generate search index\n    if (options?.generateSearchIndex !== false) {\n      await this.generateSearchIndex(created as T);\n    }\n\n    return created as T;\n  }\n\n  /**\n   * Get document by ID using DAL.\n   *\n   * @param id\n   * @param options\n   */\n  async getDocument<T extends BaseDocumentEntity>(\n    id: string,\n    options: DocumentQueryOptions = {}\n  ): Promise<T | null> {\n    const document = await this.documentRepository.findById(id);\n\n    if (!document) {\n      return null;\n    }\n\n    // Load relationships if requested\n    if (options?.includeRelationships) {\n      (document as any).relationships = await this.getDocumentRelationships(id);\n    }\n\n    // Load workflow state if requested\n    if (options?.includeWorkflowState) {\n      (document as any).workflowState = await this.getDocumentWorkflowState(id);\n    }\n\n    return document as T;\n  }\n\n  /**\n   * Update document using DAL.\n   *\n   * @param id\n   * @param updates\n   * @param options\n   */\n  async updateDocument<T extends BaseDocumentEntity>(\n    id: string,\n    updates: Partial<Omit<T, 'id' | 'created_at' | 'updated_at' | 'checksum'>>,\n    options: DocumentCreateOptions = {}\n  ): Promise<T> {\n    const now = new Date();\n    const updatedData = {\n      ...updates,\n      updated_at: now,\n      checksum: updates.content ? this.generateChecksum(updates.content) : undefined,\n    };\n\n    // Remove undefined values\n    Object.keys(updatedData).forEach(\n      (key) =>\n        updatedData?.[key as keyof typeof updatedData] === undefined &&\n        delete updatedData?.[key as keyof typeof updatedData]\n    );\n\n    const updated = await this.documentRepository.update(id, updatedData as any);\n\n    // Update search index if content changed\n    if (updates.content || updates.title) {\n      await this.updateSearchIndex(updated as T);\n    }\n\n    // Update relationships if content significantly changed\n    if (options?.autoGenerateRelationships && updates.content) {\n      await this.updateDocumentRelationships(updated as T);\n    }\n\n    return updated as T;\n  }\n\n  /**\n   * Delete document using DAL.\n   *\n   * @param id\n   */\n  async deleteDocument(id: string): Promise<void> {\n    // Delete relationships first\n    await this.deleteDocumentRelationships(id);\n\n    // Delete workflow state\n    await this.deleteDocumentWorkflowState(id);\n\n    // Delete search index\n    await this.deleteSearchIndex(id);\n\n    // Delete document\n    await this.documentRepository.delete(id);\n  }\n\n  // ==================== DOCUMENT QUERYING ====================\n\n  /**\n   * Query documents with filters using DAL.\n   *\n   * @param filters\n   * @param filters.type\n   * @param filters.projectId\n   * @param filters.status\n   * @param filters.priority\n   * @param filters.author\n   * @param filters.tags\n   * @param filters.parentDocumentId\n   * @param filters.workflowStage\n   * @param options\n   */\n  async queryDocuments<T extends BaseDocumentEntity>(\n    filters: {\n      type?: DocumentType | DocumentType[];\n      projectId?: string;\n      status?: string | string[];\n      priority?: string | string[];\n      author?: string;\n      tags?: string[];\n      parentDocumentId?: string;\n      workflowStage?: string;\n    },\n    options: DocumentQueryOptions = {}\n  ): Promise<{\n    documents: T[];\n    total: number;\n    hasMore: boolean;\n  }> {\n    // Build query options for DAL\n    const queryOptions = {\n      limit: options?.limit || 50,\n      offset: options?.offset || 0,\n    };\n\n    // Use DAL findAll with filters\n    const documents = await this.documentRepository.findAll(queryOptions);\n\n    // Apply advanced filtering using DAL query capabilities\n    let filtered = documents as T[];\n\n    if (filters.type) {\n      const types = Array.isArray(filters.type) ? filters.type : [filters.type];\n      filtered = filtered.filter((doc) => types.includes(doc.type));\n    }\n\n    if (filters.projectId) {\n      filtered = filtered.filter((doc) => doc.project_id === filters.projectId);\n    }\n\n    if (filters.status) {\n      const statuses = Array.isArray(filters.status) ? filters.status : [filters.status];\n      filtered = filtered.filter((doc) => statuses.includes(doc.status));\n    }\n\n    // Sort results\n    if (options?.sortBy) {\n      filtered.sort((a, b) => {\n        const aVal = a[options?.sortBy!] as any;\n        const bVal = b[options?.sortBy!] as any;\n\n        if (options.sortOrder === 'desc') {\n          return aVal > bVal ? -1 : aVal < bVal ? 1 : 0;\n        } else {\n          return aVal > bVal ? 1 : aVal < bVal ? -1 : 0;\n        }\n      });\n    }\n\n    return {\n      documents: filtered,\n      total: filtered.length,\n      hasMore: (options?.offset || 0) + filtered.length < filtered.length,\n    };\n  }\n\n  /**\n   * Advanced document search using multiple search strategies.\n   *\n   * @param searchOptions\n   */\n  async searchDocuments<T extends BaseDocumentEntity>(\n    searchOptions: DocumentSearchOptions\n  ): Promise<{\n    documents: T[];\n    total: number;\n    hasMore: boolean;\n    searchMetadata: {\n      searchType: string;\n      query: string;\n      processingTime: number;\n      relevanceScores?: number[];\n    };\n  }> {\n    const startTime = Date.now();\n    let documents: T[] = [];\n    let relevanceScores: number[] = [];\n\n    // Get all documents with filters applied\n    const baseFilters: {\n      type?: DocumentType | DocumentType[];\n      projectId?: string;\n      status?: string | string[];\n      priority?: string | string[];\n      author?: string;\n      tags?: string[];\n      parentDocumentId?: string;\n      workflowStage?: string;\n    } = {};\n    if (searchOptions?.projectId) baseFilters.projectId = searchOptions?.projectId;\n    if (searchOptions?.documentTypes) baseFilters.type = searchOptions?.documentTypes;\n    if (searchOptions?.status) baseFilters.status = searchOptions?.status;\n    if (searchOptions?.priority) baseFilters.priority = searchOptions?.priority;\n\n    const { documents: candidateDocuments } = await this.queryDocuments(baseFilters, {\n      includeContent: true,\n      includeRelationships: true,\n      limit: 1000, // Large limit for comprehensive search\n    });\n\n    // Apply date range filter if specified\n    let filteredCandidates = candidateDocuments as T[];\n    if (searchOptions?.dateRange) {\n      const { start, end, field } = searchOptions?.dateRange;\n      filteredCandidates = filteredCandidates.filter((doc) => {\n        const dateValue = doc[field];\n        return dateValue >= start && dateValue <= end;\n      });\n    }\n\n    // Execute search based on search type\n    switch (searchOptions?.searchType) {\n      case 'fulltext':\n        ({ documents, relevanceScores } = this.performFulltextSearch(\n          filteredCandidates,\n          searchOptions?.query\n        ));\n        break;\n      case 'semantic':\n        ({ documents, relevanceScores } = await this.performSemanticSearch(\n          filteredCandidates,\n          searchOptions?.query\n        ));\n        break;\n      case 'keyword':\n        ({ documents, relevanceScores } = this.performKeywordSearch(\n          filteredCandidates,\n          searchOptions?.query\n        ));\n        break;\n      case 'combined':\n        ({ documents, relevanceScores } = await this.performCombinedSearch(\n          filteredCandidates,\n          searchOptions?.query\n        ));\n        break;\n      default:\n        ({ documents, relevanceScores } = this.performFulltextSearch(\n          filteredCandidates,\n          searchOptions?.query\n        ));\n    }\n\n    // Apply pagination\n    const total = documents.length;\n    const offset = searchOptions?.offset || 0;\n    const limit = searchOptions?.limit || 20;\n    const paginatedDocuments = documents.slice(offset, offset + limit);\n    const paginatedScores = relevanceScores.slice(offset, offset + limit);\n    const hasMore = offset + limit < total;\n\n    const processingTime = Date.now() - startTime;\n\n    return {\n      documents: paginatedDocuments,\n      total,\n      hasMore,\n      searchMetadata: {\n        searchType: searchOptions?.searchType,\n        query: searchOptions?.query,\n        processingTime,\n        relevanceScores: paginatedScores,\n      },\n    };\n  }\n\n  /**\n   * Perform fulltext search with TF-IDF scoring.\n   *\n   * @param documents\n   * @param query\n   */\n  private performFulltextSearch<T extends BaseDocumentEntity>(\n    documents: T[],\n    query: string\n  ): { documents: T[]; relevanceScores: number[] } {\n    const queryTerms = this.tokenizeText(query.toLowerCase());\n    const results: Array<{ document: T; score: number }> = [];\n\n    for (const doc of documents) {\n      const docText = `${doc.title} ${doc.content} ${doc.keywords.join(' ')}`.toLowerCase();\n      const docTerms = this.tokenizeText(docText);\n\n      let score = 0;\n      for (const term of queryTerms) {\n        const tf = this.calculateTermFrequency(term, docTerms);\n        const idf = this.calculateInverseDocumentFrequency(term, documents);\n        score += tf * idf;\n      }\n\n      // Boost score for title matches\n      if (doc.title.toLowerCase().includes(query.toLowerCase())) {\n        score *= 2;\n      }\n\n      // Boost score for exact keyword matches\n      if (doc.keywords.some((k) => k.toLowerCase().includes(query.toLowerCase()))) {\n        score *= 1.5;\n      }\n\n      if (score > 0) {\n        results?.push({ document: doc, score });\n      }\n    }\n\n    // Sort by relevance score\n    results?.sort((a, b) => b.score - a.score);\n\n    return {\n      documents: results?.map((r) => r.document),\n      relevanceScores: results?.map((r) => r.score),\n    };\n  }\n\n  /**\n   * Perform semantic search using content similarity.\n   *\n   * @param documents\n   * @param query\n   */\n  private async performSemanticSearch<T extends BaseDocumentEntity>(\n    documents: T[],\n    query: string\n  ): Promise<{ documents: T[]; relevanceScores: number[] }> {\n    // For now, implement a simplified semantic search\n    // In production, this would use vector embeddings and similarity search\n    const results: Array<{ document: T; score: number }> = [];\n    const queryTokens = this.tokenizeText(query.toLowerCase());\n\n    for (const doc of documents) {\n      const docTokens = this.tokenizeText(`${doc.title} ${doc.content}`.toLowerCase());\n\n      // Calculate semantic similarity using Jaccard similarity with word expansion\n      const expandedQueryTokens = this.expandTokensWithSynonyms(queryTokens);\n      const expandedDocTokens = this.expandTokensWithSynonyms(docTokens);\n\n      const similarity = this.calculateJaccardSimilarity(expandedQueryTokens, expandedDocTokens);\n\n      // Boost for conceptual matches\n      const conceptualScore = this.calculateConceptualSimilarity(query, doc.content);\n      const finalScore = similarity * 0.7 + conceptualScore * 0.3;\n\n      if (finalScore > 0.1) {\n        results?.push({ document: doc, score: finalScore });\n      }\n    }\n\n    results?.sort((a, b) => b.score - a.score);\n\n    return {\n      documents: results?.map((r) => r.document),\n      relevanceScores: results?.map((r) => r.score),\n    };\n  }\n\n  /**\n   * Perform keyword-based search.\n   *\n   * @param documents\n   * @param query\n   */\n  private performKeywordSearch<T extends BaseDocumentEntity>(\n    documents: T[],\n    query: string\n  ): { documents: T[]; relevanceScores: number[] } {\n    const queryKeywords = query\n      .toLowerCase()\n      .split(/\\s+/)\n      .filter((k) => k.length > 2);\n    const results: Array<{ document: T; score: number }> = [];\n\n    for (const doc of documents) {\n      let score = 0;\n      const docKeywords = doc.keywords.map((k) => k.toLowerCase());\n\n      for (const queryKeyword of queryKeywords) {\n        // Exact keyword match\n        if (docKeywords.includes(queryKeyword)) {\n          score += 1.0;\n        }\n        // Partial keyword match\n        else if (docKeywords.some((k) => k.includes(queryKeyword) || queryKeyword.includes(k))) {\n          score += 0.5;\n        }\n        // Title match\n        else if (doc.title.toLowerCase().includes(queryKeyword)) {\n          score += 0.3;\n        }\n      }\n\n      if (score > 0) {\n        results?.push({ document: doc, score });\n      }\n    }\n\n    results?.sort((a, b) => b.score - a.score);\n\n    return {\n      documents: results?.map((r) => r.document),\n      relevanceScores: results?.map((r) => r.score),\n    };\n  }\n\n  /**\n   * Perform combined search using multiple strategies.\n   *\n   * @param documents\n   * @param query\n   */\n  private async performCombinedSearch<T extends BaseDocumentEntity>(\n    documents: T[],\n    query: string\n  ): Promise<{ documents: T[]; relevanceScores: number[] }> {\n    // Get results from all search methods\n    const fulltextResults = this.performFulltextSearch(documents, query);\n    const semanticResults = await this.performSemanticSearch(documents, query);\n    const keywordResults = this.performKeywordSearch(documents, query);\n\n    // Combine scores with weights\n    const combinedScores = new Map<string, number>();\n    const allDocuments = new Map<string, T>();\n\n    // Fulltext search (40% weight)\n    fulltextResults?.documents.forEach((doc, index) => {\n      const score = (fulltextResults?.relevanceScores?.[index] || 0) * 0.4;\n      combinedScores.set(doc.id, (combinedScores.get(doc.id) || 0) + score);\n      allDocuments.set(doc.id, doc);\n    });\n\n    // Semantic search (35% weight)\n    semanticResults?.documents.forEach((doc, index) => {\n      const score = (semanticResults?.relevanceScores?.[index] || 0) * 0.35;\n      combinedScores.set(doc.id, (combinedScores.get(doc.id) || 0) + score);\n      allDocuments.set(doc.id, doc);\n    });\n\n    // Keyword search (25% weight)\n    keywordResults?.documents.forEach((doc, index) => {\n      const score = (keywordResults?.relevanceScores?.[index] || 0) * 0.25;\n      combinedScores.set(doc.id, (combinedScores.get(doc.id) || 0) + score);\n      allDocuments.set(doc.id, doc);\n    });\n\n    // Sort by combined score\n    const sortedResults = Array.from(combinedScores.entries())\n      .sort((a, b) => b[1] - a[1])\n      .filter(([, score]) => score > 0.1); // Filter out very low scores\n\n    return {\n      documents: sortedResults?.map(([docId]) => allDocuments.get(docId)!),\n      relevanceScores: sortedResults?.map(([, score]) => score),\n    };\n  }\n\n  // ==================== PROJECT OPERATIONS ====================\n\n  /**\n   * Create a new project using DAL.\n   *\n   * @param project\n   */\n  async createProject(\n    project: Omit<ProjectEntity, 'id' | 'created_at' | 'updated_at'>\n  ): Promise<ProjectEntity> {\n    const id = nanoid();\n    const now = new Date();\n\n    const fullProject: ProjectEntity = {\n      ...project,\n      id,\n      created_at: now,\n      updated_at: now,\n    };\n\n    return await this.projectRepository.create(fullProject);\n  }\n\n  /**\n   * Get project with all related documents using DAL.\n   *\n   * @param projectId\n   */\n  async getProjectWithDocuments(projectId: string): Promise<{\n    project: ProjectEntity;\n    documents: {\n      visions: VisionDocumentEntity[];\n      adrs: ADRDocumentEntity[];\n      prds: PRDDocumentEntity[];\n      epics: EpicDocumentEntity[];\n      features: FeatureDocumentEntity[];\n      tasks: TaskDocumentEntity[];\n    };\n  } | null> {\n    const project = await this.projectRepository.findById(projectId);\n\n    if (!project) {\n      return null;\n    }\n\n    // Get all project documents\n    const { documents } = await this.queryDocuments(\n      { projectId },\n      { includeContent: true, includeRelationships: true }\n    );\n\n    // Group documents by type\n    const groupedDocuments = {\n      visions: documents.filter((d) => d.type === 'vision') as VisionDocumentEntity[],\n      adrs: documents.filter((d) => d.type === 'adr') as ADRDocumentEntity[],\n      prds: documents.filter((d) => d.type === 'prd') as PRDDocumentEntity[],\n      epics: documents.filter((d) => d.type === 'epic') as EpicDocumentEntity[],\n      features: documents.filter((d) => d.type === 'feature') as FeatureDocumentEntity[],\n      tasks: documents.filter((d) => d.type === 'task') as TaskDocumentEntity[],\n    };\n\n    return {\n      project,\n      documents: groupedDocuments,\n    };\n  }\n\n  // ==================== WORKFLOW AUTOMATION ====================\n\n  /**\n   * Start workflow for document using DAL with automated stage progression.\n   *\n   * @param documentId\n   * @param workflowName\n   * @param initialStage\n   */\n  async startDocumentWorkflow(\n    documentId: string,\n    workflowName: string,\n    initialStage = 'draft'\n  ): Promise<DocumentWorkflowStateEntity> {\n    const id = nanoid();\n    const now = new Date();\n    const workflowDefinition = this.getWorkflowDefinition(workflowName);\n\n    const workflowState: DocumentWorkflowStateEntity = {\n      id,\n      document_id: documentId,\n      workflow_name: workflowName,\n      current_stage: initialStage,\n      stages_completed: [],\n      next_stages: workflowDefinition.getNextStages(initialStage),\n      started_at: now,\n      updated_at: now,\n      auto_transitions: workflowDefinition.autoTransitions,\n      requires_approval: workflowDefinition.requiresApproval(initialStage),\n      generated_artifacts: [],\n      workflow_results: {},\n    };\n\n    const created = await this.workflowRepository.create(workflowState);\n\n    // Auto-advance if the initial stage allows it\n    if (workflowState.auto_transitions && !workflowState.requires_approval) {\n      await this.checkAndTriggerWorkflowAutomation(documentId);\n    }\n\n    return created;\n  }\n\n  /**\n   * Advance document workflow with automated rule checking.\n   *\n   * @param documentId\n   * @param nextStage\n   * @param results\n   */\n  async advanceDocumentWorkflow(\n    documentId: string,\n    nextStage: string,\n    results?: Record<string, any>\n  ): Promise<DocumentWorkflowStateEntity> {\n    // Find existing workflow state\n    const allWorkflows = await this.workflowRepository.findAll();\n    const existing = allWorkflows.find((w) => w.document_id === documentId);\n\n    if (!existing) {\n      throw new Error(`No workflow state found for document: ${documentId}`);\n    }\n\n    // Validate transition is allowed\n    const workflowDefinition = this.getWorkflowDefinition(existing.workflow_name);\n    if (!workflowDefinition.canTransition(existing.current_stage, nextStage)) {\n      throw new Error(`Invalid transition from ${existing.current_stage} to ${nextStage}`);\n    }\n\n    const updatedState: Partial<DocumentWorkflowStateEntity> = {\n      current_stage: nextStage,\n      stages_completed: [...existing.stages_completed, existing.current_stage],\n      next_stages: workflowDefinition.getNextStages(nextStage),\n      updated_at: new Date(),\n      requires_approval: workflowDefinition.requiresApproval(nextStage),\n      workflow_results: results\n        ? { ...existing.workflow_results, ...results }\n        : existing.workflow_results,\n    };\n\n    const updated = await this.workflowRepository.update(existing.id, updatedState);\n\n    // Check for automation triggers after stage transition\n    await this.checkAndTriggerWorkflowAutomation(documentId);\n\n    return updated;\n  }\n\n  /**\n   * Check and trigger workflow automation based on predefined rules.\n   *\n   * @param documentId\n   */\n  async checkAndTriggerWorkflowAutomation(documentId: string): Promise<void> {\n    const document = await this.getDocument(documentId, { includeWorkflowState: true });\n    if (!document || !(document as any).workflowState) return;\n\n    const workflowState = (document as any).workflowState as DocumentWorkflowStateEntity;\n    const workflowDefinition = this.getWorkflowDefinition(workflowState.workflow_name);\n\n    // Check automation rules for current stage\n    const automationRules = workflowDefinition.getAutomationRules(workflowState.current_stage);\n\n    for (const rule of automationRules) {\n      if (await this.evaluateAutomationRule(document, rule)) {\n        await this.executeAutomationAction(document, rule);\n      }\n    }\n  }\n\n  /**\n   * Evaluate if an automation rule should trigger.\n   *\n   * @param document\n   * @param rule\n   */\n  private async evaluateAutomationRule(\n    document: BaseDocumentEntity,\n    rule: WorkflowAutomationRule\n  ): Promise<boolean> {\n    switch (rule.condition.type) {\n      case 'status_change':\n        return document.status === rule.condition.value;\n\n      case 'stage_duration': {\n        const workflowState = await this.getDocumentWorkflowState(document.id);\n        if (!workflowState) return false;\n        const durationMs = Date.now() - workflowState.updated_at.getTime();\n        return durationMs >= (rule.condition.value as number);\n      }\n\n      case 'document_type':\n        return document.type === rule.condition.value;\n\n      case 'priority_level':\n        return document.priority === rule.condition.value;\n\n      case 'completion_percentage':\n        return (document.completion_percentage || 0) >= (rule.condition.value as number);\n\n      case 'has_relationships': {\n        const relationships = await this.getDocumentRelationships(document.id);\n        return relationships.length > 0;\n      }\n\n      case 'custom_field': {\n        const { field, operator, value } = rule.condition.value;\n        const fieldValue = (document as any)[field];\n        return this.evaluateCondition(fieldValue, operator, value);\n      }\n\n      default:\n        return false;\n    }\n  }\n\n  /**\n   * Execute automation action when rule triggers.\n   *\n   * @param document\n   * @param rule\n   */\n  private async executeAutomationAction(\n    document: BaseDocumentEntity,\n    rule: WorkflowAutomationRule\n  ): Promise<void> {\n    switch (rule.action.type) {\n      case 'advance_stage':\n        await this.advanceDocumentWorkflow(document.id, rule.action.value as string);\n        break;\n\n      case 'create_document':\n        await this.executeCreateDocumentAction(document, rule.action.value);\n        break;\n\n      case 'update_status':\n        // TODO: TypeScript error TS2322 - status type issue (AI unsure of safe fix - human review needed)\n        await this.updateDocument(document.id, { status: rule.action.value });\n        break;\n\n      case 'assign_reviewer':\n        await this.updateDocument(document.id, {\n          metadata: {\n            ...document.metadata,\n            assigned_reviewer: rule.action.value,\n          },\n        });\n        break;\n\n      case 'generate_artifacts':\n        await this.generateWorkflowArtifacts(document, rule.action.value as string[]);\n        break;\n\n      case 'send_notification':\n        await this.sendWorkflowNotification(document, rule.action.value);\n        break;\n\n      case 'update_relationships':\n        await this.updateDocumentRelationships(document);\n        break;\n\n      default:\n        logger.warn(`Unknown automation action type: ${rule.action.type}`);\n    }\n  }\n\n  /**\n   * Execute create document automation action.\n   *\n   * @param sourceDocument\n   * @param actionConfig\n   * @param actionConfig.documentType\n   * @param actionConfig.template\n   * @param actionConfig.title\n   * @param actionConfig.assignTo\n   * @param actionConfig.priority\n   * @param actionConfig.status\n   * @param actionConfig.inheritKeywords\n   */\n  private async executeCreateDocumentAction(\n    sourceDocument: BaseDocumentEntity,\n    actionConfig: {\n      documentType: DocumentType;\n      template?: string;\n      title?: string;\n      assignTo?: string;\n      priority?: string;\n      status?: string;\n      inheritKeywords?: boolean;\n    }\n  ): Promise<BaseDocumentEntity> {\n    const documentTitle =\n      actionConfig?.title ||\n      `${actionConfig?.documentType?.charAt(0).toUpperCase() + actionConfig?.documentType?.slice(1)} for ${sourceDocument.title}`;\n\n    const newDocumentData = {\n      type: actionConfig?.documentType,\n      title: documentTitle,\n      content: actionConfig?.template || this.getDefaultTemplate(actionConfig?.documentType),\n      summary: `Auto-generated ${actionConfig?.documentType} from ${sourceDocument.type}: ${sourceDocument.title}`,\n      author: actionConfig?.assignTo || sourceDocument.author,\n      project_id: sourceDocument.project_id,\n      status: actionConfig?.status || 'draft',\n      priority: actionConfig?.priority || sourceDocument.priority,\n      keywords: actionConfig?.inheritKeywords ? [...sourceDocument.keywords] : [],\n      metadata: {\n        source_document_id: sourceDocument.id,\n        auto_generated: true,\n        generated_by_rule: true,\n        generation_timestamp: new Date().toISOString(),\n      },\n    };\n\n    // TODO: TypeScript error TS2379 - optional property types issue (AI unsure of safe fix - human review needed)\n    const createdDocument = await this.createDocument(newDocumentData as any, {\n      autoGenerateRelationships: true,\n      startWorkflow: `${actionConfig?.documentType}_workflow`,\n      generateSearchIndex: true,\n    });\n\n    // Create explicit relationship between source and generated document\n    await this.relationshipRepository.create({\n      source_document_id: sourceDocument.id,\n      target_document_id: createdDocument.id,\n      relationship_type: 'generates',\n      // TODO: TypeScript error TS2353 - 'strength' property doesn't exist (AI unsure of safe fix - human review needed)\n      // strength: 1.0,\n      created_at: new Date(),\n      metadata: {\n        auto_generated: true,\n        generation_rule: 'workflow_automation',\n      },\n    });\n\n    return createdDocument;\n  }\n\n  /**\n   * Generate workflow artifacts.\n   *\n   * @param document\n   * @param artifactTypes\n   */\n  private async generateWorkflowArtifacts(\n    document: BaseDocumentEntity,\n    artifactTypes: string[]\n  ): Promise<void> {\n    const workflowState = await this.getDocumentWorkflowState(document.id);\n    if (!workflowState) return;\n\n    const artifacts: string[] = [];\n\n    for (const artifactType of artifactTypes) {\n      switch (artifactType) {\n        case 'summary_report':\n          artifacts.push(await this.generateSummaryReport(document));\n          break;\n        case 'checklist':\n          artifacts.push(await this.generateChecklist(document));\n          break;\n        case 'timeline':\n          artifacts.push(await this.generateTimeline(document));\n          break;\n        case 'stakeholder_matrix':\n          artifacts.push(await this.generateStakeholderMatrix(document));\n          break;\n      }\n    }\n\n    // Update workflow state with generated artifacts\n    await this.workflowRepository.update(workflowState.id, {\n      generated_artifacts: [...workflowState.generated_artifacts, ...artifacts],\n      updated_at: new Date(),\n    });\n  }\n\n  /**\n   * Send workflow notification.\n   *\n   * @param document\n   * @param notificationConfig\n   * @param notificationConfig.recipients\n   * @param notificationConfig.template\n   * @param notificationConfig.channel\n   * @param notificationConfig.urgency\n   * @param _document\n   * @param _notificationConfig\n   * @param _notificationConfig.recipients\n   * @param _notificationConfig.template\n   * @param _notificationConfig.channel\n   * @param _notificationConfig.urgency\n   */\n  private async sendWorkflowNotification(\n    _document: BaseDocumentEntity,\n    _notificationConfig: {\n      recipients: string[];\n      template: string;\n      channel: 'email' | 'slack' | 'teams';\n      urgency: 'low' | 'medium' | 'high';\n    }\n  ): Promise<void> {}\n\n  /**\n   * Get workflow definition for a workflow type.\n   *\n   * @param workflowName\n   */\n  private getWorkflowDefinition(workflowName: string): WorkflowDefinition {\n    const definitions: Record<string, WorkflowDefinition> = {\n      vision_workflow: new VisionWorkflowDefinition(),\n      adr_workflow: new ADRWorkflowDefinition(),\n      prd_workflow: new PRDWorkflowDefinition(),\n      epic_workflow: new EpicWorkflowDefinition(),\n      feature_workflow: new FeatureWorkflowDefinition(),\n      task_workflow: new TaskWorkflowDefinition(),\n      default_workflow: new DefaultWorkflowDefinition(),\n    };\n\n    return definitions[workflowName] || definitions['default_workflow']!;\n  }\n\n  /**\n   * Evaluate a condition with operator.\n   *\n   * @param value\n   * @param operator\n   * @param expected\n   */\n  private evaluateCondition(value: any, operator: string, expected: any): boolean {\n    switch (operator) {\n      case 'equals':\n        return value === expected;\n      case 'not_equals':\n        return value !== expected;\n      case 'greater_than':\n        return value > expected;\n      case 'less_than':\n        return value < expected;\n      case 'contains':\n        return String(value).includes(String(expected));\n      case 'starts_with':\n        return String(value).startsWith(String(expected));\n      case 'ends_with':\n        return String(value).endsWith(String(expected));\n      case 'in':\n        return Array.isArray(expected) && expected.includes(value);\n      case 'not_in':\n        return Array.isArray(expected) && !expected.includes(value);\n      default:\n        return false;\n    }\n  }\n\n  /**\n   * Get default template for document type.\n   *\n   * @param documentType\n   */\n  private getDefaultTemplate(documentType: DocumentType): string {\n    const templates: Record<DocumentType, string> = {\n      vision: '# Vision\\n\\n## Overview\\n\\n## Goals\\n\\n## Success Criteria\\n\\n## Stakeholders\\n',\n      adr: '# Architecture Decision Record\\n\\n## Status\\n\\n## Context\\n\\n## Decision\\n\\n## Consequences\\n',\n      prd: '# Product Requirements Document\\n\\n## Problem Statement\\n\\n## Requirements\\n\\n## Acceptance Criteria\\n\\n## Dependencies\\n',\n      epic: '# Epic\\n\\n## Description\\n\\n## User Stories\\n\\n## Definition of Done\\n\\n## Dependencies\\n',\n      feature:\n        '# Feature\\n\\n## Description\\n\\n## Functional Requirements\\n\\n## Technical Requirements\\n\\n## Testing Plan\\n',\n      task: '# Task\\n\\n## Description\\n\\n## Steps\\n\\n## Acceptance Criteria\\n\\n## Notes\\n',\n      code: '# Code\\n\\n## Implementation\\n',\n      test: '# Test\\n\\n## Test Cases\\n',\n      documentation: '# Documentation\\n\\n## Content\\n',\n    };\n\n    return templates[documentType] || '# Document\\n\\n## Content\\n';\n  }\n\n  // ==================== WORKFLOW ARTIFACT GENERATORS ====================\n\n  private async generateSummaryReport(document: BaseDocumentEntity): Promise<string> {\n    return `Summary report generated for ${document.title} on ${new Date().toISOString()}`;\n  }\n\n  private async generateChecklist(document: BaseDocumentEntity): Promise<string> {\n    return `Checklist generated for ${document.title} on ${new Date().toISOString()}`;\n  }\n\n  private async generateTimeline(document: BaseDocumentEntity): Promise<string> {\n    return `Timeline generated for ${document.title} on ${new Date().toISOString()}`;\n  }\n\n  private async generateStakeholderMatrix(document: BaseDocumentEntity): Promise<string> {\n    return `Stakeholder matrix generated for ${document.title} on ${new Date().toISOString()}`;\n  }\n\n  // ==================== PRIVATE HELPER METHODS ====================\n\n  private generateChecksum(content: string): string {\n    // Production-ready SHA-256 checksum with error handling\n    try {\n      const crypto = require('crypto');\n      const hash = crypto.createHash('sha256');\n      hash.update(content, 'utf8');\n      \n      // Return first 16 characters of hex digest for consistency with previous format\n      const fullHash = hash.digest('hex');\n      const shortHash = fullHash.substring(0, 16);\n      \n      // Log checksum generation for audit purposes\n      logger.debug(`Generated checksum for content (${content.length} chars): ${shortHash}`);\n      \n      return shortHash;\n    } catch (error) {\n      logger.error('Failed to generate checksum:', error);\n      // Fallback to base64 method if crypto fails\n      return Buffer.from(content).toString('base64').slice(0, 16);\n    }\n  }\n\n  // ==================== RELATIONSHIP MANAGEMENT ====================\n\n  /**\n   * Generate document relationships based on content analysis and workflow stage.\n   *\n   * @param document\n   */\n  private async generateDocumentRelationships(document: BaseDocumentEntity): Promise<void> {\n    const relationships: Omit<DocumentRelationshipEntity, 'id' | 'created_at'>[] = [];\n\n    // Auto-generate parent relationships based on document type hierarchy\n    const parentRelationships = await this.findParentDocuments(document);\n    relationships.push(...parentRelationships);\n\n    // Generate semantic relationships based on content analysis\n    const semanticRelationships = await this.findSemanticRelationships(document);\n    relationships.push(...semanticRelationships);\n\n    // Generate workflow-based relationships\n    const workflowRelationships = await this.findWorkflowRelationships(document);\n    relationships.push(...workflowRelationships);\n\n    // Create all relationships in database\n    for (const relationship of relationships) {\n      await this.relationshipRepository.create({\n        ...relationship,\n        created_at: new Date(),\n      });\n    }\n  }\n\n  /**\n   * Find parent documents based on document type hierarchy.\n   *\n   * @param document\n   */\n  private async findParentDocuments(\n    document: BaseDocumentEntity\n  ): Promise<Omit<DocumentRelationshipEntity, 'id' | 'created_at'>[]> {\n    const relationships: Omit<DocumentRelationshipEntity, 'id' | 'created_at'>[] = [];\n\n    // Define document type hierarchy for automatic parent relationships\n    const typeHierarchy: Record<DocumentType, DocumentType[]> = {\n      vision: [], // Vision documents have no automatic parents\n      adr: ['vision'], // ADRs can relate to visions\n      prd: ['vision', 'adr'], // PRDs can relate to visions and ADRs\n      epic: ['prd', 'vision'], // Epics relate to PRDs and visions\n      feature: ['epic', 'prd'], // Features relate to epics and PRDs\n      task: ['feature', 'epic'], // Tasks relate to features and epics\n      code: ['feature', 'task'],\n      test: ['code', 'feature'],\n      documentation: ['feature', 'code'],\n    };\n\n    const parentTypes = typeHierarchy[document.type] || [];\n\n    if (parentTypes.length > 0) {\n      // Find documents in the same project with parent types\n      // TODO: TypeScript error TS2379 - optional property types issue (AI unsure of safe fix - human review needed)\n      const { documents: potentialParents } = await this.queryDocuments({\n        type: parentTypes,\n        projectId: document.project_id,\n      });\n\n      // Create relationships based on content similarity and recency\n      for (const parent of potentialParents?.slice(0, 3)) {\n        // Limit to 3 most relevant\n        const strength = this.calculateRelationshipStrength(document, parent);\n        if (strength > 0.3) {\n          // Only create relationships above threshold\n          relationships.push({\n            source_document_id: document.id,\n            target_document_id: parent?.id,\n            // TODO: TypeScript error TS2322 - 'derives_from' not in relationship type enum (AI unsure of safe fix - human review needed)\n            relationship_type: 'relates_to' as any,\n            // TODO: TypeScript error TS2353 - 'strength' property doesn't exist (AI unsure of safe fix - human review needed)\n            // strength,\n            metadata: {\n              auto_generated: true,\n              generation_method: 'type_hierarchy',\n              parent_type: parent?.type,\n            },\n          });\n        }\n      }\n    }\n\n    return relationships;\n  }\n\n  /**\n   * Find semantic relationships based on content analysis.\n   *\n   * @param document\n   */\n  private async findSemanticRelationships(\n    document: BaseDocumentEntity\n  ): Promise<Omit<DocumentRelationshipEntity, 'id' | 'created_at'>[]> {\n    const relationships: Omit<DocumentRelationshipEntity, 'id' | 'created_at'>[] = [];\n\n    // Find documents with similar keywords\n    // TODO: TypeScript error TS2379 - optional property types issue (AI unsure of safe fix - human review needed)\n    const { documents: similarDocuments } = await this.queryDocuments({\n      projectId: document.project_id,\n    });\n\n    for (const other of similarDocuments) {\n      if (other.id === document.id) continue;\n\n      // Calculate keyword overlap\n      const keywordOverlap = this.calculateKeywordOverlap(document.keywords, other.keywords);\n      if (keywordOverlap > 0.4) {\n        relationships.push({\n          source_document_id: document.id,\n          target_document_id: other.id,\n          relationship_type: 'relates_to',\n          // TODO: TypeScript error TS2353 - 'strength' property doesn't exist (AI unsure of safe fix - human review needed)\n          // strength: keywordOverlap,\n          metadata: {\n            auto_generated: true,\n            generation_method: 'keyword_analysis',\n            keyword_overlap: keywordOverlap,\n            shared_keywords: document.keywords.filter((k) => other.keywords.includes(k)),\n          },\n        });\n      }\n\n      // Check for content references (mentions of other document titles)\n      if (document.content.toLowerCase().includes(other.title.toLowerCase())) {\n        relationships.push({\n          source_document_id: document.id,\n          target_document_id: other.id,\n          // TODO: TypeScript error TS2322 - 'references' not in relationship type enum (AI unsure of safe fix - human review needed)\n          relationship_type: 'relates_to' as any,\n          // TODO: TypeScript error TS2353 - 'strength' property doesn't exist (AI unsure of safe fix - human review needed)\n          // strength: 0.8,\n          metadata: {\n            auto_generated: true,\n            generation_method: 'content_reference',\n            reference_type: 'title_mention',\n          },\n        });\n      }\n    }\n\n    return relationships;\n  }\n\n  /**\n   * Find workflow-based relationships.\n   *\n   * @param document\n   */\n  private async findWorkflowRelationships(\n    document: BaseDocumentEntity\n  ): Promise<Omit<DocumentRelationshipEntity, 'id' | 'created_at'>[]> {\n    const relationships: Omit<DocumentRelationshipEntity, 'id' | 'created_at'>[] = [];\n\n    // Find documents that should be generated from this document based on workflow rules\n    const generationRules = this.getWorkflowGenerationRules(document.type);\n\n    for (const rule of generationRules) {\n      // TODO: TypeScript error TS2379 - optional property types issue (AI unsure of safe fix - human review needed)\n      const { documents: existingDocs } = await this.queryDocuments({\n        type: rule.targetType,\n        projectId: document.project_id,\n      });\n\n      // Check if documents were generated from this source\n      for (const target of existingDocs) {\n        if (target?.metadata?.['source_document_id'] === document.id) {\n          relationships.push({\n            source_document_id: document.id,\n            target_document_id: target?.id,\n            relationship_type: 'generates',\n            // TODO: TypeScript error TS2353 - 'strength' property doesn't exist (AI unsure of safe fix - human review needed)\n            // strength: 1.0,\n            metadata: {\n              auto_generated: true,\n              generation_method: 'workflow_rule',\n              workflow_rule: rule.name,\n            },\n          });\n        }\n      }\n    }\n\n    return relationships;\n  }\n\n  /**\n   * Calculate relationship strength between two documents.\n   *\n   * @param doc1\n   * @param doc2\n   */\n  private calculateRelationshipStrength(\n    doc1: BaseDocumentEntity,\n    doc2: BaseDocumentEntity\n  ): number {\n    let strength = 0;\n\n    // Keyword similarity (40% weight)\n    const keywordSimilarity = this.calculateKeywordOverlap(doc1.keywords, doc2.keywords);\n    strength += keywordSimilarity * 0.4;\n\n    // Priority alignment (20% weight)\n    if (doc1.priority === doc2.priority) {\n      strength += 0.2;\n    }\n\n    // Author similarity (10% weight)\n    if (doc1.author === doc2.author) {\n      strength += 0.1;\n    }\n\n    // Recency factor (30% weight) - more recent documents get higher strength\n    const timeDiff = Math.abs(doc1.created_at.getTime() - doc2.created_at.getTime());\n    const maxDiff = 30 * 24 * 60 * 60 * 1000; // 30 days\n    const recencyFactor = Math.max(0, 1 - timeDiff / maxDiff);\n    strength += recencyFactor * 0.3;\n\n    return Math.min(1.0, strength);\n  }\n\n  /**\n   * Calculate keyword overlap between two arrays.\n   *\n   * @param keywords1\n   * @param keywords2\n   */\n  private calculateKeywordOverlap(keywords1: string[], keywords2: string[]): number {\n    if (keywords1.length === 0 || keywords2.length === 0) return 0;\n\n    const set1 = new Set(keywords1.map((k) => k.toLowerCase()));\n    const set2 = new Set(keywords2.map((k) => k.toLowerCase()));\n\n    const intersection = new Set([...set1].filter((k) => set2.has(k)));\n    const union = new Set([...set1, ...set2]);\n\n    return intersection.size / union.size; // Jaccard similarity\n  }\n\n  /**\n   * Get workflow generation rules for document type.\n   *\n   * @param documentType\n   */\n  private getWorkflowGenerationRules(documentType: DocumentType): Array<{\n    name: string;\n    sourceType: DocumentType;\n    targetType: DocumentType;\n    condition?: (doc: BaseDocumentEntity) => boolean;\n  }> {\n    const rules = [\n      {\n        name: 'prd_to_epic',\n        sourceType: 'prd' as DocumentType,\n        targetType: 'epic' as DocumentType,\n      },\n      {\n        name: 'epic_to_feature',\n        sourceType: 'epic' as DocumentType,\n        targetType: 'feature' as DocumentType,\n      },\n      {\n        name: 'feature_to_task',\n        sourceType: 'feature' as DocumentType,\n        targetType: 'task' as DocumentType,\n      },\n      // Note: vision_to_adr relationship removed - ADRs are independent architectural governance\n      // ADRs may reference visions but are not auto-generated from them\n    ];\n\n    return rules.filter((rule) => rule.sourceType === documentType);\n  }\n\n  private async getDocumentRelationships(\n    documentId: string\n  ): Promise<DocumentRelationshipEntity[]> {\n    const allRelationships = await this.relationshipRepository.findAll();\n    return allRelationships.filter(\n      (r) => r.source_document_id === documentId || r.target_document_id === documentId\n    );\n  }\n\n  private async getDocumentWorkflowState(\n    documentId: string\n  ): Promise<DocumentWorkflowStateEntity | null> {\n    const allWorkflows = await this.workflowRepository.findAll();\n    return allWorkflows.find((w) => w.document_id === documentId) || null;\n  }\n\n  private async generateSearchIndex(_document: BaseDocumentEntity): Promise<void> {\n    // TODO: Implement search index generation using vector DAL\n  }\n\n  private async updateSearchIndex(_document: BaseDocumentEntity): Promise<void> {\n    // TODO: Implement search index update using vector DAL\n  }\n\n  /**\n   * Update document relationships when content changes significantly.\n   *\n   * @param document\n   */\n  private async updateDocumentRelationships(document: BaseDocumentEntity): Promise<void> {\n    // Get existing relationships\n    const existingRelationships = await this.getDocumentRelationships(document.id);\n\n    // Remove auto-generated relationships that might be outdated\n    const autoGeneratedRelationships = existingRelationships.filter(\n      (r) => r.metadata?.['auto_generated'] === true\n    );\n\n    for (const relationship of autoGeneratedRelationships) {\n      await this.relationshipRepository.delete(relationship.id);\n    }\n\n    // Regenerate relationships with updated document content\n    await this.generateDocumentRelationships(document);\n  }\n\n  private async deleteDocumentRelationships(documentId: string): Promise<void> {\n    const relationships = await this.getDocumentRelationships(documentId);\n    for (const relationship of relationships) {\n      await this.relationshipRepository.delete(relationship.id);\n    }\n  }\n\n  private async deleteDocumentWorkflowState(documentId: string): Promise<void> {\n    const workflow = await this.getDocumentWorkflowState(documentId);\n    if (workflow) {\n      await this.workflowRepository.delete(workflow.id);\n    }\n  }\n\n  private async deleteSearchIndex(_documentId: string): Promise<void> {\n    // TODO: Implement search index deletion using vector DAL\n  }\n\n  // ==================== MISSING TEXT PROCESSING METHODS ====================\n\n  private tokenizeText(text: string): string[] {\n    // Simple tokenization - split on whitespace and punctuation\n    return text\n      .toLowerCase()\n      .replace(/[^\\w\\s]/g, ' ')\n      .split(/\\s+/)\n      .filter((token) => token.length > 2);\n  }\n\n  private calculateTermFrequency(term: string, docTerms: string[]): number {\n    const termCount = docTerms.filter((t) => t === term).length;\n    return docTerms.length > 0 ? termCount / docTerms.length : 0;\n  }\n\n  private calculateInverseDocumentFrequency(term: string, documents: BaseDocumentEntity[]): number {\n    const docsContainingTerm = documents.filter((doc) =>\n      `${doc.title} ${doc.content}`.toLowerCase().includes(term)\n    ).length;\n    return docsContainingTerm > 0 ? Math.log(documents.length / docsContainingTerm) : 0;\n  }\n\n  private expandTokensWithSynonyms(tokens: string[]): string[] {\n    // Production-ready semantic synonym expansion with comprehensive domain mapping\n    try {\n      const expanded = new Set(tokens);\n      \n      // Enhanced domain-specific synonym mapping with business context\n      const synonymMap: Record<string, string[]> = {\n        // User/stakeholder terms\n        user: ['customer', 'client', 'end-user', 'consumer', 'stakeholder', 'actor'],\n        customer: ['user', 'client', 'end-user', 'consumer', 'buyer', 'purchaser'],\n        stakeholder: ['user', 'client', 'participant', 'actor', 'interested-party'],\n        \n        // System/technical terms\n        system: ['platform', 'application', 'service', 'solution', 'framework', 'infrastructure'],\n        platform: ['system', 'framework', 'infrastructure', 'environment', 'architecture'],\n        application: ['system', 'software', 'program', 'solution', 'tool', 'app'],\n        service: ['system', 'component', 'module', 'utility', 'functionality'],\n        \n        // Feature/functionality terms\n        feature: ['functionality', 'capability', 'component', 'function', 'behavior', 'characteristic'],\n        functionality: ['feature', 'capability', 'function', 'behavior', 'operation'],\n        capability: ['feature', 'functionality', 'ability', 'capacity', 'function'],\n        component: ['module', 'element', 'part', 'unit', 'feature', 'building-block'],\n        \n        // Requirements/specification terms\n        requirement: ['specification', 'need', 'criteria', 'constraint', 'condition', 'rule'],\n        specification: ['requirement', 'definition', 'description', 'criteria', 'standard'],\n        criteria: ['requirement', 'condition', 'rule', 'standard', 'measure', 'metric'],\n        \n        // Process/workflow terms\n        process: ['workflow', 'procedure', 'method', 'approach', 'flow', 'sequence'],\n        workflow: ['process', 'procedure', 'flow', 'sequence', 'pipeline', 'chain'],\n        task: ['activity', 'action', 'step', 'operation', 'job', 'assignment'],\n        \n        // Data/information terms\n        data: ['information', 'content', 'details', 'facts', 'records', 'input'],\n        information: ['data', 'details', 'content', 'facts', 'knowledge', 'intelligence'],\n        content: ['data', 'information', 'material', 'text', 'details'],\n        \n        // Quality/testing terms\n        test: ['validation', 'verification', 'check', 'examination', 'assessment'],\n        validation: ['verification', 'confirmation', 'check', 'test', 'approval'],\n        quality: ['standard', 'grade', 'level', 'excellence', 'reliability'],\n        \n        // Management/coordination terms\n        manage: ['control', 'handle', 'coordinate', 'oversee', 'administer', 'govern'],\n        control: ['manage', 'regulate', 'govern', 'direct', 'supervise'],\n        coordinate: ['manage', 'organize', 'synchronize', 'align', 'orchestrate'],\n        \n        // Interface/interaction terms\n        interface: ['ui', 'gui', 'frontend', 'interaction', 'connection', 'boundary'],\n        ui: ['interface', 'gui', 'frontend', 'user-interface', 'display'],\n        api: ['interface', 'endpoint', 'service', 'connection', 'integration'],\n      };\n      \n      // Contextual synonym selection based on token frequency and co-occurrence\n      const tokenCounts = new Map<string, number>();\n      tokens.forEach(token => {\n        tokenCounts.set(token, (tokenCounts.get(token) || 0) + 1);\n      });\n      \n      for (const token of tokens) {\n        const lowerToken = token.toLowerCase();\n        \n        if (synonymMap[lowerToken]) {\n          // Add base synonyms\n          synonymMap[lowerToken].forEach(synonym => expanded.add(synonym));\n          \n          // Contextual expansion: if token appears frequently, add more related terms\n          const frequency = tokenCounts.get(token) || 0;\n          if (frequency > 1) {\n            // High-frequency terms get additional semantic expansion\n            this.getSemanticExpansion(lowerToken).forEach(term => expanded.add(term));\n          }\n        }\n        \n        // Handle compound terms and technical abbreviations\n        if (lowerToken.includes('-') || lowerToken.includes('_')) {\n          const parts = lowerToken.split(/[-_]/);\n          parts.forEach(part => {\n            if (synonymMap[part]) {\n              synonymMap[part].forEach(synonym => expanded.add(synonym));\n            }\n          });\n        }\n      }\n      \n      // Filter out very short terms that might be noise\n      const filtered = Array.from(expanded).filter(term => \n        term.length > 2 && !/^\\d+$/.test(term)\n      );\n      \n      logger.debug(`Expanded ${tokens.length} tokens to ${filtered.length} terms with semantic mapping`);\n      \n      return filtered;\n      \n    } catch (error) {\n      logger.error('Error in synonym expansion:', error);\n      // Fallback to original simple expansion\n      const synonymMap: Record<string, string[]> = {\n        user: ['customer', 'client', 'end-user'],\n        system: ['platform', 'application', 'service'],\n        feature: ['functionality', 'capability', 'component'],\n        requirement: ['specification', 'need', 'criteria'],\n      };\n      \n      const expanded = new Set(tokens);\n      for (const token of tokens) {\n        if (synonymMap[token]) {\n          synonymMap[token]?.forEach((synonym) => expanded.add(synonym));\n        }\n      }\n      return Array.from(expanded);\n    }\n  }\n  \n  /**\n   * Get additional semantic expansion for high-frequency terms\n   */\n  private getSemanticExpansion(term: string): string[] {\n    const semanticExpansions: Record<string, string[]> = {\n      user: ['persona', 'profile', 'account', 'member'],\n      system: ['ecosystem', 'architecture', 'stack', 'backend'],\n      feature: ['enhancement', 'improvement', 'addition', 'extension'],\n      requirement: ['business-rule', 'constraint', 'acceptance-criteria'],\n      process: ['methodology', 'framework', 'approach', 'strategy'],\n      data: ['dataset', 'payload', 'structure', 'model'],\n      interface: ['contract', 'protocol', 'specification', 'definition'],\n      quality: ['performance', 'reliability', 'maintainability', 'usability'],\n    };\n    \n    return semanticExpansions[term] || [];\n  }\n\n  private calculateJaccardSimilarity(tokens1: string[], tokens2: string[]): number {\n    const set1 = new Set(tokens1);\n    const set2 = new Set(tokens2);\n    const intersection = new Set([...set1].filter((x) => set2.has(x)));\n    const union = new Set([...set1, ...set2]);\n    return union.size > 0 ? intersection.size / union.size : 0;\n  }\n\n  private calculateConceptualSimilarity(text1: string, text2: string): number {\n    // Simple conceptual similarity based on common phrases\n    const phrases1 = this.extractPhrases(text1);\n    const phrases2 = this.extractPhrases(text2);\n    return this.calculateJaccardSimilarity(phrases1, phrases2);\n  }\n\n  private extractPhrases(text: string): string[] {\n    // Extract 2-3 word phrases\n    const words = this.tokenizeText(text);\n    const phrases: string[] = [];\n\n    for (let i = 0; i < words.length - 1; i++) {\n      phrases.push(`${words[i]} ${words[i + 1]}`);\n      if (i < words.length - 2) {\n        phrases.push(`${words[i]} ${words[i + 1]} ${words[i + 2]}`);\n      }\n    }\n\n    return phrases;\n  }\n}\n\n// Export a singleton instance\n// ==================== WORKFLOW DEFINITIONS ====================\n\ninterface WorkflowAutomationRule {\n  name: string;\n  condition: {\n    type:\n      | 'status_change'\n      | 'stage_duration'\n      | 'document_type'\n      | 'priority_level'\n      | 'completion_percentage'\n      | 'has_relationships'\n      | 'custom_field';\n    value: any;\n  };\n  action: {\n    type:\n      | 'advance_stage'\n      | 'create_document'\n      | 'update_status'\n      | 'assign_reviewer'\n      | 'generate_artifacts'\n      | 'send_notification'\n      | 'update_relationships';\n    value: any;\n  };\n}\n\nabstract class WorkflowDefinition {\n  abstract name: string;\n  abstract stages: string[];\n  abstract autoTransitions: boolean;\n  abstract rules: WorkflowAutomationRule[];\n\n  abstract getNextStages(currentStage: string): string[];\n  abstract canTransition(fromStage: string, toStage: string): boolean;\n  abstract requiresApproval(stage: string): boolean;\n  abstract getAutomationRules(stage: string): WorkflowAutomationRule[];\n}\n\nclass PRDWorkflowDefinition extends WorkflowDefinition {\n  name = 'prd_workflow';\n  stages = ['draft', 'review', 'approved', 'implementation', 'completed'];\n  autoTransitions = true as boolean;\n\n  rules: WorkflowAutomationRule[] = [\n    {\n      name: 'auto_create_epics_on_approval',\n      condition: { type: 'status_change', value: 'approved' },\n      action: {\n        type: 'create_document',\n        value: {\n          documentType: 'epic' as DocumentType,\n          title: undefined, // Will be auto-generated\n          assignTo: undefined, // Inherit from PRD\n          priority: 'high',\n          status: 'draft',\n          inheritKeywords: true,\n        },\n      },\n    },\n    {\n      name: 'generate_implementation_artifacts',\n      condition: { type: 'status_change', value: 'approved' },\n      action: {\n        type: 'generate_artifacts',\n        value: ['summary_report', 'checklist', 'stakeholder_matrix'],\n      },\n    },\n  ];\n\n  getNextStages(currentStage: string): string[] {\n    const stageMap: Record<string, string[]> = {\n      draft: ['review'],\n      review: ['approved', 'draft'],\n      approved: ['implementation'],\n      implementation: ['completed'],\n      completed: [],\n    };\n    return stageMap[currentStage] || [];\n  }\n\n  canTransition(fromStage: string, toStage: string): boolean {\n    const allowedTransitions = this.getNextStages(fromStage);\n    return allowedTransitions.includes(toStage);\n  }\n\n  requiresApproval(stage: string): boolean {\n    return ['approved', 'completed'].includes(stage);\n  }\n\n  getAutomationRules(stage: string): WorkflowAutomationRule[] {\n    return this.rules.filter(\n      (rule) =>\n        rule.condition.type === 'status_change' &&\n        (stage === 'approved' || stage === 'implementation')\n    );\n  }\n}\n\nclass FeatureWorkflowDefinition extends WorkflowDefinition {\n  name = 'feature_workflow';\n  stages = ['draft', 'approved', 'implementation', 'testing', 'completed'];\n  autoTransitions = true as boolean;\n\n  rules: WorkflowAutomationRule[] = [\n    {\n      name: 'auto_create_tasks_on_approval',\n      condition: { type: 'status_change', value: 'approved' },\n      action: {\n        type: 'create_document',\n        value: {\n          documentType: 'task' as DocumentType,\n          priority: 'medium',\n          status: 'todo',\n          inheritKeywords: true,\n        },\n      },\n    },\n  ];\n\n  getNextStages(currentStage: string): string[] {\n    const stageMap: Record<string, string[]> = {\n      draft: ['approved'],\n      approved: ['implementation'],\n      implementation: ['testing'],\n      testing: ['completed', 'implementation'],\n      completed: [],\n    };\n    return stageMap[currentStage] || [];\n  }\n\n  canTransition(fromStage: string, toStage: string): boolean {\n    return this.getNextStages(fromStage).includes(toStage);\n  }\n\n  requiresApproval(stage: string): boolean {\n    return ['approved', 'completed'].includes(stage);\n  }\n\n  getAutomationRules(stage: string): WorkflowAutomationRule[] {\n    return this.rules.filter((_rule) => stage === 'approved');\n  }\n}\n\n// Additional workflow definitions\nclass VisionWorkflowDefinition extends WorkflowDefinition {\n  name = 'vision_workflow';\n  stages = ['draft', 'stakeholder_review', 'approved', 'active'];\n  autoTransitions = false;\n  rules: WorkflowAutomationRule[] = [];\n\n  getNextStages(currentStage: string): string[] {\n    const stageMap: Record<string, string[]> = {\n      draft: ['stakeholder_review'],\n      stakeholder_review: ['approved', 'draft'],\n      approved: ['active'],\n      active: [],\n    };\n    return stageMap[currentStage] || [];\n  }\n\n  canTransition(fromStage: string, toStage: string): boolean {\n    return this.getNextStages(fromStage).includes(toStage);\n  }\n\n  requiresApproval(stage: string): boolean {\n    return ['approved', 'active'].includes(stage);\n  }\n\n  getAutomationRules(): WorkflowAutomationRule[] {\n    return [];\n  }\n}\n\nclass ADRWorkflowDefinition extends WorkflowDefinition {\n  name = 'adr_workflow';\n  stages = ['proposed', 'discussion', 'decided', 'implemented'];\n  autoTransitions = false;\n  rules: WorkflowAutomationRule[] = [];\n\n  getNextStages(currentStage: string): string[] {\n    const stageMap: Record<string, string[]> = {\n      proposed: ['discussion', 'decided'],\n      discussion: ['decided', 'proposed'],\n      decided: ['implemented'],\n      implemented: [],\n    };\n    return stageMap[currentStage] || [];\n  }\n\n  canTransition(fromStage: string, toStage: string): boolean {\n    return this.getNextStages(fromStage).includes(toStage);\n  }\n\n  requiresApproval(stage: string): boolean {\n    return ['decided', 'implemented'].includes(stage);\n  }\n\n  getAutomationRules(): WorkflowAutomationRule[] {\n    return [];\n  }\n}\n\nclass EpicWorkflowDefinition extends WorkflowDefinition {\n  name = 'epic_workflow';\n  stages = ['draft', 'groomed', 'in_progress', 'completed'];\n  autoTransitions = true as boolean;\n\n  rules: WorkflowAutomationRule[] = [\n    {\n      name: 'auto_create_features_on_groom',\n      condition: { type: 'status_change', value: 'groomed' },\n      action: {\n        type: 'create_document',\n        value: {\n          documentType: 'feature' as DocumentType,\n          priority: 'medium',\n          status: 'draft',\n          inheritKeywords: true,\n        },\n      },\n    },\n  ];\n\n  getNextStages(currentStage: string): string[] {\n    const stageMap: Record<string, string[]> = {\n      draft: ['groomed'],\n      groomed: ['in_progress'],\n      in_progress: ['completed'],\n      completed: [],\n    };\n    return stageMap[currentStage] || [];\n  }\n\n  canTransition(fromStage: string, toStage: string): boolean {\n    return this.getNextStages(fromStage).includes(toStage);\n  }\n\n  requiresApproval(stage: string): boolean {\n    return ['groomed', 'completed'].includes(stage);\n  }\n\n  getAutomationRules(stage: string): WorkflowAutomationRule[] {\n    return this.rules.filter((_rule) => stage === 'groomed');\n  }\n}\n\nclass TaskWorkflowDefinition extends WorkflowDefinition {\n  name = 'task_workflow';\n  stages = ['todo', 'in_progress', 'review', 'done'];\n  autoTransitions = false;\n  rules: WorkflowAutomationRule[] = [];\n\n  getNextStages(currentStage: string): string[] {\n    const stageMap: Record<string, string[]> = {\n      todo: ['in_progress'],\n      in_progress: ['review', 'done'],\n      review: ['done', 'in_progress'],\n      done: [],\n    };\n    return stageMap[currentStage] || [];\n  }\n\n  canTransition(fromStage: string, toStage: string): boolean {\n    return this.getNextStages(fromStage).includes(toStage);\n  }\n\n  requiresApproval(stage: string): boolean {\n    return ['done'].includes(stage);\n  }\n\n  getAutomationRules(): WorkflowAutomationRule[] {\n    return [];\n  }\n}\n\nclass DefaultWorkflowDefinition extends WorkflowDefinition {\n  name = 'default_workflow';\n  stages = ['draft', 'review', 'approved', 'completed'];\n  autoTransitions = false;\n  rules: WorkflowAutomationRule[] = [];\n\n  getNextStages(currentStage: string): string[] {\n    const stageMap: Record<string, string[]> = {\n      draft: ['review'],\n      review: ['approved', 'draft'],\n      approved: ['completed'],\n      completed: [],\n    };\n    return stageMap[currentStage] || [];\n  }\n\n  canTransition(fromStage: string, toStage: string): boolean {\n    return this.getNextStages(fromStage).includes(toStage);\n  }\n\n  requiresApproval(stage: string): boolean {\n    return ['approved', 'completed'].includes(stage);\n  }\n\n  getAutomationRules(): WorkflowAutomationRule[] {\n    return [];\n  }\n}\n\nexport const documentManager = new DocumentManager();\nexport default documentManager;\n"],
  "mappings": "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",
  "names": ["crypto"]
}
