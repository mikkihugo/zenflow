{
  "version": 3,
  "sources": ["../../src/database/dao/memory.dao.ts"],
  "sourcesContent": ["/**\n * Memory Repository Implementation.\n *\n * In-memory repository with TTL support, caching capabilities,\n * and memory management for fast data access.\n */\n/**\n * @file Database layer: memory.dao.\n */\n\nimport { BaseDao } from '../base.dao.ts';\nimport type { DatabaseAdapter, ILogger } from '../core/interfaces/base-interfaces';\nimport type { CustomQuery, IMemoryRepository, MemoryStats } from '../interfaces.ts';\n\n/**\n * In-memory cache entry.\n *\n * @example\n */\ninterface CacheEntry<T> {\n  value: T;\n  createdAt: Date;\n  accessedAt: Date;\n  ttl?: number;\n  expiresAt?: Date;\n}\n\n/**\n * Memory repository implementation with caching and TTL support.\n *\n * @template T The entity type this repository manages.\n * @example\n */\nexport class MemoryDao<T> extends BaseDao<T> implements IMemoryRepository<T> {\n  private memoryStore = new Map<string, CacheEntry<T>>();\n  private keyStore = new Map<string, CacheEntry<any>>();\n  private ttlTimers = new Map<string, NodeJS.Timeout>();\n  private accessCount = 0;\n  private hitCount = 0;\n  private missCount = 0;\n  private evictionCount = 0;\n\n  private readonly maxSize: number;\n  private readonly defaultTTL: number;\n  private readonly cleanupInterval: number;\n  private cleanupTimer?: NodeJS.Timeout;\n\n  constructor(\n    adapter: DatabaseAdapter,\n    logger: ILogger,\n    tableName: string,\n    entitySchema?: Record<string, any>,\n    options?: {\n      maxSize?: number;\n      ttlDefault?: number;\n      cleanupInterval?: number;\n    }\n  ) {\n    super(adapter, logger, tableName, entitySchema);\n\n    this.maxSize = options?.maxSize || 1000;\n    this.defaultTTL = options?.ttlDefault || 3600; // 1 hour\n    this.cleanupInterval = options?.cleanupInterval || 60000; // 1 minute\n\n    this.startCleanupTimer();\n  }\n\n  /**\n   * Set TTL (time to live) for an entity.\n   *\n   * @param id\n   * @param ttlSeconds\n   */\n  async setTTL(id: string | number, ttlSeconds: number): Promise<void> {\n    this.logger.debug(`Setting TTL for entity ${id}: ${ttlSeconds} seconds`);\n\n    const key = this.getEntityKey(id);\n    const entry = this.memoryStore.get(key);\n\n    if (!entry) {\n      throw new Error(`Entity with ID ${id} not found in memory`);\n    }\n\n    const oldTimer = this.ttlTimers.get(key);\n    if (oldTimer) {\n      clearTimeout(oldTimer);\n    }\n\n    entry.ttl = ttlSeconds;\n    entry.expiresAt = new Date(Date.now() + ttlSeconds * 1000);\n\n    // Set expiration timer\n    const timer = setTimeout(() => {\n      this.expireEntity(key);\n    }, ttlSeconds * 1000);\n\n    this.ttlTimers.set(key, timer);\n    this.logger.debug(`TTL set for entity ${id}, expires at: ${entry.expiresAt}`);\n  }\n\n  /**\n   * Get TTL for an entity.\n   *\n   * @param id\n   */\n  async getTTL(id: string | number): Promise<number | null> {\n    const key = this.getEntityKey(id);\n    const entry = this.memoryStore.get(key);\n\n    if (!entry || !entry.expiresAt) {\n      return null;\n    }\n\n    const remainingMs = entry.expiresAt.getTime() - Date.now();\n    return remainingMs > 0 ? Math.ceil(remainingMs / 1000) : 0;\n  }\n\n  /**\n   * Cache entity with optional TTL.\n   *\n   * @param key\n   * @param value\n   * @param ttlSeconds\n   */\n  async cache(key: string, value: T, ttlSeconds?: number): Promise<void> {\n    this.logger.debug(`Caching value with key: ${key}`, { ttlSeconds });\n\n    // Check if we need to evict entries to make space\n    await this.ensureSpace();\n\n    const entry: CacheEntry<T> = {\n      value,\n      createdAt: new Date(),\n      accessedAt: new Date(),\n      ...(ttlSeconds !== undefined && { ttl: ttlSeconds }),\n      ...(ttlSeconds && { expiresAt: new Date(Date.now() + ttlSeconds * 1000) }),\n    };\n\n    this.keyStore.set(key, entry);\n\n    // Set expiration timer if TTL is specified\n    if (ttlSeconds) {\n      const timer = setTimeout(() => {\n        this.expireKey(key);\n      }, ttlSeconds * 1000);\n\n      this.ttlTimers.set(key, timer);\n    }\n\n    this.logger.debug(`Cached value with key: ${key}`);\n  }\n\n  /**\n   * Get cached entity.\n   *\n   * @param key\n   */\n  async getCached(key: string): Promise<T | null> {\n    this.accessCount++;\n\n    const entry = this.keyStore.get(key);\n\n    if (!entry) {\n      this.missCount++;\n      return null;\n    }\n\n    // Check if entry has expired\n    if (entry.expiresAt && entry.expiresAt <= new Date()) {\n      this.expireKey(key);\n      this.missCount++;\n      return null;\n    }\n\n    // Update access time\n    entry.accessedAt = new Date();\n    this.hitCount++;\n\n    this.logger.debug(`Cache hit for key: ${key}`);\n    return entry.value;\n  }\n\n  /**\n   * Clear cache.\n   *\n   * @param pattern\n   */\n  async clearCache(pattern?: string): Promise<number> {\n    let clearedCount = 0;\n\n    if (!pattern) {\n      // Clear all cache entries\n      clearedCount = this.keyStore.size;\n      this.keyStore.clear();\n\n      // Clear all TTL timers\n      for (const timer of this.ttlTimers.values()) {\n        clearTimeout(timer);\n      }\n      this.ttlTimers.clear();\n\n      this.logger.debug(`Cleared entire cache: ${clearedCount} entries`);\n    } else {\n      // Clear entries matching pattern\n      const regex = new RegExp(pattern);\n      const keysToDelete: string[] = [];\n\n      for (const key of this.keyStore.keys()) {\n        if (regex.test(key)) {\n          keysToDelete.push(key);\n        }\n      }\n\n      for (const key of keysToDelete) {\n        this.keyStore.delete(key);\n        const timer = this.ttlTimers.get(key);\n        if (timer) {\n          clearTimeout(timer);\n          this.ttlTimers.delete(key);\n        }\n        clearedCount++;\n      }\n\n      this.logger.debug(`Cleared cache with pattern '${pattern}': ${clearedCount} entries`);\n    }\n\n    return clearedCount;\n  }\n\n  /**\n   * Get memory usage statistics.\n   */\n  async getMemoryStats(): Promise<MemoryStats> {\n    const totalEntries = this.memoryStore.size + this.keyStore.size;\n    const estimatedMemoryUsage = this.estimateMemoryUsage();\n\n    return {\n      totalMemory: estimatedMemoryUsage,\n      usedMemory: estimatedMemoryUsage,\n      freeMemory: Math.max(0, this.maxSize - totalEntries) * 1024, // Rough estimate\n      hitRate: this.accessCount > 0 ? (this.hitCount / this.accessCount) * 100 : 0,\n      missRate: this.accessCount > 0 ? (this.missCount / this.accessCount) * 100 : 0,\n      evictions: this.evictionCount,\n    };\n  }\n\n  /**\n   * Override base repository methods for memory-specific implementations.\n   */\n\n  override async findById(id: string | number): Promise<T | null> {\n    this.accessCount++;\n\n    const key = this.getEntityKey(id);\n    const entry = this.memoryStore.get(key);\n\n    if (!entry) {\n      this.missCount++;\n      // Fallback to adapter if not in memory\n      const result = await super.findById(id);\n      if (result) {\n        await this.storeInMemory(id, result);\n      }\n      return result;\n    }\n\n    // Check if entry has expired\n    if (entry.expiresAt && entry.expiresAt <= new Date()) {\n      this.expireEntity(key);\n      this.missCount++;\n      // Fallback to adapter\n      const result = await super.findById(id);\n      if (result) {\n        await this.storeInMemory(id, result);\n      }\n      return result;\n    }\n\n    // Update access time\n    entry.accessedAt = new Date();\n    this.hitCount++;\n\n    this.logger.debug(`Memory hit for entity: ${id}`);\n    return entry.value;\n  }\n\n  override async create(entity: Omit<T, 'id'>): Promise<T> {\n    // Create in underlying storage first\n    const created = await super.create(entity);\n\n    // Store in memory with default TTL\n    await this.storeInMemory((created as any).id, created, this.defaultTTL);\n\n    return created;\n  }\n\n  override async update(id: string | number, updates: Partial<T>): Promise<T> {\n    // Update in underlying storage first\n    const updated = await super.update(id, updates);\n\n    // Update memory cache\n    await this.storeInMemory(id, updated, this.defaultTTL);\n\n    return updated;\n  }\n\n  override async delete(id: string | number): Promise<boolean> {\n    // Delete from underlying storage first\n    const deleted = await super.delete(id);\n\n    if (deleted) {\n      // Remove from memory\n      const key = this.getEntityKey(id);\n      this.memoryStore.delete(key);\n\n      const timer = this.ttlTimers.get(key);\n      if (timer) {\n        clearTimeout(timer);\n        this.ttlTimers.delete(key);\n      }\n    }\n\n    return deleted;\n  }\n\n  protected mapRowToEntity(row: any): T {\n    return row as T;\n  }\n\n  protected mapEntityToRow(entity: Partial<T>): Record<string, any> {\n    return entity as Record<string, any>;\n  }\n\n  /**\n   * Execute custom query - override to handle memory-specific queries.\n   *\n   * @param customQuery\n   */\n  override async executeCustomQuery<R = any>(customQuery: CustomQuery): Promise<R> {\n    if (customQuery.type === 'memory') {\n      const query = customQuery.query as any;\n\n      if (query.operation === 'get_stats') {\n        const stats = await this.getMemoryStats();\n        return stats as R;\n      }\n\n      if (query.operation === 'clear_cache') {\n        const cleared = await this.clearCache(query.pattern);\n        return { cleared } as R;\n      }\n\n      if (query.operation === 'set_ttl') {\n        await this.setTTL(query.id, query.ttl);\n        return { success: true } as R;\n      }\n    }\n\n    return super.executeCustomQuery<R>(customQuery);\n  }\n\n  /**\n   * Private helper methods.\n   */\n\n  private getEntityKey(id: string | number): string {\n    return `entity:${this.tableName}:${id}`;\n  }\n\n  private async storeInMemory(id: string | number, entity: T, ttlSeconds?: number): Promise<void> {\n    await this.ensureSpace();\n\n    const key = this.getEntityKey(id);\n    const ttl = ttlSeconds || this.defaultTTL;\n\n    const entry: CacheEntry<T> = {\n      value: entity,\n      createdAt: new Date(),\n      accessedAt: new Date(),\n      ttl,\n      expiresAt: new Date(Date.now() + ttl * 1000),\n    };\n\n    this.memoryStore.set(key, entry);\n\n    // Set expiration timer\n    const timer = setTimeout(() => {\n      this.expireEntity(key);\n    }, ttl * 1000);\n\n    this.ttlTimers.set(key, timer);\n  }\n\n  private async ensureSpace(): Promise<void> {\n    const totalEntries = this.memoryStore.size + this.keyStore.size;\n\n    if (totalEntries >= this.maxSize) {\n      // Evict least recently used entries\n      await this.evictLRU();\n    }\n  }\n\n  private async evictLRU(): Promise<void> {\n    const allEntries: Array<{ key: string; entry: CacheEntry<any>; store: 'memory' | 'key' }> = [];\n\n    // Collect all entries with their access times\n    for (const [key, entry] of this.memoryStore.entries()) {\n      allEntries.push({ key, entry, store: 'memory' });\n    }\n\n    for (const [key, entry] of this.keyStore.entries()) {\n      allEntries.push({ key, entry, store: 'key' });\n    }\n\n    // Sort by access time (oldest first)\n    allEntries.sort((a, b) => a.entry.accessedAt.getTime() - b.entry.accessedAt.getTime());\n\n    // Evict 25% of entries\n    const evictCount = Math.ceil(allEntries.length * 0.25);\n\n    for (let i = 0; i < evictCount && i < allEntries.length; i++) {\n      const entry = allEntries[i];\n      if (!entry) continue;\n      const { key, store } = entry;\n\n      if (store === 'memory') {\n        this.memoryStore.delete(key);\n      } else {\n        this.keyStore.delete(key);\n      }\n\n      const timer = this.ttlTimers.get(key);\n      if (timer) {\n        clearTimeout(timer);\n        this.ttlTimers.delete(key);\n      }\n\n      this.evictionCount++;\n    }\n\n    this.logger.debug(`Evicted ${evictCount} LRU entries`);\n  }\n\n  private expireEntity(key: string): void {\n    this.memoryStore.delete(key);\n    const timer = this.ttlTimers.get(key);\n    if (timer) {\n      clearTimeout(timer);\n      this.ttlTimers.delete(key);\n    }\n    this.logger.debug(`Expired entity: ${key}`);\n  }\n\n  private expireKey(key: string): void {\n    this.keyStore.delete(key);\n    const timer = this.ttlTimers.get(key);\n    if (timer) {\n      clearTimeout(timer);\n      this.ttlTimers.delete(key);\n    }\n    this.logger.debug(`Expired cache key: ${key}`);\n  }\n\n  private startCleanupTimer(): void {\n    this.cleanupTimer = setInterval(() => {\n      this.performCleanup();\n    }, this.cleanupInterval);\n  }\n\n  private performCleanup(): void {\n    const now = new Date();\n    const expiredKeys: string[] = [];\n\n    // Check memory store for expired entries\n    for (const [key, entry] of this.memoryStore.entries()) {\n      if (entry.expiresAt && entry.expiresAt <= now) {\n        expiredKeys.push(key);\n      }\n    }\n\n    // Check key store for expired entries\n    for (const [key, entry] of this.keyStore.entries()) {\n      if (entry.expiresAt && entry.expiresAt <= now) {\n        expiredKeys.push(key);\n      }\n    }\n\n    // Remove expired entries\n    for (const key of expiredKeys) {\n      this.memoryStore.delete(key);\n      this.keyStore.delete(key);\n\n      const timer = this.ttlTimers.get(key);\n      if (timer) {\n        clearTimeout(timer);\n        this.ttlTimers.delete(key);\n      }\n    }\n\n    if (expiredKeys.length > 0) {\n      this.logger.debug(`Cleaned up ${expiredKeys.length} expired entries`);\n    }\n  }\n\n  private estimateMemoryUsage(): number {\n    // Rough estimation of memory usage in bytes\n    let totalSize = 0;\n\n    for (const entry of this.memoryStore.values()) {\n      totalSize += JSON.stringify(entry.value).length * 2; // UTF-16 encoding\n      totalSize += 200; // Overhead for dates and metadata\n    }\n\n    for (const entry of this.keyStore.values()) {\n      totalSize += JSON.stringify(entry.value).length * 2;\n      totalSize += 200;\n    }\n\n    return totalSize;\n  }\n\n  /**\n   * Cleanup method to be called on shutdown.\n   */\n  async shutdown(): Promise<void> {\n    if (this.cleanupTimer) {\n      clearInterval(this.cleanupTimer);\n    }\n\n    // Clear all TTL timers\n    for (const timer of this.ttlTimers.values()) {\n      clearTimeout(timer);\n    }\n\n    this.memoryStore.clear();\n    this.keyStore.clear();\n    this.ttlTimers.clear();\n\n    this.logger.debug('Memory repository shutdown completed');\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
