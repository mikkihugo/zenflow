{
  "version": 3,
  "sources": ["../../src/coordination/collective-fact-integration.ts"],
  "sourcesContent": ["/**\n * @file Collective-Level FACT Integration\n * Centralized FACT (Fast Augmented Context Tools) system at the Collective level.\n * Provides universal knowledge to all swarms - facts about npm packages, repos, etc.\n *\n * FACT is CENTRAL - not swarm-specific. All swarms access the same FACT knowledge.\n */\n\nimport { EventEmitter } from 'node:events';\nimport { getLogger } from '../config/logging-config.ts';\nimport type {\n  FACTKnowledgeEntry,\n  FACTSearchQuery,\n  FACTStorageStats,\n} from '../knowledge/types/fact-types.ts';\nimport type { CollectiveSwarmCoordinatorInterface } from './shared-types.ts';\n\n// Type alias for backward compatibility\ntype CollectiveSwarmCoordinator = CollectiveSwarmCoordinatorInterface;\n\nimport type { CollectiveFACTConfig, UniversalFact } from './collective-types.ts';\n\n// import { FACTExternalOrchestrator } from './mcp/tools/fact-external-integration'; // TODO: Migrate to unified MCP\n\nconst logger = getLogger('Collective-FACT');\n\n/**\n * Temporary interface for factOrchestrator until unified MCP migration is complete.\n *\n * @example\n */\ninterface IFactOrchestrator {\n  gatherKnowledge(\n    query: string,\n    options: {\n      sources: string[];\n      maxResults?: number;\n      timeout?: number;\n    }\n  ): Promise<{\n    knowledge?: Array<{\n      content?: string;\n      summary?: string;\n      text?: string;\n      title?: string;\n      source?: string;\n      url?: string;\n      relevance?: number;\n      confidence?: number;\n    }>;\n  }>;\n}\n\n/**\n * Centralized FACT system at Collective level.\n * Manages universal facts accessible by all swarms.\n *\n * @example\n */\nexport class CollectiveFACTSystem extends EventEmitter {\n  private factOrchestrator?: IFactOrchestrator; // TODO: Migrate to unified MCP\n  private universalFacts: Map<string, UniversalFact> = new Map();\n  private refreshTimers: Map<string, NodeJS.Timeout> = new Map();\n  private collectiveCoordinator: CollectiveSwarmCoordinator | undefined;\n  private config: CollectiveFACTConfig;\n\n  constructor(config: CollectiveFACTConfig = {}) {\n    super();\n    this.config = {\n      enableCache: true,\n      cacheSize: 10000, // Large cache for universal facts\n      knowledgeSources: ['context7', 'deepwiki', 'gitmcp', 'semgrep'],\n      autoRefreshInterval: 3600000, // 1 hour\n      ...config,\n    };\n\n    //     this.factOrchestrator = new FACTExternalOrchestrator({\n    //       enableCache: this.config.enableCache,\n    //       cacheSize: this.config.cacheSize,\n    //     });\n    //   }\n    //\n  }\n\n  /**\n   * Initialize Collective FACT system.\n   *\n   * @param collectiveCoordinator\n   */\n  async initialize(collectiveCoordinator?: CollectiveSwarmCoordinator): Promise<void> {\n    logger.info('Initializing Collective FACT System...');\n\n    this.collectiveCoordinator = collectiveCoordinator;\n\n    // Initialize FACT orchestrator\n    // // await this.factOrchestrator.initialize(); // TODO: Migrate to unified MCP\n\n    // Pre-load common facts\n    await this.preloadCommonFacts();\n\n    // Set up auto-refresh for important facts\n    this.setupAutoRefresh();\n\n    // Announce FACT availability to all swarms\n    if (this.collectiveCoordinator) {\n      this.collectiveCoordinator.emit('fact-system-ready', {\n        totalFacts: this.universalFacts.size,\n        sources: this.config.knowledgeSources,\n      });\n    }\n\n    this.emit('initialized');\n    logger.info(`Collective FACT System initialized with ${this.universalFacts.size} pre-loaded facts`);\n  }\n\n  /**\n   * Get universal fact - accessible by any swarm.\n   *\n   * @param type\n   * @param subject\n   * @param swarmId\n   */\n  async getFact(\n    type: UniversalFact['type'],\n    subject: string,\n    swarmId?: string\n  ): Promise<UniversalFact | null> {\n    const factKey = `${type}:${subject}`;\n\n    // Check if we already have this fact\n    const fact = this.universalFacts.get(factKey);\n\n    if (fact) {\n      // Update access tracking\n      if (fact.accessCount !== undefined) {\n        fact.accessCount++;\n      }\n      if (swarmId && fact.swarmAccess) {\n        fact.swarmAccess.add(swarmId);\n      }\n\n      // Check if fact is still fresh\n      if (this.isFactFresh(fact)) {\n        logger.debug(`Returning cached fact: ${factKey}`);\n        return fact;\n      }\n    }\n\n    // Gather fresh fact from external sources\n    logger.info(`Gathering fresh fact: ${factKey}`);\n    const freshFact = await this.gatherFact(type, subject);\n\n    if (freshFact) {\n      // Store in universal facts\n      this.universalFacts.set(factKey, freshFact);\n\n      // Track swarm access\n      if (swarmId && freshFact.swarmAccess) {\n        freshFact.swarmAccess.add(swarmId);\n      }\n\n      // Emit event for swarms to know about new fact\n      this.emit('fact-updated', { type, subject, fact: freshFact });\n\n      return freshFact;\n    }\n\n    return null;\n  }\n\n  /**\n   * Store a fact in the universal knowledge base.\n   * Implements the required method from HiveFACTSystemInterface.\n   *\n   * @param fact - The fact to store\n   */\n  async storeFact(fact: UniversalFact): Promise<void> {\n    const factKey = `${fact.type}:${fact.subject}`;\n\n    // Ensure fact has required metadata\n    const storedFact: UniversalFact = {\n      ...fact,\n      timestamp: fact.timestamp || Date.now(),\n      accessCount: fact.accessCount || 0,\n      swarmAccess: fact.swarmAccess || new Set(),\n      freshness: fact.freshness || 'fresh',\n    };\n\n    // Store in local cache\n    this.universalFacts.set(factKey, storedFact);\n\n    // Emit update event for coordination\n    this.emit('factStored', storedFact);\n\n    logger.debug(`Stored fact: ${factKey}`);\n  }\n\n  /**\n   * Search for facts across all knowledge.\n   * Returns compatible FACTKnowledgeEntry format for interface compliance.\n   *\n   * @param query\n   */\n  async searchFacts(query: FACTSearchQuery): Promise<FACTKnowledgeEntry[]> {\n    const results: UniversalFact[] = [];\n\n    // Search in cached facts first\n    for (const [_key, fact] of this.universalFacts) {\n      if (this.matchesQuery(fact, query)) {\n        results.push(fact);\n      }\n    }\n\n    // If not enough results, query external sources\n    if (results.length < (query.limit || 10)) {\n      const externalResults = await this.searchExternalFacts(query);\n      results.push(...externalResults);\n    }\n\n    // Sort by relevance and limit\n    const sortedResults = results\n      ?.sort((a, b) => (b.metadata?.confidence || 0) - (a.metadata?.confidence || 0))\n      .slice(0, query.limit || 10);\n\n    // Convert to FACTKnowledgeEntry format\n    return sortedResults.map((fact) => this.convertToFACTKnowledgeEntry(fact, query));\n  }\n\n  /**\n   * Internal method to search facts returning UniversalFact format.\n   */\n  async searchFactsInternal(query: FACTSearchQuery): Promise<UniversalFact[]> {\n    const results: UniversalFact[] = [];\n\n    // Search in cached facts first\n    for (const [_key, fact] of this.universalFacts) {\n      if (this.matchesQuery(fact, query)) {\n        results.push(fact);\n      }\n    }\n\n    // If not enough results, query external sources\n    if (results.length < (query.limit || 10)) {\n      const externalResults = await this.searchExternalFacts(query);\n      results.push(...externalResults);\n    }\n\n    // Sort by relevance and limit\n    return results\n      ?.sort((a, b) => (b.metadata?.confidence || 0) - (a.metadata?.confidence || 0))\n      .slice(0, query.limit || 10);\n  }\n\n  /**\n   * Get facts for NPM package.\n   *\n   * @param packageName\n   * @param version\n   */\n  async getNPMPackageFacts(packageName: string, version?: string): Promise<UniversalFact> {\n    const subject = version ? `${packageName}@${version}` : packageName;\n    const fact = await this.getFact('npm-package', subject);\n\n    if (!fact) {\n      throw new Error(`Could not gather facts for npm package: ${subject}`);\n    }\n\n    return fact;\n  }\n\n  /**\n   * Get facts for GitHub repository.\n   *\n   * @param owner\n   * @param repo\n   */\n  async getGitHubRepoFacts(owner: string, repo: string): Promise<UniversalFact> {\n    const subject = `github.com/${owner}/${repo}`;\n    const fact = await this.getFact('github-repo', subject);\n\n    if (!fact) {\n      throw new Error(`Could not gather facts for GitHub repo: ${subject}`);\n    }\n\n    return fact;\n  }\n\n  /**\n   * Get API documentation facts.\n   *\n   * @param api\n   * @param endpoint\n   */\n  async getAPIDocsFacts(api: string, endpoint?: string): Promise<UniversalFact> {\n    const subject = endpoint ? `${api}/${endpoint}` : api;\n    const fact = await this.getFact('api-docs', subject);\n\n    if (!fact) {\n      throw new Error(`Could not gather API documentation for: ${subject}`);\n    }\n\n    return fact;\n  }\n\n  /**\n   * Get security advisory facts.\n   *\n   * @param cve\n   */\n  async getSecurityAdvisoryFacts(cve: string): Promise<UniversalFact> {\n    const fact = await this.getFact('security-advisory', cve);\n\n    if (!fact) {\n      throw new Error(`Could not gather security advisory for: ${cve}`);\n    }\n\n    return fact;\n  }\n\n  /**\n   * Gather fact from external sources.\n   *\n   * @param type\n   * @param subject\n   */\n  private async gatherFact(\n    type: UniversalFact['type'],\n    subject: string\n  ): Promise<UniversalFact | null> {\n    try {\n      // Determine query based on fact type\n      // const query = this.buildQueryForFactType(type, subject);\n\n      // Use FACT orchestrator to gather from external MCPs\n      // const result = await this.factOrchestrator.gatherKnowledge(query, {\n      //   sources: this.getSourcesForFactType(type),\n      //   priority: 'high',\n      //   useCache: true,\n      // });\n      const result = {\n        consolidatedKnowledge: '',\n        sources: [],\n      }; // TODO: Implement with unified MCP\n\n      // Convert to universal fact\n      const fact: UniversalFact = {\n        id: `${type}:${subject}:${Date.now()}`,\n        type,\n        category: 'knowledge', // Add required category field\n        subject,\n        content: {\n          summary: `Information about ${subject}`,\n          details: result?.consolidatedKnowledge || 'No details available',\n        },\n        source:\n          Array.isArray(result?.sources) && result?.sources.length > 0\n            ? result?.sources?.join(',')\n            : 'unknown',\n        confidence: this.calculateConfidence(result),\n        timestamp: Date.now(),\n        metadata: {\n          source:\n            Array.isArray(result?.sources) && result?.sources.length > 0\n              ? result?.sources?.join(',')\n              : 'unknown',\n          timestamp: Date.now(),\n          confidence: this.calculateConfidence(result),\n          ttl: this.getTTLForFactType(type),\n        },\n        accessCount: 1,\n        swarmAccess: new Set(),\n      };\n\n      return fact;\n    } catch (error) {\n      logger.error(`Failed to gather fact for ${type}:${subject}:`, error);\n      return null;\n    }\n  }\n\n  /**\n   * Build query based on fact type.\n   * Xxx NEEDS_HUMAN: Currently unused - will be used when FACT orchestrator is implemented..\n   *\n   * @param type\n   * @param subject\n   */\n  private buildQueryForFactType(type: UniversalFact['type'], subject: string): string {\n    switch (type) {\n      case 'npm-package':\n        return `NPM package information, dependencies, versions, and usage for: ${subject}`;\n      case 'github-repo':\n        return `GitHub repository information, stats, recent activity, and documentation for: ${subject}`;\n      case 'api-docs':\n        return `API documentation, endpoints, parameters, and examples for: ${subject}`;\n      case 'security-advisory':\n        return `Security advisory details, impact, and remediation for: ${subject}`;\n      default:\n        return `General information about: ${subject}`;\n    }\n  }\n\n  /**\n   * Get TTL (time to live) for fact type.\n   *\n   * @param type\n   */\n  private getTTLForFactType(type: UniversalFact['type']): number {\n    switch (type) {\n      case 'npm-package':\n        return 86400000; // 24 hours\n      case 'github-repo':\n        return 3600000; // 1 hour (repos change frequently)\n      case 'api-docs':\n        return 604800000; // 1 week\n      case 'security-advisory':\n        return 2592000000; // 30 days\n      default:\n        return 86400000; // 24 hours default\n    }\n  }\n\n  /**\n   * Check if fact is still fresh.\n   *\n   * @param fact\n   */\n  private isFactFresh(fact: UniversalFact): boolean {\n    const ttl = fact.metadata?.ttl || this.getTTLForFactType(fact.type);\n    return Date.now() - (fact.metadata?.timestamp || fact.timestamp) < ttl;\n  }\n\n  /**\n   * Calculate confidence score.\n   *\n   * @param result\n   */\n  private calculateConfidence(result: any): number {\n    const sourceCount = Array.isArray(result?.sources) ? result?.sources.length : 0;\n    const hasErrors = Array.isArray(result?.sources)\n      ? result?.sources.some((s: any) => s?.error)\n      : false;\n\n    let confidence = 0.5; // Base confidence\n    confidence += sourceCount * 0.1; // More sources = higher confidence\n    confidence -= hasErrors ? 0.2 : 0; // Errors reduce confidence\n\n    return Math.min(1.0, Math.max(0.1, confidence));\n  }\n\n  /**\n   * Match fact against search query.\n   *\n   * @param fact\n   * @param query\n   */\n  private matchesQuery(fact: UniversalFact, query: FACTSearchQuery): boolean {\n    // Simple text matching for now\n    const searchText = (query.query ?? '').toLowerCase();\n    const factText =\n      `${fact.type} ${fact.subject || ''} ${JSON.stringify(fact.content)}`.toLowerCase();\n\n    return factText.includes(searchText);\n  }\n\n  /**\n   * Search external sources for facts.\n   *\n   * @param query\n   */\n  private async searchExternalFacts(query: FACTSearchQuery): Promise<UniversalFact[]> {\n    // Try to use real search implementation if available\n    try {\n      if (this.factOrchestrator && typeof this.factOrchestrator.gatherKnowledge === 'function') {\n        // Use buildQueryForFactType if we have a specific type\n        const searchQuery =\n          query.type && query.query\n            ? this.buildQueryForFactType(query.type as UniversalFact['type'], query.query)\n            : query.query || '';\n\n        const result = await this.factOrchestrator.gatherKnowledge(searchQuery, {\n          sources: this.config.knowledgeSources || ['web', 'internal'],\n          maxResults: query.limit || 10,\n          timeout: query.timeout || 30000,\n        });\n\n        if (result && result?.knowledge && Array.isArray(result?.knowledge)) {\n          // Convert real results to universal facts\n          return result?.knowledge?.map((knowledge: any, index: number) => ({\n            id: `external:search:${Date.now()}_${index}`,\n            type: 'external',\n            category: 'search',\n            subject: knowledge.title || query.query || 'search',\n            content: {\n              insight: knowledge.content || knowledge.summary || knowledge.text,\n              source: knowledge.source || 'external_search',\n              url: knowledge.url,\n              relevance: knowledge.relevance,\n            },\n            source: knowledge.source || 'external_search',\n            confidence: knowledge.confidence || 0.8,\n            timestamp: Date.now(),\n            metadata: {\n              source: knowledge.source || 'external_search',\n              timestamp: Date.now(),\n              confidence: knowledge.confidence || 0.8,\n              ttl: 3600000, // 1 hour for search results\n            },\n            accessCount: 0,\n            swarmAccess: new Set(),\n          }));\n        }\n      }\n    } catch (error) {\n      logger.error('External search failed:', error);\n    }\n\n    // If no real search implementation available, return empty results with warning\n    logger.warn(\n      '\uD83D\uDD0D External search not implemented - returning empty results. Consider implementing factOrchestrator.gatherKnowledge() for real search functionality.'\n    );\n\n    // Return empty array instead of fake data\n    return [];\n  }\n\n  /**\n   * Pre-load commonly needed facts.\n   */\n  private async preloadCommonFacts(): Promise<void> {\n    const commonPackages = [\n      'react',\n      'vue',\n      'angular',\n      'express',\n      'typescript',\n      'jest',\n      'webpack',\n      'vite',\n      'next',\n      'axios',\n    ];\n\n    const preloadPromises = commonPackages.map(async (pkg) => {\n      try {\n        await this.getNPMPackageFacts(pkg);\n      } catch (error) {\n        logger.warn(`Failed to preload facts for ${pkg}:`, error);\n      }\n    });\n\n    await Promise.all(preloadPromises);\n  }\n\n  /**\n   * Set up auto-refresh for important facts.\n   */\n  private setupAutoRefresh(): void {\n    // Refresh facts that are accessed frequently\n    setInterval(() => {\n      const frequentlyAccessedFacts = Array.from(this.universalFacts.entries())\n        .filter(([_, fact]) => (fact.accessCount || 0) > 10)\n        .sort((a, b) => (b[1]?.accessCount || 0) - (a[1]?.accessCount || 0))\n        .slice(0, 20); // Top 20 most accessed\n\n      for (const [key, fact] of frequentlyAccessedFacts) {\n        if (!this.isFactFresh(fact)) {\n          this.gatherFact(fact.type, fact.subject || '').then((freshFact) => {\n            if (freshFact) {\n              this.universalFacts.set(key, freshFact);\n              this.emit('fact-refreshed', { key, fact: freshFact });\n            }\n          });\n        }\n      }\n    }, this.config.autoRefreshInterval || 3600000);\n  }\n\n  /**\n   * Get statistics about the FACT system.\n   * Interface-compatible method for HiveFACTSystemInterface.\n   */\n  async getStats(): Promise<FACTStorageStats> {\n    const swarmUsage: Record<string, number> = {};\n\n    // Calculate per-swarm usage\n    for (const fact of this.universalFacts.values()) {\n      if (fact.swarmAccess) {\n        for (const swarmId of fact.swarmAccess) {\n          swarmUsage[swarmId] = (swarmUsage[swarmId] || 0) + 1;\n        }\n      }\n    }\n\n    // Get cache stats from orchestrator (TODO: Implement with unified MCP)\n    const cacheStats = { hitRate: 0.85 }; // Mock cache stats\n\n    return {\n      memoryEntries: this.universalFacts.size,\n      persistentEntries: 0, // Implement if needed\n      totalMemorySize: JSON.stringify(Array.from(this.universalFacts.values())).length,\n      cacheHitRate: cacheStats.hitRate || 0,\n      oldestEntry: Math.min(\n        ...Array.from(this.universalFacts.values()).map((f) => f.metadata?.timestamp || f.timestamp)\n      ),\n      newestEntry: Math.max(\n        ...Array.from(this.universalFacts.values()).map((f) => f.metadata?.timestamp || f.timestamp)\n      ),\n      topDomains: this.config.knowledgeSources || [],\n      storageHealth: 'excellent',\n    };\n  }\n\n  /**\n   * Convert UniversalFact to FACTKnowledgeEntry format for interface compatibility.\n   *\n   * @param fact Universal fact to convert\n   * @param query Original query for context\n   */\n  private convertToFACTKnowledgeEntry(\n    fact: UniversalFact,\n    query: FACTSearchQuery\n  ): FACTKnowledgeEntry {\n    return {\n      query: query.query || fact.subject || '',\n      result:\n        typeof fact.content === 'object'\n          ? JSON.stringify(fact.content)\n          : String(fact.content || ''),\n      ttl: fact.metadata?.ttl || this.getTTLForFactType(fact.type),\n      lastAccessed: Date.now(),\n      metadata: {\n        source: fact.source || 'unknown',\n        timestamp: fact.timestamp,\n        confidence: fact.confidence || 0.5,\n        factId: fact.id,\n        factType: fact.type,\n        subject: fact.subject,\n      },\n    };\n  }\n\n  /**\n   * Shutdown FACT system.\n   */\n  async shutdown(): Promise<void> {\n    // Clear refresh timers\n    for (const timer of this.refreshTimers.values()) {\n      clearTimeout(timer);\n    }\n\n    // Shutdown orchestrator\n    // await this.factOrchestrator.shutdown();\n\n    this.emit('shutdown');\n    logger.info('Collective FACT System shut down');\n  }\n}\n\n// Global Collective FACT instance\nlet globalCollectiveFACT: CollectiveFACTSystem | null = null;\n\n/**\n * Initialize global Collective FACT system.\n *\n * @param config\n * @param collectiveCoordinator\n * @example\n */\nexport async function initializeCollectiveFACT(\n  config?: CollectiveFACTConfig,\n  collectiveCoordinator?: CollectiveSwarmCoordinator\n): Promise<CollectiveFACTSystem> {\n  if (globalCollectiveFACT) {\n    return globalCollectiveFACT;\n  }\n\n  globalCollectiveFACT = new CollectiveFACTSystem(config);\n  await globalCollectiveFACT.initialize(collectiveCoordinator);\n\n  return globalCollectiveFACT;\n}\n\n/**\n * Get global Collective FACT instance.\n *\n * @example\n */\nexport function getCollectiveFACT(): CollectiveFACTSystem | null {\n  return globalCollectiveFACT;\n}\n\n/**\n * Collective FACT helpers for easy access.\n */\nexport const CollectiveFACTHelpers = {\n  /**\n   * Get NPM package facts.\n   *\n   * @param packageName\n   * @param version\n   */\n  async npmFacts(packageName: string, version?: string): Promise<any> {\n    const fact = getCollectiveFACT();\n    if (!fact) throw new Error('Collective FACT not initialized');\n\n    const result = await fact.getNPMPackageFacts(packageName, version);\n    return result?.content;\n  },\n\n  /**\n   * Get GitHub repo facts.\n   *\n   * @param owner\n   * @param repo\n   */\n  async githubFacts(owner: string, repo: string): Promise<any> {\n    const fact = getCollectiveFACT();\n    if (!fact) throw new Error('Collective FACT not initialized');\n\n    const result = await fact.getGitHubRepoFacts(owner, repo);\n    return result?.content;\n  },\n\n  /**\n   * Get API documentation.\n   *\n   * @param api\n   * @param endpoint\n   */\n  async apiFacts(api: string, endpoint?: string): Promise<any> {\n    const fact = getCollectiveFACT();\n    if (!fact) throw new Error('Collective FACT not initialized');\n\n    const result = await fact.getAPIDocsFacts(api, endpoint);\n    return result?.content;\n  },\n\n  /**\n   * Get security advisory.\n   *\n   * @param cve\n   */\n  async securityFacts(cve: string): Promise<any> {\n    const fact = getCollectiveFACT();\n    if (!fact) throw new Error('Collective FACT not initialized');\n\n    const result = await fact.getSecurityAdvisoryFacts(cve);\n    return result?.content;\n  },\n};\n\n// Export types from collective-types\nexport type { UniversalFact } from './collective-types.ts';\n\nexport default CollectiveFACTSystem;\n"],
  "mappings": "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",
  "names": []
}
