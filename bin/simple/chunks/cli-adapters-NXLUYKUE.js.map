{
  "version": 3,
  "sources": ["../../src/interfaces/terminal/adapters/cli-adapters.ts"],
  "sourcesContent": ["/**\n * @file CLI Adapters for Terminal Interface.\n *\n * Provides terminal interface with access to CLI functionality without direct imports.\n * Uses adapter pattern to maintain interface separation.\n */\n\nimport type {\n  CommandResult,\n  DiscoverCommandInterface,\n  ExecutionContext,\n} from '../../shared/command-interfaces.ts';\n\n/**\n * Discover Command Adapter\n * Provides access to discover command functionality without direct CLI dependency.\n *\n * @example\n */\nexport class DiscoverCommandAdapter implements DiscoverCommandInterface {\n  name = 'discover';\n  description = 'Discover and analyze project structure and capabilities';\n\n  async execute(context: ExecutionContext): Promise<CommandResult> {\n    try {\n      // Dynamic import to avoid circular dependency\n      const { DiscoverCommand } = await import('../../cli/commands/discover.ts');\n      const discoverCommand = new DiscoverCommand();\n\n      // Execute the discover command\n      const result = (await discoverCommand.execute?.(context)) ||\n        (await discoverCommand.run?.(context)) || { success: true, message: 'Discovery completed' };\n\n      return result;\n    } catch (error) {\n      console.warn('Discover command execution failed:', error);\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : 'Discovery failed',\n        message: 'Could not execute discover command',\n      };\n    }\n  }\n}\n\n/**\n * CLI Command Registry Adapter\n * Provides access to CLI commands through a safe interface.\n *\n * @example\n */\nexport class CLICommandRegistry {\n  private static instance: CLICommandRegistry;\n  private commands: Map<string, DiscoverCommandInterface> = new Map();\n\n  private constructor() {\n    // Register available commands\n    this.commands.set('discover', new DiscoverCommandAdapter());\n  }\n\n  static getInstance(): CLICommandRegistry {\n    if (!CLICommandRegistry.instance) {\n      CLICommandRegistry.instance = new CLICommandRegistry();\n    }\n    return CLICommandRegistry.instance;\n  }\n\n  async getCommand(name: string): Promise<DiscoverCommandInterface | null> {\n    return this.commands.get(name) || null;\n  }\n\n  async executeCommand(name: string, context: ExecutionContext): Promise<CommandResult> {\n    const command = await this.getCommand(name);\n    if (!command) {\n      return {\n        success: false,\n        error: `Command '${name}' not found`,\n        message: `Available commands: ${Array.from(this.commands.keys()).join(', ')}`,\n      };\n    }\n\n    return await command.execute(context);\n  }\n\n  getAvailableCommands(): string[] {\n    return Array.from(this.commands.keys());\n  }\n}\n"],
  "mappings": ";;;;;;;;;;;;;AAmBO,IAAM,yBAAN,MAAiE;AAAA,EAnBxE,OAmBwE;AAAA;AAAA;AAAA,EACtE,OAAO;AAAA,EACP,cAAc;AAAA,EAEd,MAAM,QAAQ,SAAmD;AAC/D,QAAI;AAEF,YAAM,EAAE,gBAAgB,IAAI,MAAM,OAAO,gCAAgC;AACzE,YAAM,kBAAkB,IAAI,gBAAgB;AAG5C,YAAM,SAAU,MAAM,gBAAgB,UAAU,OAAO,KACpD,MAAM,gBAAgB,MAAM,OAAO,KAAM,EAAE,SAAS,MAAM,SAAS,sBAAsB;AAE5F,aAAO;AAAA,IACT,SAAS,OAAO;AACd,cAAQ,KAAK,sCAAsC,KAAK;AACxD,aAAO;AAAA,QACL,SAAS;AAAA,QACT,OAAO,iBAAiB,QAAQ,MAAM,UAAU;AAAA,QAChD,SAAS;AAAA,MACX;AAAA,IACF;AAAA,EACF;AACF;AAQO,IAAM,qBAAN,MAAM,oBAAmB;AAAA,EAnDhC,OAmDgC;AAAA;AAAA;AAAA,EAC9B,OAAe;AAAA,EACP,WAAkD,oBAAI,IAAI;AAAA,EAE1D,cAAc;AAEpB,SAAK,SAAS,IAAI,YAAY,IAAI,uBAAuB,CAAC;AAAA,EAC5D;AAAA,EAEA,OAAO,cAAkC;AACvC,QAAI,CAAC,oBAAmB,UAAU;AAChC,0BAAmB,WAAW,IAAI,oBAAmB;AAAA,IACvD;AACA,WAAO,oBAAmB;AAAA,EAC5B;AAAA,EAEA,MAAM,WAAW,MAAwD;AACvE,WAAO,KAAK,SAAS,IAAI,IAAI,KAAK;AAAA,EACpC;AAAA,EAEA,MAAM,eAAe,MAAc,SAAmD;AACpF,UAAM,UAAU,MAAM,KAAK,WAAW,IAAI;AAC1C,QAAI,CAAC,SAAS;AACZ,aAAO;AAAA,QACL,SAAS;AAAA,QACT,OAAO,YAAY,IAAI;AAAA,QACvB,SAAS,uBAAuB,MAAM,KAAK,KAAK,SAAS,KAAK,CAAC,EAAE,KAAK,IAAI,CAAC;AAAA,MAC7E;AAAA,IACF;AAEA,WAAO,MAAM,QAAQ,QAAQ,OAAO;AAAA,EACtC;AAAA,EAEA,uBAAiC;AAC/B,WAAO,MAAM,KAAK,KAAK,SAAS,KAAK,CAAC;AAAA,EACxC;AACF;",
  "names": []
}
