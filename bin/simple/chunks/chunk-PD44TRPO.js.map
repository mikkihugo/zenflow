{
  "version": 3,
  "sources": ["../../src/di/container/di-scope.ts", "../../src/di/types/di-types.ts", "../../src/di/container/di-container.ts"],
  "sourcesContent": ["/**\n * Scoped dependency injection container implementation.\n * Provides hierarchical scoping for service lifetimes.\n */\n/**\n * @file Di-scope implementation.\n */\n\nimport type { DIContainer, DIToken, DIScope as IDIScope, Provider } from '../types/di-types.ts';\n\nexport class DIScope implements IDIScope {\n  private readonly scopedProviders = new Map<symbol, Provider<any>>();\n  private readonly scopedInstances = new Map<symbol, any>();\n  private readonly children = new Set<DIScope>();\n\n  constructor(public readonly parent: DIContainer) {}\n\n  /**\n   * Register a service provider in this scope.\n   *\n   * @param token\n   * @param provider\n   */\n  register<T>(token: DIToken<T>, provider: Provider<T>): void {\n    this.scopedProviders.set(token.symbol, provider);\n  }\n\n  /**\n   * Resolve a service, checking scope hierarchy.\n   *\n   * @param token\n   */\n  resolve<T>(token: DIToken<T>): T {\n    // First check scoped providers\n    const scopedProvider = this.scopedProviders.get(token.symbol);\n    if (scopedProvider) {\n      return this.resolveScoped(token, scopedProvider);\n    }\n\n    // Fallback to parent container\n    return this.parent.resolve(token);\n  }\n\n  /**\n   * Create a child scope.\n   */\n  createScope(): IDIScope {\n    const child = new DIScope(this);\n    this.children.add(child);\n    return child;\n  }\n\n  /**\n   * Create a child scope (alias for createScope).\n   */\n  createChild(): IDIScope {\n    return this.createScope();\n  }\n\n  /**\n   * Dispose scope and all child scopes.\n   */\n  async dispose(): Promise<void> {\n    const disposalPromises: Promise<void>[] = [];\n\n    // Dispose all scoped instances\n    for (const [symbol, instance] of this.scopedInstances) {\n      const provider = this.scopedProviders.get(symbol);\n      if (provider?.dispose) {\n        disposalPromises.push(provider.dispose(instance));\n      }\n    }\n\n    // Dispose all child scopes\n    for (const child of this.children) {\n      disposalPromises.push(child?.dispose());\n    }\n\n    await Promise.all(disposalPromises);\n\n    this.scopedInstances.clear();\n    this.scopedProviders.clear();\n    this.children.clear();\n  }\n\n  /**\n   * Check if a service is registered in this scope.\n   *\n   * @param token\n   */\n  isRegisteredInScope<T>(token: DIToken<T>): boolean {\n    return this.scopedProviders.has(token.symbol);\n  }\n\n  /**\n   * Resolve a scoped service with instance caching.\n   *\n   * @param token\n   * @param provider\n   */\n  private resolveScoped<T>(token: DIToken<T>, provider: Provider<T>): T {\n    if (this.scopedInstances.has(token.symbol)) {\n      return this.scopedInstances.get(token.symbol);\n    }\n\n    const instance = provider.create(this);\n    this.scopedInstances.set(token.symbol, instance);\n    return instance;\n  }\n}\n", "/**\n * Core dependency injection type definitions.\n * Following Google TypeScript Style Guide and enterprise DI patterns.\n */\n\n/**\n * Dependency injection token for type-safe service registration.\n *\n * @example\n */\n/**\n * @file TypeScript type definitions.\n */\n\nexport interface DIToken<T> {\n  readonly symbol: symbol;\n  readonly name: string;\n  readonly type?: new (...args: any[]) => T;\n}\n\n/**\n * Provider lifecycle types.\n */\nexport type ProviderLifestyle = 'singleton' | 'transient' | 'scoped';\n\n/**\n * Base provider interface for service creation.\n *\n * @example\n */\nexport interface Provider<T> {\n  readonly type: ProviderLifestyle;\n  create(container: DIContainer): T;\n  dispose?(instance: T): Promise<void>;\n}\n\n/**\n * Main dependency injection container interface.\n *\n * @example\n */\nexport interface DIContainer {\n  register<T>(token: DIToken<T>, provider: Provider<T>): void;\n  resolve<T>(token: DIToken<T>): T;\n  createScope(): DIScope;\n  dispose(): Promise<void>;\n}\n\n/**\n * Scoped container interface extending base container.\n *\n * @example\n */\nexport interface DIScope extends DIContainer {\n  readonly parent: DIContainer | null;\n  createChild(): DIScope;\n}\n\n/**\n * Singleton provider configuration.\n *\n * @example\n */\nexport interface SingletonProvider<T> extends Provider<T> {\n  readonly type: 'singleton';\n  readonly instance?: T;\n}\n\n/**\n * Factory provider configuration.\n *\n * @example\n */\nexport interface FactoryProvider<T> extends Provider<T> {\n  readonly type: 'transient';\n  readonly factory: (container: DIContainer) => T;\n}\n\n/**\n * Scoped provider configuration.\n *\n * @example\n */\nexport interface ScopedProvider<T> extends Provider<T> {\n  readonly type: 'scoped';\n}\n\n/**\n * Service configuration for configuration-based registration.\n *\n * @example\n */\nexport interface ServiceConfiguration {\n  services: Array<{\n    token: string;\n    implementation: string;\n    lifestyle: ProviderLifestyle;\n    dependencies?: string[];\n  }>;\n  modules: string[];\n}\n\n/**\n * Service mapping for auto-registration.\n *\n * @example\n */\nexport interface ServiceMapping {\n  token: DIToken<any>;\n  implementation: new (...args: any[]) => any;\n  lifestyle: ProviderLifestyle;\n  dependencies: DIToken<any>[];\n}\n\n/**\n * Service registration result.\n *\n * @example\n */\nexport interface ServiceRegistration {\n  file: string;\n  exports: Array<{\n    name: string;\n    type: 'class' | 'interface' | 'function';\n    isService: boolean;\n  }>;\n}\n\n/**\n * DI container configuration options.\n *\n * @example\n */\nexport interface DIContainerOptions {\n  enableCircularDependencyDetection?: boolean;\n  maxResolutionDepth?: number;\n  enablePerformanceMetrics?: boolean;\n  autoRegisterByConvention?: boolean;\n}\n\n/**\n * DI error types.\n *\n * @example\n */\nexport class DIError extends Error {\n  constructor(\n    message: string,\n    public readonly code?: string\n  ) {\n    super(message);\n    this.name = 'DIError';\n  }\n}\n\nexport class CircularDependencyError extends DIError {\n  constructor(dependencyChain: string[]) {\n    super(`Circular dependency detected: ${dependencyChain.join(' -> ')}`, 'CIRCULAR_DEPENDENCY');\n    this.name = 'CircularDependencyError';\n  }\n}\n\nexport class ServiceNotFoundError extends DIError {\n  constructor(token: string) {\n    super(`No provider registered for token: ${token}`, 'SERVICE_NOT_FOUND');\n    this.name = 'ServiceNotFoundError';\n  }\n}\n\n/**\n * Injection metadata for decorator support.\n *\n * @example\n */\nexport interface InjectionMetadata {\n  parameterTypes: any[];\n  injectionTokens: (DIToken<any> | undefined)[];\n}\n\n/**\n * Constructor type for injectable classes.\n */\nexport type Constructor<T = {}> = new (...args: any[]) => T;\n\n/**\n * Parameter decorator type.\n */\nexport type ParameterDecorator = (\n  target: any,\n  propertyKey: string | symbol | undefined,\n  parameterIndex: number\n) => void;\n\n/**\n * Class decorator type for injectable.\n */\nexport type ClassDecorator = <T extends Constructor>(constructor: T) => T;\n", "/**\n * @file Di-container implementation.\n */\n\nimport { getLogger } from '../../config/logging-config.ts';\n\nconst logger = getLogger('di-container-di-container');\n\n/**\n * Main dependency injection container implementation.\n * Provides type-safe service registration and resolution.\n */\n\nimport type {\n  DIContainerOptions,\n  DIScope,\n  DIToken,\n  DIContainer as IDIContainer,\n  Provider,\n} from '../types/di-types.ts';\nimport { CircularDependencyError, DIError, ServiceNotFoundError } from '../types/di-types.ts';\n\nexport class DIContainer implements IDIContainer {\n  private readonly providers = new Map<symbol, Provider<any>>();\n  private readonly singletonInstances = new Map<symbol, any>();\n  private readonly scopes = new WeakSet<DIScope>();\n  private readonly resolutionStack: symbol[] = [];\n  private readonly options: Required<DIContainerOptions>;\n\n  constructor(options: DIContainerOptions = {}) {\n    this.options = {\n      enableCircularDependencyDetection: options?.enableCircularDependencyDetection ?? true,\n      maxResolutionDepth: options?.maxResolutionDepth ?? 50,\n      enablePerformanceMetrics: options?.enablePerformanceMetrics ?? false,\n      autoRegisterByConvention: options?.autoRegisterByConvention ?? false,\n    };\n  }\n\n  /**\n   * Register a service provider with the container.\n   *\n   * @param token\n   * @param provider\n   */\n  register<T>(token: DIToken<T>, provider: Provider<T>): void {\n    if (this.providers.has(token.symbol)) {\n      logger.warn(`Provider for token '${token.name}' is being overwritten`);\n    }\n\n    this.providers.set(token.symbol, provider);\n  }\n\n  /**\n   * Resolve a service from the container.\n   *\n   * @param token\n   */\n  resolve<T>(token: DIToken<T>): T {\n    const startTime = this.options.enablePerformanceMetrics ? Date.now() : 0;\n\n    try {\n      const result = this.resolveInternal(token);\n\n      if (this.options.enablePerformanceMetrics) {\n        const duration = Date.now() - startTime;\n        this.recordResolutionMetric(token, duration);\n      }\n\n      return result;\n    } catch (error) {\n      if (error instanceof DIError) {\n        throw error;\n      }\n      throw new DIError(`Failed to resolve service '${token.name}': ${error}`, 'RESOLUTION_FAILED');\n    }\n  }\n\n  /**\n   * Create a new scope.\n   */\n  createScope(): DIScope {\n    // Import DIScope dynamically to avoid circular dependency\n    const DIScopeModule = require('./di-scope.js');\n    const DIScopeImpl = DIScopeModule.DIScope;\n    const scope = new DIScopeImpl(this);\n    this.scopes.add(scope);\n    return scope;\n  }\n\n  /**\n   * Dispose all singleton instances and clean up resources.\n   */\n  async dispose(): Promise<void> {\n    const disposalPromises: Promise<void>[] = [];\n\n    // Dispose all singleton instances\n    for (const [symbol, instance] of this.singletonInstances) {\n      const provider = this.providers.get(symbol);\n      if (provider?.dispose) {\n        disposalPromises.push(provider.dispose(instance));\n      }\n    }\n\n    await Promise.all(disposalPromises);\n\n    this.singletonInstances.clear();\n    this.providers.clear();\n  }\n\n  /**\n   * Check if a service is registered.\n   *\n   * @param token\n   */\n  isRegistered<T>(token: DIToken<T>): boolean {\n    return this.providers.has(token.symbol);\n  }\n\n  /**\n   * Get all registered tokens (for debugging).\n   */\n  getRegisteredTokens(): string[] {\n    return Array.from(this.providers.entries()).map(([symbol, _]) => {\n      // Find token name by symbol (reverse lookup)\n      for (const [tokenSymbol, _provider] of this.providers) {\n        if (tokenSymbol === symbol) {\n          return symbol.toString();\n        }\n      }\n      return symbol.toString();\n    });\n  }\n\n  /**\n   * Internal resolution with circular dependency detection.\n   *\n   * @param token\n   */\n  private resolveInternal<T>(token: DIToken<T>): T {\n    // Check circular dependency\n    if (this.options.enableCircularDependencyDetection) {\n      if (this.resolutionStack.includes(token.symbol)) {\n        const chain = this.resolutionStack.map((s) => s.toString()).concat(token.name);\n        throw new CircularDependencyError(chain);\n      }\n\n      if (this.resolutionStack.length >= this.options.maxResolutionDepth) {\n        throw new DIError(\n          `Maximum resolution depth exceeded (${this.options.maxResolutionDepth})`,\n          'MAX_DEPTH_EXCEEDED'\n        );\n      }\n    }\n\n    const provider = this.providers.get(token.symbol);\n    if (!provider) {\n      throw new ServiceNotFoundError(token.name);\n    }\n\n    this.resolutionStack.push(token.symbol);\n\n    try {\n      switch (provider.type) {\n        case 'singleton':\n          return this.resolveSingleton(token, provider);\n        case 'transient':\n          return provider.create(this);\n        case 'scoped':\n          return provider.create(this);\n        default:\n          throw new DIError(\n            `Unknown provider type: ${(provider as any).type}`,\n            'UNKNOWN_PROVIDER_TYPE'\n          );\n      }\n    } finally {\n      this.resolutionStack.pop();\n    }\n  }\n\n  /**\n   * Resolve singleton with instance caching.\n   *\n   * @param token\n   * @param provider\n   */\n  private resolveSingleton<T>(token: DIToken<T>, provider: Provider<T>): T {\n    if (this.singletonInstances.has(token.symbol)) {\n      return this.singletonInstances.get(token.symbol);\n    }\n\n    const instance = provider.create(this);\n    this.singletonInstances.set(token.symbol, instance);\n    return instance;\n  }\n\n  /**\n   * Record performance metrics for service resolution.\n   *\n   * @param token - The service token that was resolved.\n   * @param duration - Resolution time in milliseconds.\n   */\n  private recordResolutionMetric<T>(token: DIToken<T>, duration: number): void {\n    // Log performance metric - could be extended to use proper metrics collector\n    logger.debug(`DI Resolution: ${token.name} resolved in ${duration}ms`);\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
