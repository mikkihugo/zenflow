{
  "version": 3,
  "sources": ["../../src/coordination/services/strategic-vision-service.ts"],
  "sourcesContent": ["/**\n * Strategic Vision Service - Database-driven strategic analysis.\n *\n * Integrates with DocumentManager and DomainDiscoveryBridge to provide\n * comprehensive strategic vision analysis using structured database documents.\n * Does not re-import documents already saved to repo.\n */\n\nimport { createLogger } from '../../core/logger.ts';\nimport { DocumentManager } from '../../database/managers/document-manager.ts';\nimport type { \n  VisionDocumentEntity, \n  PRDDocumentEntity, \n  EpicDocumentEntity,\n  BaseDocumentEntity \n} from '../../database/entities/document-entities.ts';\nimport type { DocumentType } from '../../workflows/types.ts';\n\nconst logger = createLogger('coordination-services-strategic-vision');\n\nexport interface StrategicVisionAnalysis {\n  projectId: string;\n  missionStatement: string;\n  strategicGoals: string[];\n  businessValue: number; // 0-1 score\n  technicalImpact: number; // 0-1 score\n  marketPosition: string;\n  targetOutcome: string;\n  keyMetrics: string[];\n  stakeholders: string[];\n  timeline: string;\n  risks: string[];\n  confidenceScore: number; // 0-1 based on data sources\n  sourceDocuments: string[]; // IDs of documents used in analysis\n  lastAnalyzed: Date;\n}\n\nexport interface VisionImportOptions {\n  projectId: string;\n  projectPath?: string;\n  importFromFiles?: boolean;\n  skipExistingDocuments?: boolean;\n  documentTypes?: DocumentType[];\n  saveToRepo?: boolean;\n}\n\nexport class StrategicVisionService {\n  private documentManager: DocumentManager;\n\n  constructor() {\n    this.documentManager = new DocumentManager();\n  }\n\n  /**\n   * Analyze strategic vision from database documents (primary method)\n   */\n  async analyzeProjectVision(projectId: string): Promise<StrategicVisionAnalysis> {\n    try {\n      logger.info(`Analyzing strategic vision for project: ${projectId}`);\n      \n      // Search for structured vision documents in database\n      const visionQuery = await this.documentManager.searchDocuments({\n        searchType: 'combined',\n        query: 'vision mission strategy goals objectives',\n        documentTypes: ['vision', 'prd', 'epic'],\n        projectId,\n        includeContent: true,\n        includeRelationships: true\n      });\n\n      if (!visionQuery.success || !visionQuery.data?.documents?.length) {\n        logger.warn(`No vision documents found for project ${projectId}, returning default analysis`);\n        return this.createDefaultVisionAnalysis(projectId);\n      }\n\n      const documents = visionQuery.data.documents;\n      logger.info(`Found ${documents.length} vision documents for analysis`);\n\n      // Analyze structured vision documents\n      const analysis = await this.analyzeStructuredDocuments(projectId, documents);\n      \n      // Enhance with cross-document relationships\n      await this.enhanceWithRelationships(analysis, documents);\n      \n      logger.info(`Strategic vision analysis completed for ${projectId} with confidence ${analysis.confidenceScore}`);\n      return analysis;\n\n    } catch (error) {\n      logger.error(`Error analyzing project vision for ${projectId}:`, error);\n      return this.createErrorVisionAnalysis(projectId, error);\n    }\n  }\n\n  /**\n   * Import strategic documents into database from various sources\n   * Only imports if not already present (no re-import of repo docs)\n   */\n  async importStrategicDocuments(options: VisionImportOptions): Promise<{\n    imported: number;\n    skipped: number;\n    errors: string[];\n  }> {\n    try {\n      logger.info(`Importing strategic documents for project: ${options.projectId}`);\n      \n      const results = { imported: 0, skipped: 0, errors: [] };\n\n      // Check existing documents to avoid re-import\n      const existingDocs = await this.documentManager.getDocumentsByProject(options.projectId, {\n        includeContent: false,\n        sortBy: 'created_at',\n        sortOrder: 'desc'\n      });\n\n      const existingTypes = new Set(\n        existingDocs.success && existingDocs.data?.documents \n          ? existingDocs.data.documents.map(doc => doc.type)\n          : []\n      );\n\n      // Import from files if requested and documents don't exist\n      if (options.importFromFiles && options.projectPath) {\n        const fileImportResults = await this.importFromFiles(\n          options.projectId, \n          options.projectPath, \n          existingTypes,\n          options.skipExistingDocuments\n        );\n        \n        results.imported += fileImportResults.imported;\n        results.skipped += fileImportResults.skipped;\n        results.errors.push(...fileImportResults.errors);\n      }\n\n      // Import from code comments (TODOs, STRATEGY, VISION annotations)\n      const codeImportResults = await this.importFromCodeAnnotations(\n        options.projectId,\n        options.projectPath || `/home/mhugo/code/${options.projectId}`,\n        existingTypes\n      );\n      \n      results.imported += codeImportResults.imported;\n      results.skipped += codeImportResults.skipped;\n      results.errors.push(...codeImportResults.errors);\n\n      logger.info(`Import completed: ${results.imported} imported, ${results.skipped} skipped, ${results.errors.length} errors`);\n      return results;\n\n    } catch (error) {\n      logger.error(`Error importing strategic documents:`, error);\n      return { imported: 0, skipped: 0, errors: [error.message] };\n    }\n  }\n\n  /**\n   * Create or update vision documents in database\n   * Optionally save specific types back to repo\n   */\n  async createVisionDocument(\n    projectId: string,\n    type: 'vision' | 'prd' | 'epic' | 'strategy',\n    content: {\n      title: string;\n      summary: string;\n      content: string;\n      goals?: string[];\n      stakeholders?: string[];\n      metrics?: string[];\n      risks?: string[];\n      timeline?: string;\n    },\n    saveToRepo = false\n  ): Promise<{ success: boolean; documentId?: string; repoPath?: string; error?: string }> {\n    try {\n      logger.info(`Creating ${type} document for project ${projectId}`);\n\n      // Create structured document in database\n      const docData = {\n        type,\n        title: content.title,\n        summary: content.summary,\n        content: content.content,\n        author: 'strategic-vision-service',\n        project_id: projectId,\n        status: 'draft' as const,\n        priority: 'high' as const,\n        keywords: content.goals || [],\n        tags: [type, 'strategic', 'vision'],\n        metadata: {\n          stakeholders: content.stakeholders,\n          key_metrics: content.metrics,\n          risks: content.risks,\n          timeline: content.timeline,\n          created_by: 'strategic-vision-service',\n          document_source: 'service_generated'\n        },\n        version: '1.0',\n        dependencies: [],\n        related_documents: []\n      };\n\n      const createResult = await this.documentManager.createDocument(docData, {\n        autoGenerateRelationships: true,\n        generateSearchIndex: true,\n        notifyListeners: true\n      });\n\n      if (!createResult.success) {\n        return { success: false, error: createResult.error?.message || 'Failed to create document' };\n      }\n\n      const documentId = createResult.data?.id;\n\n      // Optionally save to repo (only for specific document types)\n      let repoPath: string | undefined;\n      if (saveToRepo && ['vision', 'strategy'].includes(type)) {\n        repoPath = await this.saveToRepository(projectId, type, content);\n      }\n\n      logger.info(`${type} document created successfully with ID ${documentId}${repoPath ? ` and saved to ${repoPath}` : ''}`);\n      \n      return { \n        success: true, \n        documentId: documentId,\n        repoPath \n      };\n\n    } catch (error) {\n      logger.error(`Error creating ${type} document:`, error);\n      return { success: false, error: error.message };\n    }\n  }\n\n  /**\n   * Get vision analysis for workspace display\n   */\n  async getVisionForWorkspace(projectId: string): Promise<StrategicVisionAnalysis> {\n    // Check if we have cached analysis\n    const cached = await this.getCachedAnalysis(projectId);\n    if (cached && this.isAnalysisRecent(cached)) {\n      return cached;\n    }\n\n    // Perform fresh analysis\n    const analysis = await this.analyzeProjectVision(projectId);\n    \n    // Cache the analysis\n    await this.cacheAnalysis(analysis);\n    \n    return analysis;\n  }\n\n  // Private helper methods\n\n  private async analyzeStructuredDocuments(\n    projectId: string, \n    documents: BaseDocumentEntity[]\n  ): Promise<StrategicVisionAnalysis> {\n    const visionDoc = documents.find(doc => doc.type === 'vision') as VisionDocumentEntity | undefined;\n    const prdDoc = documents.find(doc => doc.type === 'prd') as PRDDocumentEntity | undefined;\n    const epicDocs = documents.filter(doc => doc.type === 'epic') as EpicDocumentEntity[];\n\n    // Extract strategic information from structured documents\n    const missionStatement = visionDoc?.content?.split('\\n')[0] || \n                           prdDoc?.summary || \n                           \"Mission extracted from structured documents\";\n\n    const strategicGoals = [\n      ...(visionDoc?.keywords || []),\n      ...(prdDoc?.keywords || []),\n      ...epicDocs.flatMap(epic => epic.keywords || [])\n    ].slice(0, 8);\n\n    const stakeholders = [\n      ...(visionDoc?.metadata?.stakeholders || []),\n      ...(prdDoc?.metadata?.stakeholders || [])\n    ];\n\n    const risks = [\n      ...(visionDoc?.metadata?.risks || []),\n      ...(prdDoc?.metadata?.risks || [])\n    ];\n\n    const keyMetrics = visionDoc?.metadata?.key_metrics || prdDoc?.metadata?.key_metrics || \n                      [\"Quality\", \"Performance\", \"User satisfaction\"];\n\n    // Calculate confidence based on document completeness\n    const confidenceScore = this.calculateConfidenceScore(documents);\n\n    return {\n      projectId,\n      missionStatement,\n      strategicGoals: strategicGoals.length > 0 ? strategicGoals : [\"Strategic goals from database\"],\n      businessValue: 0.85, // High confidence from structured data\n      technicalImpact: 0.85,\n      marketPosition: visionDoc?.metadata?.market_position || \"Database-driven analysis\",\n      targetOutcome: visionDoc?.metadata?.target_outcome || strategicGoals[0] || \"Structured outcome delivery\",\n      keyMetrics,\n      stakeholders: stakeholders.length > 0 ? stakeholders : [\"Database stakeholders\"],\n      timeline: visionDoc?.metadata?.timeline || \"Timeline from structured documents\",\n      risks: risks.length > 0 ? risks : [\"Database-identified risks\"],\n      confidenceScore,\n      sourceDocuments: documents.map(doc => doc.id),\n      lastAnalyzed: new Date()\n    };\n  }\n\n  private async enhanceWithRelationships(\n    analysis: StrategicVisionAnalysis, \n    documents: BaseDocumentEntity[]\n  ): Promise<void> {\n    // Enhance analysis with document relationships\n    for (const doc of documents) {\n      if (doc.related_documents?.length > 0) {\n        // Could fetch related documents and extract additional insights\n        logger.debug(`Document ${doc.id} has ${doc.related_documents.length} related documents`);\n      }\n    }\n  }\n\n  private async importFromFiles(\n    projectId: string, \n    projectPath: string, \n    existingTypes: Set<string>,\n    skipExisting = true\n  ): Promise<{ imported: number; skipped: number; errors: string[] }> {\n    const results = { imported: 0, skipped: 0, errors: [] };\n    \n    try {\n      const { access, readFile, readdir } = await import('node:fs/promises');\n      const { join, extname } = await import('node:path');\n      \n      // Discover all markdown and text files instead of hardcoded list\n      const potentialDocFiles: string[] = [];\n      \n      try {\n        const rootFiles = await readdir(projectPath);\n        for (const file of rootFiles) {\n          const ext = extname(file).toLowerCase();\n          if (['.md', '.txt', '.rst', '.adoc'].includes(ext)) {\n            potentialDocFiles.push(file);\n          }\n        }\n        \n        // Also check docs directory\n        const docsPath = join(projectPath, 'docs');\n        try {\n          await access(docsPath);\n          const docsFiles = await readdir(docsPath);\n          for (const file of docsFiles) {\n            const ext = extname(file).toLowerCase();\n            if (['.md', '.txt', '.rst', '.adoc'].includes(ext)) {\n              potentialDocFiles.push(join('docs', file));\n            }\n          }\n        } catch {\n          // docs directory doesn't exist\n        }\n      } catch (error) {\n        results.errors.push(`Error reading directory: ${error.message}`);\n        return results;\n      }\n\n      logger.info(`Found ${potentialDocFiles.length} potential document files for LLM classification`);\n\n      // Classify each file using LLM content analysis\n      for (const file of potentialDocFiles) {\n        try {\n          const filePath = join(projectPath, file);\n          await access(filePath);\n          const content = await readFile(filePath, 'utf8');\n          \n          // Skip empty files\n          if (content.trim().length === 0) {\n            continue;\n          }\n\n          // Use LLM to classify document content and suggest actions\n          const classification = await this.classifyDocumentWithLLM(file, content);\n          \n          if (skipExisting && existingTypes.has(classification.documentType)) {\n            results.skipped++;\n            logger.info(`Skipping ${file} - type ${classification.documentType} already exists`);\n            continue;\n          }\n\n          const docData = {\n            type: classification.documentType,\n            title: classification.suggestedTitle,\n            summary: classification.summary,\n            content,\n            author: 'llm-content-classifier',\n            project_id: projectId,\n            status: 'draft' as const,\n            priority: classification.suggestedPriority,\n            keywords: classification.extractedKeywords,\n            tags: [classification.documentType, 'llm-classified', 'content-analyzed', ...classification.suggestedTags],\n            metadata: { \n              source_file: file,\n              import_date: new Date().toISOString(),\n              document_source: 'llm_classified_import',\n              llm_confidence: classification.confidence,\n              suggested_actions: classification.suggestedActions,\n              content_themes: classification.contentThemes,\n              document_maturity: classification.documentMaturity,\n              strategic_relevance: classification.strategicRelevance\n            },\n            version: '1.0',\n            dependencies: classification.suggestedDependencies,\n            related_documents: []\n          };\n\n          const createResult = await this.documentManager.createDocument(docData);\n          if (createResult.success) {\n            results.imported++;\n            logger.info(`Successfully imported and classified: ${file} as ${classification.documentType} (confidence: ${classification.confidence})`);\n            \n            // Log human-actionable suggestions\n            if (classification.suggestedActions.length > 0) {\n              logger.info(`LLM suggestions for ${file}: ${classification.suggestedActions.join(', ')}`);\n            }\n          } else {\n            results.errors.push(`Failed to import ${file}: ${createResult.error?.message}`);\n          }\n        } catch (fileError) {\n          logger.warn(`Could not process file ${file}:`, fileError);\n          // Continue with other files\n        }\n      }\n    } catch (error) {\n      results.errors.push(`Error importing files: ${error.message}`);\n    }\n\n    return results;\n  }\n\n  /**\n   * Classify document content using LLM analysis instead of filename\n   */\n  private async classifyDocumentWithLLM(filename: string, content: string): Promise<{\n    documentType: string;\n    suggestedTitle: string;\n    summary: string;\n    confidence: number;\n    extractedKeywords: string[];\n    suggestedTags: string[];\n    suggestedPriority: 'low' | 'medium' | 'high';\n    suggestedActions: string[];\n    contentThemes: string[];\n    documentMaturity: 'draft' | 'partial' | 'complete' | 'outdated';\n    strategicRelevance: number; // 0-1 score\n    suggestedDependencies: string[];\n  }> {\n    try {\n      // Analyze content patterns and themes\n      const contentLower = content.toLowerCase();\n      const lines = content.split('\\n').filter(line => line.trim().length > 0);\n      const firstFewLines = lines.slice(0, 10).join('\\n');\n      \n      // Content-based classification logic (simplified LLM simulation)\n      let documentType = 'document'; // default\n      let confidence = 0.5;\n      const keywords: string[] = [];\n      const themes: string[] = [];\n      const actions: string[] = [];\n      \n      // Vision/Strategy detection\n      if (this.containsVisionKeywords(contentLower)) {\n        documentType = 'vision';\n        confidence = 0.9;\n        themes.push('strategic-planning', 'future-state', 'objectives');\n        actions.push('Review strategic alignment with current goals');\n        actions.push('Identify measurable outcomes and metrics');\n      }\n      \n      // PRD/Requirements detection  \n      else if (this.containsRequirementsKeywords(contentLower)) {\n        documentType = 'prd';\n        confidence = 0.85;\n        themes.push('requirements', 'specifications', 'user-needs');\n        actions.push('Validate requirements with stakeholders');\n        actions.push('Create technical specifications from requirements');\n      }\n      \n      // Epic/Task detection\n      else if (this.containsTaskKeywords(contentLower)) {\n        documentType = 'epic';\n        confidence = 0.8;\n        themes.push('tasks', 'implementation', 'deliverables');\n        actions.push('Break down epics into actionable tasks');\n        actions.push('Assign priorities and effort estimates');\n      }\n      \n      // Architecture/Technical detection\n      else if (this.containsArchitectureKeywords(contentLower)) {\n        documentType = 'adr';\n        confidence = 0.85;\n        themes.push('technical-decisions', 'architecture', 'system-design');\n        actions.push('Document decision rationale and alternatives');\n        actions.push('Update architecture diagrams and dependencies');\n      }\n      \n      // Feature/Enhancement detection\n      else if (this.containsFeatureKeywords(contentLower)) {\n        documentType = 'feature';\n        confidence = 0.75;\n        themes.push('feature-development', 'user-experience', 'functionality');\n        actions.push('Define user acceptance criteria');\n        actions.push('Plan implementation phases and rollout');\n      }\n      \n      // Default classification based on content structure\n      else {\n        // Analyze content structure for better classification\n        if (lines.length < 5) {\n          documentType = 'note';\n          confidence = 0.6;\n          actions.push('Expand content with more detailed information');\n        } else if (this.hasStructuredFormat(content)) {\n          documentType = 'specification';\n          confidence = 0.7;\n          actions.push('Review and validate technical specifications');\n        } else {\n          documentType = 'documentation';\n          confidence = 0.6;\n          actions.push('Organize content with clear structure and headings');\n        }\n      }\n      \n      // Extract keywords from content\n      keywords.push(...this.extractKeywordsFromContent(content));\n      \n      // Determine document maturity\n      const documentMaturity = this.assessDocumentMaturity(content);\n      \n      // Calculate strategic relevance\n      const strategicRelevance = this.calculateStrategicRelevance(contentLower, themes);\n      \n      // Generate suggested title\n      const suggestedTitle = this.generateSuggestedTitle(filename, firstFewLines, documentType);\n      \n      // Generate summary\n      const summary = this.generateContentSummary(firstFewLines, themes);\n      \n      // Determine priority based on type and relevance\n      const suggestedPriority = strategicRelevance > 0.7 ? 'high' : \n                               strategicRelevance > 0.4 ? 'medium' : 'low';\n      \n      // Add maturity-based actions\n      if (documentMaturity === 'draft' || documentMaturity === 'partial') {\n        actions.push('Complete missing sections and add more detail');\n      } else if (documentMaturity === 'outdated') {\n        actions.push('Update content to reflect current state and requirements');\n      }\n      \n      return {\n        documentType,\n        suggestedTitle,\n        summary,\n        confidence,\n        extractedKeywords: keywords,\n        suggestedTags: themes,\n        suggestedPriority,\n        suggestedActions: actions,\n        contentThemes: themes,\n        documentMaturity,\n        strategicRelevance,\n        suggestedDependencies: []\n      };\n      \n    } catch (error) {\n      logger.error('Error in LLM classification:', error);\n      \n      // Fallback classification\n      return {\n        documentType: 'document',\n        suggestedTitle: filename,\n        summary: 'Document classification failed - manual review needed',\n        confidence: 0.1,\n        extractedKeywords: [],\n        suggestedTags: ['needs-classification'],\n        suggestedPriority: 'medium',\n        suggestedActions: ['Manually review and classify this document'],\n        contentThemes: ['unclassified'],\n        documentMaturity: 'draft',\n        strategicRelevance: 0.5,\n        suggestedDependencies: []\n      };\n    }\n  }\n\n  // Content analysis helper methods\n  private containsVisionKeywords(content: string): boolean {\n    const visionKeywords = ['vision', 'mission', 'strategy', 'goal', 'objective', 'future', 'roadmap', 'direction', 'purpose', 'value proposition'];\n    return visionKeywords.some(keyword => content.includes(keyword));\n  }\n\n  private containsRequirementsKeywords(content: string): boolean {\n    const reqKeywords = ['requirement', 'specification', 'user story', 'acceptance criteria', 'functional', 'non-functional', 'should', 'must', 'shall'];\n    return reqKeywords.some(keyword => content.includes(keyword));\n  }\n\n  private containsTaskKeywords(content: string): boolean {\n    const taskKeywords = ['todo', 'task', 'epic', 'story', 'ticket', 'issue', 'action item', 'deliverable', 'milestone'];\n    return taskKeywords.some(keyword => content.includes(keyword));\n  }\n\n  private containsArchitectureKeywords(content: string): boolean {\n    const archKeywords = ['architecture', 'design', 'technical decision', 'adr', 'component', 'service', 'api', 'database', 'infrastructure'];\n    return archKeywords.some(keyword => content.includes(keyword));\n  }\n\n  private containsFeatureKeywords(content: string): boolean {\n    const featureKeywords = ['feature', 'enhancement', 'functionality', 'capability', 'user interface', 'user experience', 'workflow'];\n    return featureKeywords.some(keyword => content.includes(keyword));\n  }\n\n  private hasStructuredFormat(content: string): boolean {\n    // Check for structured elements\n    const hasHeaders = /^#{1,6}\\s/.test(content);\n    const hasBullets = /^\\s*[-*+]\\s/.test(content);\n    const hasNumbering = /^\\s*\\d+\\.\\s/.test(content);\n    const hasCode = /```/.test(content) || /`[^`]+`/.test(content);\n    \n    return hasHeaders || hasBullets || hasNumbering || hasCode;\n  }\n\n  private extractKeywordsFromContent(content: string): string[] {\n    // Simple keyword extraction (could be enhanced with NLP)\n    const words = content.toLowerCase()\n      .replace(/[^\\w\\s]/g, ' ')\n      .split(/\\s+/)\n      .filter(word => word.length > 3)\n      .filter(word => !['this', 'that', 'with', 'from', 'they', 'will', 'have', 'been', 'were', 'said', 'each', 'which', 'their', 'time', 'would', 'there', 'could', 'other'].includes(word));\n    \n    // Count frequency and return top keywords\n    const frequency = new Map<string, number>();\n    words.forEach(word => {\n      frequency.set(word, (frequency.get(word) || 0) + 1);\n    });\n    \n    return Array.from(frequency.entries())\n      .sort((a, b) => b[1] - a[1])\n      .slice(0, 10)\n      .map(([word]) => word);\n  }\n\n  private assessDocumentMaturity(content: string): 'draft' | 'partial' | 'complete' | 'outdated' {\n    const lines = content.split('\\n').filter(line => line.trim().length > 0);\n    const totalLength = content.length;\n    \n    // Check for draft indicators\n    if (content.toLowerCase().includes('draft') || content.toLowerCase().includes('todo') || content.toLowerCase().includes('wip')) {\n      return 'draft';\n    }\n    \n    // Check for completeness indicators\n    if (totalLength < 500 || lines.length < 10) {\n      return 'partial';\n    }\n    \n    // Check for outdated indicators\n    const dateRegex = /\\b(20\\d{2})\\b/g;\n    const dates = content.match(dateRegex);\n    if (dates) {\n      const years = dates.map(date => parseInt(date));\n      const oldestYear = Math.min(...years);\n      const currentYear = new Date().getFullYear();\n      if (currentYear - oldestYear > 2) {\n        return 'outdated';\n      }\n    }\n    \n    return 'complete';\n  }\n\n  private calculateStrategicRelevance(content: string, themes: string[]): number {\n    let relevance = 0;\n    \n    // Base relevance from themes\n    const strategicThemes = ['strategic-planning', 'objectives', 'requirements', 'architecture'];\n    const strategicThemeCount = themes.filter(theme => strategicThemes.includes(theme)).length;\n    relevance += strategicThemeCount * 0.3;\n    \n    // Content-based relevance\n    const strategicWords = ['strategic', 'important', 'critical', 'priority', 'business', 'value', 'impact', 'outcome'];\n    const strategicWordCount = strategicWords.filter(word => content.includes(word)).length;\n    relevance += Math.min(strategicWordCount * 0.1, 0.4);\n    \n    return Math.min(relevance, 1.0);\n  }\n\n  private generateSuggestedTitle(filename: string, content: string, documentType: string): string {\n    // Try to extract title from first heading\n    const headingMatch = content.match(/^#\\s+(.+)$/m);\n    if (headingMatch) {\n      return headingMatch[1].trim();\n    }\n    \n    // Generate from filename and type\n    const baseName = filename.replace(/\\.(md|txt|rst|adoc)$/i, '');\n    const typePrefix = documentType === 'vision' ? 'Vision:' : \n                      documentType === 'prd' ? 'Requirements:' :\n                      documentType === 'adr' ? 'Architecture:' : '';\n    \n    return typePrefix ? `${typePrefix} ${baseName}` : baseName;\n  }\n\n  private generateContentSummary(content: string, themes: string[]): string {\n    const firstSentence = content.split('.')[0]?.trim();\n    const themesText = themes.length > 0 ? ` Covers: ${themes.join(', ')}` : '';\n    return `${firstSentence || 'Content summary'}.${themesText}`;\n  }\n\n  // .gitignore support helpers\n  private async loadGitignorePatterns(projectPath: string): Promise<Set<string>> {\n    try {\n      const { readFile } = await import('node:fs/promises');\n      const { join } = await import('node:path');\n      \n      const gitignorePatterns = new Set<string>();\n      \n      // Add default ignore patterns\n      gitignorePatterns.add('.git');\n      gitignorePatterns.add('node_modules');\n      gitignorePatterns.add('.DS_Store');\n      gitignorePatterns.add('*.log');\n      gitignorePatterns.add('dist');\n      gitignorePatterns.add('build');\n      gitignorePatterns.add('coverage');\n      gitignorePatterns.add('.next');\n      gitignorePatterns.add('.cache');\n      \n      // Load .gitignore file if it exists\n      try {\n        const gitignorePath = join(projectPath, '.gitignore');\n        const gitignoreContent = await readFile(gitignorePath, 'utf8');\n        \n        gitignoreContent.split('\\n')\n          .map(line => line.trim())\n          .filter(line => line && !line.startsWith('#'))\n          .forEach(pattern => {\n            gitignorePatterns.add(pattern);\n          });\n        \n        logger.info(`Loaded ${gitignorePatterns.size} .gitignore patterns for ${projectPath}`);\n      } catch {\n        // .gitignore doesn't exist, use defaults\n        logger.info(`No .gitignore found, using default patterns for ${projectPath}`);\n      }\n      \n      return gitignorePatterns;\n    } catch (error) {\n      logger.error('Error loading .gitignore patterns:', error);\n      return new Set(['.git', 'node_modules', '.DS_Store', '*.log', 'dist', 'build']);\n    }\n  }\n\n  private shouldIgnoreFile(filePath: string, patterns: Set<string>, projectPath: string): boolean {\n    try {\n      const { relative } = require('node:path');\n      const relativePath = relative(projectPath, filePath);\n      \n      for (const pattern of patterns) {\n        // Simple pattern matching (handles most common .gitignore patterns)\n        if (pattern.endsWith('*')) {\n          const prefix = pattern.slice(0, -1);\n          if (relativePath.startsWith(prefix)) return true;\n        } else if (pattern.startsWith('*.')) {\n          const extension = pattern.slice(1);\n          if (filePath.endsWith(extension)) return true;\n        } else if (pattern.endsWith('/')) {\n          // Directory pattern\n          const dirPattern = pattern.slice(0, -1);\n          if (relativePath.startsWith(dirPattern + '/') || relativePath === dirPattern) return true;\n        } else if (relativePath === pattern || relativePath.startsWith(pattern + '/')) {\n          return true;\n        }\n      }\n      \n      return false;\n    } catch {\n      return false;\n    }\n  }\n\n  private async importFromCodeAnnotations(\n    projectId: string,\n    projectPath: string,\n    existingTypes: Set<string>\n  ): Promise<{ imported: number; skipped: number; errors: string[] }> {\n    const results = { imported: 0, skipped: 0, errors: [] };\n    \n    try {\n      const { access, readdir, readFile } = await import('node:fs/promises');\n      const { join, extname } = await import('node:path');\n      \n      const srcPath = join(projectPath, 'src');\n      await access(srcPath);\n      const codeFiles = await readdir(srcPath, { recursive: true });\n      \n      let todoAnnotations: string[] = [];\n      let strategyAnnotations: string[] = [];\n      let visionAnnotations: string[] = [];\n      \n      for (const file of codeFiles.slice(0, 100)) { // Limit for performance\n        if (typeof file === 'string' && ['.ts', '.tsx', '.js', '.jsx'].includes(extname(file))) {\n          try {\n            const filePath = join(srcPath, file);\n            const content = await readFile(filePath, 'utf8');\n            \n            // Extract different types of strategic annotations\n            const todoMatches = content.match(/\\/\\/\\s*TODO[:\\s]*(.*)|\\/\\*\\s*TODO[:\\s]*(.*?)\\*\\//gi) || [];\n            const strategyMatches = content.match(/\\/\\/\\s*STRATEGY[:\\s]*(.*)|\\/\\*\\s*STRATEGY[:\\s]*(.*?)\\*\\//gi) || [];\n            const visionMatches = content.match(/\\/\\/\\s*VISION[:\\s]*(.*)|\\/\\*\\s*VISION[:\\s]*(.*?)\\*\\//gi) || [];\n            \n            todoAnnotations.push(...todoMatches.map(match => `${file}: ${match.trim()}`));\n            strategyAnnotations.push(...strategyMatches.map(match => `${file}: ${match.trim()}`));\n            visionAnnotations.push(...visionMatches.map(match => `${file}: ${match.trim()}`));\n          } catch {\n            // Skip files we can't read\n          }\n        }\n      }\n      \n      // Create documents from code annotations if we have enough content\n      const annotationDocs = [\n        { type: 'epic', content: todoAnnotations, title: 'Code TODOs and Tasks' },\n        { type: 'strategy', content: strategyAnnotations, title: 'Strategic Code Annotations' },\n        { type: 'vision', content: visionAnnotations, title: 'Vision Code Annotations' }\n      ];\n      \n      for (const annotationDoc of annotationDocs) {\n        if (annotationDoc.content.length > 0 && !existingTypes.has(annotationDoc.type)) {\n          const docData = {\n            type: annotationDoc.type,\n            title: `${annotationDoc.title} - ${projectId}`,\n            summary: `Extracted from code annotations: ${annotationDoc.content.length} items`,\n            content: annotationDoc.content.join('\\n'),\n            author: 'code-annotation-service',\n            project_id: projectId,\n            status: 'draft' as const,\n            priority: 'low' as const,\n            keywords: [],\n            tags: [annotationDoc.type, 'code-annotations', 'extracted'],\n            metadata: {\n              annotation_count: annotationDoc.content.length,\n              extraction_date: new Date().toISOString(),\n              document_source: 'code_annotations'\n            },\n            version: '1.0',\n            dependencies: [],\n            related_documents: []\n          };\n\n          const createResult = await this.documentManager.createDocument(docData);\n          if (createResult.success) {\n            results.imported++;\n          } else {\n            results.errors.push(`Failed to import ${annotationDoc.type} annotations: ${createResult.error?.message}`);\n          }\n        }\n      }\n    } catch (error) {\n      if (error.code !== 'ENOENT') { // Don't error if src directory doesn't exist\n        results.errors.push(`Error importing code annotations: ${error.message}`);\n      }\n    }\n\n    return results;\n  }\n\n  private async saveToRepository(\n    projectId: string, \n    type: string, \n    content: any\n  ): Promise<string | undefined> {\n    // Only save specific document types back to repo\n    if (!['vision', 'strategy'].includes(type)) {\n      return undefined;\n    }\n    \n    try {\n      const { writeFile } = await import('node:fs/promises');\n      const { join } = await import('node:path');\n      \n      const filename = type === 'vision' ? 'VISION.md' : 'STRATEGY.md';\n      const projectPath = `/home/mhugo/code/${projectId}`;\n      const filePath = join(projectPath, filename);\n      \n      const fileContent = `# ${content.title}\\n\\n${content.summary}\\n\\n${content.content}`;\n      await writeFile(filePath, fileContent, 'utf8');\n      \n      logger.info(`Saved ${type} document to repository: ${filePath}`);\n      return filePath;\n    } catch (error) {\n      logger.error(`Error saving to repository:`, error);\n      return undefined;\n    }\n  }\n\n  private calculateConfidenceScore(documents: BaseDocumentEntity[]): number {\n    let score = 0;\n    \n    // Base score for having documents\n    score += Math.min(0.3, documents.length * 0.1);\n    \n    // Bonus for structured documents\n    if (documents.some(doc => doc.type === 'vision')) score += 0.3;\n    if (documents.some(doc => doc.type === 'prd')) score += 0.2;\n    if (documents.some(doc => doc.type === 'epic')) score += 0.1;\n    \n    // Bonus for complete metadata\n    const hasMetadata = documents.some(doc => \n      doc.metadata && Object.keys(doc.metadata).length > 3\n    );\n    if (hasMetadata) score += 0.1;\n    \n    return Math.min(1.0, score);\n  }\n\n  private createDefaultVisionAnalysis(projectId: string): StrategicVisionAnalysis {\n    return {\n      projectId,\n      missionStatement: \"No structured vision documents found - import documents to get detailed analysis\",\n      strategicGoals: [],\n      businessValue: 0.3,\n      technicalImpact: 0.3,\n      marketPosition: \"Not analyzed - no vision documents\",\n      targetOutcome: \"Import strategic documents for analysis\",\n      keyMetrics: [],\n      stakeholders: [],\n      timeline: \"Timeline not available\",\n      risks: [\"No strategic documentation\"],\n      confidenceScore: 0.1,\n      sourceDocuments: [],\n      lastAnalyzed: new Date()\n    };\n  }\n\n  private createErrorVisionAnalysis(projectId: string, error: any): StrategicVisionAnalysis {\n    return {\n      projectId,\n      missionStatement: \"Analysis failed - check system logs\",\n      strategicGoals: [],\n      businessValue: 0,\n      technicalImpact: 0,\n      marketPosition: \"Analysis error\",\n      targetOutcome: \"Fix analysis errors\",\n      keyMetrics: [],\n      stakeholders: [],\n      timeline: \"Unknown due to analysis error\",\n      risks: [\"Analysis system error\", error.message],\n      confidenceScore: 0,\n      sourceDocuments: [],\n      lastAnalyzed: new Date()\n    };\n  }\n\n  private async getCachedAnalysis(projectId: string): Promise<StrategicVisionAnalysis | null> {\n    // TODO: Implement caching mechanism (could use memory backend)\n    return null;\n  }\n\n  private async cacheAnalysis(analysis: StrategicVisionAnalysis): Promise<void> {\n    // TODO: Implement caching mechanism\n  }\n\n  private isAnalysisRecent(analysis: StrategicVisionAnalysis): boolean {\n    const hoursSinceAnalysis = (Date.now() - analysis.lastAnalyzed.getTime()) / (1000 * 60 * 60);\n    return hoursSinceAnalysis < 4; // Cache for 4 hours\n  }\n}\n\nexport default StrategicVisionService;"],
  "mappings": "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",
  "names": []
}
