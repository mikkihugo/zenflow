{
  "version": 3,
  "sources": ["../../src/fact-integration/rust-fact-bridge.ts"],
  "sourcesContent": ["/**\n * Bridge to integrate Rust FACT core with TypeScript workspace system\n * \n * This replaces the TypeScript FACT implementation with the high-performance\n * Rust FACT core via Node.js bindings or CLI interface.\n */\n\nimport { spawn, ChildProcess } from 'child_process';\nimport { join } from 'path';\nimport { EventEmitter } from 'events';\n\nexport interface RustFactConfig {\n  /** Path to the Rust FACT binary */\n  binaryPath?: string;\n  /** Cache size in bytes */\n  cacheSize?: number;\n  /** Processing timeout in milliseconds */\n  timeout?: number;\n  /** Enable performance monitoring */\n  monitoring?: boolean;\n}\n\nexport interface FactProcessingRequest {\n  /** Template ID to use */\n  templateId: string;\n  /** Context data to process */\n  context: Record<string, any>;\n  /** Processing options */\n  options?: {\n    timeout?: number;\n    priority?: 'low' | 'normal' | 'high' | 'critical';\n    noCache?: boolean;\n  };\n}\n\nexport interface FactProcessingResult {\n  templateId: string;\n  templateName: string;\n  result: any;\n  metadata: {\n    processedAt: string;\n    priority: string;\n    processingTimeMs: number;\n    cacheHit: boolean;\n  };\n}\n\nexport interface FactCacheStats {\n  entries: number;\n  hits: number;\n  misses: number;\n  hitRate: number;\n  memoryUsage: number;\n}\n\n/**\n * Bridge to high-performance Rust FACT core\n */\nexport class RustFactBridge extends EventEmitter {\n  private config: RustFactConfig;\n  private binaryPath: string;\n  private isInitialized = false;\n\n  constructor(config: RustFactConfig = {}) {\n    super();\n    this.config = {\n      binaryPath: join(__dirname, '../../fact-core/target/release/fact-core'),\n      cacheSize: 100 * 1024 * 1024, // 100MB\n      timeout: 30000, // 30 seconds\n      monitoring: true,\n      ...config,\n    };\n    this.binaryPath = this.config.binaryPath!;\n  }\n\n  /**\n   * Initialize the Rust FACT system\n   */\n  async initialize(): Promise<void> {\n    if (this.isInitialized) {\n      return;\n    }\n\n    // Verify binary exists and is executable\n    try {\n      const testResult = await this.executeCommand('--version');\n      console.log(`Rust FACT initialized: ${testResult.stdout.trim()}`);\n      this.isInitialized = true;\n    } catch (error) {\n      throw new Error(`Failed to initialize Rust FACT: ${error}`);\n    }\n  }\n\n  /**\n   * Process data using a Rust FACT template\n   */\n  async process(request: FactProcessingRequest): Promise<FactProcessingResult> {\n    if (!this.isInitialized) {\n      await this.initialize();\n    }\n\n    const command = 'process';\n    const args = [\n      '--template', request.templateId,\n      '--context', JSON.stringify(request.context),\n    ];\n\n    // Add optional parameters\n    if (request.options?.timeout) {\n      args.push('--timeout', request.options.timeout.toString());\n    }\n    if (request.options?.priority) {\n      args.push('--priority', request.options.priority);\n    }\n    if (request.options?.noCache) {\n      args.push('--no-cache');\n    }\n\n    try {\n      const result = await this.executeCommand(command, args);\n      const output = JSON.parse(result.stdout);\n      \n      this.emit('processed', {\n        templateId: request.templateId,\n        success: true,\n        processingTime: output.metadata?.processingTimeMs || 0,\n      });\n\n      return output as FactProcessingResult;\n    } catch (error) {\n      this.emit('error', {\n        templateId: request.templateId,\n        error: error instanceof Error ? error.message : 'Unknown error',\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Process version-specific tool knowledge\n   */\n  async processToolKnowledge(\n    toolName: string, \n    version: string, \n    knowledgeType: 'docs' | 'snippets' | 'examples' | 'best-practices' = 'docs'\n  ): Promise<{\n    tool: string;\n    version: string;\n    knowledgeType: string;\n    documentation?: string;\n    snippets?: Array<{ title: string; code: string; description: string }>;\n    examples?: Array<{ title: string; code: string; explanation: string }>;\n    bestPractices?: Array<{ practice: string; rationale: string }>;\n    troubleshooting?: Array<{ issue: string; solution: string }>;\n  }> {\n    return this.process({\n      templateId: 'tool-knowledge-extraction',\n      context: {\n        tool: toolName,\n        version,\n        knowledgeType,\n        // Include version-specific context\n        versionedSubject: `${toolName}@${version}`,\n      },\n    });\n  }\n\n  /**\n   * Process project environment analysis\n   */\n  async analyzeEnvironment(environmentData: {\n    tools: Array<{ name: string; version?: string; available: boolean }>;\n    dependencies: Array<{ name: string; version: string; source: string }>;\n    projectType: string;\n    buildSystems: string[];\n    languages: string[];\n  }): Promise<{\n    toolCompatibility: Record<string, 'compatible' | 'warning' | 'incompatible'>;\n    suggestedVersions: Record<string, string>;\n    environmentHealth: number; // 0-1 score\n    recommendations: Array<{\n      type: 'upgrade' | 'install' | 'configure' | 'warning';\n      tool: string;\n      message: string;\n      priority: 'low' | 'medium' | 'high';\n    }>;\n  }> {\n    return this.process({\n      templateId: 'environment-analysis',\n      context: environmentData,\n    });\n  }\n\n  /**\n   * Get cache statistics from Rust FACT\n   */\n  async getCacheStats(): Promise<FactCacheStats> {\n    const result = await this.executeCommand('cache-stats');\n    return JSON.parse(result.stdout);\n  }\n\n  /**\n   * Clear the cache\n   */\n  async clearCache(): Promise<void> {\n    await this.executeCommand('clear-cache');\n    this.emit('cache-cleared');\n  }\n\n  /**\n   * List available templates\n   */\n  async listTemplates(): Promise<Array<{\n    id: string;\n    name: string;\n    description: string;\n    tags: string[];\n    performance: {\n      avgExecutionTimeMs: number;\n      memoryUsageBytes: number;\n      complexity: number;\n    };\n  }>> {\n    const result = await this.executeCommand('list-templates');\n    return JSON.parse(result.stdout);\n  }\n\n  /**\n   * Search templates by tags\n   */\n  async searchTemplates(tags: string[]): Promise<Array<{\n    id: string;\n    name: string;\n    description: string;\n    relevanceScore: number;\n  }>> {\n    const result = await this.executeCommand('search-templates', [\n      '--tags', tags.join(',')\n    ]);\n    return JSON.parse(result.stdout);\n  }\n\n  /**\n   * Execute a command with the Rust FACT binary\n   */\n  private executeCommand(command: string, args: string[] = []): Promise<{\n    stdout: string;\n    stderr: string;\n    code: number;\n  }> {\n    return new Promise((resolve, reject) => {\n      const fullArgs = [command, ...args];\n      const child = spawn(this.binaryPath, fullArgs, {\n        stdio: 'pipe',\n        timeout: this.config.timeout,\n      });\n\n      let stdout = '';\n      let stderr = '';\n\n      child.stdout?.on('data', (data) => {\n        stdout += data.toString();\n      });\n\n      child.stderr?.on('data', (data) => {\n        stderr += data.toString();\n      });\n\n      child.on('close', (code) => {\n        if (code === 0) {\n          resolve({ stdout, stderr, code: code || 0 });\n        } else {\n          reject(new Error(`Rust FACT process exited with code ${code}: ${stderr}`));\n        }\n      });\n\n      child.on('error', (error) => {\n        reject(new Error(`Failed to spawn Rust FACT process: ${error.message}`));\n      });\n    });\n  }\n\n  /**\n   * Shutdown the bridge\n   */\n  async shutdown(): Promise<void> {\n    // Cleanup if needed\n    this.emit('shutdown');\n  }\n}\n\n/**\n * Singleton instance for global access\n */\nlet globalRustFactBridge: RustFactBridge | null = null;\n\nexport function getRustFactBridge(config?: RustFactConfig): RustFactBridge {\n  if (!globalRustFactBridge) {\n    globalRustFactBridge = new RustFactBridge(config);\n  }\n  return globalRustFactBridge;\n}\n\nexport default RustFactBridge;"],
  "mappings": "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",
  "names": []
}
