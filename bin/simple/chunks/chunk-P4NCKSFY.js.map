{
  "version": 3,
  "sources": ["../../src/database/base.dao.ts"],
  "sourcesContent": ["/**\n * Unified Data Access Layer (DAL) - Base Repository Implementation.\n *\n * Provides the base implementation for all repository types, with adapter pattern.\n * To support different underlying database technologies.\n */\n/**\n * @file Database layer: base.dao.\n */\n\nimport type {\n  CustomQuery,\n  DatabaseMetadata,\n  SortCriteria,\n  TransactionOperation,\n} from '../database/interfaces.ts';\nimport type { HealthStatus } from '../types/health-types';\nimport type { PerformanceMetrics } from '../types/performance-types';\nimport type { IDataAccessObject, IRepository, QueryOptions } from './interfaces.ts';\n\n// Create a simple logger interface to avoid import issues\ninterface ILogger {\n  debug(message: string, meta?: any): void;\n  info(message: string, meta?: any): void;\n  warn(message: string, meta?: any): void;\n  error(message: string, meta?: any): void;\n}\n\n// Create a simple database adapter interface\ninterface DatabaseAdapter {\n  query(sql: string, params?: any[]): Promise<{ rows: any[]; rowCount: number }>;\n  execute(sql: string, params?: any[]): Promise<{ affectedRows: number; insertId?: any }>;\n  transaction<T>(fn: (tx: any) => Promise<T>): Promise<T>;\n  getSchema?(): Promise<any>;\n}\n\n/**\n * Base repository implementation that adapts to different database types.\n *\n * @template T The entity type this repository manages.\n * @example\n */\nexport abstract class BaseDao<T> implements IRepository<T> {\n  protected constructor(\n    protected adapter: DatabaseAdapter,\n    protected logger: ILogger,\n    protected tableName: string,\n    protected entitySchema?: Record<string, any>\n  ) {}\n\n  /**\n   * Abstract methods that must be implemented by subclasses.\n   */\n  protected abstract mapRowToEntity(row: any): T;\n  protected abstract mapEntityToRow(entity: Partial<T>): Record<string, any>;\n\n  /**\n   * Find entity by ID.\n   *\n   * @param id\n   */\n  async findById(id: string | number): Promise<T | null> {\n    this.logger.debug(`Finding entity by ID: ${id} in table: ${this.tableName}`);\n\n    try {\n      const query = this.buildFindByIdQuery(id);\n      const result = await this.adapter.query(query.sql, query.params);\n\n      if (result?.rowCount === 0) {\n        return null;\n      }\n\n      return this.mapRowToEntity(result?.rows?.[0]);\n    } catch (error) {\n      this.logger.error(`Failed to find entity by ID: ${error}`);\n      throw new Error(\n        `Find by ID failed: ${error instanceof Error ? error.message : 'Unknown error'}`\n      );\n    }\n  }\n\n  /**\n   * Find entities by criteria.\n   *\n   * @param criteria\n   * @param options\n   */\n  async findBy(criteria: Partial<T>, options?: QueryOptions): Promise<T[]> {\n    this.logger.debug(`Finding entities by criteria in table: ${this.tableName}`, {\n      criteria,\n      options,\n    });\n\n    try {\n      const query = this.buildFindByQuery(criteria, options);\n      const result = await this.adapter.query(query.sql, query.params);\n\n      return result?.rows.map((row) => this.mapRowToEntity(row));\n    } catch (error) {\n      this.logger.error(`Failed to find entities by criteria: ${error}`);\n      throw new Error(\n        `Find by criteria failed: ${error instanceof Error ? error.message : 'Unknown error'}`\n      );\n    }\n  }\n\n  /**\n   * Find all entities.\n   *\n   * @param options\n   */\n  async findAll(options?: QueryOptions): Promise<T[]> {\n    this.logger.debug(`Finding all entities in table: ${this.tableName}`, {\n      options,\n    });\n\n    try {\n      const query = this.buildFindAllQuery(options);\n      const result = await this.adapter.query(query.sql, query.params);\n\n      return result?.rows.map((row) => this.mapRowToEntity(row));\n    } catch (error) {\n      this.logger.error(`Failed to find all entities: ${error}`);\n      throw new Error(\n        `Find all failed: ${error instanceof Error ? error.message : 'Unknown error'}`\n      );\n    }\n  }\n\n  /**\n   * Create a new entity.\n   *\n   * @param entity\n   */\n  async create(entity: Omit<T, 'id'>): Promise<T> {\n    this.logger.debug(`Creating new entity in table: ${this.tableName}`, {\n      entity,\n    });\n\n    try {\n      const query = this.buildCreateQuery(entity);\n      const result = await this.adapter.query(query.sql, query.params);\n\n      // For most databases, we need to fetch the created entity\n      if (result?.rows && result?.rows.length > 0) {\n        return this.mapRowToEntity(result?.rows?.[0]);\n      }\n\n      // Fallback: assume auto-generated ID and fetch the entity\n      const createdId = result?.rows?.[0]?.id || result?.rows?.[0]?.insertId;\n      if (createdId) {\n        const created = await this.findById(createdId);\n        if (created) {\n          return created;\n        }\n      }\n\n      throw new Error('Failed to retrieve created entity');\n    } catch (error) {\n      this.logger.error(`Failed to create entity: ${error}`);\n      throw new Error(`Create failed: ${error instanceof Error ? error.message : 'Unknown error'}`);\n    }\n  }\n\n  /**\n   * Update an existing entity.\n   *\n   * @param id\n   * @param updates\n   */\n  async update(id: string | number, updates: Partial<T>): Promise<T> {\n    this.logger.debug(`Updating entity ${id} in table: ${this.tableName}`, {\n      updates,\n    });\n\n    try {\n      const query = this.buildUpdateQuery(id, updates);\n      await this.adapter.query(query.sql, query.params);\n\n      // Fetch the updated entity\n      const updated = await this.findById(id);\n      if (!updated) {\n        throw new Error('Entity not found after update');\n      }\n\n      return updated;\n    } catch (error) {\n      this.logger.error(`Failed to update entity: ${error}`);\n      throw new Error(`Update failed: ${error instanceof Error ? error.message : 'Unknown error'}`);\n    }\n  }\n\n  /**\n   * Delete an entity by ID.\n   *\n   * @param id\n   */\n  async delete(id: string | number): Promise<boolean> {\n    this.logger.debug(`Deleting entity ${id} from table: ${this.tableName}`);\n\n    try {\n      const query = this.buildDeleteQuery(id);\n      const result = await this.adapter.query(query.sql, query.params);\n\n      return result?.rowCount > 0;\n    } catch (error) {\n      this.logger.error(`Failed to delete entity: ${error}`);\n      throw new Error(`Delete failed: ${error instanceof Error ? error.message : 'Unknown error'}`);\n    }\n  }\n\n  /**\n   * Count entities matching criteria.\n   *\n   * @param criteria\n   */\n  async count(criteria?: Partial<T>): Promise<number> {\n    this.logger.debug(`Counting entities in table: ${this.tableName}`, {\n      criteria,\n    });\n\n    try {\n      const query = this.buildCountQuery(criteria);\n      const result = await this.adapter.query(query.sql, query.params);\n\n      return result?.rows?.[0]?.count || 0;\n    } catch (error) {\n      this.logger.error(`Failed to count entities: ${error}`);\n      throw new Error(`Count failed: ${error instanceof Error ? error.message : 'Unknown error'}`);\n    }\n  }\n\n  /**\n   * Check if entity exists.\n   *\n   * @param id\n   */\n  async exists(id: string | number): Promise<boolean> {\n    this.logger.debug(`Checking if entity ${id} exists in table: ${this.tableName}`);\n\n    try {\n      const entity = await this.findById(id);\n      return entity !== null;\n    } catch (error) {\n      this.logger.error(`Failed to check entity existence: ${error}`);\n      return false;\n    }\n  }\n\n  /**\n   * Execute custom query specific to the underlying database.\n   *\n   * @param query\n   */\n  async executeCustomQuery<R = any>(query: CustomQuery): Promise<R> {\n    this.logger.debug(`Executing custom query: ${query.type}`);\n\n    try {\n      let sql: string;\n      let params: any[] = [];\n\n      if (typeof query.query === 'string') {\n        sql = query.query;\n        params = Object.values(query.parameters || {});\n      } else {\n        // Handle object-based queries (could be extended for different DB types)\n        sql = JSON.stringify(query.query);\n        params = Object.values(query.parameters || {});\n      }\n\n      const result = await this.adapter.query(sql, params);\n      return result as R;\n    } catch (error) {\n      this.logger.error(`Custom query failed: ${error}`);\n      throw new Error(\n        `Custom query failed: ${error instanceof Error ? error.message : 'Unknown error'}`\n      );\n    }\n  }\n\n  /**\n   * Query building methods.\n   *\n   * @param id\n   */\n  protected buildFindByIdQuery(id: string | number): {\n    sql: string;\n    params: any[];\n  } {\n    return {\n      sql: `SELECT * FROM ${this.tableName} WHERE id = ?`,\n      params: [id],\n    };\n  }\n\n  protected buildFindByQuery(\n    criteria: Partial<T>,\n    options?: QueryOptions\n  ): { sql: string; params: any[] } {\n    const mappedCriteria = this.mapEntityToRow(criteria);\n    const whereClause = this.buildWhereClause(mappedCriteria);\n    const orderClause = this.buildOrderClause(options?.['sort']);\n    const limitClause = this.buildLimitClause(options?.['limit'], options?.['offset']);\n\n    const sql =\n      `SELECT * FROM ${this.tableName} ${whereClause} ${orderClause} ${limitClause}`.trim();\n    const params = Object.values(mappedCriteria);\n\n    return { sql, params };\n  }\n\n  protected buildFindAllQuery(options?: QueryOptions): {\n    sql: string;\n    params: any[];\n  } {\n    const orderClause = this.buildOrderClause(options?.['sort']);\n    const limitClause = this.buildLimitClause(options?.['limit'], options?.['offset']);\n\n    const sql = `SELECT * FROM ${this.tableName} ${orderClause} ${limitClause}`.trim();\n\n    return { sql, params: [] };\n  }\n\n  protected buildCreateQuery(entity: Omit<T, 'id'>): {\n    sql: string;\n    params: any[];\n  } {\n    const mappedEntity = this.mapEntityToRow(entity as Partial<T>);\n    const columns = Object.keys(mappedEntity).join(', ');\n    const placeholders = Object.keys(mappedEntity)\n      .map(() => '?')\n      .join(', ');\n\n    const sql = `INSERT INTO ${this.tableName} (${columns}) VALUES (${placeholders})`;\n    const params = Object.values(mappedEntity);\n\n    return { sql, params };\n  }\n\n  protected buildUpdateQuery(\n    id: string | number,\n    updates: Partial<T>\n  ): { sql: string; params: any[] } {\n    const mappedUpdates = this.mapEntityToRow(updates);\n    const setClause = Object.keys(mappedUpdates)\n      .map((column) => `${column} = ?`)\n      .join(', ');\n\n    const sql = `UPDATE ${this.tableName} SET ${setClause} WHERE id = ?`;\n    const params = [...Object.values(mappedUpdates), id];\n\n    return { sql, params };\n  }\n\n  protected buildDeleteQuery(id: string | number): {\n    sql: string;\n    params: any[];\n  } {\n    return {\n      sql: `DELETE FROM ${this.tableName} WHERE id = ?`,\n      params: [id],\n    };\n  }\n\n  protected buildCountQuery(criteria?: Partial<T>): {\n    sql: string;\n    params: any[];\n  } {\n    if (!criteria || Object.keys(criteria).length === 0) {\n      return {\n        sql: `SELECT COUNT(*) as count FROM ${this.tableName}`,\n        params: [],\n      };\n    }\n\n    const mappedCriteria = this.mapEntityToRow(criteria);\n    const whereClause = this.buildWhereClause(mappedCriteria);\n\n    const sql = `SELECT COUNT(*) as count FROM ${this.tableName} ${whereClause}`;\n    const params = Object.values(mappedCriteria);\n\n    return { sql, params };\n  }\n\n  protected buildWhereClause(criteria: Record<string, any>): string {\n    if (Object.keys(criteria).length === 0) {\n      return '';\n    }\n\n    const conditions = Object.keys(criteria).map((column) => `${column} = ?`);\n    return `WHERE ${conditions.join(' AND ')}`;\n  }\n\n  protected buildOrderClause(sortCriteria?: SortCriteria[]): string {\n    if (!sortCriteria || sortCriteria.length === 0) {\n      return '';\n    }\n\n    const orderBy = sortCriteria\n      .map((sort) => `${sort.field} ${sort.direction.toUpperCase()}`)\n      .join(', ');\n\n    return `ORDER BY ${orderBy}`;\n  }\n\n  protected buildLimitClause(limit?: number, offset?: number): string {\n    if (!limit) {\n      return '';\n    }\n\n    if (offset) {\n      return `LIMIT ${limit} OFFSET ${offset}`;\n    }\n\n    return `LIMIT ${limit}`;\n  }\n}\n\n/**\n * Base Data Access Object implementation that wraps a repository.\n *\n * @template T The entity type.\n * @example\n */\nexport abstract class BaseManager<T> implements IDataAccessObject<T> {\n  protected constructor(\n    protected repository: IRepository<T>,\n    protected adapter: DatabaseAdapter,\n    protected logger: ILogger\n  ) {}\n\n  /**\n   * Get repository for basic CRUD operations.\n   */\n  getRepository(): IRepository<T> {\n    return this.repository;\n  }\n\n  /**\n   * Execute transaction with multiple operations.\n   *\n   * @param operations\n   */\n  async executeTransaction<R>(operations: TransactionOperation[]): Promise<R> {\n    this.logger.debug(`Executing transaction with ${operations.length} operations`);\n\n    try {\n      return await this.adapter.transaction(async (_tx) => {\n        const results: any[] = [];\n\n        for (const operation of operations) {\n          let result: any;\n\n          switch (operation.type) {\n            case 'create':\n              if (operation.data && operation.entityType) {\n                result = await this.repository.create(operation.data);\n              }\n              break;\n\n            case 'update':\n              if (operation.data?.id && operation.data) {\n                const { id, ...updates } = operation.data;\n                result = await this.repository.update(id, updates);\n              }\n              break;\n\n            case 'delete':\n              if (operation.data?.id) {\n                result = await this.repository.delete(operation.data.id);\n              }\n              break;\n\n            case 'custom':\n              if (operation.customQuery) {\n                result = await this.repository.executeCustomQuery(operation.customQuery);\n              }\n              break;\n\n            default:\n              throw new Error(`Unsupported operation type: ${operation.type}`);\n          }\n\n          results.push(result);\n        }\n\n        return results as R;\n      });\n    } catch (error) {\n      this.logger.error(`Transaction failed: ${error}`);\n      throw new Error(\n        `Transaction failed: ${error instanceof Error ? error.message : 'Unknown error'}`\n      );\n    }\n  }\n\n  /**\n   * Get database-specific metadata.\n   */\n  async getMetadata(): Promise<DatabaseMetadata> {\n    this.logger.debug('Getting database metadata');\n\n    try {\n      const schema = this.adapter.getSchema ? await this.adapter.getSchema() : {};\n\n      return {\n        type: this.getDatabaseType(),\n        version: schema.version || '1.0.0',\n        features: this.getSupportedFeatures(),\n        schema: schema,\n        config: this.getConfiguration(),\n      };\n    } catch (error) {\n      this.logger.error(`Failed to get database metadata: ${error}`);\n      throw new Error(\n        `Get metadata failed: ${error instanceof Error ? error.message : 'Unknown error'}`\n      );\n    }\n  }\n\n  /**\n   * Perform health check.\n   */\n  async healthCheck(): Promise<HealthStatus> {\n    this.logger.debug('Performing health check');\n\n    try {\n      // Basic health check - try to count entities\n      const count = await this.repository.count();\n\n      return {\n        healthy: true,\n        score: 100,\n        details: {\n          entityCount: count,\n          accessible: true,\n        },\n        lastCheck: new Date(),\n      };\n    } catch (error) {\n      this.logger.error(`Health check failed: ${error}`);\n\n      return {\n        healthy: false,\n        score: 0,\n        details: {\n          accessible: false,\n          error: error instanceof Error ? error.message : 'Unknown error',\n        },\n        lastCheck: new Date(),\n        errors: [error instanceof Error ? error.message : 'Unknown error'],\n      };\n    }\n  }\n\n  /**\n   * Get performance metrics.\n   */\n  async getMetrics(): Promise<PerformanceMetrics> {\n    this.logger.debug('Getting performance metrics');\n\n    try {\n      return {\n        averageQueryTime: 0,\n        queriesPerSecond: 0,\n        connectionPool: {\n          active: 1,\n          idle: 0,\n          total: 1,\n          utilization: 100,\n        },\n        memoryUsage: {\n          used: 0,\n          total: 0,\n          percentage: 0,\n        },\n        custom: {\n          entityCount: await this.repository.count(),\n        },\n      };\n    } catch (error) {\n      this.logger.error(`Failed to get performance metrics: ${error}`);\n      throw new Error(\n        `Get metrics failed: ${error instanceof Error ? error.message : 'Unknown error'}`\n      );\n    }\n  }\n\n  /**\n   * Abstract methods for subclasses to implement.\n   */\n  protected abstract getDatabaseType(): DatabaseMetadata['type'];\n  protected abstract getSupportedFeatures(): string[];\n  protected abstract getConfiguration(): Record<string, any>;\n}\n"],
  "mappings": "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",
  "names": []
}
