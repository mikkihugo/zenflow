{
  "version": 3,
  "sources": ["../../src/database/dao/coordination.dao.ts"],
  "sourcesContent": ["/**\n * Coordination Repository Implementation.\n *\n * Specialized repository for coordination operations including.\n * Distributed locking, pub/sub messaging, and change notifications.\n */\n/**\n * @file Database layer: coordination.dao.\n */\n\nimport { EventEmitter } from 'node:events';\nimport type { DatabaseAdapter, ILogger } from '../../core/interfaces/base-interfaces.ts';\nimport { BaseDao } from '../base.dao.ts';\nimport type {\n  CoordinationChange,\n  CoordinationEvent,\n  CoordinationLock,\n  CoordinationStats,\n  CustomQuery,\n  ICoordinationRepository,\n} from '../interfaces.ts';\n\n/**\n * Subscription information.\n *\n * @example\n */\ninterface Subscription {\n  id: string;\n  pattern: string;\n  callback: (change: CoordinationChange<any>) => void;\n  createdAt: Date;\n  lastTriggered?: Date;\n  triggerCount: number;\n}\n\n/**\n * Lock information.\n *\n * @example\n */\ninterface LockInfo extends CoordinationLock {\n  timer?: NodeJS.Timeout;\n}\n\n/**\n * Coordination repository implementation with distributed coordination capabilities.\n *\n * @template T The entity type this repository manages.\n * @example\n */\nexport class CoordinationDao<T> extends BaseDao<T> implements ICoordinationRepository<T> {\n  private eventEmitter = new EventEmitter();\n  private locks = new Map<string, LockInfo>();\n  private subscriptions = new Map<string, Subscription>();\n  private publishedMessages = 0 as number;\n  private receivedMessages = 0 as number;\n  private startTime = Date.now();\n\n  constructor(\n    adapter: DatabaseAdapter,\n    logger: ILogger,\n    tableName: string,\n    entitySchema?: Record<string, any>\n  ) {\n    super(adapter, logger, tableName, entitySchema);\n\n    // Set up event emitter with increased listener limit for coordination\n    this.eventEmitter.setMaxListeners(1000);\n  }\n\n  /**\n   * Lock resource for coordination.\n   *\n   * @param resourceId\n   * @param lockTimeout\n   */\n  async acquireLock(resourceId: string, lockTimeout: number = 30000): Promise<CoordinationLock> {\n    this.logger.debug(`Acquiring lock for resource: ${resourceId}, timeout: ${lockTimeout}ms`);\n\n    const lockId = this.generateLockId(resourceId);\n    const existingLock = this.locks.get(resourceId);\n\n    // Check if resource is already locked\n    if (existingLock && existingLock.expiresAt > new Date()) {\n      throw new Error(`Resource ${resourceId} is already locked by ${existingLock.owner}`);\n    }\n\n    // Create new lock\n    const lock: CoordinationLock = {\n      id: lockId,\n      resourceId,\n      acquired: new Date(),\n      expiresAt: new Date(Date.now() + lockTimeout),\n      owner: this.generateOwnerIdentifier(),\n    };\n\n    // Set up automatic release timer\n    const timer = setTimeout(() => {\n      this.releaseLock(lockId).catch((error) => {\n        this.logger.warn(`Failed to auto-release lock ${lockId}: ${error}`);\n      });\n    }, lockTimeout);\n\n    const lockInfo: LockInfo = {\n      ...lock,\n      timer,\n    };\n\n    this.locks.set(resourceId, lockInfo);\n\n    // Persist lock to database for distributed coordination\n    try {\n      await this.persistLock(lockInfo);\n    } catch (error) {\n      this.logger.warn(`Failed to persist lock to database: ${error}`);\n    }\n\n    this.logger.debug(`Lock acquired: ${lockId} for resource: ${resourceId}`);\n    return lock;\n  }\n\n  /**\n   * Release lock.\n   *\n   * @param lockId\n   */\n  async releaseLock(lockId: string): Promise<void> {\n    this.logger.debug(`Releasing lock: ${lockId}`);\n\n    // Find lock by ID\n    let resourceId: string | null = null;\n    let lockInfo: LockInfo | null = null;\n\n    for (const [resource, lock] of this.locks.entries()) {\n      if (lock.id === lockId) {\n        resourceId = resource;\n        lockInfo = lock;\n        break;\n      }\n    }\n\n    if (!lockInfo || !resourceId) {\n      throw new Error(`Lock ${lockId} not found`);\n    }\n\n    // Clear timer\n    if (lockInfo.timer) {\n      clearTimeout(lockInfo.timer);\n    }\n\n    // Remove from memory\n    this.locks.delete(resourceId);\n\n    // Remove from database\n    try {\n      await this.removeLockFromDatabase(lockId);\n    } catch (error) {\n      this.logger.warn(`Failed to remove lock from database: ${error}`);\n    }\n\n    this.logger.debug(`Lock released: ${lockId}`);\n  }\n\n  /**\n   * Subscribe to changes.\n   *\n   * @param pattern\n   * @param callback\n   */\n  async subscribe(\n    pattern: string,\n    callback: (change: CoordinationChange<T>) => void\n  ): Promise<string> {\n    const subscriptionId = this.generateSubscriptionId();\n\n    this.logger.debug(`Creating subscription: ${subscriptionId} for pattern: ${pattern}`);\n\n    const subscription: Subscription = {\n      id: subscriptionId,\n      pattern,\n      callback,\n      createdAt: new Date(),\n      triggerCount: 0,\n    };\n\n    this.subscriptions.set(subscriptionId, subscription);\n\n    // Set up event listener\n    this.eventEmitter.on('change', (change: CoordinationChange<T>) => {\n      if (this.matchesPattern(change, pattern)) {\n        subscription.lastTriggered = new Date();\n        subscription.triggerCount++;\n\n        try {\n          callback(change);\n        } catch (error) {\n          this.logger.error(`Error in subscription callback ${subscriptionId}: ${error}`);\n        }\n      }\n    });\n\n    this.logger.debug(`Subscription created: ${subscriptionId}`);\n    return subscriptionId;\n  }\n\n  /**\n   * Unsubscribe from changes.\n   *\n   * @param subscriptionId\n   */\n  async unsubscribe(subscriptionId: string): Promise<void> {\n    this.logger.debug(`Unsubscribing: ${subscriptionId}`);\n\n    const subscription = this.subscriptions.get(subscriptionId);\n    if (!subscription) {\n      throw new Error(`Subscription ${subscriptionId} not found`);\n    }\n\n    this.subscriptions.delete(subscriptionId);\n\n    // Remove event listeners (EventEmitter doesn't provide easy way to remove specific listeners)\n    // In a production implementation, you'd want a more sophisticated event handling system\n\n    this.logger.debug(`Unsubscribed: ${subscriptionId}`);\n  }\n\n  /**\n   * Publish coordination event.\n   *\n   * @param channel\n   * @param event\n   */\n  async publish(channel: string, event: CoordinationEvent<T>): Promise<void> {\n    this.logger.debug(`Publishing event to channel: ${channel}`, { event });\n\n    try {\n      // Emit to local subscribers\n      this.eventEmitter.emit('event', { channel, event });\n\n      // Persist event for distributed coordination\n      await this.persistEvent(channel, event);\n\n      this.publishedMessages++;\n      this.logger.debug(`Event published to channel: ${channel}`);\n    } catch (error) {\n      this.logger.error(`Failed to publish event: ${error}`);\n      throw new Error(\n        `Publish failed: ${error instanceof Error ? error.message : 'Unknown error'}`\n      );\n    }\n  }\n\n  /**\n   * Get coordination statistics.\n   */\n  async getCoordinationStats(): Promise<CoordinationStats> {\n    return {\n      activeLocks: this.locks.size,\n      activeSubscriptions: this.subscriptions.size,\n      messagesPublished: this.publishedMessages,\n      messagesReceived: this.receivedMessages,\n      uptime: Date.now() - this.startTime,\n    };\n  }\n\n  /**\n   * Execute raw SQL/query - implements ICoordinationRepository interface.\n   *\n   * @param sql\n   * @param params\n   */\n  async execute(\n    sql: string,\n    params?: unknown[]\n  ): Promise<{ affectedRows?: number; insertId?: number }> {\n    try {\n      const result = await this.adapter.execute(sql, params);\n      return {\n        affectedRows: result.affectedRows,\n        insertId: result.insertId,\n      };\n    } catch (error) {\n      this.logger.error('Execute query failed:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Query database directly - implements ICoordinationRepository interface.\n   *\n   * @param sql\n   * @param params\n   */\n  async query(sql: string, params?: unknown[]): Promise<any[]> {\n    try {\n      const result = await this.adapter.query(sql, params);\n      return result.rows;\n    } catch (error) {\n      this.logger.error('Query failed:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Override base repository methods to add coordination events.\n   */\n\n  override async create(entity: Omit<T, 'id'>): Promise<T> {\n    const created = await super.create(entity);\n\n    // Emit change notification\n    await this.emitChange('create', (created as any).id, created);\n\n    return created;\n  }\n\n  override async update(id: string | number, updates: Partial<T>): Promise<T> {\n    const updated = await super.update(id, updates);\n\n    // Emit change notification\n    await this.emitChange('update', id, updated);\n\n    return updated;\n  }\n\n  override async delete(id: string | number): Promise<boolean> {\n    const deleted = await super.delete(id);\n\n    if (deleted) {\n      // Emit change notification\n      await this.emitChange('delete', id);\n    }\n\n    return deleted;\n  }\n\n  protected mapRowToEntity(row: any): T {\n    return row as T;\n  }\n\n  protected mapEntityToRow(entity: Partial<T>): Record<string, any> {\n    return entity as Record<string, any>;\n  }\n\n  /**\n   * Execute custom query - override to handle coordination-specific queries.\n   *\n   * @param customQuery\n   */\n  override async executeCustomQuery<R = any>(customQuery: CustomQuery): Promise<R> {\n    if (customQuery.type === 'coordination') {\n      const query = customQuery.query as any;\n\n      if (query.operation === 'acquire_lock') {\n        const lock = await this.acquireLock(query.resourceId, query.timeout);\n        return lock as R;\n      }\n\n      if (query.operation === 'release_lock') {\n        await this.releaseLock(query.lockId);\n        return { success: true } as R;\n      }\n\n      if (query.operation === 'publish') {\n        await this.publish(query.channel, query.event);\n        return { success: true } as R;\n      }\n\n      if (query.operation === 'get_stats') {\n        const stats = await this.getCoordinationStats();\n        return stats as R;\n      }\n    }\n\n    return super.executeCustomQuery<R>(customQuery);\n  }\n\n  /**\n   * Enhanced coordination-specific operations.\n   */\n\n  /**\n   * Try to acquire lock with retry mechanism.\n   *\n   * @param resourceId\n   * @param maxRetries\n   * @param retryDelay\n   * @param lockTimeout\n   */\n  async tryAcquireLock(\n    resourceId: string,\n    maxRetries: number = 3,\n    retryDelay: number = 1000,\n    lockTimeout: number = 30000\n  ): Promise<CoordinationLock | null> {\n    this.logger.debug(\n      `Trying to acquire lock for resource: ${resourceId} (max retries: ${maxRetries})`\n    );\n\n    for (let attempt = 0 as number; attempt <= maxRetries; attempt++) {\n      try {\n        return await this.acquireLock(resourceId, lockTimeout);\n      } catch (error) {\n        if (attempt === maxRetries) {\n          this.logger.warn(`Failed to acquire lock after ${maxRetries} attempts: ${error}`);\n          return null;\n        }\n\n        this.logger.debug(\n          `Lock acquisition attempt ${attempt + 1} failed, retrying in ${retryDelay}ms`\n        );\n        await this.sleep(retryDelay);\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Execute with lock (acquire, execute, release).\n   *\n   * @param resourceId\n   * @param operation\n   * @param lockTimeout\n   */\n  async executeWithLock<R>(\n    resourceId: string,\n    operation: () => Promise<R>,\n    lockTimeout: number = 30000\n  ): Promise<R> {\n    this.logger.debug(`Executing operation with lock for resource: ${resourceId}`);\n\n    const lock = await this.acquireLock(resourceId, lockTimeout);\n\n    try {\n      const result = await operation();\n      return result;\n    } finally {\n      await this.releaseLock(lock.id);\n    }\n  }\n\n  /**\n   * Broadcast event to all subscribers.\n   *\n   * @param event\n   */\n  async broadcast(event: CoordinationEvent<T>): Promise<void> {\n    const broadcastChannel = 'broadcast';\n    await this.publish(broadcastChannel, event);\n  }\n\n  /**\n   * Get active locks.\n   */\n  async getActiveLocks(): Promise<CoordinationLock[]> {\n    const activeLocks: CoordinationLock[] = [];\n    const now = new Date();\n\n    for (const lock of this.locks.values()) {\n      if (lock.expiresAt > now) {\n        activeLocks.push({\n          id: lock.id,\n          resourceId: lock.resourceId,\n          acquired: lock.acquired,\n          expiresAt: lock.expiresAt,\n          owner: lock.owner,\n        });\n      }\n    }\n\n    return activeLocks;\n  }\n\n  /**\n   * Get subscription information.\n   */\n  async getSubscriptions(): Promise<\n    Array<{\n      id: string;\n      pattern: string;\n      createdAt: Date;\n      lastTriggered?: Date;\n      triggerCount: number;\n    }>\n  > {\n    return Array.from(this.subscriptions.values()).map((sub) => ({\n      id: sub.id,\n      pattern: sub.pattern,\n      createdAt: sub.createdAt,\n      ...(sub.lastTriggered && { lastTriggered: sub.lastTriggered }),\n      triggerCount: sub.triggerCount,\n    }));\n  }\n\n  /**\n   * Private helper methods.\n   */\n\n  private async emitChange(\n    type: 'create' | 'update' | 'delete',\n    entityId: string | number,\n    entity?: T\n  ): Promise<void> {\n    const change: CoordinationChange<T> = {\n      type,\n      entityId,\n      entity,\n      timestamp: new Date(),\n      metadata: {\n        tableName: this.tableName,\n        source: this.generateOwnerIdentifier(),\n      },\n    };\n\n    this.eventEmitter.emit('change', change);\n  }\n\n  private matchesPattern(change: CoordinationChange<T>, pattern: string): boolean {\n    // Simple pattern matching - can be enhanced with more sophisticated matching\n    if (pattern === '*') return true;\n\n    const regex = new RegExp(pattern.replace(/\\*/g, '.*'));\n    return (\n      regex.test(change.type) ||\n      regex.test(change.entityId.toString()) ||\n      regex.test(this.tableName)\n    );\n  }\n\n  private generateLockId(resourceId: string): string {\n    return `lock_${resourceId}_${Date.now()}_${Math.random().toString(36).substring(2, 11)}`;\n  }\n\n  private generateSubscriptionId(): string {\n    return `sub_${Date.now()}_${Math.random().toString(36).substring(2, 11)}`;\n  }\n\n  private generateOwnerIdentifier(): string {\n    return `process_${process.pid}_${Date.now()}`;\n  }\n\n  private async persistLock(lock: LockInfo): Promise<void> {\n    // In a real implementation, this would persist to the database\n    // For now, we'll use a simple table structure\n    try {\n      const lockData = {\n        lock_id: lock.id,\n        resource_id: lock.resourceId,\n        owner: lock.owner,\n        acquired_at: lock.acquired,\n        expires_at: lock.expiresAt,\n        created_at: new Date(),\n      };\n\n      await this.adapter.execute(\n        `INSERT OR REPLACE INTO coordination_locks (lock_id, resource_id, owner, acquired_at, expires_at, created_at) \n         VALUES (?, ?, ?, ?, ?, ?)`,\n        Object.values(lockData)\n      );\n    } catch (error) {\n      // Table might not exist, which is fine for this implementation\n      this.logger.debug(`Could not persist lock to database: ${error}`);\n    }\n  }\n\n  private async removeLockFromDatabase(lockId: string): Promise<void> {\n    try {\n      await this.adapter.execute('DELETE FROM coordination_locks WHERE lock_id = ?', [lockId]);\n    } catch (error) {\n      // Table might not exist, which is fine for this implementation\n      this.logger.debug(`Could not remove lock from database: ${error}`);\n    }\n  }\n\n  private async persistEvent(channel: string, event: CoordinationEvent<T>): Promise<void> {\n    try {\n      const eventData = {\n        channel,\n        event_type: event.type,\n        event_data: JSON.stringify(event.data),\n        source: event.source,\n        timestamp: event.timestamp,\n        metadata: JSON.stringify(event.metadata || {}),\n      };\n\n      await this.adapter.execute(\n        `INSERT INTO coordination_events (channel, event_type, event_data, source, timestamp, metadata) \n         VALUES (?, ?, ?, ?, ?, ?)`,\n        Object.values(eventData)\n      );\n    } catch (error) {\n      // Table might not exist, which is fine for this implementation\n      this.logger.debug(`Could not persist event to database: ${error}`);\n    }\n  }\n\n  private sleep(ms: number): Promise<void> {\n    return new Promise((resolve) => setTimeout(resolve, ms));\n  }\n\n  /**\n   * Cleanup method to be called on shutdown.\n   */\n  async shutdown(): Promise<void> {\n    this.logger.debug('Shutting down coordination repository');\n\n    // Release all active locks\n    const activeLocks = Array.from(this.locks.keys());\n    for (const resourceId of activeLocks) {\n      const lock = this.locks.get(resourceId);\n      if (lock) {\n        try {\n          await this.releaseLock(lock.id);\n        } catch (error) {\n          this.logger.warn(`Failed to release lock during shutdown: ${error}`);\n        }\n      }\n    }\n\n    // Clear all subscriptions\n    this.subscriptions.clear();\n\n    // Remove all event listeners\n    this.eventEmitter.removeAllListeners();\n\n    this.logger.debug('Coordination repository shutdown completed');\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
