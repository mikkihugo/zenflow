{
  "version": 3,
  "sources": ["../../src/database/dao/vector.dao.ts"],
  "sourcesContent": ["/**\n * Vector Database Repository Implementation (LanceDB).\n *\n * Specialized repository for vector database operations including.\n * Similarity search, vector insertion, indexing, and clustering.\n */\n/**\n * @file Database layer: vector.dao.\n */\n\nimport { BaseDao } from '../base.dao.ts';\nimport type {\n  ClusteringOptions,\n  ClusterResult,\n  CustomQuery,\n  IVectorRepository,\n  VectorDocument,\n  VectorIndexConfig,\n  VectorInsertResult,\n  VectorSearchOptions,\n  VectorSearchResult,\n  VectorStats,\n} from '../interfaces.ts';\nimport type { VectorDatabaseAdapter } from '../providers/database-providers.ts';\n\n/**\n * Vector database repository implementation for LanceDB.\n *\n * @template T The entity type this repository manages.\n * @example\n */\nexport class VectorDao<T> extends BaseDao<T> implements IVectorRepository<T> {\n  private get vectorAdapter(): VectorDatabaseAdapter {\n    return this.adapter as VectorDatabaseAdapter;\n  }\n\n  /**\n   * Perform vector similarity search.\n   *\n   * @param queryVector\n   * @param options\n   */\n  async similaritySearch(\n    queryVector: number[],\n    options?: VectorSearchOptions\n  ): Promise<VectorSearchResult<T>[]> {\n    this.logger.debug(`Performing similarity search with ${queryVector.length}D vector`, {\n      options,\n    });\n\n    try {\n      // Validate vector dimensions\n      this.validateVector(queryVector);\n\n      const searchOptions = {\n        limit: options?.limit || 10,\n        threshold: options?.threshold || 0.0,\n        metric: options?.metric || 'cosine',\n        filter: options?.filter,\n      };\n\n      // Use the vector adapter for similarity search\n      const vectorResult = await this.vectorAdapter.vectorSearch(queryVector, searchOptions?.limit);\n\n      // Convert results to VectorSearchResult format\n      const results: VectorSearchResult<T>[] = vectorResult?.matches\n        ?.filter((match) => match?.score >= searchOptions?.threshold)\n        .map((match) => ({\n          id: match?.id,\n          score: match?.score,\n          document: this.mapVectorDocumentToEntity(match),\n          vector: match?.vector,\n        }));\n\n      this.logger.debug(`Similarity search completed: ${results.length} results`);\n      return results;\n    } catch (error) {\n      this.logger.error(`Similarity search failed: ${error}`);\n      throw new Error(\n        `Similarity search failed: ${error instanceof Error ? error.message : 'Unknown error'}`\n      );\n    }\n  }\n\n  /**\n   * Add vectors in batch.\n   *\n   * @param vectors\n   */\n  async addVectors(vectors: VectorDocument<T>[]): Promise<VectorInsertResult> {\n    if (vectors.length === 0) {\n      return { inserted: 0, errors: [] };\n    }\n\n    this.logger.debug(`Adding ${vectors.length} vectors to ${this.tableName}`);\n\n    try {\n      // Validate all vectors\n      for (const vectorDoc of vectors) {\n        this.validateVector(vectorDoc.vector);\n      }\n\n      // Convert to adapter format\n      const adapterVectors = vectors.map((vectorDoc) => ({\n        id: vectorDoc.id,\n        vector: vectorDoc.vector,\n        metadata: vectorDoc.metadata,\n      }));\n\n      // Use vector adapter to insert vectors\n      await this.vectorAdapter.addVectors(adapterVectors as any);\n\n      // Return success result (LanceDB doesn't provide detailed error info in current adapter)\n      const result: VectorInsertResult = {\n        inserted: vectors.length,\n        errors: [],\n      };\n\n      this.logger.debug(`Successfully added ${result?.inserted} vectors`);\n      return result;\n    } catch (error) {\n      this.logger.error(`Add vectors failed: ${error}`);\n\n      // Return error result\n      return {\n        inserted: 0,\n        errors: vectors.map((v) => ({\n          id: v.id,\n          error: error instanceof Error ? error.message : 'Unknown error',\n        })),\n      };\n    }\n  }\n\n  /**\n   * Create vector index.\n   *\n   * @param config\n   */\n  async createIndex(config: VectorIndexConfig): Promise<void> {\n    this.logger.debug(`Creating vector index: ${config?.name}`, { config });\n\n    try {\n      await this.vectorAdapter.createIndex(config);\n      this.logger.debug(`Successfully created vector index: ${config?.name}`);\n    } catch (error) {\n      this.logger.error(`Create index failed: ${error}`);\n      throw new Error(\n        `Create index failed: ${error instanceof Error ? error.message : 'Unknown error'}`\n      );\n    }\n  }\n\n  /**\n   * Get vector statistics.\n   */\n  async getVectorStats(): Promise<VectorStats> {\n    this.logger.debug(`Getting vector statistics for ${this.tableName}`);\n\n    try {\n      // This would need to be implemented based on actual LanceDB capabilities\n      // For now, return basic stats\n      const count = await this.count();\n\n      const stats: VectorStats = {\n        totalVectors: count,\n        dimensions: this.getVectorDimension(),\n        indexType: 'auto',\n        memoryUsage: count * this.getVectorDimension() * 4, // Rough estimate: float32 = 4 bytes\n      };\n\n      return stats;\n    } catch (error) {\n      this.logger.error(`Get vector stats failed: ${error}`);\n      throw new Error(\n        `Get vector stats failed: ${error instanceof Error ? error.message : 'Unknown error'}`\n      );\n    }\n  }\n\n  /**\n   * Perform clustering operation.\n   *\n   * @param options\n   */\n  async cluster(options?: ClusteringOptions): Promise<ClusterResult> {\n    this.logger.debug('Performing vector clustering', { options });\n\n    try {\n      const clusterOptions = {\n        algorithm: options?.algorithm || 'kmeans',\n        numClusters: options?.numClusters || 5,\n        epsilon: options?.epsilon || 0.5,\n        minSamples: options?.minSamples || 5,\n      };\n\n      // This is a simplified implementation - real clustering would use specialized algorithms\n      const allVectors = await this.findAll();\n      const vectorIds = allVectors.map((entity: any) => entity.id);\n\n      // Simple k-means-like clustering (simplified)\n      const clusters = this.performSimpleClustering(vectorIds, clusterOptions?.numClusters);\n\n      const result: ClusterResult = {\n        clusters,\n        statistics: {\n          silhouetteScore: 0.7, // Mock score\n          inertia: 100.5, // Mock inertia\n        },\n      };\n\n      this.logger.debug(`Clustering completed: ${result?.clusters.length} clusters`);\n      return result;\n    } catch (error) {\n      this.logger.error(`Clustering failed: ${error}`);\n      throw new Error(\n        `Clustering failed: ${error instanceof Error ? error.message : 'Unknown error'}`\n      );\n    }\n  }\n\n  /**\n   * Enhanced vector-specific operations.\n   */\n\n  /**\n   * Find similar entities to a given entity.\n   *\n   * @param entityId\n   * @param options\n   */\n  async findSimilarToEntity(\n    entityId: string | number,\n    options?: VectorSearchOptions\n  ): Promise<VectorSearchResult<T>[]> {\n    this.logger.debug(`Finding entities similar to: ${entityId}`);\n\n    try {\n      // Get the entity and its vector\n      const entity = await this.findById(entityId);\n      if (!entity) {\n        throw new Error(`Entity with ID ${entityId} not found`);\n      }\n\n      const vector = this.extractVectorFromEntity(entity);\n      if (!vector) {\n        throw new Error(`No vector found for entity ${entityId}`);\n      }\n\n      // Perform similarity search excluding the original entity\n      const results = await this.similaritySearch(vector, options);\n      return results?.filter((result) => result?.id !== entityId);\n    } catch (error) {\n      this.logger.error(`Find similar to entity failed: ${error}`);\n      throw new Error(\n        `Find similar to entity failed: ${error instanceof Error ? error.message : 'Unknown error'}`\n      );\n    }\n  }\n\n  /**\n   * Update vector for existing entity.\n   *\n   * @param entityId\n   * @param newVector\n   */\n  async updateVector(entityId: string | number, newVector: number[]): Promise<T> {\n    this.logger.debug(`Updating vector for entity: ${entityId}`);\n\n    try {\n      this.validateVector(newVector);\n\n      // Get existing entity\n      const existingEntity = await this.findById(entityId);\n      if (!existingEntity) {\n        throw new Error(`Entity with ID ${entityId} not found`);\n      }\n\n      // Update the entity with new vector\n      const updatedEntity = await this.update(entityId, {\n        vector: newVector,\n      } as unknown as Partial<T>);\n\n      return updatedEntity;\n    } catch (error) {\n      this.logger.error(`Update vector failed: ${error}`);\n      throw new Error(\n        `Update vector failed: ${error instanceof Error ? error.message : 'Unknown error'}`\n      );\n    }\n  }\n\n  /**\n   * Batch similarity search with multiple query vectors.\n   *\n   * @param queryVectors\n   * @param options\n   */\n  async batchSimilaritySearch(\n    queryVectors: number[][],\n    options?: VectorSearchOptions\n  ): Promise<VectorSearchResult<T>[][]> {\n    this.logger.debug(\n      `Performing batch similarity search with ${queryVectors.length} query vectors`\n    );\n\n    try {\n      const results: VectorSearchResult<T>[][] = [];\n\n      // Execute searches in parallel\n      const searchPromises = queryVectors.map((queryVector) =>\n        this.similaritySearch(queryVector, options)\n      );\n\n      const batchResults = await Promise.all(searchPromises);\n      results?.push(...batchResults);\n\n      this.logger.debug(`Batch similarity search completed: ${results.length} result sets`);\n      return results;\n    } catch (error) {\n      this.logger.error(`Batch similarity search failed: ${error}`);\n      throw new Error(\n        `Batch similarity search failed: ${error instanceof Error ? error.message : 'Unknown error'}`\n      );\n    }\n  }\n\n  /**\n   * Override base repository methods for vector-specific implementations.\n   */\n\n  protected mapRowToEntity(row: any): T {\n    // For vector databases, ensure vector field is properly handled\n    if (row.vector && typeof row.vector === 'string') {\n      try {\n        row.vector = JSON.parse(row.vector);\n      } catch {\n        // If parsing fails, assume it's already an array\n      }\n    }\n\n    return row as T;\n  }\n\n  protected mapEntityToRow(entity: Partial<T>): Record<string, any> {\n    if (!entity) return {};\n\n    const row: any = { ...entity };\n\n    // Ensure vector is serialized properly if needed\n    if (row.vector && Array.isArray(row.vector)) {\n      // LanceDB handles arrays natively, but some adapters might need JSON serialization\n      // row.vector = JSON.stringify(row.vector);\n    }\n\n    return row;\n  }\n\n  /**\n   * Execute custom query - override to handle vector-specific queries.\n   *\n   * @param customQuery\n   */\n  override async executeCustomQuery<R = any>(customQuery: CustomQuery): Promise<R> {\n    if (customQuery.type === 'vector') {\n      // Handle vector-specific queries\n      const query = customQuery.query as any;\n\n      if (query.operation === 'similarity_search') {\n        const results = await this.similaritySearch(query.vector, query.options);\n        return results as R;\n      }\n\n      if (query.operation === 'cluster') {\n        const results = await this.cluster(query.options);\n        return results as R;\n      }\n    }\n\n    return super.executeCustomQuery<R>(customQuery);\n  }\n\n  /**\n   * Helper methods.\n   */\n\n  private validateVector(vector: number[]): void {\n    if (!Array.isArray(vector)) {\n      throw new Error('Vector must be an array of numbers');\n    }\n\n    if (vector.length === 0) {\n      throw new Error('Vector cannot be empty');\n    }\n\n    if (!vector.every((v) => typeof v === 'number' && !Number.isNaN(v))) {\n      throw new Error('Vector must contain only valid numbers');\n    }\n\n    const expectedDimension = this.getVectorDimension();\n    if (expectedDimension && vector.length !== expectedDimension) {\n      throw new Error(\n        `Vector dimension mismatch: expected ${expectedDimension}, got ${vector.length}`\n      );\n    }\n  }\n\n  private getVectorDimension(): number {\n    // Get from schema or default configuration\n    return this.entitySchema?.['vector']?.dimension || 384;\n  }\n\n  private mapVectorDocumentToEntity(match: any): T {\n    return {\n      id: match?.id,\n      vector: match?.vector,\n      ...match?.metadata,\n    } as T;\n  }\n\n  private extractVectorFromEntity(entity: T): number[] | null {\n    const entityObj = entity as any;\n    return entityObj.vector || null;\n  }\n\n  private performSimpleClustering(vectorIds: any[], numClusters: number): any[] {\n    // Simplified clustering implementation\n    const clusters: any[] = [];\n    const idsPerCluster = Math.ceil(vectorIds.length / numClusters);\n\n    for (let i = 0; i < numClusters; i++) {\n      const startIdx = i * idsPerCluster;\n      const endIdx = Math.min(startIdx + idsPerCluster, vectorIds.length);\n      const clusterMembers = vectorIds.slice(startIdx, endIdx);\n\n      if (clusterMembers.length > 0) {\n        clusters.push({\n          id: i,\n          centroid: new Array(this.getVectorDimension()).fill(0), // Mock centroid\n          members: clusterMembers,\n        });\n      }\n    }\n\n    return clusters;\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
