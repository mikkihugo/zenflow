{
  "version": 3,
  "sources": ["../../src/neural/wasm/wasm-loader.ts", "../../src/neural/wasm/wasm-memory-optimizer.ts", "../../src/neural/wasm/gateway.ts", "../../src/neural/wasm/wasm-compat.ts", "../../src/wasm-loader.cjs", "../../src/coordination/swarm/core/utils.ts", "../../src/coordination/agents/agent.ts", "../../src/coordination/swarm/core/singleton-container.ts", "../../src/neural/core/cognitive-pattern-evolution.ts", "../../src/neural/core/daa-cognition.ts", "../../src/neural/core/meta-learning-framework.ts", "../../src/neural/core/neural-coordination-protocol.ts", "../../src/neural/core/neural-models/index.ts", "../../src/neural/core/neural-models/neural-presets-complete.ts", "../../src/neural/core/neural-models/presets/index.ts", "../../src/neural/core/neural-network-manager.ts", "../../src/neural/wasm/wasm-loader2.ts", "../../src/coordination/swarm/core/daa-service.ts", "../../src/coordination/swarm/mcp/mcp-daa-tools.ts", "../../src/coordination/swarm/core/base-swarm.ts", "../../src/coordination/swarm/core/errors.ts", "../../src/coordination/swarm/core/hooks/index.ts", "../../src/coordination/swarm/core/logger.ts", "../../src/coordination/swarm/core/logging-config.ts", "../../src/coordination/swarm/core/monitoring-dashboard.ts", "../../src/coordination/swarm/core/performance.ts", "../../src/coordination/swarm/core/performance-benchmarks.ts", "../../src/coordination/swarm/chaos-engineering/chaos-engineering.ts", "../../src/core/errors.ts", "../../src/coordination/swarm/connection-management/connection-state-manager.ts", "../../src/coordination/swarm/core/recovery-workflows.ts", "../../src/coordination/swarm/core/recovery-integration.ts", "../../src/coordination/diagnostics/health-monitor.ts", "../../src/coordination/swarm/core/schemas.ts", "../../src/coordination/swarm/core/session-manager.ts", "../../src/database/index.ts", "../../src/coordination/swarm/core/session-utils.ts", "../../src/coordination/swarm/core/session-integration.ts", "../../src/coordination/protocols/topology/topology-manager.ts", "../../src/coordination/swarm/core/index.ts", "../../src/coordination/swarm/core/agent-adapter.ts"],
  "sourcesContent": ["/**\n * WASM Module Loader - Temporary stub implementation.\n * TODO: Implement full WASM loading functionality.\n */\n/**\n * @file Neural network: wasm-loader.\n */\n\nexport class WasmModuleLoader {\n  private loaded = false;\n  private module: any = null;\n\n  async load(): Promise<void> {\n    if (this.loaded) return;\n\n    // TODO: Implement actual WASM loading\n    this.loaded = true;\n    this.module = { exports: {} };\n  }\n\n  async loadModule(): Promise<void> {\n    await this.load();\n  }\n\n  isLoaded(): boolean {\n    return this.loaded;\n  }\n\n  async initialize(): Promise<void> {\n    await this.load();\n  }\n\n  getModule(): any {\n    return this.module;\n  }\n\n  // Add missing methods for compatibility\n  async cleanup(): Promise<void> {\n    this.loaded = false;\n    this.module = null;\n  }\n\n  getTotalMemoryUsage(): number {\n    return 0; // Stub implementation\n  }\n\n  getModuleStatus(): any {\n    return {\n      loaded: this.loaded,\n      memoryUsage: 0,\n      status: this.loaded ? 'ready' : 'unloaded',\n    };\n  }\n}\n\nexport default WasmModuleLoader;\n", "/**\n * WASM Memory Optimizer - Active WASM system component.\n *\n * \u26A0\uFE0F  ACTIVE WASM SYSTEM COMPONENT - NEVER REMOVE \u26A0\uFE0F.\n *\n * This module is ACTIVELY USED in the WASM gateway system:\n * - src/neural/wasm/gateway.ts - Direct import and instantiation: new WasmMemoryOptimizer()\n * - src/neural/wasm/index.ts - Re-exported as default export\n * - src/neural/wasm/wasm-compat.ts - Compatibility layer wrapper.\n *\n * Static analysis may miss usage due to:\n * 1. Re-export chains through index.ts\n * 2. Compatibility layer patterns\n * 3. WASM system architecture.\n *\n * Currently stub implementation but integrated into WASM gateway architecture.\n * TODO: Implement WASM memory optimization functionality.\n *\n * @usage ACTIVE - Core component of WASM gateway system\n * @importedBy src/neural/wasm/gateway.ts (instantiated), src/neural/wasm/index.ts (re-exported)\n * @compatibilityLayer src/neural/wasm/wasm-compat.ts\n */\n/**\n * @file Neural network: wasm-memory-optimizer.\n */\n\nexport class WasmMemoryOptimizer {\n  private optimized = false;\n\n  async optimize(): Promise<void> {\n    if (this.optimized) return;\n\n    // TODO: Implement actual memory optimization\n    this.optimized = true;\n  }\n\n  isOptimized(): boolean {\n    return this.optimized;\n  }\n\n  reset(): void {\n    this.optimized = false;\n  }\n}\n\nexport default WasmMemoryOptimizer;\n", "/**\n * NeuralWasmGateway.\n * Unified, public-safe facade for all neural WebAssembly functionality.\n * Enforces controlled access, lazy initialization, and metrics capture.\n *\n * Architectural Contract:\n * - All external modules MUST import WASM capabilities only via this gateway\n * - Direct imports of deep wasm internals (src/neural/wasm/(src|binaries|fact-core)) are blocked by dependency-cruiser\n * - Provides stable surface while underlying loaders evolve.\n */\n/**\n * @file Neural network: gateway.\n */\n\nimport { WasmModuleLoader } from './wasm-loader.ts';\nimport { WasmMemoryOptimizer } from './wasm-memory-optimizer.ts';\n\nexport interface WasmGatewayMetrics {\n  initialized: boolean;\n  optimized: boolean;\n  initTimeMs?: number;\n  optimizeTimeMs?: number;\n  modulesLoaded: number;\n  lastUpdated: number;\n}\n\nexport interface WasmExecutionContext {\n  task: string;\n  payload?: unknown;\n  options?: Record<string, unknown>;\n}\n\nexport interface WasmExecutionResult<T = unknown> {\n  success: boolean;\n  data?: T;\n  error?: string;\n  durationMs: number;\n}\n\nclass NeuralWasmGatewayImpl {\n  private loader = new WasmModuleLoader();\n  private optimizer = new WasmMemoryOptimizer();\n  private initialized = false;\n  private metrics: WasmGatewayMetrics = {\n    initialized: false,\n    optimized: false,\n    modulesLoaded: 0,\n    lastUpdated: Date.now(),\n  };\n\n  /** Lazy initialization (idempotent) */\n  async initialize(): Promise<void> {\n    if (this.initialized) return;\n    const start = performance.now?.() ?? Date.now();\n    await (this.loader as any).initialize?.();\n    this.initialized = true;\n    this.metrics.initialized = true;\n    this.metrics.initTimeMs = (performance.now?.() ?? Date.now()) - start;\n    this.metrics.modulesLoaded = 1; // Adjust when multiple modules integrated\n    this.metrics.lastUpdated = Date.now();\n  }\n\n  /** Memory / runtime optimization (idempotent) */\n  async optimize(): Promise<void> {\n    if (this.optimizer.isOptimized()) return;\n    const start = performance.now?.() ?? Date.now();\n    await this.optimizer.optimize();\n    this.metrics.optimized = true;\n    this.metrics.optimizeTimeMs = (performance.now?.() ?? Date.now()) - start;\n    this.metrics.lastUpdated = Date.now();\n  }\n\n  /**\n   * Execute a WASM-backed task (stub until real dispatch added).\n   *\n   * @param ctx\n   */\n  async execute<T = unknown>(ctx: WasmExecutionContext): Promise<WasmExecutionResult<T>> {\n    const start = performance.now?.() ?? Date.now();\n    try {\n      await this.initialize();\n      // TODO: Route by ctx.task -> underlying wasm exported function tables\n      return {\n        success: true,\n        data: { task: ctx.task } as unknown as T,\n        durationMs: (performance.now?.() ?? Date.now()) - start,\n      };\n    } catch (e: any) {\n      return {\n        success: false,\n        error: e?.message || 'WASM execution failed',\n        durationMs: (performance.now?.() ?? Date.now()) - start,\n      };\n    }\n  }\n\n  getMetrics(): WasmGatewayMetrics {\n    return { ...this.metrics };\n  }\n\n  isInitialized(): boolean {\n    return this.initialized;\n  }\n}\n\n// Singleton instance (stateless surface externally)\nexport const NeuralWasmGateway = new NeuralWasmGatewayImpl();\nexport type NeuralWasmGatewayType = typeof NeuralWasmGateway;\n\nexport default NeuralWasmGateway;\n", "/**\n * WASM Compatibility Layer.\n *\n * Provides a backwards-compatible wrapper so legacy code/tests using\n * `new WasmModuleLoader()` continue to function while the system.\n * Migrates to the unified `NeuralWasmGateway` facade.\n *\n * Deprecation Plan:\n * 1. Migrate imports to `NeuralWasmGateway`\n * 2. Remove this compat layer and legacy shims.\n */\n/**\n * @file Neural network: wasm-compat.\n */\n\nimport { NeuralWasmGateway } from './gateway.ts';\n\nexport class WasmModuleLoaderCompat {\n  async initialize(): Promise<void> {\n    await NeuralWasmGateway.initialize();\n  }\n\n  async load(): Promise<void> {\n    await NeuralWasmGateway.initialize();\n  }\n\n  async loadModule(): Promise<void> {\n    await NeuralWasmGateway.initialize();\n  }\n\n  isLoaded(): boolean {\n    return NeuralWasmGateway.isInitialized();\n  }\n\n  getModule(): any {\n    return { gateway: true };\n  }\n\n  async cleanup(): Promise<void> {\n    // No direct cleanup semantics yet \u2013 placeholder\n  }\n\n  getTotalMemoryUsage(): number {\n    // Gateway metrics currently do not expose memory \u2013 return 0 placeholder\n    return 0;\n  }\n\n  getModuleStatus(): any {\n    const m = NeuralWasmGateway.getMetrics();\n    return {\n      loaded: m.initialized,\n      memoryUsage: 0,\n      status: m.initialized ? 'ready' : 'unloaded',\n      optimized: m.optimized,\n    };\n  }\n}\n\nexport { WasmModuleLoaderCompat as WasmModuleLoader };\n\nexport class WasmMemoryOptimizerCompat {\n  async optimize(): Promise<void> {\n    await NeuralWasmGateway.optimize();\n  }\n  isOptimized(): boolean {\n    return NeuralWasmGateway.getMetrics().optimized;\n  }\n  reset(): void {\n    // Placeholder reset; real implementation would extend gateway\n  }\n}\n\nexport { WasmMemoryOptimizerCompat as WasmMemoryOptimizer };\n", "// Legacy compatibility shim - delegates to unified neural/wasm implementation\n// TODO: Remove after all tests & code paths migrated to import from 'src/neural/wasm'\n// Legacy shim now routes to compatibility layer (wasm-compat)\n// Deprecated: use NeuralWasmGateway from 'src/neural/wasm/gateway'\nmodule.exports = require('./neural/wasm/wasm-compat.ts');\n", "/**\n * Utility functions for ZenSwarm.\n */\n/**\n * @file Coordination system: utils.\n */\n\nimport type { AgentType, CognitiveProfile, SwarmTopology, TaskPriority } from './types.ts';\n\n/**\n * Generate a unique ID for agents, tasks, and messages.\n *\n * @param prefix\n * @example\n */\nexport function generateId(prefix: string = ''): string {\n  const timestamp = Date.now().toString(36);\n  const random = Math.random().toString(36).substring(2, 9);\n  return prefix ? `${prefix}_${timestamp}_${random}` : `${timestamp}_${random}`;\n}\n\n/**\n * Create a default cognitive profile based on agent type.\n *\n * @param type\n * @example\n */\nexport function getDefaultCognitiveProfile(type: AgentType): CognitiveProfile {\n  // Default profiles for known types - using Partial<Record> for flexibility\n  const knownProfiles: Partial<Record<AgentType, CognitiveProfile>> = {\n    researcher: {\n      analytical: 0.9,\n      creative: 0.6,\n      systematic: 0.8,\n      intuitive: 0.5,\n      collaborative: 0.7,\n      independent: 0.8,\n    },\n    coder: {\n      analytical: 0.8,\n      creative: 0.7,\n      systematic: 0.9,\n      intuitive: 0.4,\n      collaborative: 0.6,\n      independent: 0.7,\n    },\n    analyst: {\n      analytical: 0.95,\n      creative: 0.4,\n      systematic: 0.9,\n      intuitive: 0.3,\n      collaborative: 0.6,\n      independent: 0.8,\n    },\n    architect: {\n      analytical: 0.8,\n      creative: 0.8,\n      systematic: 0.85,\n      intuitive: 0.7,\n      collaborative: 0.8,\n      independent: 0.6,\n    },\n    reviewer: {\n      analytical: 0.85,\n      creative: 0.5,\n      systematic: 0.9,\n      intuitive: 0.4,\n      collaborative: 0.7,\n      independent: 0.7,\n    },\n    debug: {\n      analytical: 0.9,\n      creative: 0.6,\n      systematic: 0.85,\n      intuitive: 0.6,\n      collaborative: 0.5,\n      independent: 0.8,\n    },\n    tester: {\n      analytical: 0.8,\n      creative: 0.6,\n      systematic: 0.95,\n      intuitive: 0.3,\n      collaborative: 0.6,\n      independent: 0.7,\n    },\n    documenter: {\n      analytical: 0.7,\n      creative: 0.7,\n      systematic: 0.85,\n      intuitive: 0.4,\n      collaborative: 0.8,\n      independent: 0.6,\n    },\n    optimizer: {\n      analytical: 0.9,\n      creative: 0.6,\n      systematic: 0.8,\n      intuitive: 0.5,\n      collaborative: 0.5,\n      independent: 0.8,\n    },\n    coordinator: {\n      analytical: 0.7,\n      creative: 0.6,\n      systematic: 0.8,\n      intuitive: 0.7,\n      collaborative: 0.9,\n      independent: 0.4,\n    },\n  };\n\n  // Return known profile or default for unknown types\n  return (\n    knownProfiles[type] || {\n      analytical: 0.5,\n      creative: 0.5,\n      systematic: 0.5,\n      intuitive: 0.5,\n      collaborative: 0.5,\n      independent: 0.5,\n    }\n  );\n}\n\n/**\n * Calculate cognitive diversity score between two profiles.\n *\n * @param profile1\n * @param profile2\n * @example\n */\nexport function calculateCognitiveDiversity(\n  profile1: CognitiveProfile,\n  profile2: CognitiveProfile\n): number {\n  const dimensions = Object.keys(profile1) as (keyof CognitiveProfile)[];\n  let totalDifference = 0;\n\n  for (const dimension of dimensions) {\n    const diff = Math.abs(profile1[dimension] - profile2[dimension]);\n    totalDifference += diff;\n  }\n\n  return totalDifference / dimensions.length;\n}\n\n/**\n * Determine optimal topology based on swarm characteristics.\n *\n * @param agentCount\n * @param taskComplexity\n * @param coordinationNeeds\n * @example\n */\nexport function recommendTopology(\n  agentCount: number,\n  taskComplexity: 'low' | 'medium' | 'high',\n  coordinationNeeds: 'minimal' | 'moderate' | 'extensive'\n): SwarmTopology {\n  if (agentCount <= 5) {\n    return 'mesh';\n  }\n\n  if (coordinationNeeds === 'extensive') {\n    return 'hierarchical';\n  }\n\n  if (taskComplexity === 'high' && agentCount > 10) {\n    return 'hybrid';\n  }\n\n  if (coordinationNeeds === 'minimal') {\n    return 'distributed';\n  }\n\n  return 'centralized';\n}\n\n/**\n * Convert task priority to numeric value for sorting.\n *\n * @param priority\n * @example\n */\nexport function priorityToNumber(priority: TaskPriority): number {\n  const priorityMap: Record<TaskPriority, number> = {\n    low: 1,\n    medium: 2,\n    high: 3,\n    critical: 4,\n  };\n  return priorityMap[priority];\n}\n\n/**\n * Format swarm metrics for display.\n *\n * @param metrics\n * @param metrics.totalTasks\n * @param metrics.completedTasks\n * @param metrics.failedTasks\n * @param metrics.averageCompletionTime\n * @param metrics.throughput\n * @example\n */\nexport function formatMetrics(metrics: {\n  totalTasks: number;\n  completedTasks: number;\n  failedTasks: number;\n  averageCompletionTime: number;\n  throughput: number;\n}): string {\n  const successRate =\n    metrics.totalTasks > 0\n      ? ((metrics.completedTasks / metrics.totalTasks) * 100).toFixed(1)\n      : '0.0';\n\n  return `\nSwarm Metrics:\n- Total Tasks: ${metrics.totalTasks}\n- Completed: ${metrics.completedTasks}\n- Failed: ${metrics.failedTasks}\n- Success Rate: ${successRate}%\n- Avg Completion Time: ${metrics.averageCompletionTime.toFixed(2)}ms\n- Throughput: ${metrics.throughput.toFixed(2)} tasks/sec\n  `.trim();\n}\n\n/**\n * Validate swarm options.\n *\n * @param options\n * @example\n */\nexport function validateSwarmOptions(options: any): string[] {\n  const errors: string[] = [];\n\n  if (options?.maxAgents !== undefined) {\n    if (typeof options?.maxAgents !== 'number' || options?.maxAgents < 1) {\n      errors.push('maxAgents must be a positive number');\n    }\n  }\n\n  if (options?.connectionDensity !== undefined) {\n    if (\n      typeof options?.connectionDensity !== 'number' ||\n      options?.connectionDensity < 0 ||\n      options?.connectionDensity > 1\n    ) {\n      errors.push('connectionDensity must be a number between 0 and 1');\n    }\n  }\n\n  if (options?.topology !== undefined) {\n    const validTopologies = ['mesh', 'hierarchical', 'distributed', 'centralized', 'hybrid'];\n    if (!validTopologies.includes(options?.topology)) {\n      errors.push(`topology must be one of: ${validTopologies.join(', ')}`);\n    }\n  }\n\n  return errors;\n}\n\n/**\n * Deep clone an object.\n *\n * @param obj\n * @example\n */\nexport function deepClone<T>(obj: T): T {\n  if (obj === null || typeof obj !== 'object') {\n    return obj;\n  }\n\n  if (obj instanceof Date) {\n    return new Date(obj.getTime()) as any;\n  }\n\n  if (Array.isArray(obj)) {\n    return obj.map((item) => deepClone(item)) as any;\n  }\n\n  if (obj instanceof Map) {\n    const cloned = new Map();\n    obj.forEach((value, key) => {\n      cloned.set(key, deepClone(value));\n    });\n    return cloned as any;\n  }\n\n  if (obj instanceof Set) {\n    const cloned = new Set();\n    obj.forEach((value) => {\n      cloned.add(deepClone(value));\n    });\n    return cloned as any;\n  }\n\n  const cloned = {} as T;\n  for (const key in obj) {\n    if (Object.hasOwn(obj, key)) {\n      cloned[key] = deepClone(obj[key]);\n    }\n  }\n\n  return cloned;\n}\n\n/**\n * Retry a function with exponential backoff.\n *\n * @param fn\n * @param maxRetries\n * @param initialDelay\n * @example\n */\nexport async function retryWithBackoff<T>(\n  fn: () => Promise<T>,\n  maxRetries: number = 3,\n  initialDelay: number = 100\n): Promise<T> {\n  let lastError: Error;\n\n  for (let i = 0; i < maxRetries; i++) {\n    try {\n      return await fn();\n    } catch (error) {\n      lastError = error as Error;\n      if (i < maxRetries - 1) {\n        const delay = initialDelay * 2 ** i;\n        await new Promise((resolve) => setTimeout(resolve, delay));\n      }\n    }\n  }\n\n  throw lastError!;\n}\n", "/**\n * @file Coordination system: agent.\n */\n\nimport { getLogger } from '../../config/logging-config.ts';\n\nconst logger = getLogger('coordination-agents-agent');\n\n/**\n * Agent implementation and wrappers.\n */\n\nimport { generateId, getDefaultCognitiveProfile } from '../swarm/core/utils.ts';\nimport type {\n  Agent,\n  AgentConfig,\n  AgentMetrics,\n  AgentState,\n  AgentStatus,\n  AgentType,\n  ExecutionResult,\n  Message,\n  MessageType,\n  Task,\n} from '../types.ts';\n\nexport class BaseAgent implements Agent {\n  id: string;\n  type: AgentType;\n  metrics: AgentMetrics;\n  config: AgentConfig;\n  state: AgentState;\n  connections: string[] = [];\n\n  private messageHandlers: Map<MessageType, (message: Message) => Promise<void>> = new Map();\n  private wasmAgentId?: number;\n\n  // Convenience getter for status\n  get status(): AgentStatus {\n    return this.state.status;\n  }\n\n  // Convenience setter for status\n  set status(value: AgentStatus) {\n    this.state.status = value;\n  }\n\n  constructor(config: AgentConfig) {\n    this.id = config?.id || generateId('agent');\n    this.type = config?.type;\n    this.config = {\n      ...config,\n      id: this.id,\n      cognitiveProfile: config?.cognitiveProfile || getDefaultCognitiveProfile(config?.type),\n    };\n\n    // Initialize metrics\n    this.metrics = {\n      tasksCompleted: 0,\n      tasksFailed: 0,\n      tasksInProgress: 0,\n      averageExecutionTime: 0,\n      successRate: 0,\n      cpuUsage: 0,\n      memoryUsage: 0,\n      diskUsage: 0,\n      networkUsage: 0,\n      codeQuality: 0,\n      testCoverage: 0,\n      bugRate: 0,\n      userSatisfaction: 0,\n      totalUptime: 0,\n      lastActivity: new Date(),\n      responseTime: 0,\n      resourceUsage: {\n        cpu: 0,\n        memory: 0,\n        disk: 0,\n        network: 0,\n      },\n    };\n\n    this.state = {\n      id: this.id as any, // Temporarily cast to any for AgentId compatibility\n      name: config?.name || `Agent-${this.id}`,\n      type: config?.type,\n      status: 'idle',\n      capabilities: {\n        codeGeneration: true,\n        codeReview: true,\n        testing: true,\n        documentation: true,\n        research: true,\n        analysis: true,\n        webSearch: false,\n        apiIntegration: true,\n        fileSystem: true,\n        terminalAccess: false,\n        languages: ['javascript', 'typescript', 'python'],\n        frameworks: ['node.js', 'react', 'express'],\n        domains: ['web-development', 'api-development'],\n        tools: ['git', 'npm', 'docker'],\n        maxConcurrentTasks: 5,\n        maxMemoryUsage: 1024,\n        maxExecutionTime: 30000,\n        reliability: 0.95,\n        speed: 0.8,\n        quality: 0.9,\n        ...config?.capabilities,\n      },\n      metrics: this.metrics,\n      workload: 0,\n      health: 1.0,\n      config: this.config,\n      environment: {\n        runtime: 'node',\n        version: process.version,\n        workingDirectory: process.cwd(),\n        tempDirectory: '/tmp',\n        logDirectory: './logs',\n        apiEndpoints: {},\n        credentials: {},\n        availableTools: [],\n        toolConfigs: {},\n      },\n      endpoints: [],\n      lastHeartbeat: new Date(),\n      taskHistory: [],\n      errorHistory: [],\n      childAgents: [],\n      collaborators: [],\n      currentTask: null,\n      load: 0,\n    };\n\n    this.setupMessageHandlers();\n  }\n\n  private setupMessageHandlers(): void {\n    this.messageHandlers.set('task_assignment', this.handleTaskAssignment.bind(this));\n    this.messageHandlers.set('coordination', this.handleCoordination.bind(this));\n    this.messageHandlers.set('knowledge_share', this.handleKnowledgeShare.bind(this));\n    this.messageHandlers.set('status_update', this.handleStatusUpdate.bind(this));\n  }\n\n  protected async executeTaskByType(task: Task): Promise<any> {\n    // Simulate work\n    await new Promise((resolve) => setTimeout(resolve, 100 + Math.random() * 400));\n\n    return {\n      taskId: task.id,\n      agentId: this.id,\n      result: `Task completed by ${this.config.type} agent`,\n      timestamp: Date.now(),\n    };\n  }\n\n  async communicate(message: Message): Promise<void> {\n    const handler = this.messageHandlers.get(message.type);\n    if (handler) {\n      await handler(message);\n    } else {\n      logger.warn(`No handler for message type: ${message.type}`);\n    }\n  }\n\n  update(state: Partial<AgentState>): void {\n    this.state = { ...this.state, ...state };\n  }\n\n  private updatePerformanceMetrics(success: boolean, executionTime: number): void {\n    // Initialize performance if it doesn't exist\n    if (!this.state.performance) {\n      this.state.performance = {\n        tasksCompleted: 0,\n        tasksFailed: 0,\n        averageExecutionTime: 0,\n        successRate: 0,\n      };\n    }\n\n    const performance = this.state.performance;\n\n    if (success) {\n      performance.tasksCompleted++;\n    } else {\n      performance.tasksFailed++;\n    }\n\n    const totalTasks = performance.tasksCompleted + performance.tasksFailed;\n    performance.successRate = totalTasks > 0 ? performance.tasksCompleted / totalTasks : 0;\n\n    // Update average execution time\n    const totalTime = performance.averageExecutionTime * (totalTasks - 1) + executionTime;\n    performance.averageExecutionTime = totalTime / totalTasks;\n  }\n\n  private async handleTaskAssignment(message: Message): Promise<void> {\n    const task = message.payload as Task;\n\n    // Execute the assigned task\n    this.state.status = 'busy';\n    try {\n      const result = await this.execute(task);\n\n      // Send result back to the swarm coordinator\n      await this.communicate({\n        id: `result-${Date.now()}`,\n        fromAgentId: this.id,\n        toAgentId: message.fromAgentId,\n        swarmId: message.swarmId,\n        type: 'result',\n        content: result,\n        timestamp: new Date(),\n        requiresResponse: false,\n      });\n\n      this.state.status = 'idle';\n    } catch (error) {\n      this.state.status = 'error';\n      throw error;\n    }\n  }\n\n  private async handleCoordination(_message: Message): Promise<void> {\n    // Handle coordination logic\n  }\n\n  private async handleKnowledgeShare(message: Message): Promise<void> {\n    // Store shared knowledge in memory\n    if (this.config.memory) {\n      this.config.memory.shortTerm.set(`knowledge_${message.id}`, message.payload);\n    }\n  }\n\n  private async handleStatusUpdate(_message: Message): Promise<void> {\n    // Process status update\n  }\n\n  setWasmAgentId(id: number): void {\n    this.wasmAgentId = id;\n  }\n\n  getWasmAgentId(): number | undefined {\n    return this.wasmAgentId;\n  }\n\n  // Required Agent interface methods\n  async initialize(): Promise<void> {\n    this.state.status = 'initializing';\n    // Initialize agent resources, connections, etc.\n    this.state.status = 'idle';\n    this.state.lastHeartbeat = new Date();\n  }\n\n  async execute(task: Task): Promise<ExecutionResult> {\n    const startTime = Date.now();\n    this.state.status = 'busy';\n    this.state.currentTask = task.id;\n\n    try {\n      // Basic task execution - can be overridden by specialized agents\n      const result = {\n        success: true,\n        data: { message: `Task ${task.id} completed by ${this.type} agent` },\n        executionTime: Date.now() - startTime,\n        agentId: this.id,\n        metadata: {\n          agentType: this.type,\n          taskId: task.id,\n        },\n      };\n\n      this.metrics.tasksCompleted++;\n      this.updatePerformanceMetrics(true, result?.executionTime);\n      return result;\n    } catch (error) {\n      this.metrics.tasksFailed++;\n      this.updatePerformanceMetrics(false, Date.now() - startTime);\n\n      return {\n        success: false,\n        data: { error: error instanceof Error ? error.message : String(error) },\n        executionTime: Date.now() - startTime,\n        agentId: this.id,\n        metadata: {\n          agentType: this.type,\n          taskId: task.id,\n        },\n      };\n    } finally {\n      this.state.status = 'idle';\n      this.state.currentTask = null;\n      this.state.lastHeartbeat = new Date();\n    }\n  }\n\n  async handleMessage(message: Message): Promise<void> {\n    await this.communicate(message);\n  }\n\n  updateState(updates: Partial<AgentState>): void {\n    this.state = { ...this.state, ...updates };\n  }\n\n  getStatus(): AgentStatus {\n    return this.state.status;\n  }\n\n  async shutdown(): Promise<void> {\n    this.state.status = 'terminated';\n    // Clean up resources, close connections, etc.\n    this.state.status = 'offline';\n  }\n}\n\n/**\n * Specialized agent for research tasks.\n *\n * @example\n */\nexport class ResearcherAgent extends BaseAgent {\n  constructor(config: Omit<AgentConfig, 'type'>) {\n    super({ ...config, type: 'researcher' });\n  }\n\n  protected override async executeTaskByType(task: Task): Promise<any> {\n    // Simulate research activities\n    const phases = ['collecting_data', 'analyzing', 'synthesizing', 'reporting'];\n    const results: any[] = [];\n\n    for (const phase of phases) {\n      await new Promise((resolve) => setTimeout(resolve, 200));\n      results.push({\n        phase,\n        timestamp: Date.now(),\n        findings: `${phase} completed for ${task.description}`,\n      });\n    }\n\n    return {\n      taskId: task.id,\n      agentId: this.id,\n      type: 'research_report',\n      phases: results,\n      summary: `Research completed on: ${task.description}`,\n      recommendations: ['Further investigation needed', 'Consider alternative approaches'],\n    };\n  }\n}\n\n/**\n * Specialized agent for coding tasks.\n *\n * @example\n */\nexport class CoderAgent extends BaseAgent {\n  constructor(config: Omit<AgentConfig, 'type'>) {\n    super({ ...config, type: 'coder' });\n  }\n\n  protected override async executeTaskByType(task: Task): Promise<any> {\n    // Simulate coding activities\n    const steps = ['design', 'implement', 'test', 'refactor'];\n    const codeArtifacts: any[] = [];\n\n    for (const step of steps) {\n      await new Promise((resolve) => setTimeout(resolve, 300));\n      codeArtifacts.push({\n        step,\n        timestamp: Date.now(),\n        artifact: `${step}_${task.id}.ts`,\n      });\n    }\n\n    return {\n      taskId: task.id,\n      agentId: this.id,\n      type: 'code_implementation',\n      artifacts: codeArtifacts,\n      summary: `Implementation completed for: ${task.description}`,\n      metrics: {\n        linesOfCode: Math.floor(Math.random() * 500) + 100,\n        complexity: Math.floor(Math.random() * 10) + 1,\n      },\n    };\n  }\n}\n\n/**\n * Specialized agent for analysis tasks.\n *\n * @example\n */\nexport class AnalystAgent extends BaseAgent {\n  constructor(config: Omit<AgentConfig, 'type'>) {\n    super({ ...config, type: 'analyst' });\n  }\n\n  protected override async executeTaskByType(task: Task): Promise<any> {\n    // Simulate analysis activities\n    await new Promise((resolve) => setTimeout(resolve, 400));\n\n    return {\n      taskId: task.id,\n      agentId: this.id,\n      type: 'analysis_report',\n      metrics: {\n        dataPoints: Math.floor(Math.random() * 1000) + 100,\n        confidence: Math.random() * 0.3 + 0.7,\n      },\n      insights: [\n        'Pattern detected in data',\n        'Anomaly found at timestamp X',\n        'Recommendation for optimization',\n      ],\n      visualizations: ['chart_1.png', 'graph_2.svg'],\n    };\n  }\n}\n\n/**\n * Factory function to create specialized agents.\n *\n * @param config\n * @example\n */\nexport function createAgent(config: AgentConfig): Agent {\n  switch (config?.type) {\n    case 'researcher':\n      return new ResearcherAgent(config);\n    case 'coder':\n      return new CoderAgent(config);\n    case 'analyst':\n      return new AnalystAgent(config);\n    default:\n      return new BaseAgent(config);\n  }\n}\n\n/**\n * Agent pool for managing multiple agents.\n *\n * @example\n */\nexport class AgentPool {\n  private agents: Map<string, Agent> = new Map();\n  private availableAgents: Set<string> = new Set();\n\n  addAgent(agent: Agent): void {\n    this.agents.set(agent.id, agent);\n    if (agent.state.status === 'idle') {\n      this.availableAgents.add(agent.id);\n    }\n  }\n\n  removeAgent(agentId: string): void {\n    this.agents.delete(agentId);\n    this.availableAgents.delete(agentId);\n  }\n\n  getAgent(agentId: string): Agent | undefined {\n    return this.agents.get(agentId);\n  }\n\n  getAvailableAgent(preferredType?: string): Agent | undefined {\n    let selectedAgent: Agent | undefined;\n\n    for (const agentId of Array.from(this.availableAgents)) {\n      const agent = this.agents.get(agentId);\n      if (!agent) continue;\n\n      if (!preferredType || agent.config.type === preferredType) {\n        selectedAgent = agent;\n        break;\n      }\n    }\n\n    if (!selectedAgent && this.availableAgents.size > 0) {\n      const firstAvailable = Array.from(this.availableAgents)[0];\n      if (firstAvailable) {\n        selectedAgent = this.agents.get(firstAvailable);\n      }\n    }\n\n    if (selectedAgent?.id) {\n      this.availableAgents.delete(selectedAgent?.id);\n    }\n\n    return selectedAgent;\n  }\n\n  releaseAgent(agentId: string): void {\n    const agent = this.agents.get(agentId);\n    if (agent && agent.state.status === 'idle') {\n      this.availableAgents.add(agentId);\n    }\n  }\n\n  getAllAgents(): Agent[] {\n    return Array.from(this.agents.values());\n  }\n\n  getAgentsByType(type: string): Agent[] {\n    return this.getAllAgents().filter((agent) => agent.config.type === type);\n  }\n\n  getAgentsByStatus(status: AgentStatus): Agent[] {\n    return this.getAllAgents().filter((agent) => agent.state.status === status);\n  }\n\n  async shutdown(): Promise<void> {\n    // Shutdown all agents\n    for (const agent of this.agents.values()) {\n      if (typeof agent.shutdown === 'function') {\n        await agent.shutdown();\n      }\n    }\n\n    // Clear the pools\n    this.agents.clear();\n    this.availableAgents.clear();\n  }\n}\n", "/**\n * @file Coordination system: singleton-container.\n */\n\nimport { getLogger } from '../../../config/logging-config.ts';\n\nconst logger = getLogger('coordination-swarm-core-singleton-container');\n/**\n * Registration options for singleton container.\n *\n * @example\n */\ninterface RegistrationOptions {\n  lazy?: boolean;\n  singleton?: boolean;\n  dependencies?: string[];\n}\n\n/**\n * Singleton Container - Dependency Injection Pattern.\n * Replaces global state management with proper IoC container.\n *\n * @example\n */\nclass SingletonContainer {\n  public instances: Map<string, any>;\n  public factories: Map<string, any>;\n  public isDestroying: boolean;\n\n  constructor() {\n    this.instances = new Map();\n    this.factories = new Map();\n    this.isDestroying = false;\n  }\n\n  /**\n   * Register a singleton factory.\n   *\n   * @param {string} key - Service identifier.\n   * @param {Function} factory - Factory function to create instance.\n   * @param {Object} options - Configuration options.\n   */\n  register(key: string, factory: (...args: any[]) => any, options: RegistrationOptions = {}) {\n    if (typeof factory !== 'function') {\n      throw new Error(`Factory for '${key}' must be a function`);\n    }\n\n    this.factories.set(key, {\n      factory,\n      lazy: options?.lazy !== false, // Default to lazy loading\n      singleton: options?.singleton !== false, // Default to singleton\n      dependencies: options?.dependencies || [],\n    });\n  }\n\n  /**\n   * Get or create singleton instance.\n   *\n   * @param {string} key - Service identifier.\n   * @returns {*} Singleton instance.\n   */\n  get<T = any>(key: string): T {\n    if (this.isDestroying) {\n      throw new Error(`Cannot get instance '${key}' during container destruction`);\n    }\n\n    // Return existing instance if available\n    if (this.instances.has(key)) {\n      return this.instances.get(key);\n    }\n\n    // Get factory configuration\n    const config = this.factories.get(key);\n    if (!config) {\n      throw new Error(`No factory registered for '${key}'`);\n    }\n\n    // Resolve dependencies\n    const dependencies = config?.dependencies?.map((dep) => this.get(dep));\n\n    try {\n      // Create instance using factory\n      const instance = config?.factory(...dependencies);\n\n      // Store singleton instance\n      if (config?.singleton) {\n        this.instances.set(key, instance);\n      }\n\n      return instance;\n    } catch (error) {\n      throw new Error(`Failed to create instance '${key}': ${error.message}`);\n    }\n  }\n\n  /**\n   * Check if service is registered.\n   *\n   * @param {string} key - Service identifier.\n   * @returns {boolean} True if registered.\n   */\n  has(key: string): boolean {\n    return this.factories.has(key) || this.instances.has(key);\n  }\n\n  /**\n   * Clear specific instance (force recreation).\n   *\n   * @param {string} key - Service identifier.\n   */\n  clear(key: string): void {\n    const instance = this.instances.get(key);\n    if (instance && typeof instance.destroy === 'function') {\n      instance.destroy();\n    }\n    this.instances.delete(key);\n  }\n\n  /**\n   * Destroy all instances and clear container.\n   */\n  destroy(): void {\n    this.isDestroying = true;\n\n    // Destroy instances in reverse order of creation\n    const instances = Array.from(this.instances.entries()).reverse();\n\n    for (const [key, instance] of instances) {\n      try {\n        if (instance && typeof instance.destroy === 'function') {\n          instance.destroy();\n        }\n      } catch (error) {\n        logger.warn(`Error destroying instance '${key}':`, error.message);\n      }\n    }\n\n    this.instances.clear();\n    this.factories.clear();\n\n    // Keep destroying flag to prevent new instance creation\n    // Reset only when explicitly requested\n  }\n\n  /**\n   * Reset container state (for testing).\n   */\n  reset(): void {\n    this.destroy();\n    this.isDestroying = false;\n  }\n\n  /**\n   * Get container statistics.\n   *\n   * @returns {Object} Container stats.\n   */\n  getStats(): any {\n    return {\n      registeredServices: this.factories.size,\n      activeInstances: this.instances.size,\n      services: Array.from(this.factories.keys()),\n      instances: Array.from(this.instances.keys()),\n    };\n  }\n}\n\n// Global container instance (properly managed)\nlet globalContainer: SingletonContainer | null = null;\n\n/**\n * Get or create global container.\n *\n * @returns {SingletonContainer} Global container instance.\n * @example\n */\nexport function getContainer(): SingletonContainer {\n  if (!globalContainer) {\n    globalContainer = new SingletonContainer();\n\n    // Register cleanup on process exit\n    if (typeof process !== 'undefined') {\n      process.on('exit', () => {\n        if (globalContainer) {\n          globalContainer.destroy();\n          globalContainer = null;\n        }\n      });\n\n      process.on('SIGINT', () => {\n        if (globalContainer) {\n          globalContainer.destroy();\n          globalContainer = null;\n        }\n        process.exit(0);\n      });\n    }\n  }\n\n  return globalContainer;\n}\n\n/**\n * Reset global container (for testing).\n *\n * @example\n */\nexport function resetContainer(): void {\n  if (globalContainer) {\n    globalContainer.destroy();\n  }\n  globalContainer = null;\n}\n\nexport { SingletonContainer };\n", "/**\n * Cognitive Pattern Evolution.\n * Advanced neural pattern recognition and evolution system.\n */\n/**\n * @file Neural network: cognitive-pattern-evolution.\n */\n\nexport class CognitivePatternEvolution {\n  private patterns: Map<string, any>;\n  private evolutionHistory: any[];\n  private options: any;\n\n  constructor(options = {}) {\n    this.patterns = new Map();\n    this.evolutionHistory = [];\n    this.options = {\n      mutationRate: 0.1,\n      selectionPressure: 0.3,\n      maxGenerations: 100,\n      ...options,\n    };\n  }\n\n  /**\n   * Evolve cognitive patterns based on performance.\n   *\n   * @param agentId\n   * @param performanceData\n   */\n  async evolvePatterns(agentId, performanceData) {\n    const generation = this.evolutionHistory.length;\n\n    // Select best performing patterns for this agent\n    const agentPatterns = Array.from(this.patterns.values()).filter((p) => p.agentId === agentId);\n\n    const selected = this.selectPatterns(performanceData || agentPatterns);\n\n    // Apply mutations and crossover\n    const evolved = this.applyEvolution(selected);\n\n    // Update pattern registry\n    this.updatePatterns(evolved);\n\n    this.evolutionHistory.push({\n      generation,\n      patterns: evolved.length,\n      avgFitness: this.calculateAverageFitness(evolved),\n      timestamp: new Date(),\n    });\n\n    return evolved;\n  }\n\n  /**\n   * Register a new cognitive pattern.\n   *\n   * @param id\n   * @param pattern\n   */\n  registerPattern(id, pattern) {\n    this.patterns.set(id, {\n      ...pattern,\n      fitness: 0,\n      generation: this.evolutionHistory.length,\n      created: new Date(),\n    });\n  }\n\n  /**\n   * Get pattern by ID.\n   *\n   * @param id\n   */\n  getPattern(id) {\n    return this.patterns.get(id);\n  }\n\n  /**\n   * Get all patterns.\n   */\n  getAllPatterns() {\n    return Array.from(this.patterns.values());\n  }\n\n  private selectPatterns(_performanceData) {\n    // Mock selection based on fitness\n    return Array.from(this.patterns.values())\n      .sort((a, b) => b.fitness - a.fitness)\n      .slice(0, Math.ceil(this.patterns.size * this.options.selectionPressure));\n  }\n\n  private applyEvolution(patterns) {\n    // Mock evolution logic\n    return patterns.map((pattern) => ({\n      ...pattern,\n      fitness: pattern.fitness + (Math.random() - 0.5) * this.options.mutationRate,\n      generation: this.evolutionHistory.length + 1,\n    }));\n  }\n\n  private updatePatterns(evolved) {\n    // Update existing patterns\n    evolved.forEach((pattern) => {\n      if (this.patterns.has(pattern.id)) {\n        this.patterns.set(pattern.id, pattern);\n      }\n    });\n  }\n\n  private calculateAverageFitness(patterns) {\n    if (patterns.length === 0) return 0;\n    const total = patterns.reduce((sum, p) => sum + p.fitness, 0);\n    return total / patterns.length;\n  }\n\n  /**\n   * Initialize agent for cognitive pattern evolution.\n   *\n   * @param agentId\n   * @param config\n   */\n  async initializeAgent(agentId: string, config: any) {\n    const agentPattern = {\n      id: `agent_${agentId}`,\n      agentId,\n      config,\n      patterns: [],\n      fitness: 0.5,\n      generation: 0,\n      timestamp: new Date(),\n    };\n\n    this.patterns.set(agentPattern.id, agentPattern);\n    return agentPattern;\n  }\n\n  /**\n   * Assess cognitive growth for an agent.\n   *\n   * @param agentId\n   */\n  async assessGrowth(agentId: string) {\n    const agentPatterns = Array.from(this.patterns.values()).filter((p) => p.agentId === agentId);\n\n    if (agentPatterns.length === 0) {\n      return { growth: 0, patterns: 0 };\n    }\n\n    const avgFitness = this.calculateAverageFitness(agentPatterns);\n    return {\n      growth: avgFitness,\n      patterns: agentPatterns.length,\n      latestGeneration: Math.max(...agentPatterns.map((p) => p.generation || 0)),\n    };\n  }\n\n  /**\n   * Enable cross-agent evolution.\n   *\n   * @param agentIds\n   * @param session\n   * @param _session\n   */\n  async enableCrossAgentEvolution(agentIds: string[], _session: any) {\n    for (const agentId of agentIds) {\n      const patterns = Array.from(this.patterns.values()).filter((p) => p.agentId === agentId);\n\n      // Share patterns across agents\n      for (const otherAgentId of agentIds) {\n        if (otherAgentId !== agentId) {\n          for (const pattern of patterns.slice(0, 3)) {\n            // Share top 3 patterns\n            const sharedPattern = {\n              ...pattern,\n              id: `shared_${pattern.id}_${otherAgentId}`,\n              agentId: otherAgentId,\n              sharedFrom: agentId,\n            };\n            this.patterns.set(sharedPattern.id, sharedPattern);\n          }\n        }\n      }\n    }\n\n    return { success: true, sharedPatterns: agentIds.length * 3 };\n  }\n\n  /**\n   * Calculate aggregation weights for gradients.\n   *\n   * @param gradients\n   */\n  calculateAggregationWeights(gradients: any[]) {\n    return gradients.map((_, _index) => {\n      // Simple equal weighting for now\n      return 1.0 / gradients.length;\n    });\n  }\n\n  /**\n   * Preserve cognitive history for an agent.\n   *\n   * @param agentId\n   */\n  async preserveHistory(agentId: string) {\n    const agentPatterns = Array.from(this.patterns.values()).filter((p) => p.agentId === agentId);\n\n    return {\n      agentId,\n      patterns: agentPatterns,\n      evolutionHistory: this.evolutionHistory.filter((h) => h.agentId === agentId),\n      timestamp: new Date(),\n    };\n  }\n\n  /**\n   * Restore cognitive history for an agent.\n   *\n   * @param agentId\n   * @param _agentId\n   * @param history\n   */\n  async restoreHistory(_agentId: string, history: any) {\n    if (history?.patterns) {\n      for (const pattern of history.patterns) {\n        this.patterns.set(pattern.id, pattern);\n      }\n    }\n    return { success: true };\n  }\n\n  /**\n   * Extract patterns for an agent.\n   *\n   * @param agentId\n   */\n  async extractPatterns(agentId: string) {\n    return Array.from(this.patterns.values())\n      .filter((p) => p.agentId === agentId)\n      .map((p) => ({\n        id: p.id,\n        type: p.type || 'general',\n        fitness: p.fitness,\n        generation: p.generation,\n      }));\n  }\n\n  /**\n   * Transfer patterns to another agent.\n   *\n   * @param agentId\n   * @param patterns\n   */\n  async transferPatterns(agentId: string, patterns: any[]) {\n    for (const pattern of patterns) {\n      const transferredPattern = {\n        ...pattern,\n        id: `transferred_${pattern.id}_${agentId}`,\n        agentId,\n        transferred: true,\n        timestamp: new Date(),\n      };\n      this.patterns.set(transferredPattern.id, transferredPattern);\n    }\n    return { success: true, transferred: patterns.length };\n  }\n\n  /**\n   * Apply pattern updates to an agent.\n   *\n   * @param agentId\n   * @param patternUpdates\n   */\n  async applyPatternUpdates(agentId: string, patternUpdates: any) {\n    const agentPatterns = Array.from(this.patterns.values()).filter((p) => p.agentId === agentId);\n\n    for (const pattern of agentPatterns) {\n      if (patternUpdates[pattern.id]) {\n        Object.assign(pattern, patternUpdates[pattern.id]);\n      }\n    }\n\n    return { success: true, updated: agentPatterns.length };\n  }\n\n  /**\n   * Get evolution statistics.\n   */\n  getStatistics() {\n    return {\n      totalPatterns: this.patterns.size,\n      generations: this.evolutionHistory.length,\n      averageFitness: this.calculateAverageFitness(Array.from(this.patterns.values())),\n      options: this.options,\n    };\n  }\n}\n\nexport default CognitivePatternEvolution;\n", "/**\n * DAA Cognition (Decision, Action, Adaptation)\n * Cognitive decision-making system with adaptive learning.\n */\n/**\n * @file Neural network: daa-cognition.\n */\n\ninterface DAACognitionOptions {\n  adaptationRate?: number;\n  decisionThreshold?: number;\n  maxHistory?: number;\n  [key: string]: any;\n}\n\ninterface CognitionDecision {\n  id: string;\n  context: any;\n  confidence: number;\n  timestamp: Date;\n  outcome?: any;\n}\n\ninterface CognitionAction {\n  id: string;\n  type: string;\n  parameters: any;\n  result?: any;\n}\n\ninterface CognitionAdaptation {\n  id: string;\n  trigger: string;\n  change: any;\n  effectiveness?: number;\n}\n\nexport class DAACognition {\n  public decisions: Map<string, CognitionDecision>;\n  public actions: Map<string, CognitionAction>;\n  public adaptations: Map<string, CognitionAdaptation>;\n  public options: DAACognitionOptions;\n  public history: any[];\n\n  constructor(options: DAACognitionOptions = {}) {\n    this.decisions = new Map();\n    this.actions = new Map();\n    this.adaptations = new Map();\n    this.options = {\n      adaptationRate: 0.05,\n      decisionThreshold: 0.7,\n      maxHistory: 1000,\n      ...options,\n    };\n    this.history = [];\n  }\n\n  /**\n   * Make a cognitive decision based on input data.\n   *\n   * @param context\n   * @param options\n   */\n  async makeDecision(context: any, options: any = {}): Promise<CognitionDecision> {\n    const decisionId = `decision_${Date.now()}_${Math.random().toString(36).slice(2)}`;\n\n    const decision = {\n      id: decisionId,\n      context,\n      confidence: this.calculateConfidence(context),\n      timestamp: new Date(),\n      options: options,\n    };\n\n    // Apply cognitive filters\n    const filtered = this.applyFilters(decision);\n\n    // Store decision\n    this.decisions.set(decisionId, filtered);\n    this.history.push(filtered);\n\n    // Cleanup old history\n    if (this.history.length > (this.options.maxHistory ?? 1000)) {\n      this.history = this.history.slice(-(this.options.maxHistory ?? 1000));\n    }\n\n    return filtered;\n  }\n\n  /**\n   * Execute an action based on decision.\n   *\n   * @param decisionId\n   * @param actionType\n   * @param parameters\n   */\n  async executeAction(decisionId, actionType, parameters = {}) {\n    const decision = this.decisions.get(decisionId);\n    if (!decision) {\n      throw new Error(`Decision ${decisionId} not found`);\n    }\n\n    const action = {\n      id: `action_${Date.now()}_${Math.random().toString(36).slice(2)}`,\n      decisionId,\n      type: actionType,\n      parameters,\n      executed: new Date(),\n      result: null,\n    };\n\n    // Mock action execution\n    const result = await this.performAction(action);\n    (action as any).result = result;\n\n    this.actions.set(action.id, action);\n    return action;\n  }\n\n  /**\n   * Adapt based on feedback.\n   *\n   * @param feedback\n   */\n  async adapt(feedback) {\n    const adaptationId = `adapt_${Date.now()}_${Math.random().toString(36).slice(2)}`;\n\n    const adaptation = {\n      id: adaptationId,\n      trigger: 'feedback_adaptation',\n      change: this.calculateAdaptations(feedback),\n      effectiveness: feedback.success ? 0.8 : 0.4,\n    };\n\n    // Apply adaptations\n    this.applyAdaptations(adaptation.change);\n\n    this.adaptations.set(adaptationId, adaptation);\n    return adaptation;\n  }\n\n  /**\n   * Get decision history.\n   *\n   * @param limit\n   */\n  getDecisionHistory(limit = 10) {\n    return this.history.slice(-limit).sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime());\n  }\n\n  /**\n   * Get cognitive metrics.\n   */\n  getMetrics() {\n    return {\n      totalDecisions: this.decisions.size,\n      totalActions: this.actions.size,\n      totalAdaptations: this.adaptations.size,\n      avgConfidence: this.calculateAverageConfidence(),\n      adaptationRate: this.options.adaptationRate,\n      recentDecisions: this.history.slice(-10).length,\n    };\n  }\n\n  private calculateConfidence(context) {\n    // Mock confidence calculation\n    const baseConfidence = 0.5;\n    const contextFactor = Object.keys(context).length * 0.1;\n    const historyFactor = this.history.length > 0 ? 0.1 : 0;\n\n    return Math.min(1, baseConfidence + contextFactor + historyFactor);\n  }\n\n  private applyFilters(decision) {\n    // Apply cognitive filters\n    const filtered = { ...decision };\n\n    // Threshold filter\n    if (filtered.confidence < (this.options.decisionThreshold ?? 0.7)) {\n      filtered.filtered = true;\n      filtered.reason = 'Below confidence threshold';\n    }\n\n    return filtered;\n  }\n\n  private async performAction(action) {\n    // Mock action performance\n    await new Promise((resolve) => setTimeout(resolve, 10 + Math.random() * 40));\n\n    return {\n      success: Math.random() > 0.1, // 90% success rate\n      duration: 10 + Math.random() * 40,\n      output: `Result for ${action.type}`,\n    };\n  }\n\n  private calculateAdaptations(feedback): Array<{ type: string; delta: number }> {\n    const changes: Array<{ type: string; delta: number }> = [];\n\n    // Adjust adaptation rate based on feedback\n    if (feedback.success !== undefined) {\n      if (feedback.success) {\n        changes.push({\n          type: 'adaptationRate',\n          delta: (this.options.adaptationRate ?? 0.05) * 0.1,\n        });\n      } else {\n        changes.push({\n          type: 'adaptationRate',\n          delta: -(this.options.adaptationRate ?? 0.05) * 0.1,\n        });\n      }\n    }\n\n    // Adjust decision threshold\n    if (feedback.confidence !== undefined) {\n      changes.push({\n        type: 'decisionThreshold',\n        delta: (feedback.confidence - (this.options.decisionThreshold ?? 0.7)) * 0.05,\n      });\n    }\n\n    return changes;\n  }\n\n  private applyAdaptations(changes) {\n    for (const change of changes) {\n      switch (change.type) {\n        case 'adaptationRate':\n          this.options.adaptationRate = Math.max(\n            0.01,\n            Math.min(0.5, (this.options.adaptationRate ?? 0.05) + change.delta)\n          );\n          break;\n        case 'decisionThreshold':\n          this.options.decisionThreshold = Math.max(\n            0.1,\n            Math.min(0.9, (this.options.decisionThreshold ?? 0.7) + change.delta)\n          );\n          break;\n      }\n    }\n  }\n\n  private calculateAverageConfidence() {\n    if (this.history.length === 0) return 0;\n\n    const total = this.history.reduce((sum, decision) => sum + decision.confidence, 0);\n    return total / this.history.length;\n  }\n}\n\nexport default DAACognition;\n", "/**\n * Meta Learning Framework.\n * Learning to learn - adaptive learning strategies.\n */\n/**\n * @file Neural network: meta-learning-framework.\n */\n\ninterface MetaLearningOptions {\n  maxStrategies?: number;\n  evaluationWindow?: number;\n  [key: string]: any;\n}\n\ninterface LearningStrategy {\n  performance: number;\n  usage: number;\n  created: Date;\n  [key: string]: any;\n}\n\nexport class MetaLearningFramework {\n  public learningStrategies: Map<string, LearningStrategy>;\n  public performanceHistory: any[];\n  public taskHistory: Map<string, any[]>;\n  public options: MetaLearningOptions;\n\n  constructor(options: MetaLearningOptions = {}) {\n    this.learningStrategies = new Map();\n    this.performanceHistory = [];\n    this.taskHistory = new Map();\n    this.options = {\n      maxStrategies: 10,\n      evaluationWindow: 100,\n      ...options,\n    };\n  }\n\n  /**\n   * Register a learning strategy.\n   *\n   * @param id\n   * @param strategy\n   */\n  registerStrategy(id: string, strategy: any): void {\n    this.learningStrategies.set(id, {\n      ...strategy,\n      performance: 0,\n      usage: 0,\n      created: new Date(),\n    });\n  }\n\n  /**\n   * Select best strategy for given task.\n   *\n   * @param taskType\n   * @param _context\n   */\n  selectStrategy(taskType, _context = {}) {\n    const strategies = Array.from(this.learningStrategies.values())\n      .filter((s) => s.applicableTasks?.includes(taskType) || !s.applicableTasks)\n      .sort((a, b) => b.performance - a.performance);\n\n    return strategies[0] || null;\n  }\n\n  /**\n   * Update strategy performance.\n   *\n   * @param strategyId\n   * @param performance\n   */\n  updatePerformance(strategyId, performance) {\n    const strategy = this.learningStrategies.get(strategyId);\n    if (strategy) {\n      strategy.performance =\n        (strategy.performance * strategy.usage + performance) / (strategy.usage + 1);\n      strategy.usage++;\n\n      this.performanceHistory.push({\n        strategyId,\n        performance,\n        timestamp: new Date(),\n      });\n\n      // Keep history within window\n      if (this.performanceHistory.length > this.options.evaluationWindow) {\n        this.performanceHistory = this.performanceHistory.slice(-this.options.evaluationWindow);\n      }\n    }\n  }\n\n  /**\n   * Get framework metrics.\n   */\n  getMetrics() {\n    return {\n      totalStrategies: this.learningStrategies.size,\n      avgPerformance: this.calculateAveragePerformance(),\n      bestStrategy: this.getBestStrategy(),\n      recentPerformance: this.performanceHistory.slice(-10),\n    };\n  }\n\n  private calculateAveragePerformance() {\n    const strategies = Array.from(this.learningStrategies.values());\n    if (strategies.length === 0) return 0;\n\n    const total = strategies.reduce((sum, s) => sum + s.performance, 0);\n    return total / strategies.length;\n  }\n\n  private getBestStrategy() {\n    const strategies = Array.from(this.learningStrategies.values());\n    return strategies.reduce(\n      (best, current) => (current?.performance > best.performance ? current : best),\n      { performance: -1 }\n    );\n  }\n\n  /**\n   * Adapt configuration for an agent.\n   *\n   * @param agentId\n   * @param config\n   */\n  async adaptConfiguration(agentId: string, config: any) {\n    const agentHistory = this.taskHistory.get(agentId) || [];\n\n    if (agentHistory.length === 0) {\n      return config; // No history, return original config\n    }\n\n    // Find best performing configuration from history\n    const bestTask = agentHistory.reduce((best, task) =>\n      task.performance > best.performance ? task : best\n    );\n\n    // Adapt configuration based on best performance\n    const adaptedConfig = {\n      ...config,\n      learningRate: bestTask.config?.learningRate || config?.learningRate,\n      architecture: bestTask.config?.architecture || config?.architecture,\n    };\n\n    return adaptedConfig;\n  }\n\n  /**\n   * Optimize training options for an agent.\n   *\n   * @param agentId\n   * @param options\n   */\n  async optimizeTraining(agentId: string, options: any) {\n    const agentHistory = this.taskHistory.get(agentId) || [];\n\n    if (agentHistory.length === 0) {\n      return options;\n    }\n\n    // Analyze historical training performance\n    const recentTasks = agentHistory.slice(-5);\n    const avgPerformance =\n      recentTasks.reduce((sum, task) => sum + task.performance, 0) / recentTasks.length;\n\n    const optimizedOptions = { ...options };\n\n    // Adjust learning rate based on performance\n    if (avgPerformance < 0.7) {\n      optimizedOptions.learningRate = (options?.learningRate || 0.001) * 1.1;\n    } else if (avgPerformance > 0.9) {\n      optimizedOptions.learningRate = (options?.learningRate || 0.001) * 0.9;\n    }\n\n    return optimizedOptions;\n  }\n\n  /**\n   * Preserve learning state for an agent.\n   *\n   * @param agentId\n   */\n  async preserveState(agentId: string) {\n    return {\n      agentId,\n      taskHistory: this.taskHistory.get(agentId) || [],\n      learningStrategies: Array.from(this.learningStrategies.values()),\n      timestamp: new Date(),\n    };\n  }\n\n  /**\n   * Restore learning state for an agent.\n   *\n   * @param agentId\n   * @param state\n   */\n  async restoreState(agentId: string, state: any) {\n    if (state?.taskHistory) {\n      this.taskHistory.set(agentId, state.taskHistory);\n    }\n    return { success: true };\n  }\n\n  /**\n   * Extract experiences for an agent.\n   *\n   * @param agentId\n   */\n  async extractExperiences(agentId: string) {\n    const history = this.taskHistory.get(agentId) || [];\n    return history.map((task) => ({\n      taskId: task.id,\n      performance: task.performance,\n      strategy: task.strategy,\n      timestamp: task.timestamp,\n    }));\n  }\n\n  /**\n   * Get meta-learning statistics.\n   */\n  getStatistics() {\n    const totalTasks = Array.from(this.taskHistory.values()).reduce(\n      (sum, history) => sum + history.length,\n      0\n    );\n\n    return {\n      totalAgents: this.taskHistory.size,\n      totalTasks,\n      strategies: this.learningStrategies.size,\n      averagePerformance: this.calculateAveragePerformance(),\n    };\n  }\n}\n\nexport default MetaLearningFramework;\n", "/**\n * Neural Coordination Protocol.\n * Protocol for coordinating neural networks across distributed agents.\n */\n/**\n * @file Neural network: neural-coordination-protocol\n */\n\nexport class NeuralCoordinationProtocol {\n  public nodes: Map<string, any>;\n  public messages: any[];\n  private sessions?: Map<string, any>;\n  private coordinationResults?: Map<string, any>;\n  public options: {\n    syncInterval: number;\n    maxMessages: number;\n    compressionEnabled: boolean;\n    [key: string]: any;\n  };\n\n  constructor(options = {}) {\n    this.nodes = new Map();\n    this.messages = [];\n    this.options = {\n      syncInterval: 1000,\n      maxMessages: 1000,\n      compressionEnabled: true,\n      ...options,\n    };\n  }\n\n  /**\n   * Register a neural node.\n   *\n   * @param nodeId\n   * @param nodeInfo\n   */\n  registerNode(nodeId, nodeInfo) {\n    this.nodes.set(nodeId, {\n      ...nodeInfo,\n      lastSync: new Date(),\n      messageCount: 0,\n      status: 'active',\n    });\n  }\n\n  /**\n   * Send coordination message.\n   *\n   * @param fromNode\n   * @param toNode\n   * @param messageType\n   * @param payload\n   */\n  async sendMessage(fromNode, toNode, messageType, payload) {\n    const message = {\n      id: `msg_${Date.now()}_${Math.random().toString(36).slice(2)}`,\n      from: fromNode,\n      to: toNode,\n      type: messageType,\n      payload,\n      timestamp: new Date(),\n    };\n\n    this.messages.push(message);\n\n    // Update node stats\n    const node = this.nodes.get(fromNode);\n    if (node) {\n      if (node.messageCount !== undefined) node.messageCount++;\n      if (node) node.lastSync = new Date();\n    }\n\n    // Cleanup old messages\n    if (this.messages.length > this.options.maxMessages) {\n      this.messages = this.messages.slice(-this.options.maxMessages);\n    }\n\n    return message;\n  }\n\n  /**\n   * Synchronize neural states.\n   *\n   * @param nodeId\n   * @param neuralState\n   */\n  async synchronize(nodeId, neuralState) {\n    const node = this.nodes.get(nodeId);\n    if (!node) {\n      throw new Error(`Node ${nodeId} not registered`);\n    }\n\n    // Mock synchronization\n    if (node) node.lastSync = new Date();\n    if (node) node.status = 'synced';\n\n    // Broadcast sync to other nodes\n    const syncMessage = {\n      type: 'neural_sync',\n      nodeId,\n      state: neuralState,\n      timestamp: new Date(),\n    };\n\n    for (const otherId of Array.from(this.nodes.keys())) {\n      if (otherId !== nodeId) {\n        await this.sendMessage(nodeId, otherId, 'sync', syncMessage);\n      }\n    }\n\n    return { success: true, syncedNodes: this.nodes.size - 1 };\n  }\n\n  /**\n   * Get protocol metrics.\n   */\n  getMetrics() {\n    const nodes = Array.from(this.nodes.values());\n    return {\n      totalNodes: nodes.length,\n      activeNodes: nodes?.filter((n) => n.status === 'active').length,\n      totalMessages: this.messages.length,\n      avgMessagesPerNode:\n        nodes.length > 0 ? nodes?.reduce((sum, n) => sum + n.messageCount, 0) / nodes.length : 0,\n      lastActivity:\n        this.messages.length > 0 ? this.messages[this.messages.length - 1]?.timestamp : null,\n    };\n  }\n\n  /**\n   * Get recent messages.\n   *\n   * @param limit\n   */\n  getRecentMessages(limit = 10) {\n    return this.messages\n      .slice(-limit)\n      .sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime());\n  }\n\n  /**\n   * Register an agent with the coordination protocol.\n   *\n   * @param agentId\n   * @param agent\n   */\n  async registerAgent(agentId: string, agent: any) {\n    const nodeInfo = {\n      id: agentId,\n      agent,\n      status: 'active',\n      messageCount: 0,\n      lastSeen: new Date(),\n      capabilities: agent.modelType || 'unknown',\n    };\n\n    this.nodes.set(agentId, nodeInfo);\n\n    // Send registration message to other nodes\n    for (const otherId of Array.from(this.nodes.keys())) {\n      if (otherId !== agentId) {\n        await this.sendMessage(agentId, otherId, 'register', {\n          type: 'agent_registration',\n          agentId,\n          capabilities: nodeInfo?.capabilities,\n          timestamp: new Date(),\n        });\n      }\n    }\n\n    return { success: true, registeredNodes: this.nodes.size };\n  }\n\n  /**\n   * Initialize a coordination session.\n   *\n   * @param session\n   */\n  async initializeSession(session: any) {\n    const sessionInfo = {\n      id: session.id,\n      agentIds: session.agentIds || [],\n      strategy: session.strategy || 'federated',\n      startTime: new Date(),\n      status: 'active',\n    };\n\n    // Register all agents in the session\n    for (const agentId of sessionInfo.agentIds) {\n      if (!this.nodes.has(agentId)) {\n        this.nodes.set(agentId, {\n          id: agentId,\n          status: 'active',\n          messageCount: 0,\n          lastSeen: new Date(),\n          capabilities: 'unknown',\n        });\n      }\n    }\n\n    // Store session for later reference\n    if (!this.sessions) {\n      this.sessions = new Map();\n    }\n    this.sessions.set(session.id, sessionInfo);\n\n    return { success: true, session: sessionInfo };\n  }\n\n  /**\n   * Coordinate agents in a session.\n   *\n   * @param session\n   */\n  async coordinate(session: any) {\n    const sessionInfo = this.sessions?.get(session.id);\n    if (!sessionInfo) {\n      throw new Error(`Session ${session.id} not found`);\n    }\n\n    // Perform coordination based on strategy\n    const coordinationResults = new Map();\n\n    for (const agentId of sessionInfo.agentIds) {\n      const node = this.nodes.get(agentId);\n      if (node) {\n        const coordination = {\n          agentId,\n          weightAdjustments: this.generateWeightAdjustments(),\n          patternUpdates: this.generatePatternUpdates(),\n          collaborationScore: Math.random() * 100,\n          newPatterns: [],\n          timestamp: new Date(),\n        };\n\n        coordinationResults?.set(agentId, coordination);\n      }\n    }\n\n    // Store results for later retrieval\n    if (!this.coordinationResults) {\n      this.coordinationResults = new Map();\n    }\n    this.coordinationResults.set(session.id, coordinationResults);\n\n    return { success: true, coordinated: coordinationResults.size };\n  }\n\n  /**\n   * Get coordination results for a session.\n   *\n   * @param sessionId\n   */\n  async getResults(sessionId: string) {\n    return this.coordinationResults?.get(sessionId) || null;\n  }\n\n  /**\n   * Get coordination statistics.\n   */\n  getStatistics() {\n    return {\n      totalNodes: this.nodes.size,\n      totalMessages: this.messages.length,\n      activeSessions: this.sessions?.size || 0,\n      averageMessageCount: this.calculateAverageMessageCount(),\n    };\n  }\n\n  private generateWeightAdjustments() {\n    return {\n      layer_0: Array.from({ length: 10 }, () => (Math.random() - 0.5) * 0.1),\n      layer_1: Array.from({ length: 10 }, () => (Math.random() - 0.5) * 0.1),\n    };\n  }\n\n  private generatePatternUpdates() {\n    return {\n      pattern_1: { type: 'enhancement', factor: 1.1 },\n      pattern_2: { type: 'refinement', factor: 0.95 },\n    };\n  }\n\n  private calculateAverageMessageCount() {\n    const nodes = Array.from(this.nodes.values());\n    if (nodes.length === 0) return 0;\n\n    const total = nodes?.reduce((sum, node) => sum + (node?.messageCount || 0), 0);\n    return total / nodes.length;\n  }\n}\n\nexport default NeuralCoordinationProtocol;\n", "/**\n * Neural Models Index.\n * Central registry for neural network models and presets.\n */\n/**\n * @file Neural-models module exports.\n */\n\nexport const MODEL_PRESETS = {\n  CLASSIFICATION: {\n    id: 'classification',\n    name: 'Classification Model',\n    architecture: 'feedforward',\n    layers: [128, 64, 32],\n    activation: 'relu',\n    outputActivation: 'softmax',\n  },\n  REGRESSION: {\n    id: 'regression',\n    name: 'Regression Model',\n    architecture: 'feedforward',\n    layers: [64, 32, 16],\n    activation: 'relu',\n    outputActivation: 'linear',\n  },\n  AUTOENCODER: {\n    id: 'autoencoder',\n    name: 'Autoencoder Model',\n    architecture: 'autoencoder',\n    encoderLayers: [128, 64, 32],\n    decoderLayers: [32, 64, 128],\n    activation: 'relu',\n  },\n  TRANSFORMER: {\n    id: 'transformer',\n    name: 'Transformer Model',\n    architecture: 'transformer',\n    heads: 8,\n    layers: 6,\n    hiddenSize: 512,\n    activation: 'gelu',\n  },\n};\n\n/**\n * Create a neural model from preset or custom configuration.\n *\n * @param modelType\n * @param config\n * @example\n */\nexport function createNeuralModel(modelType, config = {}) {\n  // If modelType is string, look for preset\n  if (typeof modelType === 'string') {\n    const preset = MODEL_PRESETS[modelType.toUpperCase()];\n    if (preset) {\n      return {\n        ...preset,\n        ...config, // Allow config overrides\n        created: new Date(),\n        id: `${preset.id}_${Date.now()}`,\n      };\n    }\n  }\n\n  // If modelType is actually config object (legacy usage)\n  const actualConfig = typeof modelType === 'object' ? modelType : config;\n\n  return {\n    ...actualConfig,\n    created: new Date(),\n    id: actualConfig?.id || `custom_${Date.now()}`,\n  };\n}\n\n/**\n * Get available model presets.\n *\n * @example\n */\nexport function getAvailablePresets() {\n  return Object.keys(MODEL_PRESETS);\n}\n\n/**\n * Validate model configuration.\n *\n * @param config\n * @example\n */\nexport function validateModelConfig(config) {\n  const required = ['architecture', 'layers'];\n  const missing = required.filter((field) => !config?.[field]);\n\n  if (missing.length > 0) {\n    throw new Error(`Missing required fields: ${missing.join(', ')}`);\n  }\n\n  return true;\n}\n\nexport default {\n  MODEL_PRESETS,\n  createNeuralModel,\n  getAvailablePresets,\n  validateModelConfig,\n};\n", "/**\n * Neural Presets Complete.\n * Complete collection of neural network presets and utilities.\n */\n/**\n * @file Neural network: neural-presets-complete.\n */\n\nexport interface Preset {\n  id: string;\n  architecture: string;\n  layers?: number[] | number; // Some presets use numeric layer count instead of array\n  hiddenSize?: number;\n  heads?: number;\n  sequenceLength?: number;\n  learningRate: number;\n  dropout?: number;\n  activation?: string;\n  [k: string]: any; // Allow extension for legacy dynamic fields\n}\n\n// Define CompletePreset type\nexport type CompletePreset = Preset;\n\nexport type CompletePresetMap = Record<string, CompletePreset>;\n\nexport const COMPLETE_NEURAL_PRESETS: CompletePresetMap = {\n  // Basic presets\n  SIMPLE_MLP: {\n    id: 'simple_mlp',\n    architecture: 'feedforward',\n    layers: [64, 32, 16],\n    activation: 'relu',\n    learningRate: 0.001,\n  },\n\n  // Advanced presets\n  DEEP_NETWORK: {\n    id: 'deep_network',\n    architecture: 'feedforward',\n    layers: [512, 256, 128, 64, 32],\n    activation: 'leaky_relu',\n    learningRate: 0.0001,\n    dropout: 0.2,\n  },\n\n  // Specialized presets\n  TIME_SERIES: {\n    id: 'time_series',\n    architecture: 'lstm',\n    hiddenSize: 128,\n    layers: 2,\n    sequenceLength: 50,\n    learningRate: 0.001,\n  },\n\n  ATTENTION_MODEL: {\n    id: 'attention',\n    architecture: 'transformer',\n    heads: 8,\n    layers: 6,\n    hiddenSize: 512,\n    sequenceLength: 128,\n    learningRate: 0.0001,\n  },\n};\n\n/**\n * Cognitive Pattern Selector.\n * Selects optimal neural patterns based on task requirements.\n *\n * @example\n */\nexport class CognitivePatternSelector {\n  private patterns: Map<string, any>;\n  private selectionHistory: Array<{\n    taskType: string;\n    requirements: any;\n    selected?: string;\n    timestamp: Date;\n  }>;\n\n  constructor() {\n    this.patterns = new Map();\n    this.selectionHistory = [];\n  }\n\n  /**\n   * Select pattern based on task type and requirements.\n   *\n   * @param taskType\n   * @param requirements\n   */\n  selectPattern(taskType: string, requirements: Record<string, any> = {}) {\n    const candidates = this.getCandidatePatterns(taskType, requirements);\n    const selected = this.scoreAndSelect(candidates, requirements);\n\n    this.selectionHistory.push({\n      taskType,\n      requirements,\n      selected: (selected as any)?.['id'],\n      timestamp: new Date(),\n    });\n\n    return selected;\n  }\n\n  /**\n   * Register a custom pattern.\n   *\n   * @param pattern\n   * @param pattern.id\n   */\n  registerPattern(pattern: { id: string; [k: string]: any }) {\n    this.patterns.set(pattern.id, pattern);\n  }\n\n  private getCandidatePatterns(_taskType: string, requirements: Record<string, any>) {\n    const presets = Object.values(COMPLETE_NEURAL_PRESETS);\n    const custom = Array.from(this.patterns.values());\n\n    return [...presets, ...custom].filter((pattern: any) => {\n      const reqArch = requirements['architecture'];\n      if (reqArch && pattern['architecture'] !== reqArch) {\n        return false;\n      }\n      return true;\n    });\n  }\n\n  private scoreAndSelect(\n    candidates: Array<Record<string, any>>,\n    requirements: Record<string, any>\n  ) {\n    if (candidates.length === 0) return null;\n\n    // Simple scoring based on requirements match\n    const scored = candidates.map((pattern) => ({\n      pattern,\n      score: this.calculateScore(pattern, requirements),\n    }));\n\n    return scored.sort((a, b) => b.score - a.score)[0]?.pattern;\n  }\n\n  private calculateScore(pattern: Record<string, any>, requirements: Record<string, any>) {\n    let score = 0.5; // Base score\n\n    // Architecture match\n    if (requirements['architecture'] === pattern['architecture']) {\n      score += 0.3;\n    }\n\n    // Size preferences\n    const patternLayers: number[] | undefined = Array.isArray(pattern['layers'])\n      ? pattern['layers']\n      : typeof pattern['layers'] === 'number'\n        ? Array(pattern['layers']).fill(0)\n        : undefined;\n\n    if (requirements['complexity'] === 'high' && patternLayers && patternLayers.length > 4) {\n      score += 0.2;\n    } else if (requirements['complexity'] === 'low' && patternLayers && patternLayers.length <= 3) {\n      score += 0.2;\n    }\n\n    return score;\n  }\n\n  /**\n   * Select patterns for a specific preset.\n   *\n   * @param modelType\n   * @param presetName\n   * @param _presetName\n   * @param taskContext\n   */\n  selectPatternsForPreset(modelType: string, _presetName: string, taskContext: any = {}) {\n    // Return appropriate cognitive patterns based on model type and context\n    const patterns: string[] = [];\n\n    if (modelType === 'transformer' || modelType === 'attention') {\n      patterns.push('attention', 'abstract');\n    } else if (modelType === 'lstm' || modelType === 'gru') {\n      patterns.push('systems', 'convergent');\n    } else if (modelType === 'cnn') {\n      patterns.push('lateral', 'critical');\n    } else {\n      patterns.push('convergent');\n    }\n\n    // Add creativity-based patterns\n    if (taskContext.requiresCreativity) {\n      patterns.push('divergent', 'lateral');\n    }\n\n    if (taskContext.requiresPrecision) {\n      patterns.push('convergent', 'critical');\n    }\n\n    return patterns;\n  }\n\n  /**\n   * Get preset recommendations based on use case.\n   *\n   * @param useCase\n   * @param requirements\n   * @param _requirements\n   */\n  getPresetRecommendations(useCase: string, _requirements: any = {}) {\n    const recommendations: Array<{\n      preset: string;\n      score: number;\n      reason: string;\n    }> = [];\n\n    // Basic matching logic\n    if (useCase.toLowerCase().includes('text') || useCase.toLowerCase().includes('nlp')) {\n      recommendations.push({\n        preset: 'transformer',\n        score: 0.9,\n        reason: 'Text processing use case',\n      });\n    } else if (\n      useCase.toLowerCase().includes('image') ||\n      useCase.toLowerCase().includes('vision')\n    ) {\n      recommendations.push({\n        preset: 'cnn',\n        score: 0.85,\n        reason: 'Image processing use case',\n      });\n    } else if (\n      useCase.toLowerCase().includes('time') ||\n      useCase.toLowerCase().includes('sequence')\n    ) {\n      recommendations.push({\n        preset: 'lstm',\n        score: 0.8,\n        reason: 'Sequential data use case',\n      });\n    } else {\n      recommendations.push({\n        preset: 'feedforward',\n        score: 0.7,\n        reason: 'General purpose neural network',\n      });\n    }\n\n    return recommendations;\n  }\n}\n\n/**\n * Neural Adaptation Engine.\n * Adapts neural networks based on performance feedback.\n *\n * @example\n */\nexport interface AdaptationRecord {\n  timestamp: Date;\n  originalConfig: any;\n  id?: string;\n  adaptations?: Array<{\n    parameter: string;\n    change: string;\n    factor?: number;\n    reason: string;\n  }>;\n  expectedImprovement?: number;\n  [key: string]: any;\n}\n\nexport interface PerformanceRecord {\n  performance: { accuracy?: number; loss?: number; [k: string]: any };\n  timestamp: Date;\n}\n\nexport class NeuralAdaptationEngine {\n  private adaptations: AdaptationRecord[];\n  private performanceHistory: PerformanceRecord[];\n\n  constructor() {\n    this.adaptations = [];\n    this.performanceHistory = [];\n  }\n\n  /**\n   * Adapt network based on performance feedback.\n   *\n   * @param networkConfig\n   * @param performanceData\n   * @param performanceData.accuracy\n   * @param performanceData.loss\n   */\n  adapt(\n    networkConfig: any,\n    performanceData: { accuracy?: number; loss?: number; [k: string]: any }\n  ) {\n    const adaptation = this.generateAdaptation(networkConfig, performanceData);\n\n    this.adaptations.push({\n      ...adaptation,\n      timestamp: new Date(),\n      originalConfig: networkConfig,\n    });\n\n    this.performanceHistory.push({\n      performance: performanceData,\n      timestamp: new Date(),\n    });\n\n    return adaptation;\n  }\n\n  /**\n   * Get adaptation recommendations.\n   *\n   * @param _networkConfig\n   */\n  getRecommendations(_networkConfig: any) {\n    const recentPerformance = this.performanceHistory.slice(-10);\n\n    if (recentPerformance.length === 0) {\n      return { action: 'monitor', reason: 'Insufficient performance data' };\n    }\n\n    const avgPerformance =\n      recentPerformance.reduce((sum, p) => sum + (p.performance.accuracy || 0), 0) /\n        recentPerformance.length || 0;\n\n    if (avgPerformance < 0.7) {\n      return {\n        action: 'increase_complexity',\n        reason: 'Low performance detected',\n        suggestion: 'Add more layers or increase learning rate',\n      };\n    } else if (avgPerformance > 0.95) {\n      return {\n        action: 'reduce_complexity',\n        reason: 'Possible overfitting',\n        suggestion: 'Add dropout or reduce network size',\n      };\n    }\n\n    return { action: 'maintain', reason: 'Performance is adequate' };\n  }\n\n  private generateAdaptation(\n    _config: any,\n    performance: { accuracy?: number; loss?: number; [k: string]: any }\n  ) {\n    const adaptations: Array<{\n      parameter: string;\n      change: string;\n      factor?: number;\n      reason: string;\n    }> = [];\n\n    // Learning rate adaptation\n    if (performance.loss && performance.loss > 0.5) {\n      adaptations.push({\n        parameter: 'learningRate',\n        change: 'increase',\n        factor: 1.1,\n        reason: 'High loss detected',\n      });\n    } else if (performance.loss && performance.loss < 0.01) {\n      adaptations.push({\n        parameter: 'learningRate',\n        change: 'decrease',\n        factor: 0.9,\n        reason: 'Very low loss, may be overfitting',\n      });\n    }\n\n    // Architecture adaptation\n    if (performance.accuracy && performance.accuracy < 0.6) {\n      adaptations.push({\n        parameter: 'architecture',\n        change: 'add_layer',\n        reason: 'Low accuracy, need more capacity',\n      });\n    }\n\n    return {\n      id: `adapt_${Date.now()}`,\n      adaptations,\n      expectedImprovement: this.estimateImprovement(adaptations),\n    };\n  }\n\n  private estimateImprovement(\n    adaptations: Array<{ parameter: string; change: string; factor?: number; reason: string }>\n  ) {\n    // Simple heuristic for improvement estimation\n    return adaptations.length * 0.05; // 5% improvement per adaptation\n  }\n\n  /**\n   * Initialize adaptation for an agent.\n   *\n   * @param agentId\n   * @param modelType\n   * @param template\n   */\n  async initializeAdaptation(agentId: string, modelType: string, template: string) {\n    const initialization = {\n      agentId,\n      modelType,\n      template,\n      timestamp: new Date(),\n      adaptationState: 'initialized',\n    };\n\n    this.adaptations.push({\n      ...initialization,\n      timestamp: new Date(),\n      originalConfig: { modelType, template },\n    });\n\n    return initialization;\n  }\n\n  /**\n   * Record an adaptation result.\n   *\n   * @param agentId\n   * @param adaptationResult\n   */\n  async recordAdaptation(agentId: string, adaptationResult: any) {\n    this.adaptations.push({\n      agentId,\n      adaptationResult,\n      timestamp: new Date(),\n      originalConfig: {},\n    });\n\n    this.performanceHistory.push({\n      performance: adaptationResult?.performance || adaptationResult,\n      timestamp: new Date(),\n    });\n\n    return { success: true };\n  }\n\n  /**\n   * Get adaptation recommendations for an agent.\n   *\n   * @param agentId\n   */\n  async getAdaptationRecommendations(agentId: string) {\n    const agentAdaptations = this.adaptations.filter((a) => (a as any)['agentId'] === agentId);\n\n    if (agentAdaptations.length === 0) {\n      return {\n        action: 'monitor',\n        reason: 'No adaptation history available',\n        recommendations: [],\n      };\n    }\n\n    const recent = agentAdaptations.slice(-5);\n    const recommendations: Array<{\n      type: string;\n      action: string;\n      reason: string;\n    }> = [];\n\n    // Analyze recent adaptations for patterns\n    const avgImprovement =\n      recent.reduce((sum, a) => {\n        const accuracy = (a as any)['adaptationResult']?.accuracy;\n        return sum + (accuracy || 0);\n      }, 0) / recent.length;\n\n    if (avgImprovement < 0.7) {\n      recommendations.push({\n        type: 'architecture',\n        action: 'increase_complexity',\n        reason: 'Low performance trend detected',\n      });\n    }\n\n    return {\n      action: 'adapt',\n      reason: 'Based on performance history',\n      recommendations,\n    };\n  }\n\n  /**\n   * Export adaptation insights.\n   */\n  exportAdaptationInsights() {\n    const insights: {\n      totalAdaptations: number;\n      averageImprovement: number;\n      commonPatterns: Array<{ type: string; count: number }>;\n      recommendations: any[];\n    } = {\n      totalAdaptations: this.adaptations.length,\n      averageImprovement: 0,\n      commonPatterns: [],\n      recommendations: [],\n    };\n\n    if (this.adaptations.length > 0) {\n      const improvements = this.adaptations\n        .map((a) => (a as any)['adaptationResult']?.accuracy || 0)\n        .filter((acc) => acc > 0);\n\n      if (improvements.length > 0) {\n        insights.averageImprovement =\n          improvements.reduce((sum, imp) => sum + imp, 0) / improvements.length;\n      }\n\n      // Find common adaptation patterns\n      const adaptationTypes = this.adaptations\n        .map((a) => (a as any)['adaptationResult']?.type || 'unknown')\n        .reduce<Record<string, number>>((counts, type) => {\n          counts[type] = (counts[type] || 0) + 1;\n          return counts;\n        }, {});\n\n      insights.commonPatterns = Object.entries(adaptationTypes)\n        .map(([type, count]) => ({ type, count }))\n        .sort((a, b) => (b.count) - (a.count));\n    }\n\n    return insights;\n  }\n}\n\nexport default {\n  COMPLETE_NEURAL_PRESETS,\n  CognitivePatternSelector,\n  NeuralAdaptationEngine,\n};\n", "/**\n * Neural Network Presets Index.\n * Collection of predefined neural network configurations.\n */\n/**\n * @file Presets module exports.\n */\n\nexport interface NeuralPreset {\n  id: string;\n  name: string;\n  type: string; // classification | regression | deep | etc.\n  architecture: string;\n  layers: number[];\n  activation: string;\n  outputActivation: string;\n  learningRate: number;\n  batchSize: number;\n  useCase: string[];\n  dropout?: number;\n  config?: Record<string, any>;\n  model?: string;\n  description?: string;\n  performance?: {\n    accuracy?: number;\n    latency?: number;\n    memoryUsage?: number;\n    [key: string]: any;\n  };\n}\n\nexport type NeuralPresetMap = Record<string, NeuralPreset>;\n\nexport const NEURAL_PRESETS: NeuralPresetMap = {\n  // Basic presets\n  BASIC_CLASSIFIER: {\n    id: 'basic_classifier',\n    name: 'Basic Classification Network',\n    type: 'classification',\n    architecture: 'feedforward',\n    layers: [128, 64, 32],\n    activation: 'relu',\n    outputActivation: 'softmax',\n    learningRate: 0.001,\n    batchSize: 32,\n    useCase: ['image_classification', 'text_classification'],\n  },\n\n  REGRESSION_MODEL: {\n    id: 'regression_model',\n    name: 'Regression Network',\n    type: 'regression',\n    architecture: 'feedforward',\n    layers: [64, 32, 16],\n    activation: 'relu',\n    outputActivation: 'linear',\n    learningRate: 0.001,\n    batchSize: 32,\n    useCase: ['price_prediction', 'value_estimation'],\n  },\n\n  // Advanced presets\n  DEEP_LEARNING: {\n    id: 'deep_learning',\n    name: 'Deep Learning Network',\n    type: 'deep',\n    architecture: 'feedforward',\n    layers: [512, 256, 128, 64, 32],\n    activation: 'leaky_relu',\n    outputActivation: 'softmax',\n    learningRate: 0.0001,\n    batchSize: 64,\n    dropout: 0.3,\n    useCase: ['complex_classification', 'feature_learning'],\n  },\n};\n\n/**\n * Get preset by category and name.\n *\n * @param category\n * @param presetName\n * @example\n */\nexport function getPreset(category: string, presetName?: string): NeuralPreset | undefined {\n  if (presetName) {\n    // Two-argument version - look by category and preset name\n    const presets = Object.values(NEURAL_PRESETS);\n    return presets.find(\n      (preset) =>\n        preset.type === category &&\n        (preset.id === presetName || preset.name.toLowerCase().includes(presetName.toLowerCase()))\n    );\n  } else {\n    // Single-argument version (legacy) - category is actually presetId\n    return NEURAL_PRESETS[category.toUpperCase()];\n  }\n}\n\n/**\n * Get recommended preset for use case.\n *\n * @param useCase\n * @example\n */\nexport function getRecommendedPreset(useCase: string): NeuralPreset {\n  const presets = Object.values(NEURAL_PRESETS);\n  const found = presets.find((preset) => preset.useCase.includes(useCase));\n  // Fallback to a known safe baseline preset\n  return (found ?? NEURAL_PRESETS['BASIC_CLASSIFIER']) as NeuralPreset;\n}\n\n/**\n * Search presets by use case.\n *\n * @param useCase\n * @example\n */\nexport function searchPresetsByUseCase(useCase: string): NeuralPreset[] {\n  const presets = Object.values(NEURAL_PRESETS);\n  return presets.filter((preset) => preset.useCase.includes(useCase));\n}\n\n/**\n * Get presets by category.\n *\n * @param category\n * @example\n */\nexport function getCategoryPresets(category: string): NeuralPreset[] {\n  const presets = Object.values(NEURAL_PRESETS);\n  return presets.filter((preset) => preset.type === category);\n}\n\n/**\n * Validate preset configuration.\n *\n * @param config\n * @example\n */\nexport function validatePresetConfig(config: Partial<NeuralPreset>): boolean {\n  const required: Array<keyof NeuralPreset> = ['id', 'architecture', 'layers'];\n  const missing = required.filter((field) => !(field in config) || (config as any)[field] == null);\n\n  if (missing.length > 0) {\n    throw new Error(`Invalid preset configuration. Missing: ${missing.join(', ')}`);\n  }\n\n  if (!Array.isArray(config?.layers) || config?.layers.length === 0) {\n    throw new Error('Layers must be a non-empty array');\n  }\n\n  return true;\n}\n\nexport default {\n  NEURAL_PRESETS,\n  getPreset,\n  getRecommendedPreset,\n  searchPresetsByUseCase,\n  getCategoryPresets,\n  validatePresetConfig,\n};\n", "/**\n * @file Neural Network Manager for Per-Agent Neural Networks.\n *\n * Manages neural networks for individual agents with WASM integration,\n * cognitive pattern evolution, and collaborative learning capabilities.\n */\n\nimport { getLogger } from '../../config/logging-config.ts';\n\nconst logger = getLogger('neural-core-neural-network-manager');\n\n// Internal neural modules\nimport { CognitivePatternEvolution } from './cognitive-pattern-evolution.ts';\nimport { DAACognition } from './daa-cognition.ts';\nimport { MetaLearningFramework } from './meta-learning-framework.ts';\nimport { NeuralCoordinationProtocol } from './neural-coordination-protocol.ts';\nimport { createNeuralModel, MODEL_PRESETS } from './neural-models/index.ts';\nimport {\n  COMPLETE_NEURAL_PRESETS,\n  CognitivePatternSelector,\n  NeuralAdaptationEngine,\n} from './neural-models/neural-presets-complete.ts';\nimport {\n  getCategoryPresets,\n  getPreset,\n  getRecommendedPreset,\n  NEURAL_PRESETS,\n  searchPresetsByUseCase,\n  validatePresetConfig,\n} from './neural-models/presets/index.ts';\n\n/**\n * Neural network instance interface.\n *\n * @example\n */\ninterface NeuralNetworkInstance {\n  /** Unique identifier for the network */\n  id?: string;\n  /** Agent ID */\n  agentId?: string;\n  /** Network configuration */\n  config?: NeuralModelConfig;\n  /** Training state */\n  trainingState?: {\n    epoch: number;\n    loss: number;\n    accuracy: number;\n    learningRate: number;\n    optimizer: string;\n  };\n  /** Performance metrics */\n  metrics?: PerformanceMetrics;\n  /** Model type */\n  modelType?: string;\n  /** Training method */\n  train?: (\n    trainingData: TrainingDataItem[],\n    options: Record<string, unknown>\n  ) => Promise<PerformanceMetrics>;\n  /** Get metrics method */\n  getMetrics?: () => PerformanceMetrics;\n  /** Save method */\n  save?: (filePath: string) => Promise<boolean>;\n  /** Load method */\n  load?: (filePath: string) => Promise<boolean>;\n}\n\n/**\n * Neural model configuration.\n *\n * @example\n */\ninterface NeuralModelConfig {\n  /** Model architecture type */\n  architecture: string;\n  /** Input layer size */\n  inputSize: number;\n  /** Hidden layers configuration */\n  hiddenLayers: number[];\n  /** Output layer size */\n  outputSize: number;\n  /** Additional parameters */\n  parameters?: Record<string, unknown>;\n  /** Meta-learning enabled */\n  enableMetaLearning?: boolean;\n  /** Neural network template */\n  template?: string;\n  /** Network layers */\n  layers?: number[];\n  /** Activation function */\n  activation?: string;\n  /** Learning rate */\n  learningRate?: number;\n  /** Optimizer type */\n  optimizer?: string;\n}\n\n/**\n * Performance metrics for neural networks.\n *\n * @example\n */\ninterface PerformanceMetrics {\n  /** Training accuracy */\n  accuracy: number;\n  /** Training loss */\n  loss: number;\n  /** Training time in milliseconds */\n  trainingTime: number;\n  /** Inference time in milliseconds */\n  inferenceTime: number;\n  /** Memory usage in bytes */\n  memoryUsage: number;\n  /** Creation time */\n  creationTime?: number;\n  /** Model type */\n  modelType?: string;\n  /** Cognitive patterns */\n  cognitivePatterns?: Array<{\n    id: string;\n    type: string;\n    strength: number;\n    pattern?: string;\n    confidence?: number;\n    lastUpdated?: number;\n  }>;\n  /** Adaptation history */\n  adaptationHistory?: Array<{\n    timestamp: number;\n    trainingResult?: PerformanceMetrics | null;\n    cognitiveGrowth?: {\n      growth: number;\n      patterns: number;\n      latestGeneration?: number;\n    };\n    changes: {\n      weights?: Record<string, number[]>;\n      learningRate?: number;\n      architecture?: string[];\n    };\n    performance: PerformanceMetrics;\n  }>;\n  /** Collaboration score */\n  collaborationScore?: number;\n}\n\n/**\n * Knowledge structure for agents.\n *\n * @example\n */\ninterface AgentKnowledge {\n  agentId?: string;\n  timestamp?: number;\n  modelType?: string;\n  weights?: Record<string, number[]>;\n  patterns?: Array<{ id: string; type: string; data: unknown }>;\n  experiences?: Array<{ timestamp: number; context: unknown; outcome: unknown }>;\n  performance?: PerformanceMetrics;\n  specializations?: Array<{ domain: string; confidence?: number; timestamp?: number }>;\n  data?: Record<string, unknown>;\n}\n\n/**\n * Collaborative session interface.\n *\n * @example\n */\ninterface CollaborativeSession {\n  id?: string;\n  active: boolean;\n  agentIds: string[];\n  syncInterval: number;\n  coordinationMatrix?: number[][];\n  knowledgeGraph?: Map<string, unknown>;\n  evolutionTracker?: Map<string, unknown>;\n  privacyLevel?: string;\n  knowledgeSharingMatrix?: Record<string, Record<string, number>>;\n  strategy?: unknown;\n  networks?: (NeuralNetworkInstance | undefined)[];\n}\n\n/**\n * Agent interaction record.\n *\n * @example\n */\ninterface AgentInteraction {\n  timestamp: number;\n  strength: number;\n  type: string;\n  agentA: string;\n  agentB: string;\n}\n\n/**\n * Coordination result interface.\n *\n * @example\n */\ninterface CoordinationResult {\n  weightAdjustments?: Record<string, number[]>;\n  patternUpdates?: { id: string; changes: Record<string, unknown> };\n  collaborationScore?: number;\n  newPatterns?: Array<{ id: string; type: string; data: unknown }>;\n}\n\n/**\n * Training data interface.\n *\n * @example\n */\ninterface TrainingDataItem {\n  input: number[];\n  output: number[];\n}\n\n/**\n * Enhanced neural network instance interface.\n *\n * @example\n */\ninterface EnhancedNeuralNetworkInstance extends NeuralNetworkInstance {\n  getWeights?: () => Record<string, number[]>;\n  setWeights?: (weights: Record<string, number[]>) => void;\n}\n\n/**\n * Neural Network Manager.\n *\n * Centralized management system for per-agent neural networks with advanced.\n * Capabilities including cognitive pattern evolution, federated learning,\n * and WASM-accelerated computation..\n *\n * @example\n * ```typescript\n * const manager = new NeuralNetworkManager(wasmLoader)\n * await manager.initialize()\n *\n * const network = await manager.createNetwork('agent-001', {\n *   architecture: 'feedforward',\n *   inputSize: 10,\n *   hiddenLayers: [20, 15],\n *   outputSize: 3\n * })\n * ```\n */\ninterface WasmLoader {\n  loadModule?: (moduleName: string) => Promise<any>;\n}\n\nclass NeuralNetworkManager {\n  private wasmLoader: WasmLoader;\n  private neuralNetworks: Map<string, NeuralNetworkInstance>;\n  private neuralModels: Map<string, NeuralModelConfig>;\n  private cognitiveEvolution: CognitivePatternEvolution;\n  private metaLearning: MetaLearningFramework;\n  private coordinationProtocol: NeuralCoordinationProtocol;\n  private cognitivePatternSelector: CognitivePatternSelector;\n  private neuralAdaptationEngine: NeuralAdaptationEngine;\n  private sharedKnowledge: Map<string, unknown>;\n  private agentInteractions: Map<string, unknown>;\n  private performanceMetrics: Map<string, PerformanceMetrics>;\n  private templates: unknown;\n  // Previously undeclared fields referenced throughout implementation\n  private daaCognition: DAACognition;\n  private collaborativeMemory: Map<string, unknown>;\n  private adaptiveOptimization: boolean;\n  private federatedLearningEnabled: boolean;\n\n  /**\n   * Creates a new Neural Network Manager instance.\n   *\n   * @param wasmLoader - WebAssembly loader for neural computation acceleration.\n   * @example\n   * ```typescript\n   * const wasmLoader = await import('./neural-wasm-loader')\n   * const manager = new NeuralNetworkManager(wasmLoader)\n   * ```\n   */\n  constructor(wasmLoader: unknown) {\n    this.wasmLoader = wasmLoader as WasmLoader;\n    this.neuralNetworks = new Map();\n    this.neuralModels = new Map(); // Add missing property\n\n    // Enhanced capabilities\n    this.cognitiveEvolution = new CognitivePatternEvolution();\n    this.metaLearning = new MetaLearningFramework();\n    this.coordinationProtocol = new NeuralCoordinationProtocol();\n    this.daaCognition = new DAACognition();\n\n    // Complete neural presets integration\n    this.cognitivePatternSelector = new CognitivePatternSelector();\n    this.neuralAdaptationEngine = new NeuralAdaptationEngine();\n\n    // Cross-agent memory and knowledge sharing\n    this.sharedKnowledge = new Map();\n    this.agentInteractions = new Map();\n    this.collaborativeMemory = new Map();\n\n    // Performance tracking and optimization\n    this.performanceMetrics = new Map();\n    this.adaptiveOptimization = true;\n    this.federatedLearningEnabled = true;\n\n    this.templates = {\n      deep_analyzer: {\n        layers: [128, 256, 512, 256, 128],\n        activation: 'relu',\n        output_activation: 'sigmoid',\n        dropout: 0.3,\n      },\n      nlp_processor: {\n        layers: [512, 1024, 512, 256],\n        activation: 'gelu',\n        output_activation: 'softmax',\n        dropout: 0.4,\n      },\n      reinforcement_learner: {\n        layers: [64, 128, 128, 64],\n        activation: 'tanh',\n        output_activation: 'linear',\n        dropout: 0.2,\n      },\n      pattern_recognizer: {\n        layers: [256, 512, 1024, 512, 256],\n        activation: 'relu',\n        output_activation: 'sigmoid',\n        dropout: 0.35,\n      },\n      time_series_analyzer: {\n        layers: [128, 256, 256, 128],\n        activation: 'lstm',\n        output_activation: 'linear',\n        dropout: 0.25,\n      },\n      transformer_nlp: {\n        modelType: 'transformer',\n        preset: 'base',\n        dimensions: 512,\n        heads: 8,\n        layers: 6,\n      },\n      cnn_vision: {\n        modelType: 'cnn',\n        preset: 'cifar10',\n        inputShape: [32, 32, 3],\n        outputSize: 10,\n      },\n      gru_sequence: {\n        modelType: 'gru',\n        preset: 'text_classification',\n        hiddenSize: 256,\n        numLayers: 2,\n        bidirectional: true,\n      },\n      autoencoder_compress: {\n        modelType: 'autoencoder',\n        preset: 'mnist_compress',\n        bottleneckSize: 32,\n        variational: false,\n      },\n      gnn_social: {\n        modelType: 'gnn',\n        preset: 'social_network',\n        nodeDimensions: 128,\n        numLayers: 3,\n      },\n      resnet_classifier: {\n        modelType: 'resnet',\n        preset: 'resnet18',\n        inputDimensions: 784,\n        outputDimensions: 10,\n      },\n      vae_generator: {\n        modelType: 'vae',\n        preset: 'mnist_vae',\n        latentDimensions: 20,\n        betaKL: 1.0,\n      },\n      lstm_sequence: {\n        modelType: 'lstm',\n        preset: 'sentiment_analysis',\n        hiddenSize: 256,\n        numLayers: 2,\n        bidirectional: true,\n      },\n      // Special template for preset-based models\n      preset_model: {\n        modelType: 'preset', // Will be overridden by actual model type\n        usePreset: true,\n      },\n\n      // Advanced neural architectures (27+ models)\n      attention_mechanism: {\n        modelType: 'attention',\n        preset: 'multi_head_attention',\n        heads: 8,\n        dimensions: 512,\n        dropoutRate: 0.1,\n      },\n      diffusion_model: {\n        modelType: 'diffusion',\n        preset: 'denoising_diffusion',\n        timesteps: 1000,\n        betaSchedule: 'cosine',\n      },\n      neural_ode: {\n        modelType: 'neural_ode',\n        preset: 'continuous_dynamics',\n        solverMethod: 'dopri5',\n        tolerance: 1e-6,\n      },\n      capsule_network: {\n        modelType: 'capsnet',\n        preset: 'dynamic_routing',\n        primaryCaps: 32,\n        digitCaps: 10,\n      },\n      spiking_neural: {\n        modelType: 'snn',\n        preset: 'leaky_integrate_fire',\n        neuronModel: 'lif',\n        threshold: 1.0,\n      },\n      graph_attention: {\n        modelType: 'gat',\n        preset: 'multi_head_gat',\n        attentionHeads: 8,\n        hiddenUnits: 256,\n      },\n      neural_turing: {\n        modelType: 'ntm',\n        preset: 'differentiable_memory',\n        memorySize: [128, 20],\n        controllerSize: 100,\n      },\n      memory_network: {\n        modelType: 'memnn',\n        preset: 'end_to_end_memory',\n        memorySlots: 100,\n        hops: 3,\n      },\n      neural_cellular: {\n        modelType: 'nca',\n        preset: 'growing_patterns',\n        channels: 16,\n        updateRule: 'sobel',\n      },\n      hypernetwork: {\n        modelType: 'hypernet',\n        preset: 'weight_generation',\n        hyperDim: 512,\n        targetLayers: ['conv1', 'conv2'],\n      },\n      meta_learning: {\n        modelType: 'maml',\n        preset: 'few_shot_learning',\n        innerLR: 0.01,\n        outerLR: 0.001,\n        innerSteps: 5,\n      },\n      neural_architecture_search: {\n        modelType: 'nas',\n        preset: 'differentiable_nas',\n        searchSpace: 'mobile_search_space',\n        epochs: 50,\n      },\n      mixture_of_experts: {\n        modelType: 'moe',\n        preset: 'sparse_expert_routing',\n        numExperts: 8,\n        expertCapacity: 2,\n      },\n      neural_radiance_field: {\n        modelType: 'nerf',\n        preset: '3d_scene_reconstruction',\n        positionEncoding: 10,\n        directionEncoding: 4,\n      },\n      wavenet_audio: {\n        modelType: 'wavenet',\n        preset: 'speech_synthesis',\n        dilationChannels: 32,\n        residualChannels: 32,\n      },\n      pointnet_3d: {\n        modelType: 'pointnet',\n        preset: 'point_cloud_classification',\n        pointFeatures: 3,\n        globalFeatures: 1024,\n      },\n      neural_baby_ai: {\n        modelType: 'baby_ai',\n        preset: 'instruction_following',\n        vocabSize: 100,\n        instructionLength: 20,\n      },\n      world_model: {\n        modelType: 'world_model',\n        preset: 'environment_prediction',\n        visionModel: 'vae',\n        memoryModel: 'mdn_rnn',\n      },\n      flow_based: {\n        modelType: 'normalizing_flow',\n        preset: 'density_estimation',\n        flowType: 'real_nvp',\n        couplingLayers: 8,\n      },\n      energy_based: {\n        modelType: 'ebm',\n        preset: 'contrastive_divergence',\n        energyFunction: 'mlp',\n        samplingSteps: 100,\n      },\n      neural_processes: {\n        modelType: 'neural_process',\n        preset: 'function_approximation',\n        latentDim: 128,\n        contextPoints: 10,\n      },\n      set_transformer: {\n        modelType: 'set_transformer',\n        preset: 'permutation_invariant',\n        inducingPoints: 32,\n        dimensions: 128,\n      },\n      neural_implicit: {\n        modelType: 'neural_implicit',\n        preset: 'coordinate_networks',\n        coordinateDim: 2,\n        hiddenLayers: 8,\n      },\n      evolutionary_neural: {\n        modelType: 'evolutionary_nn',\n        preset: 'neuroevolution',\n        populationSize: 50,\n        mutationRate: 0.1,\n      },\n      quantum_neural: {\n        modelType: 'qnn',\n        preset: 'variational_quantum',\n        qubits: 4,\n        layers: 6,\n      },\n      optical_neural: {\n        modelType: 'onn',\n        preset: 'photonic_computation',\n        wavelengths: 16,\n        modulators: 'mach_zehnder',\n      },\n      neuromorphic: {\n        modelType: 'neuromorphic',\n        preset: 'event_driven',\n        spikeEncoding: 'rate',\n        synapticModel: 'stdp',\n      },\n    };\n\n    // Store instances of new neural models\n    this.neuralModels = new Map();\n  }\n\n  async createAgentNeuralNetwork(agentId: string, config: Partial<NeuralModelConfig> = {}) {\n    // Initialize cognitive evolution for this agent\n    if (this.cognitiveEvolution && typeof this.cognitiveEvolution.initializeAgent === 'function') {\n      await this.cognitiveEvolution.initializeAgent(agentId, config);\n    }\n\n    // Apply meta-learning if enabled\n    if (\n      config?.enableMetaLearning &&\n      this.metaLearning &&\n      typeof this.metaLearning.adaptConfiguration === 'function'\n    ) {\n      config = await this.metaLearning.adaptConfiguration(agentId, config);\n    }\n\n    // Check if this is a new neural model type\n    const template = config?.template || 'deep_analyzer';\n    const templateConfig = (this.templates as Record<string, any>)[template];\n\n    if (templateConfig?.modelType) {\n      // Create new neural model with enhanced capabilities\n      return this.createAdvancedNeuralModel(agentId, template, config);\n    }\n\n    // Load neural module if not already loaded\n    const neuralModule =\n      this.wasmLoader && (this.wasmLoader as any).loadModule\n        ? await (this.wasmLoader as any).loadModule('neural')\n        : null;\n\n    if (!neuralModule || neuralModule.isPlaceholder) {\n      logger.warn('Neural network module not available, using simulation');\n      return this.createSimulatedNetwork(agentId, config);\n    }\n\n    const {\n      layers = null,\n      activation = 'relu',\n      learningRate = 0.001,\n      optimizer = 'adam',\n    } = config as any;\n\n    // Use template or custom layers\n    const networkConfig = layers\n      ? { layers, activation }\n      : (this.templates as Record<string, any>)[template];\n\n    try {\n      // Create network using WASM module\n      const networkId = neuralModule.exports.create_neural_network(\n        JSON.stringify({\n          agent_id: agentId,\n          layers: networkConfig?.layers,\n          activation: networkConfig?.activation,\n          learning_rate: learningRate,\n          optimizer,\n        })\n      );\n\n      const network = new NeuralNetwork(networkId, agentId, networkConfig, neuralModule);\n      this.neuralNetworks.set(agentId, network as NeuralNetworkInstance);\n\n      return network;\n    } catch (error) {\n      logger.error('Failed to create neural network:', error);\n      return this.createSimulatedNetwork(agentId, config);\n    }\n  }\n\n  createSimulatedNetwork(agentId: string, config: Partial<NeuralModelConfig>) {\n    const network = new SimulatedNeuralNetwork(agentId, config as NeuralNetworkConfig);\n    this.neuralNetworks.set(agentId, network as NeuralNetworkInstance);\n    return network;\n  }\n\n  async createAdvancedNeuralModel(\n    agentId: string,\n    template: string,\n    customConfig: Record<string, unknown> = {}\n  ) {\n    const templateConfig = (this.templates as Record<string, any>)[template];\n\n    if (!templateConfig || !templateConfig?.modelType) {\n      throw new Error(`Invalid template: ${template}`);\n    }\n\n    // Merge template config with custom config\n    const config = {\n      ...templateConfig,\n      ...customConfig,\n    };\n\n    // Select cognitive patterns based on model type and task\n    const taskContext = {\n      requiresCreativity: (customConfig as any)['requiresCreativity'] || false,\n      requiresPrecision: (customConfig as any)['requiresPrecision'] || false,\n      requiresAdaptation: (customConfig as any)['requiresAdaptation'] || false,\n      complexity: (customConfig as any)['complexity'] || 'medium',\n    };\n\n    // Check if cognitivePatternSelector has the required method\n    let cognitivePatterns: any = null;\n    if (\n      this.cognitivePatternSelector &&\n      typeof this.cognitivePatternSelector.selectPatternsForPreset === 'function'\n    ) {\n      cognitivePatterns = this.cognitivePatternSelector.selectPatternsForPreset(\n        config?.modelType,\n        template,\n        taskContext\n      );\n    }\n\n    config.cognitivePatterns = cognitivePatterns;\n\n    // Use preset if specified\n    if (config?.preset && (MODEL_PRESETS as any)[config?.modelType]) {\n      const presetConfig = (MODEL_PRESETS as any)[config?.modelType]?.[config?.preset];\n      Object.assign(config, presetConfig);\n    }\n\n    try {\n      // Create the neural model\n      const model = await (createNeuralModel as any)(config?.modelType, config);\n\n      // Wrap in a compatible interface\n      const wrappedModel = new (AdvancedNeuralNetwork as any)(agentId, model, config);\n\n      // Enhanced registration with cognitive capabilities\n      this.neuralNetworks.set(agentId, wrappedModel);\n      this.neuralModels.set(agentId, model);\n\n      // Register with coordination protocol\n      if (\n        this.coordinationProtocol &&\n        typeof this.coordinationProtocol.registerAgent === 'function'\n      ) {\n        await this.coordinationProtocol.registerAgent(agentId, wrappedModel);\n      }\n\n      // Initialize neural adaptation engine\n      if (\n        this.neuralAdaptationEngine &&\n        typeof this.neuralAdaptationEngine.initializeAdaptation === 'function'\n      ) {\n        await this.neuralAdaptationEngine.initializeAdaptation(\n          agentId,\n          config?.modelType,\n          template\n        );\n      }\n\n      // Initialize performance tracking\n      this.performanceMetrics.set(agentId, {\n        accuracy: 0,\n        loss: 1.0,\n        trainingTime: 0,\n        inferenceTime: 0,\n        memoryUsage: 0,\n        creationTime: Date.now(),\n        modelType: config?.modelType,\n        cognitivePatterns: cognitivePatterns || [],\n        adaptationHistory: [],\n        collaborationScore: 0,\n      });\n\n      return wrappedModel;\n    } catch (error) {\n      logger.error(`Failed to create advanced neural model: ${error}`);\n      return this.createSimulatedNetwork(agentId, config);\n    }\n  }\n\n  async fineTuneNetwork(\n    agentId: string,\n    trainingData: TrainingDataItem[],\n    options: Record<string, unknown> = {}\n  ) {\n    const network = this.neuralNetworks.get(agentId);\n    if (!network) {\n      throw new Error(`No neural network found for agent ${agentId}`);\n    }\n\n    const {\n      epochs = 10,\n      batchSize = 32,\n      learningRate = 0.001,\n      freezeLayers = [],\n      enableCognitiveEvolution = true,\n      enableMetaLearning = true,\n    } = options;\n\n    // Apply cognitive pattern evolution during training\n    if (enableCognitiveEvolution) {\n      await this.cognitiveEvolution.evolvePatterns(agentId, trainingData);\n    }\n\n    // Apply meta-learning optimization\n    if (enableMetaLearning) {\n      const optimizedOptions = await this.metaLearning.optimizeTraining(agentId, options);\n      Object.assign(options, optimizedOptions);\n    }\n\n    // Enhanced training with adaptive optimization\n    const result = network.train\n      ? await network.train(trainingData, {\n          epochs,\n          batchSize,\n          learningRate,\n          freezeLayers,\n        })\n      : null;\n\n    // Update performance metrics\n    const metrics = this.performanceMetrics.get(agentId);\n    if (metrics) {\n      const adaptationResult = {\n        timestamp: Date.now(),\n        trainingResult: result,\n        cognitiveGrowth: await this.cognitiveEvolution.assessGrowth(agentId),\n        accuracy: result?.accuracy || 0,\n        cognitivePatterns: metrics.cognitivePatterns,\n        performance: result,\n        insights: [],\n      };\n\n      (metrics.adaptationHistory as any)?.push(adaptationResult);\n\n      // Record adaptation in neural adaptation engine\n      await this.neuralAdaptationEngine.recordAdaptation(agentId, adaptationResult);\n    }\n\n    return result;\n  }\n\n  async enableCollaborativeLearning(agentIds: string[], options: Record<string, unknown> = {}) {\n    const {\n      strategy = 'federated',\n      syncInterval = 30000,\n      privacyLevel = 'high',\n      enableKnowledgeSharing = true,\n      enableCrossAgentEvolution = true,\n    } = options;\n\n    const networks = agentIds.map((id) => this.neuralNetworks.get(id)).filter((n) => n);\n\n    if (networks.length < 2) {\n      throw new Error('At least 2 neural networks required for collaborative learning');\n    }\n\n    // Create enhanced collaborative learning session\n    const session = {\n      id: `collab-${Date.now()}`,\n      networks,\n      agentIds,\n      strategy,\n      syncInterval,\n      privacyLevel,\n      active: true,\n      knowledgeGraph: new Map(),\n      evolutionTracker: new Map(),\n      coordinationMatrix: new Array(agentIds.length)\n        .fill(0)\n        .map(() => new Array(agentIds.length).fill(0)),\n    };\n\n    // Initialize neural coordination protocol\n    await this.coordinationProtocol.initializeSession(session as any);\n\n    // Enable cross-agent knowledge sharing\n    if (enableKnowledgeSharing) {\n      await this.enableKnowledgeSharing(agentIds, session);\n    }\n\n    // Enable cross-agent cognitive evolution\n    if (enableCrossAgentEvolution) {\n      await this.cognitiveEvolution.enableCrossAgentEvolution(agentIds, session as any);\n    }\n\n    // Start enhanced synchronization\n    if (strategy === 'federated') {\n      this.startFederatedLearning(session as any);\n    } else if (strategy === 'knowledge_distillation') {\n      this.startKnowledgeDistillation(session as any);\n    } else if (strategy === 'neural_coordination') {\n      this.startNeuralCoordination(session as any);\n    }\n\n    return session;\n  }\n\n  startFederatedLearning(session) {\n    const syncFunction = () => {\n      if (!session.active) {\n        return;\n      }\n\n      // Aggregate gradients from all networks\n      const gradients = session.networks.map((n) => n.getGradients());\n\n      // Apply privacy-preserving aggregation\n      const aggregatedGradients = this.aggregateGradients(gradients, session.privacyLevel);\n\n      // Update all networks with aggregated gradients\n      session.networks.forEach((n) => n.applyGradients(aggregatedGradients));\n\n      // Schedule next sync\n      setTimeout(syncFunction, session.syncInterval);\n    };\n\n    // Start synchronization\n    setTimeout(syncFunction, session.syncInterval);\n  }\n\n  aggregateGradients(gradients, privacyLevel) {\n    // Enhanced aggregation with cognitive pattern preservation\n    const aggregated = {};\n    const cognitiveWeights = this.cognitiveEvolution.calculateAggregationWeights(gradients);\n\n    // Privacy levels with advanced secure aggregation\n    let noise = 0;\n    let differentialPrivacy = false;\n\n    switch (privacyLevel) {\n      case 'high':\n        noise = 0.01;\n        differentialPrivacy = true;\n        break;\n      case 'medium':\n        noise = 0.005;\n        break;\n      case 'low':\n        noise = 0.001;\n        break;\n    }\n\n    // Cognitive-weighted gradient aggregation\n    gradients.forEach((grad, index) => {\n      const weight = cognitiveWeights[index] || 1 / gradients.length;\n\n      Object.entries(grad).forEach(([key, value]) => {\n        if (!aggregated[key]) {\n          aggregated[key] = 0;\n        }\n\n        let aggregatedValue = (value as number) * weight;\n\n        // Apply differential privacy if enabled\n        if (differentialPrivacy) {\n          const sensitivity = this.calculateSensitivity(key, gradients);\n          const laplacianNoise = this.generateLaplacianNoise(sensitivity, noise);\n          aggregatedValue += laplacianNoise;\n        } else {\n          aggregatedValue += (Math.random() - 0.5) * noise;\n        }\n\n        aggregated[key] += aggregatedValue;\n      });\n    });\n\n    return aggregated;\n  }\n\n  calculateSensitivity(parameterKey, gradients) {\n    // Calculate L1 sensitivity for differential privacy\n    const values = gradients.map((grad) => Math.abs(grad[parameterKey] || 0));\n    return Math.max(...values) - Math.min(...values);\n  }\n\n  generateLaplacianNoise(sensitivity, epsilon) {\n    // Generate Laplacian noise for differential privacy\n    const scale = sensitivity / epsilon;\n    const u1 = Math.random();\n    const u2 = Math.random();\n\n    // Use Box-Muller transform for better noise distribution\n    const noise1 = scale * Math.sign(u1 - 0.5) * Math.log(1 - 2 * Math.abs(u1 - 0.5));\n    const noise2 = scale * Math.sign(u2 - 0.5) * Math.log(1 - 2 * Math.abs(u2 - 0.5));\n\n    // Return averaged noise for better privacy guarantees\n    return (noise1 + noise2) / 2;\n  }\n\n  getNetworkMetrics(agentId) {\n    const network = this.neuralNetworks.get(agentId);\n    if (!network) {\n      return null;\n    }\n\n    return network.getMetrics ? network.getMetrics() : null;\n  }\n\n  saveNetworkState(agentId, filePath) {\n    const network = this.neuralNetworks.get(agentId);\n    if (!network) {\n      throw new Error(`No neural network found for agent ${agentId}`);\n    }\n\n    return network.save ? network.save(filePath) : Promise.resolve(false);\n  }\n\n  async loadNetworkState(agentId, filePath) {\n    const network = this.neuralNetworks.get(agentId);\n    if (!network) {\n      throw new Error(`No neural network found for agent ${agentId}`);\n    }\n\n    return network.load ? network.load(filePath) : Promise.resolve(false);\n  }\n\n  // ===============================\n  // PRESET INTEGRATION METHODS\n  // ===============================\n\n  /**\n   * Create a neural network from a production preset.\n   *\n   * @param {string} agentId - Agent identifier.\n   * @param {string} category - Preset category (nlp, vision, timeseries, graph).\n   * @param {string} presetName - Name of the preset.\n   * @param {object} customConfig - Optional custom configuration overrides.\n   */\n  async createAgentFromPreset(agentId, category, presetName, customConfig = {}) {\n    // First check complete neural presets\n    const completePreset = COMPLETE_NEURAL_PRESETS[category]?.[presetName];\n    if (completePreset) {\n      return this.createAgentFromCompletePreset(agentId, category, presetName, customConfig);\n    }\n    try {\n      const preset = getPreset(category, presetName);\n      if (!preset) {\n        throw new Error(`Preset not found: ${category}/${presetName}`);\n      }\n      validatePresetConfig(preset);\n\n      // Merge preset config with custom overrides\n      const config = {\n        ...preset.config,\n        ...customConfig,\n        modelType: preset.model,\n        presetInfo: {\n          category,\n          presetName,\n          name: preset.name,\n          description: preset.description,\n          useCase: preset.useCase,\n          performance: preset.performance,\n        },\n      };\n\n      return this.createAdvancedNeuralModel(agentId, 'preset_model', config);\n    } catch (error) {\n      logger.error(`Failed to create agent from preset: ${error.message}`);\n      throw error;\n    }\n  }\n\n  /**\n   * Create a neural network from complete preset (27+ models).\n   *\n   * @param {string} agentId - Agent identifier.\n   * @param {string} modelType - Model type (transformer, cnn, lstm, etc.).\n   * @param {string} presetName - Name of the preset.\n   * @param {object} customConfig - Optional custom configuration overrides.\n   */\n  async createAgentFromCompletePreset(\n    agentId: string,\n    modelType: string,\n    presetName: string,\n    customConfig: any = {}\n  ) {\n    const preset = COMPLETE_NEURAL_PRESETS[modelType]?.[presetName];\n    if (!preset) {\n      throw new Error(`Complete preset not found: ${modelType}/${presetName}`);\n    }\n\n    // Get optimized cognitive patterns\n    const taskContext = {\n      requiresCreativity: customConfig?.requiresCreativity || false,\n      requiresPrecision: customConfig?.requiresPrecision || false,\n      requiresAdaptation: customConfig?.requiresAdaptation || false,\n      complexity: customConfig?.complexity || 'medium',\n      cognitivePreference: customConfig?.cognitivePreference,\n    };\n\n    const cognitivePatterns = this.cognitivePatternSelector.selectPatternsForPreset(\n      preset.model,\n      presetName,\n      taskContext\n    );\n\n    // Merge preset config with custom overrides\n    const config = {\n      ...preset.config,\n      ...customConfig,\n      modelType: preset.model,\n      cognitivePatterns,\n      presetInfo: {\n        modelType,\n        presetName,\n        name: preset.name,\n        description: preset.description,\n        useCase: preset.useCase,\n        performance: preset.performance,\n        cognitivePatterns: preset.cognitivePatterns,\n      },\n    };\n\n    // Select appropriate template based on model type\n    const templateMap = {\n      transformer: 'transformer_nlp',\n      cnn: 'cnn_vision',\n      lstm: 'lstm_sequence',\n      gru: 'gru_sequence',\n      autoencoder: 'autoencoder_compress',\n      vae: 'vae_generator',\n      gnn: 'gnn_social',\n      gat: 'graph_attention',\n      resnet: 'resnet_classifier',\n      attention: 'attention_mechanism',\n      diffusion: 'diffusion_model',\n      neural_ode: 'neural_ode',\n      capsnet: 'capsule_network',\n      snn: 'spiking_neural',\n      ntm: 'neural_turing',\n      memnn: 'memory_network',\n      nca: 'neural_cellular',\n      hypernet: 'hypernetwork',\n      maml: 'meta_learning',\n      nas: 'neural_architecture_search',\n      moe: 'mixture_of_experts',\n      nerf: 'neural_radiance_field',\n      wavenet: 'wavenet_audio',\n      pointnet: 'pointnet_3d',\n      world_model: 'world_model',\n      normalizing_flow: 'flow_based',\n      ebm: 'energy_based',\n      neural_process: 'neural_processes',\n      set_transformer: 'set_transformer',\n    };\n\n    const template = templateMap[preset.model] || 'preset_model';\n\n    return this.createAdvancedNeuralModel(agentId, template, config);\n  }\n\n  /**\n   * Create a neural network from a recommended preset based on use case.\n   *\n   * @param {string} agentId - Agent identifier.\n   * @param {string} useCase - Use case description.\n   * @param {object} customConfig - Optional custom configuration overrides.\n   */\n  async createAgentForUseCase(agentId, useCase, customConfig = {}) {\n    const recommendedPreset = getRecommendedPreset(useCase);\n\n    if (!recommendedPreset) {\n      // Try searching by use case\n      const searchResults = searchPresetsByUseCase(useCase);\n      if (searchResults.length === 0) {\n        throw new Error(`No preset found for use case: ${useCase}`);\n      }\n\n      const bestMatch = searchResults[0];\n\n      return this.createAgentFromPreset(\n        agentId,\n        bestMatch?.type, // Use type instead of category\n        bestMatch?.id, // Use id instead of presetName\n        customConfig\n      );\n    }\n\n    return this.createAgentFromPreset(\n      agentId,\n      recommendedPreset.type, // Use type instead of category\n      recommendedPreset.id, // Use id instead of presetName\n      customConfig\n    );\n  }\n\n  /**\n   * Get all available presets for a category.\n   *\n   * @param {string} category - Preset category.\n   */\n  getAvailablePresets(category = null) {\n    if (category) {\n      return getCategoryPresets(category);\n    }\n    return NEURAL_PRESETS;\n  }\n\n  /**\n   * Search presets by use case or description.\n   *\n   * @param {string} searchTerm - Search term.\n   */\n  searchPresets(searchTerm: string) {\n    return searchPresetsByUseCase(searchTerm);\n  }\n\n  /**\n   * Get performance information for a preset.\n   *\n   * @param {string} category - Preset category.\n   * @param {string} presetName - Preset name.\n   */\n  getPresetPerformance(category: string, presetName: string) {\n    const preset = getPreset(category, presetName);\n    return preset?.performance;\n  }\n\n  /**\n   * List all available preset categories and their counts.\n   */\n  getPresetSummary() {\n    const summary: Record<string, { count: number; presets: string[] }> = {};\n    Object.entries(NEURAL_PRESETS).forEach(([category, presets]) => {\n      summary[category] = {\n        count: Object.keys(presets).length,\n        presets: Object.keys(presets),\n      };\n    });\n    return summary;\n  }\n\n  /**\n   * Get detailed information about agent's preset (if created from preset).\n   *\n   * @param {string} agentId - Agent identifier.\n   */\n  getAgentPresetInfo(agentId: string) {\n    const network = this.neuralNetworks.get(agentId);\n    if (!network || !network.config || !(network.config as any).presetInfo) {\n      return null;\n    }\n    return (network.config as any).presetInfo;\n  }\n\n  /**\n   * Update existing agent with preset configuration.\n   *\n   * @param {string} agentId - Agent identifier.\n   * @param {string} category - Preset category.\n   * @param {string} presetName - Preset name.\n   * @param {object} customConfig - Optional custom configuration overrides.\n   */\n  async updateAgentWithPreset(\n    agentId: string,\n    category: string,\n    presetName: string,\n    customConfig: any = {}\n  ) {\n    const existingNetwork = this.neuralNetworks.get(agentId);\n    if (existingNetwork) {\n    }\n\n    // Preserve cognitive evolution history\n    const cognitiveHistory = await this.cognitiveEvolution.preserveHistory(agentId);\n    const metaLearningState = await this.metaLearning.preserveState(agentId);\n\n    // Remove existing network\n    this.neuralNetworks.delete(agentId);\n    this.neuralModels.delete(agentId);\n\n    // Create new network with preset and restored cognitive capabilities\n    const newNetwork = await this.createAgentFromPreset(\n      agentId,\n      category,\n      presetName,\n      customConfig\n    );\n\n    // Restore cognitive evolution and meta-learning state\n    await this.cognitiveEvolution.restoreHistory(agentId, cognitiveHistory);\n    await this.metaLearning.restoreState(agentId, metaLearningState);\n\n    return newNetwork;\n  }\n\n  /**\n   * Batch create agents from presets.\n   *\n   * @param {Array} agentConfigs - Array of {agentId, category, presetName, customConfig}.\n   */\n  async batchCreateAgentsFromPresets(\n    agentConfigs: Array<{\n      agentId: string;\n      category: string;\n      presetName: string;\n      customConfig?: any;\n    }>\n  ) {\n    const results: Array<{ agentId: string; success: boolean; agent: any }> = [];\n    const errors: Array<{ agentId: string; error: string }> = [];\n\n    for (const config of agentConfigs) {\n      try {\n        const agent = await this.createAgentFromPreset(\n          config?.agentId,\n          config?.category,\n          config?.presetName,\n          config?.customConfig || {}\n        );\n        results.push({ agentId: config?.agentId, success: true, agent });\n      } catch (error) {\n        errors.push({\n          agentId: config?.agentId,\n          error: error instanceof Error ? error.message : String(error),\n        });\n      }\n    }\n\n    return { results, errors };\n  }\n\n  // ===============================\n  // ENHANCED NEURAL CAPABILITIES\n  // ===============================\n\n  /**\n   * Enable knowledge sharing between agents.\n   *\n   * @param {Array} agentIds - List of agent IDs.\n   * @param {Object} session - Collaborative session object.\n   */\n  async enableKnowledgeSharing(agentIds: string[], session: CollaborativeSession) {\n    const knowledgeGraph = session.knowledgeGraph!;\n\n    for (const agentId of agentIds) {\n      const agent = this.neuralNetworks.get(agentId);\n      if (!agent) {\n        continue;\n      }\n\n      // Extract knowledge from agent\n      const knowledge = await this.extractAgentKnowledge(agentId);\n      knowledgeGraph.set(agentId, knowledge);\n\n      // Store in shared knowledge base\n      this.sharedKnowledge.set(agentId, knowledge);\n    }\n\n    // Create knowledge sharing matrix\n    const sharingMatrix = await this.createKnowledgeSharingMatrix(agentIds);\n    (session as any).knowledgeSharingMatrix = sharingMatrix;\n  }\n\n  /**\n   * Extract knowledge from a neural network agent.\n   *\n   * @param {string} agentId - Agent identifier.\n   */\n  async extractAgentKnowledge(agentId: string) {\n    const network = this.neuralNetworks.get(agentId);\n    if (!network) {\n      return null;\n    }\n\n    const knowledge = {\n      agentId,\n      timestamp: Date.now(),\n      modelType: network.modelType,\n      weights: await this.extractImportantWeights(network),\n      patterns: await this.cognitiveEvolution.extractPatterns(agentId),\n      experiences: await this.metaLearning.extractExperiences(agentId),\n      performance: network.getMetrics ? network.getMetrics() : undefined,\n      specializations: await this.identifySpecializations(agentId),\n    };\n\n    return knowledge;\n  }\n\n  /**\n   * Extract important weights from a neural network.\n   *\n   * @param {Object} network - Neural network instance.\n   */\n  async extractImportantWeights(network: EnhancedNeuralNetworkInstance) {\n    // Use magnitude-based importance scoring\n    const weights = network.getWeights?.() || {};\n    const importantWeights = {};\n\n    Object.entries(weights).forEach(([layer, weight]) => {\n      if (weight && Array.isArray(weight) && weight.length > 0) {\n        // Calculate importance scores (magnitude-based)\n        const importance = weight.map((w: any) => Math.abs(w));\n        const threshold = this.calculateImportanceThreshold(importance);\n\n        importantWeights[layer] = weight.filter(\n          (_w: any, idx: number) => importance[idx] !== undefined && importance[idx] > threshold\n        );\n      }\n    });\n\n    return importantWeights;\n  }\n\n  /**\n   * Calculate importance threshold for weight selection.\n   *\n   * @param {Array} importance - Array of importance scores.\n   */\n  calculateImportanceThreshold(importance: number[]) {\n    const sorted = importance.slice().sort((a: number, b: number) => b - a);\n    // Take top 20% of weights\n    const topPercentile = Math.floor(sorted.length * 0.2);\n    return sorted[topPercentile] || 0;\n  }\n\n  /**\n   * Identify agent specializations based on performance patterns.\n   *\n   * @param {string} agentId - Agent identifier.\n   */\n  async identifySpecializations(agentId: string) {\n    const metrics = this.performanceMetrics.get(agentId);\n    if (!metrics) {\n      return [];\n    }\n\n    const specializations = [];\n\n    // Analyze adaptation history for specialization patterns\n    for (const adaptation of metrics.adaptationHistory || []) {\n      if ((adaptation as any).trainingResult && (adaptation as any).trainingResult.accuracy > 0.8) {\n        const specializationData: { domain: string; confidence: number; timestamp: number } = {\n          domain: this.inferDomainFromTraining(adaptation),\n          confidence: (adaptation as any).trainingResult.accuracy,\n          timestamp: adaptation.timestamp,\n        };\n        (specializations as any).push(specializationData);\n      }\n    }\n\n    return specializations;\n  }\n\n  /**\n   * Infer domain from training patterns.\n   *\n   * @param {Object} adaptation - Adaptation record.\n   */\n  inferDomainFromTraining(adaptation: any) {\n    // Simple heuristic - in practice, would use more sophisticated analysis\n    const accuracy = (adaptation).trainingResult.accuracy;\n    const loss = (adaptation).trainingResult.loss;\n\n    if (accuracy > 0.9 && loss < 0.1) {\n      return 'classification';\n    }\n    if (accuracy > 0.85 && loss < 0.2) {\n      return 'regression';\n    }\n    if (loss < 0.3) {\n      return 'generation';\n    }\n    return 'general';\n  }\n\n  /**\n   * Create knowledge sharing matrix between agents.\n   *\n   * @param {Array} agentIds - List of agent IDs.\n   */\n  async createKnowledgeSharingMatrix(agentIds: string[]) {\n    const matrix: Record<string, Record<string, number>> = {};\n\n    for (let i = 0; i < agentIds.length; i++) {\n      const agentA = agentIds[i];\n      if (agentA) {\n        matrix[agentA] = {};\n\n        for (let j = 0; j < agentIds.length; j++) {\n          const agentB = agentIds[j];\n          if (agentB) {\n            if (i === j) {\n              matrix[agentA][agentB] = 1.0; // Self-similarity\n              continue;\n            }\n\n            const similarity = await this.calculateAgentSimilarity(agentA, agentB);\n            matrix[agentA][agentB] = similarity;\n          }\n        }\n      }\n    }\n\n    return matrix;\n  }\n\n  /**\n   * Calculate similarity between two agents.\n   *\n   * @param {string} agentA - First agent ID.\n   * @param {string} agentB - Second agent ID.\n   */\n  async calculateAgentSimilarity(agentA: string, agentB: string) {\n    const knowledgeA = this.sharedKnowledge.get(agentA);\n    const knowledgeB = this.sharedKnowledge.get(agentB);\n\n    if (!knowledgeA || !knowledgeB) {\n      return 0;\n    }\n\n    // Calculate multiple similarity metrics\n    const structuralSimilarity = this.calculateStructuralSimilarity(knowledgeA, knowledgeB);\n    const performanceSimilarity = this.calculatePerformanceSimilarity(knowledgeA, knowledgeB);\n    const specializationSimilarity = this.calculateSpecializationSimilarity(knowledgeA, knowledgeB);\n\n    // Weighted combination\n    return (\n      structuralSimilarity * 0.4 + performanceSimilarity * 0.3 + specializationSimilarity * 0.3\n    );\n  }\n\n  /**\n   * Calculate structural similarity between agents.\n   *\n   * @param {Object} knowledgeA - Knowledge from agent A.\n   * @param {Object} knowledgeB - Knowledge from agent B.\n   */\n  calculateStructuralSimilarity(knowledgeA: any, knowledgeB: any) {\n    if (knowledgeA.modelType !== knowledgeB.modelType) {\n      return 0.1;\n    }\n\n    // Compare weight patterns (simplified cosine similarity)\n    const weightsA = Object.values(knowledgeA.weights).flat();\n    const weightsB = Object.values(knowledgeB.weights).flat();\n\n    if (weightsA.length === 0 || weightsB.length === 0) {\n      return 0.5;\n    }\n\n    const minLength = Math.min(weightsA.length, weightsB.length);\n    let dotProduct = 0;\n    let normA = 0;\n    let normB = 0;\n\n    for (let i = 0; i < minLength; i++) {\n      const aVal = Number(weightsA[i]);\n      const bVal = Number(weightsB[i]);\n      dotProduct += aVal * bVal;\n      normA += aVal * aVal;\n      normB += bVal * bVal;\n    }\n\n    const similarity = dotProduct / (Math.sqrt(normA) * Math.sqrt(normB));\n    return Math.max(0, Math.min(1, similarity));\n  }\n\n  /**\n   * Calculate performance similarity between agents.\n   *\n   * @param {Object} knowledgeA - Knowledge from agent A.\n   * @param {Object} knowledgeB - Knowledge from agent B.\n   */\n  calculatePerformanceSimilarity(knowledgeA: any, knowledgeB: any) {\n    const perfA = knowledgeA.performance;\n    const perfB = knowledgeB.performance;\n\n    const accuracyDiff = Math.abs(perfA.accuracy - perfB.accuracy);\n    const lossDiff = Math.abs(perfA.loss - perfB.loss);\n\n    // Inverse relationship - smaller differences = higher similarity\n    const accuracySimilarity = 1 - Math.min(1, accuracyDiff);\n    const lossSimilarity = 1 - Math.min(1, lossDiff);\n\n    return (accuracySimilarity + lossSimilarity) / 2;\n  }\n\n  /**\n   * Calculate specialization similarity between agents.\n   *\n   * @param {Object} knowledgeA - Knowledge from agent A.\n   * @param {Object} knowledgeB - Knowledge from agent B.\n   */\n  calculateSpecializationSimilarity(knowledgeA: any, knowledgeB: any): number {\n    const specsA = new Set(knowledgeA.specializations.map((s: { domain: string }) => s.domain));\n    const specsB = new Set(knowledgeB.specializations.map((s: { domain: string }) => s.domain));\n\n    const intersection = new Set(Array.from(specsA).filter((x) => specsB.has(x)));\n    const union = new Set([...Array.from(specsA), ...Array.from(specsB)]);\n\n    return union.size > 0 ? intersection.size / union.size : 0;\n  }\n\n  /**\n   * Start knowledge distillation learning.\n   *\n   * @param {Object} session - Collaborative session.\n   * @param session.active\n   * @param session.agentIds\n   * @param session.syncInterval\n   */\n  startKnowledgeDistillation(session: {\n    active: boolean;\n    agentIds: string[];\n    syncInterval: number;\n  }) {\n    const distillationFunction = async () => {\n      if (!session.active) {\n        return;\n      }\n\n      try {\n        // Identify teacher and student agents\n        const teachers = await this.identifyTeacherAgents(session.agentIds);\n        const students = session.agentIds.filter((id: string) => !teachers.includes(id));\n\n        // Perform knowledge distillation\n        for (const teacher of teachers) {\n          for (const student of students) {\n            await this.performKnowledgeDistillation(teacher, student, {\n              agentIds: session.agentIds,\n              coordinationMatrix: [],\n            });\n          }\n        }\n      } catch (error) {\n        logger.error('Knowledge distillation failed:', error);\n      }\n\n      // Schedule next distillation\n      setTimeout(distillationFunction, session.syncInterval);\n    };\n\n    // Start distillation process\n    setTimeout(distillationFunction, 1000);\n  }\n\n  /**\n   * Identify teacher agents based on performance.\n   *\n   * @param {Array} agentIds - List of agent IDs.\n   */\n  async identifyTeacherAgents(agentIds: string[]): Promise<string[]> {\n    const agentPerformances: Array<{ agentId: string; performance: number }> = [];\n\n    for (const agentId of agentIds) {\n      const network = this.neuralNetworks.get(agentId);\n      if (network) {\n        const metrics = network.getMetrics ? network.getMetrics() : null;\n        agentPerformances.push({\n          agentId,\n          performance: metrics?.accuracy || 0,\n        });\n      }\n    }\n\n    // Sort by performance and take top 30%\n    agentPerformances.sort((a, b) => b.performance - a.performance);\n    const numTeachers = Math.max(1, Math.floor(agentPerformances.length * 0.3));\n\n    return agentPerformances.slice(0, numTeachers).map((ap) => ap.agentId);\n  }\n\n  /**\n   * Perform knowledge distillation between teacher and student.\n   *\n   * @param {string} teacherAgentId - Teacher agent ID.\n   * @param {string} studentAgentId - Student agent ID.\n   * @param {Object} session - Collaborative session.\n   * @param session.agentIds\n   * @param session.coordinationMatrix\n   */\n  async performKnowledgeDistillation(\n    teacherAgentId: string,\n    studentAgentId: string,\n    session: { agentIds: string[]; coordinationMatrix: number[][] }\n  ): Promise<void> {\n    const teacher = this.neuralNetworks.get(teacherAgentId);\n    const student = this.neuralNetworks.get(studentAgentId);\n\n    if (!teacher || !student) {\n      return;\n    }\n\n    try {\n      // Extract soft targets from teacher\n      const teacherKnowledge = this.sharedKnowledge.get(teacherAgentId);\n      if (!teacherKnowledge) {\n        return;\n      }\n\n      // Create distillation loss function\n      const distillationTemperature = 3.0;\n      const alpha = 0.7; // Weight for distillation loss vs hard target loss\n\n      // Apply knowledge distillation (simplified)\n      const distillationResult = await this.applyKnowledgeDistillation(student, teacherKnowledge, {\n        temperature: distillationTemperature,\n        alpha,\n      });\n\n      // Update collaboration matrix\n      const teacherIdx = session.agentIds.indexOf(teacherAgentId);\n      const studentIdx = session.agentIds.indexOf(studentAgentId);\n\n      if (\n        teacherIdx >= 0 &&\n        studentIdx >= 0 &&\n        session.coordinationMatrix?.[studentIdx]?.[teacherIdx] !== undefined\n      ) {\n        session.coordinationMatrix[studentIdx][teacherIdx] +=\n          distillationResult?.improvement || 0;\n      }\n    } catch (error) {\n      logger.error(\n        `Knowledge distillation failed between ${teacherAgentId} and ${studentAgentId}:`,\n        error\n      );\n    }\n  }\n\n  /**\n   * Apply knowledge distillation to student network.\n   *\n   * @param {Object} student - Student network.\n   * @param {Object} teacherKnowledge - Teacher's knowledge.\n   * @param {Object} options - Distillation options.\n   * @param options.temperature\n   * @param options.alpha\n   */\n  async applyKnowledgeDistillation(\n    student: any,\n    teacherKnowledge: any,\n    options: { temperature: number; alpha: number }\n  ): Promise<{ improvement: number; beforeMetrics: any; afterMetrics: any }> {\n    const { temperature, alpha } = options;\n\n    // Simulate knowledge transfer (in practice, would involve actual training)\n    const beforeMetrics = student.getMetrics();\n\n    // Apply teacher's patterns to student (simplified)\n    const patterns = teacherKnowledge.patterns;\n    if (patterns && patterns.length > 0) {\n      await this.cognitiveEvolution.transferPatterns(student.agentId, patterns);\n    }\n\n    const afterMetrics = student.getMetrics();\n    const improvement = Math.max(0, afterMetrics.accuracy - beforeMetrics.accuracy);\n\n    return { improvement, beforeMetrics, afterMetrics };\n  }\n\n  /**\n   * Start neural coordination protocol.\n   *\n   * @param {Object} session - Collaborative session.\n   * @param session.active\n   * @param session.syncInterval\n   */\n  startNeuralCoordination(session: { active: boolean; syncInterval: number }): void {\n    const coordinationFunction = async () => {\n      if (!session.active) {\n        return;\n      }\n\n      try {\n        // Update coordination matrix\n        await this.updateCoordinationMatrix({\n          agentIds: (session as any).agentIds || [],\n          coordinationMatrix: [],\n        });\n\n        // Perform neural coordination\n        await this.coordinationProtocol.coordinate(session);\n\n        // Apply coordination results\n        await this.applyCoordinationResults({ id: `session-${Date.now()}` });\n      } catch (error) {\n        logger.error('Neural coordination failed:', error);\n      }\n\n      // Schedule next coordination\n      setTimeout(coordinationFunction, session.syncInterval);\n    };\n\n    // Start coordination process\n    setTimeout(coordinationFunction, 1000);\n  }\n\n  /**\n   * Update coordination matrix based on agent interactions.\n   *\n   * @param {Object} session - Collaborative session.\n   * @param session.agentIds\n   * @param session.coordinationMatrix\n   */\n  async updateCoordinationMatrix(session: {\n    agentIds: string[];\n    coordinationMatrix: number[][];\n  }): Promise<void> {\n    for (let i = 0; i < session.agentIds.length; i++) {\n      for (let j = 0; j < session.agentIds.length; j++) {\n        if (i === j) {\n          continue;\n        }\n\n        const agentA = session.agentIds[i];\n        const agentB = session.agentIds[j];\n\n        if (agentA && agentB) {\n          // Calculate interaction strength\n          const interactionStrength = await this.calculateInteractionStrength(agentA, agentB);\n          if (\n            session.coordinationMatrix &&\n            session.coordinationMatrix[i] &&\n            session.coordinationMatrix[i]![j] !== undefined\n          ) {\n            session.coordinationMatrix[i]![j] = interactionStrength;\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Calculate interaction strength between two agents.\n   *\n   * @param {string} agentA - First agent ID.\n   * @param {string} agentB - Second agent ID.\n   */\n  async calculateInteractionStrength(agentA: string, agentB: string): Promise<number> {\n    const interactions = this.agentInteractions.get(`${agentA}-${agentB}`) || [];\n\n    if (!Array.isArray(interactions) || interactions.length === 0) {\n      return 0.1;\n    } // Minimal baseline interaction\n\n    // Calculate recency-weighted interaction strength\n    const now = Date.now();\n    let totalStrength = 0;\n    let totalWeight = 0;\n\n    for (const interaction of interactions) {\n      const age = now - interaction.timestamp;\n      const weight = Math.exp(-age / (24 * 60 * 60 * 1000)); // Exponential decay over 24 hours\n\n      totalStrength += interaction.strength * weight;\n      totalWeight += weight;\n    }\n\n    return totalWeight > 0 ? totalStrength / totalWeight : 0.1;\n  }\n\n  /**\n   * Apply coordination results to agents.\n   *\n   * @param {Object} session - Collaborative session.\n   * @param session.id\n   */\n  async applyCoordinationResults(session: { id: string }): Promise<void> {\n    const coordinationResults = await this.coordinationProtocol.getResults(session.id);\n    if (!coordinationResults) {\n      return;\n    }\n\n    for (const [agentId, coordination] of coordinationResults?.entries()) {\n      const agent = this.neuralNetworks.get(agentId);\n      if (!agent) {\n        continue;\n      }\n\n      // Apply coordination adjustments\n      if (coordination.weightAdjustments) {\n        await this.applyWeightAdjustments(agent, coordination.weightAdjustments);\n      }\n\n      // Apply cognitive pattern updates\n      if (coordination.patternUpdates) {\n        await this.cognitiveEvolution.applyPatternUpdates(agentId, coordination.patternUpdates);\n      }\n\n      // Update performance metrics\n      const metrics = this.performanceMetrics.get(agentId);\n      if (metrics) {\n        metrics.collaborationScore = coordination.collaborationScore || 0;\n        metrics.cognitivePatterns?.push(...(coordination.newPatterns || []));\n      }\n    }\n  }\n\n  /**\n   * Apply weight adjustments to a neural network.\n   *\n   * @param {Object} agent - Neural network agent.\n   * @param {Object} adjustments - Weight adjustments.\n   */\n  async applyWeightAdjustments(\n    agent: EnhancedNeuralNetworkInstance,\n    adjustments: Record<string, number[]>\n  ): Promise<void> {\n    try {\n      const currentWeights = agent.getWeights?.() || {};\n      const adjustedWeights: Record<string, number[]> = {};\n\n      Object.entries(currentWeights).forEach(([layer, weights]) => {\n        if (adjustments[layer] && Array.isArray(weights)) {\n          adjustedWeights[layer] = weights.map((w: number, idx: number) => {\n            const adjustment = adjustments[layer]?.[idx] || 0;\n            return w + adjustment * 0.1; // Scale adjustment factor\n          });\n        } else {\n          adjustedWeights[layer] = weights;\n        }\n      });\n\n      agent.setWeights?.(adjustedWeights);\n    } catch (error) {\n      logger.error('Failed to apply weight adjustments:', error);\n    }\n  }\n\n  /**\n   * Record agent interaction for coordination tracking.\n   *\n   * @param {string} agentA - First agent ID.\n   * @param {string} agentB - Second agent ID.\n   * @param {number} strength - Interaction strength (0-1).\n   * @param {string} type - Interaction type.\n   */\n  recordAgentInteraction(\n    agentA: string,\n    agentB: string,\n    strength: number,\n    type: string = 'general'\n  ): void {\n    const interactionKey = `${agentA}-${agentB}`;\n\n    if (!this.agentInteractions.has(interactionKey)) {\n      this.agentInteractions.set(interactionKey, []);\n    }\n\n    const interactionArray = this.agentInteractions.get(interactionKey);\n    if (Array.isArray(interactionArray)) {\n      interactionArray.push({\n        timestamp: Date.now(),\n        strength,\n        type,\n        agentA,\n        agentB,\n      });\n\n      // Keep only recent interactions (last 100)\n      if (interactionArray.length > 100) {\n        interactionArray.splice(0, interactionArray.length - 100);\n      }\n    }\n  }\n\n  /**\n   * Get all complete neural presets (27+ models).\n   */\n  getCompleteNeuralPresets() {\n    return COMPLETE_NEURAL_PRESETS;\n  }\n\n  /**\n   * Get preset recommendations based on requirements.\n   *\n   * @param {string} useCase - Use case description.\n   * @param {Object} requirements - Performance and other requirements.\n   */\n  getPresetRecommendations(useCase: string, requirements: Record<string, any> = {}): any {\n    return this.cognitivePatternSelector.getPresetRecommendations(useCase, requirements);\n  }\n\n  /**\n   * Get adaptation recommendations for an agent.\n   *\n   * @param {string} agentId - Agent identifier.\n   */\n  async getAdaptationRecommendations(agentId: string): Promise<any> {\n    return this.neuralAdaptationEngine.getAdaptationRecommendations(agentId);\n  }\n\n  /**\n   * Export adaptation insights across all agents.\n   */\n  getAdaptationInsights() {\n    return this.neuralAdaptationEngine.exportAdaptationInsights();\n  }\n\n  /**\n   * List all available neural model types with counts.\n   */\n  getAllNeuralModelTypes() {\n    const modelTypes = {};\n\n    // Count presets from complete neural presets\n    Object.entries(COMPLETE_NEURAL_PRESETS).forEach(([modelType, presets]) => {\n      (modelTypes as any)[modelType] = {\n        count: Object.keys(presets).length,\n        presets: Object.keys(presets),\n        description: (Object.values(presets)[0])?.description || 'Neural model type',\n      };\n    });\n\n    return modelTypes;\n  }\n\n  /**\n   * Get comprehensive neural network statistics.\n   */\n  getEnhancedStatistics() {\n    const stats = {\n      totalAgents: this.neuralNetworks.size,\n      modelTypes: {},\n      cognitiveEvolution: this.cognitiveEvolution.getStatistics(),\n      metaLearning: this.metaLearning.getStatistics(),\n      coordination: this.coordinationProtocol.getStatistics(),\n      performance: {},\n      collaborations: 0,\n    };\n\n    // Count model types\n    for (const [agentId, network] of Array.from(this.neuralNetworks.entries())) {\n      const modelType = network.modelType || 'unknown';\n      (stats.modelTypes as any)[modelType] = ((stats.modelTypes as any)[modelType] || 0) + 1;\n\n      // Performance statistics\n      const metrics = this.performanceMetrics.get(agentId);\n      if (metrics) {\n        if (!(stats.performance as any)[modelType]) {\n          (stats.performance as any)[modelType] = {\n            count: 0,\n            avgAccuracy: 0,\n            avgCollaborationScore: 0,\n            totalAdaptations: 0,\n          };\n        }\n\n        const perf = (stats.performance as any)[modelType];\n        if (perf) {\n          perf.count++;\n          perf.avgAccuracy += network.getMetrics?.()?.accuracy || 0;\n          perf.avgCollaborationScore += metrics.collaborationScore;\n          perf.totalAdaptations += metrics.adaptationHistory?.length || 0;\n        }\n      }\n    }\n\n    // Calculate averages\n    Object.values(stats.performance).forEach((perf: any) => {\n      if (perf && perf.count > 0) {\n        perf.avgAccuracy /= perf.count;\n        perf.avgCollaborationScore /= perf.count;\n      }\n    });\n\n    // Count active collaborations\n    stats.collaborations = this.sharedKnowledge.size;\n\n    return stats;\n  }\n}\n\n// Neural Network wrapper class\ninterface NeuralNetworkConfig {\n  layers: number[];\n  [key: string]: any;\n}\n\ninterface TrainingHistoryEntry {\n  epoch: number;\n  loss: number;\n}\n\ninterface WasmModule {\n  exports: {\n    forward_pass: (networkId: string, input: any) => Float32Array;\n    train_batch: (\n      networkId: string,\n      batch: string,\n      learningRate: number,\n      freezeLayers: string\n    ) => number;\n    get_gradients: (networkId: string) => string;\n    apply_gradients: (networkId: string, gradients: string) => void;\n    serialize_network: (networkId: string) => any;\n    deserialize_network: (networkId: string, state: any) => void;\n  };\n}\n\nclass NeuralNetwork {\n  public networkId: string;\n  public agentId: string;\n  public config: NeuralNetworkConfig;\n  public wasmModule: WasmModule;\n  public trainingHistory: TrainingHistoryEntry[];\n  public metrics: {\n    accuracy: number;\n    loss: number;\n    epochs_trained: number;\n    total_samples: number;\n  };\n  constructor(\n    networkId: string,\n    agentId: string,\n    config: NeuralNetworkConfig,\n    wasmModule: WasmModule\n  ) {\n    this.networkId = networkId;\n    this.agentId = agentId;\n    this.config = config;\n    this.wasmModule = wasmModule;\n    this.trainingHistory = [];\n    this.metrics = {\n      accuracy: 0,\n      loss: 1.0,\n      epochs_trained: 0,\n      total_samples: 0,\n    };\n  }\n\n  async forward(input: number[] | Float32Array): Promise<Float32Array> {\n    try {\n      const inputArray = Array.isArray(input) ? input : Array.from(input);\n      const result = this.wasmModule.exports.forward_pass(this.networkId, inputArray);\n      return result;\n    } catch (error) {\n      logger.error('Forward pass failed:', error);\n      const outputSize = this.config.layers?.[this.config.layers.length - 1] ?? 1;\n      return new Float32Array(outputSize).fill(0.5);\n    }\n  }\n\n  async train(\n    trainingData: { samples: TrainingDataItem[] },\n    options: { epochs: number; batchSize: number; learningRate: number; freezeLayers?: string[] }\n  ): Promise<typeof this.metrics> {\n    const { epochs, batchSize, learningRate, freezeLayers } = options;\n\n    for (let epoch = 0; epoch < epochs; epoch++) {\n      let epochLoss = 0;\n      let batchCount = 0;\n\n      // Process in batches\n      for (let i = 0; i < trainingData?.samples.length; i += batchSize) {\n        const batch = trainingData?.samples.slice(i, i + batchSize);\n\n        try {\n          const loss = this.wasmModule.exports.train_batch(\n            this.networkId,\n            JSON.stringify(batch),\n            learningRate,\n            JSON.stringify(freezeLayers)\n          );\n\n          epochLoss += loss;\n          batchCount++;\n        } catch (error) {\n          logger.error('Training batch failed:', error);\n        }\n      }\n\n      const avgLoss = epochLoss / batchCount;\n      this.metrics.loss = avgLoss;\n      this.metrics.epochs_trained++;\n      this.trainingHistory.push({ epoch, loss: avgLoss });\n    }\n\n    return this.metrics;\n  }\n\n  getWeights(): Record<string, any> {\n    try {\n      // In a real implementation, would get weights from WASM module\n      return {}; // Placeholder\n    } catch (error) {\n      logger.error('Failed to get weights:', error);\n      return {};\n    }\n  }\n\n  setWeights(weights: Record<string, any>): void {\n    try {\n      // In a real implementation, would set weights in WASM module\n    } catch (error) {\n      logger.error('Failed to set weights:', error);\n    }\n  }\n\n  getGradients() {\n    // Get gradients from WASM module\n    try {\n      const gradients = this.wasmModule.exports.get_gradients(this.networkId);\n      return JSON.parse(gradients);\n    } catch (error) {\n      logger.error('Failed to get gradients:', error);\n      return {};\n    }\n  }\n\n  applyGradients(gradients: any): void {\n    // Apply gradients to network\n    try {\n      this.wasmModule.exports.apply_gradients(this.networkId, JSON.stringify(gradients));\n    } catch (error) {\n      logger.error('Failed to apply gradients:', error);\n    }\n  }\n\n  getMetrics() {\n    return {\n      ...this.metrics,\n      training_history: this.trainingHistory,\n      network_info: {\n        layers: this.config.layers,\n        parameters: this.config.layers.reduce((acc: number, size: number, i: number) => {\n          if (i > 0) {\n            return acc + (this.config.layers[i - 1] ?? 0) * size;\n          }\n          return acc;\n        }, 0),\n      },\n    };\n  }\n\n  async save(filePath: string): Promise<boolean> {\n    try {\n      const state = this.wasmModule.exports.serialize_network(this.networkId);\n\n      // Save the serialized state to file\n      const fs = await import('node:fs/promises');\n      await fs.writeFile(filePath, JSON.stringify(state, null, 2));\n      return true;\n    } catch (error) {\n      logger.error('Failed to save network:', error);\n      return false;\n    }\n  }\n\n  async load(filePath: string): Promise<boolean> {\n    try {\n      // Read the serialized state from file\n      const fs = await import('node:fs/promises');\n      const stateData = await fs.readFile(filePath, 'utf-8');\n      const state = JSON.parse(stateData);\n\n      // Deserialize the network state\n      this.wasmModule.exports.deserialize_network(this.networkId, state);\n      return true;\n    } catch (error) {\n      logger.error('Failed to load network:', error);\n      return false;\n    }\n  }\n}\n\n// Simulated Neural Network for when WASM is not available\nclass SimulatedNeuralNetwork {\n  public agentId: string;\n  public config: NeuralNetworkConfig;\n  public weights: number[];\n  public trainingHistory: TrainingHistoryEntry[];\n  public metrics: {\n    accuracy: number;\n    loss: number;\n    epochs_trained: number;\n    total_samples: number;\n  };\n  constructor(agentId: string, config: NeuralNetworkConfig) {\n    this.agentId = agentId;\n    this.config = config;\n    this.weights = this.initializeWeights();\n    this.trainingHistory = [];\n    this.metrics = {\n      accuracy: 0.5 + Math.random() * 0.3,\n      loss: 0.5 + Math.random() * 0.5,\n      epochs_trained: 0,\n      total_samples: 0,\n    };\n  }\n\n  initializeWeights() {\n    // Simple weight initialization\n    return this.config.layers.map(() => Math.random() * 2 - 1) || [0];\n  }\n\n  async forward(_input: number[] | Float32Array): Promise<Float32Array> {\n    // Simple forward pass simulation\n    const outputSize = this.config.layers?.[this.config.layers.length - 1] || 1;\n    const output = new Float32Array(outputSize);\n\n    for (let i = 0; i < outputSize; i++) {\n      output[i] = Math.random();\n    }\n\n    return output;\n  }\n\n  async train(\n    _trainingData: TrainingDataItem[],\n    options: { epochs: number; batchSize?: number; learningRate?: number }\n  ): Promise<typeof this.metrics> {\n    const { epochs } = options;\n\n    for (let epoch = 0; epoch < epochs; epoch++) {\n      const loss = Math.max(0.01, this.metrics.loss * (0.9 + Math.random() * 0.1));\n      this.metrics.loss = loss;\n      this.metrics.epochs_trained++;\n      this.metrics.accuracy = Math.min(0.99, this.metrics.accuracy + 0.01);\n      this.trainingHistory.push({ epoch, loss });\n    }\n\n    return this.metrics;\n  }\n\n  getWeights(): Record<string, any> {\n    return {\n      ['layer_0']: this.weights,\n      ['layer_1']: this.weights.slice(0, -1),\n    };\n  }\n\n  setWeights(weights: Record<string, any>): void {\n    if (weights['layer_0']) {\n      this.weights = weights['layer_0'];\n    }\n  }\n\n  getGradients() {\n    // Simulated gradients\n    return {\n      layer_0: Math.random() * 0.1,\n      layer_1: Math.random() * 0.1,\n    };\n  }\n\n  applyGradients(_gradients: any): void {}\n\n  getMetrics() {\n    return {\n      ...this.metrics,\n      training_history: this.trainingHistory,\n      network_info: {\n        layers: this.config.layers || [128, 64, 32],\n        parameters: 10000, // Simulated parameter count\n      },\n    };\n  }\n\n  async save(_filePath: string): Promise<boolean> {\n    return true;\n  }\n\n  async load(_filePath: string): Promise<boolean> {\n    return true;\n  }\n}\n\n// Neural Network Templates for quick configuration\nconst NeuralNetworkTemplates = {\n  getTemplate: (templateName: string) => {\n    const templates = {\n      deep_analyzer: {\n        layers: [128, 256, 512, 256, 128],\n        activation: 'relu',\n        output_activation: 'sigmoid',\n        dropout: 0.3,\n      },\n      nlp_processor: {\n        layers: [512, 1024, 512, 256],\n        activation: 'gelu',\n        output_activation: 'softmax',\n        dropout: 0.4,\n      },\n      reinforcement_learner: {\n        layers: [64, 128, 128, 64],\n        activation: 'tanh',\n        output_activation: 'linear',\n        dropout: 0.2,\n      },\n    };\n\n    return (templates as any)[templateName] || templates.deep_analyzer;\n  },\n};\n\n// Advanced Neural Network wrapper for new model types\nclass AdvancedNeuralNetwork {\n  public agentId: string;\n  public model: any;\n  public config: any;\n  public modelType: string;\n  public isAdvanced: boolean;\n\n  constructor(agentId: string, model: any, config: any) {\n    this.agentId = agentId;\n    this.model = model;\n    this.config = config;\n    this.modelType = config?.modelType;\n    this.isAdvanced = true;\n  }\n\n  getWeights(): Record<string, any> {\n    return this.model?.getWeights ? this.model.getWeights() : {};\n  }\n\n  setWeights(weights: Record<string, any>): void {\n    if (this.model?.setWeights) {\n      this.model.setWeights(weights);\n    }\n  }\n\n  async forward(input: number[] | Float32Array | Record<string, unknown>): Promise<Float32Array> {\n    try {\n      // Handle different input formats\n      let formattedInput = input;\n\n      if (this.modelType === 'transformer' || this.modelType === 'gru') {\n        // Ensure input has shape [batch_size, sequence_length, features]\n        if (!(input as any).shape) {\n          formattedInput = new Float32Array(input as ArrayLike<number>);\n          (formattedInput as any).shape = [1, (input as any).length, 1];\n        }\n      } else if (this.modelType === 'cnn') {\n        // Ensure input has shape [batch_size, height, width, channels]\n        if (!(input as any).shape) {\n          const inputShape = this.config.inputShape;\n          formattedInput = new Float32Array(input as ArrayLike<number>);\n          (formattedInput as any).shape = [1, ...inputShape];\n        }\n      } else if (this.modelType === 'autoencoder') {\n        // Ensure input has shape [batch_size, input_size]\n        if (!(input as any).shape) {\n          formattedInput = new Float32Array(input as ArrayLike<number>);\n          (formattedInput as any).shape = [1, (input as any).length];\n        }\n      }\n\n      const result = await this.model.forward(formattedInput, false);\n\n      // Return appropriate output based on model type\n      if (this.modelType === 'autoencoder') {\n        return result?.reconstruction;\n      }\n\n      return result;\n    } catch (error) {\n      logger.error(`Forward pass failed for ${this.modelType}:`, error);\n      return new Float32Array(this.config.outputSize || 10).fill(0.5);\n    }\n  }\n\n  async train(trainingData: TrainingDataItem[], options: Record<string, unknown>) {\n    return this.model.train(trainingData, options);\n  }\n\n  getGradients() {\n    // Advanced models handle gradients internally\n    return {};\n  }\n\n  applyGradients(_gradients: any): void {}\n\n  getMetrics() {\n    return this.model.getMetrics();\n  }\n\n  async save(filePath: string) {\n    return this.model.save(filePath);\n  }\n\n  async load(filePath: string) {\n    return this.model.load(filePath);\n  }\n\n  // Special methods for specific model types\n  async encode(input: number[] | Float32Array) {\n    if (this.modelType === 'autoencoder') {\n      const encoder = await this.model.getEncoder();\n      return encoder.encode(input);\n    }\n    throw new Error(`Encode not supported for ${this.modelType}`);\n  }\n\n  async decode(latent: number[] | Float32Array) {\n    if (this.modelType === 'autoencoder') {\n      const decoder = await this.model.getDecoder();\n      return decoder.decode(latent);\n    }\n    throw new Error(`Decode not supported for ${this.modelType}`);\n  }\n\n  async generate(numSamples: number) {\n    if (this.modelType === 'autoencoder' && this.config.variational) {\n      return this.model.generate(numSamples);\n    }\n    throw new Error(`Generation not supported for ${this.modelType}`);\n  }\n}\n\nexport { NeuralNetworkManager, NeuralNetworkTemplates };\n", "/**\n * WASM Module Loader 2 - Active WASM infrastructure component.\n *\n * \u26A0\uFE0F  ACTIVE WASM INFRASTRUCTURE - NEVER REMOVE \u26A0\uFE0F.\n *\n * This module is part of the WASM loading infrastructure:\n * - Referenced in WASM system files as enhanced loader\n * - Part of WASM module loading architecture\n * - Default export available for WASM system integration.\n *\n * Static analysis may miss usage due to:\n * 1. WASM system architectural patterns\n * 2. Enhanced loader naming convention\n * 3. Future integration points.\n *\n * Currently stub implementation but positioned for WASM loading enhancement.\n * TODO: Implement enhanced WASM loading functionality.\n *\n * @usage INFRASTRUCTURE - WASM loading system component\n * @wasmSystem Part of neural WASM loading architecture\n * @enhancedLoader Secondary WASM loader for advanced functionality\n */\n/**\n * @file Neural network: wasm-loader2.\n */\n\nexport class WasmLoader2 {\n  private initialized = false;\n\n  async initialize(): Promise<void> {\n    if (this.initialized) return;\n\n    // TODO: Implement actual WASM loading\n    this.initialized = true;\n  }\n\n  isInitialized(): boolean {\n    return this.initialized;\n  }\n}\n\nexport default WasmLoader2;\n", "/**\n * DAA (Data Accessibility & Analysis) Service \u2013 temporary stub until real implementation lands.\n * Provides typed placeholders so downstream code can integrate with evolving API without pervasive `any` usage.\n *\n * NOTE: All methods currently return simulated / static values and MUST be replaced with real logic.\n */\n/** @file Daa service implementation (stub). */\n\n/** Capability flags exposed by the DAA service. */\nexport interface DaaCapabilities {\n  agents: boolean;\n  workflows: boolean;\n  learning: boolean;\n  cognitive: boolean;\n}\n\n/** Minimal agent configuration. Extend when real agent model is defined. */\nexport interface DaaAgentConfig {\n  name?: string;\n  role?: string;\n  [key: string]: unknown;\n}\n\n/** Representation of an agent within DAA service. */\nexport interface DaaAgent extends DaaAgentConfig {\n  id: string;\n  status: 'created' | 'active' | 'inactive' | 'error';\n  adapted?: boolean;\n  adaptation?: Record<string, unknown>;\n}\n\n/** Workflow definition placeholder. */\nexport interface DaaWorkflowDefinition {\n  name?: string;\n  steps?: unknown[];\n  [key: string]: unknown;\n}\n\n/** Workflow instance metadata. */\nexport interface DaaWorkflowInstance extends DaaWorkflowDefinition {\n  id: string;\n  status: 'created' | 'running' | 'completed' | 'failed';\n}\n\n/** Execution result metadata. */\nexport interface DaaWorkflowExecution {\n  workflowId: string;\n  executionId: string;\n  status: 'completed' | 'failed' | 'running';\n  result: unknown;\n}\n\n/** Knowledge share result. */\nexport interface DaaKnowledgeShareResult {\n  shared: boolean;\n  knowledge: unknown;\n  timestamp: string;\n}\n\n/** Agent learning status. */\nexport interface DaaAgentLearningStatus {\n  agentId: string;\n  learningCycles: number;\n  proficiency: number; // 0..1\n}\n\n/** System-wide learning status. */\nexport interface DaaSystemLearningStatus {\n  totalLearningCycles: number;\n  averageProficiency: number; // 0..1\n  activeAgents: number;\n}\n\n/** Cognitive pattern analysis result. */\nexport interface DaaCognitivePatternsAnalysis {\n  patterns: string[];\n  effectiveness: number; // 0..1\n}\n\n/** Set cognitive pattern result. */\nexport interface DaaCognitivePatternSetResult {\n  agentId: string;\n  pattern: unknown;\n  applied: boolean;\n}\n\n/** Meta-learning invocation arguments (open form). */\nexport interface DaaMetaLearningParams {\n  [key: string]: unknown;\n}\n\n/** Meta-learning result with enrichment. */\nexport interface DaaMetaLearningResult extends DaaMetaLearningParams {\n  learningRate: number; // 0..1 heuristic\n  adaptations: number;\n}\n\n/** Performance metrics structure. */\nexport interface DaaPerformanceMetrics {\n  agentId?: string;\n  metrics: {\n    throughput: number; // ops / interval\n    latency: number; // ms\n    accuracy: number; // 0..1\n  };\n}\n\nexport class DaaService {\n  private initialized = false;\n\n  /** Initialize the DAA service (idempotent). */\n  async initialize(): Promise<void> {\n    if (this.initialized) return;\n    // TODO(daa): wire real initialization (resource acquisition, adapters, caches)\n    this.initialized = true;\n  }\n\n  /**\n   * Process raw data ingestion pipeline.\n   * @param data Arbitrary input payload.\n   * @returns Currently echoes the provided data.\n   */\n  async processData<T = unknown>(data: T): Promise<T> {\n    // TODO(daa): implement normalization, validation, enrichment\n    return data;\n  }\n\n  /**\n   * Run analysis over provided data.\n   * @param data Input subject for analysis.\n   * @returns Stub analysis envelope.\n   */\n  async analyze<T = unknown>(data: T): Promise<{ analyzed: true; data: T }> {\n    // TODO(daa): plug in analytics engine(s)\n    return { analyzed: true, data };\n  }\n\n  /** Whether service has completed initialization. */\n  isInitialized(): boolean {\n    return this.initialized;\n  }\n\n  /** Retrieve capability flags advertised by service. */\n  async getCapabilities(): Promise<DaaCapabilities> {\n    // TODO(daa): dynamic capability discovery\n    return { agents: true, workflows: true, learning: true, cognitive: true };\n  }\n\n  /**\n   * Create a new agent.\n   * @param config Partial agent configuration.\n   */\n  async createAgent(config: DaaAgentConfig): Promise<DaaAgent> {\n    // TODO(daa): persist agent, allocate resources\n    return { id: `agent_${Date.now()}`, ...config, status: 'created' };\n  }\n\n  /**\n   * Apply adaptation to an agent.\n   * @param agentId Target agent identifier.\n   * @param adaptation Adaptation payload (strategy-dependent).\n   */\n  async adaptAgent(agentId: string, adaptation: Record<string, unknown>): Promise<DaaAgent> {\n    // TODO(daa): perform adaptation diff & persist\n    return { id: agentId, adapted: true, adaptation, status: 'active' };\n  }\n\n  /**\n   * Create a workflow definition.\n   * @param workflow Draft workflow definition.\n   */\n  async createWorkflow(workflow: DaaWorkflowDefinition): Promise<DaaWorkflowInstance> {\n    // TODO(daa): validate & persist workflow\n    return { id: `workflow_${Date.now()}`, ...workflow, status: 'created' };\n  }\n\n  /**\n   * Execute a workflow with parameters.\n   * @param workflowId Existing workflow id.\n   * @param params Execution parameters / input context.\n   */\n  async executeWorkflow(workflowId: string, params: unknown): Promise<DaaWorkflowExecution> {\n    // TODO(daa): orchestration engine invocation\n    return {\n      workflowId,\n      executionId: `exec_${Date.now()}`,\n      status: 'completed',\n      result: params,\n    };\n  }\n\n  /** Share knowledge artifact. */\n  async shareKnowledge(knowledge: unknown): Promise<DaaKnowledgeShareResult> {\n    // TODO(daa): index knowledge into memory / KB\n    return { shared: true, knowledge, timestamp: new Date().toISOString() };\n  }\n\n  /** Obtain learning status for a specific agent. */\n  async getAgentLearningStatus(agentId: string): Promise<DaaAgentLearningStatus> {\n    // TODO(daa): compute real status from telemetry\n    return { agentId, learningCycles: 10, proficiency: 0.85 };\n  }\n\n  /** Obtain aggregate system learning status. */\n  async getSystemLearningStatus(): Promise<DaaSystemLearningStatus> {\n    // TODO(daa): aggregate metrics across agents\n    return { totalLearningCycles: 100, averageProficiency: 0.82, activeAgents: 5 };\n  }\n\n  /** Analyze cognitive patterns optionally scoped to an agent. */\n  async analyzeCognitivePatterns(_agentId?: string): Promise<DaaCognitivePatternsAnalysis> {\n    // TODO(daa): mine cognitive patterns from behavior traces\n    return { patterns: ['problem-solving', 'pattern-recognition'], effectiveness: 0.88 };\n  }\n\n  /** Set / apply a cognitive pattern to an agent. */\n  async setCognitivePattern(agentId: string, pattern: unknown): Promise<DaaCognitivePatternSetResult> {\n    // TODO(daa): persist pattern mapping & propagate\n    return { agentId, pattern, applied: true };\n  }\n\n  /** Perform meta-learning cycle over supplied parameters. */\n  async performMetaLearning(params: DaaMetaLearningParams): Promise<DaaMetaLearningResult> {\n    // TODO(daa): run meta-learning algorithms\n    return { ...params, learningRate: 0.92, adaptations: 3 };\n  }\n\n  /** Retrieve performance metrics optionally scoped to an agent. */\n  async getPerformanceMetrics(agentId?: string): Promise<DaaPerformanceMetrics> {\n    // TODO(daa): query metrics subsystem\n    return { agentId, metrics: { throughput: 1000, latency: 50, accuracy: 0.95 } };\n  }\n}\n\nexport default DaaService;\n", "/**\n * @fileoverview Decentralized Autonomous Agents (DAA) MCP Tools for Claude Code Zen\n * \n * This module provides advanced autonomous agent capabilities through the stdio MCP server.\n * DAA agents are self-governing entities that can learn, adapt, and coordinate independently\n * while being orchestrated through the unified MCP interface.\n * \n * ## DAA Architecture Philosophy\n * \n * Decentralized Autonomous Agents represent the next evolution in multi-agent coordination:\n * - **Autonomous Learning**: Agents adapt and improve without direct supervision\n * - **Decentralized Decision Making**: Independent agent decision-making with peer coordination\n * - **Self-Organization**: Agents form optimal coordination patterns automatically\n * - **Persistent Memory**: Cross-session learning and knowledge retention\n * - **Cognitive Patterns**: Specialized thinking approaches for different problem domains\n * \n * ## Tool Categories\n * \n * ### System Initialization\n * - `daa_init` - Initialize the DAA service with autonomous capabilities\n * \n * ### Agent Management\n * - `daa_agent_create` - Create autonomous agents with DAA capabilities\n * - `daa_agent_adapt` - Trigger agent adaptation based on performance feedback\n * - `daa_cognitive_pattern` - Analyze and modify agent cognitive patterns\n * \n * ### Workflow Coordination\n * - `daa_workflow_create` - Create autonomous workflows with DAA coordination\n * - `daa_workflow_execute` - Execute workflows using autonomous agents\n * \n * ### Knowledge Management\n * - `daa_knowledge_share` - Enable knowledge sharing between autonomous agents\n * - `daa_learning_status` - Monitor learning progress and adaptation metrics\n * - `daa_meta_learning` - Enable cross-domain knowledge transfer\n * \n * ### Performance Monitoring\n * - `daa_performance_metrics` - Comprehensive DAA system performance metrics\n * \n * ## Cognitive Patterns\n * \n * DAA agents support multiple cognitive approaches:\n * - **Convergent**: Focused, analytical problem-solving approach\n * - **Divergent**: Creative, exploratory thinking for innovation\n * - **Lateral**: Non-linear thinking for breakthrough insights\n * - **Systems**: Holistic thinking for complex system understanding\n * - **Critical**: Rigorous evaluation and decision-making\n * - **Adaptive**: Dynamic pattern switching based on context\n * \n * ## Integration with stdio MCP\n * \n * All DAA tools are exposed through the stdio MCP server when running `claude-zen swarm`:\n * ```\n * mcp__claude-zen-unified__daa_init\n * mcp__claude-zen-unified__daa_agent_create\n * mcp__claude-zen-unified__daa_workflow_execute\n * ... and 7 other DAA coordination tools\n * ```\n * \n * ## Autonomous Learning Features\n * \n * - **Adaptive Performance**: Agents adjust strategies based on task outcomes\n * - **Cross-Session Memory**: Learning persists across different execution sessions\n * - **Meta-Learning**: Knowledge transfer between different problem domains\n * - **Cognitive Adaptation**: Dynamic switching between thinking patterns\n * - **Peer Learning**: Agents learn from each other's experiences\n * \n * @example\n * ```typescript\n * // Initialize DAA system\n * const daaTools = new DAA_MCPTools();\n * \n * // Create autonomous agent\n * const agent = await daaTools.daa_agent_create({\n *   id: 'research-specialist',\n *   cognitivePattern: 'divergent',\n *   learningRate: 0.01,\n *   capabilities: ['research', 'analysis', 'synthesis']\n * });\n * \n * // Create and execute autonomous workflow\n * await daaTools.daa_workflow_create({\n *   id: 'market-research-flow',\n *   name: 'Autonomous Market Research',\n *   steps: ['data-collection', 'analysis', 'insights', 'report']\n * });\n * \n * await daaTools.daa_workflow_execute({\n *   workflow_id: 'market-research-flow',\n *   agentIds: ['research-specialist']\n * });\n * ```\n * \n * @author Claude Code Zen Team\n * @version 1.0.0-alpha.43\n * @since 1.0.0\n * @see {@link SwarmTools} Core swarm management tools\n * @see {@link HiveTools} High-level coordination tools\n * @see {@link StdioMcpServer} MCP server that exposes these tools\n */\n\nimport { DaaService } from '../core/daa-service.ts';\n\nconst daaService = new DaaService();\n\n/**\n * Decentralized Autonomous Agents MCP tools registry for advanced agent coordination.\n * \n * This class provides sophisticated autonomous agent capabilities that extend beyond\n * traditional swarm coordination. DAA agents are self-governing entities that can\n * learn, adapt, and make independent decisions while maintaining coordination with\n * the broader system.\n * \n * ## Design Philosophy\n * \n * - **Autonomy**: Agents operate independently with minimal human intervention\n * - **Adaptability**: Dynamic learning and strategy adjustment based on performance\n * - **Decentralization**: No single point of control, distributed decision-making\n * - **Persistence**: Cross-session memory and learning continuity\n * - **Cognitive Flexibility**: Multiple thinking patterns for different problem types\n * \n * ## Tool Registration\n * \n * All DAA tools are registered and exposed through the MCP server with comprehensive\n * error handling, performance tracking, and autonomous coordination capabilities.\n * \n * @example\n * ```typescript\n * const daaTools = new DAA_MCPTools();\n * \n * // Initialize autonomous system\n * await daaTools.daa_init({\n *   enableLearning: true,\n *   enableCoordination: true,\n *   persistenceMode: 'auto'\n * });\n * \n * // Create specialized autonomous agent\n * const agent = await daaTools.daa_agent_create({\n *   id: 'code-reviewer',\n *   cognitivePattern: 'critical',\n *   capabilities: ['code-analysis', 'security-audit', 'performance-review']\n * });\n * ```\n */\nexport class DAA_MCPTools {\n  /** Enhanced MCP tools integration for coordination */\n  private mcpTools: any;\n  \n  /** DAA service initialization state */\n  private daaInitialized: boolean;\n\n  /**\n   * Creates a new DAA MCP tools registry with enhanced MCP integration.\n   * \n   * The registry provides autonomous agent capabilities through the MCP interface,\n   * enabling self-governing agents that can learn, adapt, and coordinate independently.\n   * \n   * @param enhancedMcpTools - Enhanced MCP tools for system integration\n   */\n  constructor(enhancedMcpTools) {\n    this.mcpTools = enhancedMcpTools;\n    this.daaInitialized = false;\n  }\n\n  /**\n   * Ensures the DAA service is properly initialized before tool execution.\n   * \n   * This method provides lazy initialization of the DAA service, ensuring that\n   * autonomous agent capabilities are available before any tool operations.\n   * Initialization includes setting up learning systems, memory persistence,\n   * and cognitive pattern engines.\n   * \n   * @throws {Error} When DAA service initialization fails\n   */\n  async ensureInitialized() {\n    if (!this.daaInitialized) {\n      await daaService.initialize();\n      this.daaInitialized = true;\n    }\n  }\n\n  /**\n   * Initializes the Decentralized Autonomous Agents (DAA) service with full capabilities.\n   * \n   * This tool bootstraps the autonomous agent system, enabling self-governing agents\n   * that can learn, adapt, and coordinate independently. The initialization process\n   * sets up learning algorithms, memory systems, cognitive patterns, and coordination\n   * protocols for autonomous operation.\n   * \n   * ## Features Enabled\n   * \n   * - **Autonomous Learning**: Agents adapt strategies based on performance feedback\n   * - **Peer Coordination**: Decentralized agent-to-agent communication\n   * - **Persistent Memory**: Cross-session learning and knowledge retention\n   * - **Neural Integration**: Advanced AI capabilities for complex reasoning\n   * - **Cognitive Patterns**: Multiple thinking approaches for diverse problems\n   * \n   * ## Integration with stdio MCP\n   * \n   * Available as: `mcp__claude-zen-unified__daa_init`\n   * \n   * @param params - DAA initialization configuration\n   * @param params.enableLearning - Enable autonomous learning capabilities (default: true)\n   * @param params.enableCoordination - Enable peer coordination features (default: true)\n   * @param params.persistenceMode - Memory persistence mode ('auto', 'memory', 'disk')\n   * \n   * @returns Promise resolving to DAA system status\n   * @returns result.success - Whether initialization was successful\n   * @returns result.initialized - DAA system initialization status\n   * @returns result.features - Enabled DAA features and capabilities\n   * @returns result.capabilities - Available system capabilities\n   * @returns result.timestamp - ISO timestamp of initialization\n   * \n   * @example\n   * ```typescript\n   * // Initialize with all features enabled\n   * const status = await daaTools.daa_init({\n   *   enableLearning: true,\n   *   enableCoordination: true,\n   *   persistenceMode: 'auto'\n   * });\n   * \n   * console.log(`DAA initialized: ${status.features.cognitivePatterns} patterns available`);\n   * ```\n   * \n   * @throws {Error} When DAA initialization fails\n   */\n  async daa_init(params) {\n    const startTime = performance.now();\n    try {\n      await this.ensureInitialized();\n\n      const { enableLearning = true, enableCoordination = true, persistenceMode = 'auto' } = params;\n\n      const result = {\n        success: true,\n        initialized: true,\n        features: {\n          autonomousLearning: enableLearning,\n          peerCoordination: enableCoordination,\n          persistenceMode,\n          neuralIntegration: true,\n          cognitivePatterns: 6,\n        },\n        capabilities: daaService.getCapabilities(),\n        timestamp: new Date().toISOString(),\n      };\n\n      if (this.mcpTools?.recordToolMetrics) {\n        this.mcpTools.recordToolMetrics('daa_init', startTime, 'success');\n      }\n      return result;\n    } catch (error) {\n      if (this.mcpTools?.recordToolMetrics) {\n        this.mcpTools.recordToolMetrics('daa_init', startTime, 'error', error.message);\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Creates a new autonomous agent with advanced DAA (Decentralized Autonomous Agents) capabilities.\n   * \n   * This tool spawns sophisticated agents that can operate independently with minimal\n   * supervision. DAA agents feature autonomous learning, adaptive cognitive patterns,\n   * and persistent memory that enables continuous improvement across sessions.\n   * \n   * ## Agent Capabilities\n   * \n   * - **Autonomous Learning**: Agents adapt strategies based on task outcomes\n   * - **Cognitive Patterns**: Specialized thinking approaches for different problem types\n   * - **Persistent Memory**: Learning and experiences persist across sessions\n   * - **Self-Optimization**: Automatic performance tuning and strategy adjustment\n   * - **Peer Coordination**: Collaborative learning with other DAA agents\n   * \n   * ## Cognitive Pattern Options\n   * \n   * - **Convergent**: Focused, analytical approach for well-defined problems\n   * - **Divergent**: Creative, exploratory thinking for innovation and ideation\n   * - **Lateral**: Non-linear thinking for breakthrough insights and novel solutions\n   * - **Systems**: Holistic thinking for understanding complex interconnected systems\n   * - **Critical**: Rigorous evaluation, analysis, and evidence-based decision-making\n   * - **Adaptive**: Dynamic pattern switching based on problem context and performance\n   * \n   * ## Integration with stdio MCP\n   * \n   * Available as: `mcp__claude-zen-unified__daa_agent_create`\n   * \n   * @param params - Agent creation configuration\n   * @param params.id - Unique agent identifier (required)\n   * @param params.capabilities - Array of specialized capabilities for the agent\n   * @param params.cognitivePattern - Thinking pattern approach (default: 'adaptive')\n   * @param params.learningRate - Learning adaptation rate from 0.0 to 1.0 (default: 0.001)\n   * @param params.enableMemory - Enable persistent cross-session memory (default: true)\n   * \n   * @returns Promise resolving to created agent information\n   * @returns result.agent - Agent configuration and status\n   * @returns result.agent.id - Unique agent identifier\n   * @returns result.agent.cognitive_pattern - Assigned cognitive pattern\n   * @returns result.agent.capabilities - Agent's specialized capabilities\n   * @returns result.agent.status - Current agent status\n   * @returns result.swarm_id - Associated swarm identifier\n   * @returns result.learning_enabled - Whether learning is active\n   * @returns result.memory_enabled - Whether persistent memory is enabled\n   * \n   * @example\n   * ```typescript\n   * // Create specialized code analysis agent\n   * const codeAgent = await daaTools.daa_agent_create({\n   *   id: 'code-analyzer-001',\n   *   cognitivePattern: 'critical',\n   *   capabilities: ['static-analysis', 'security-audit', 'performance-review'],\n   *   learningRate: 0.01\n   * });\n   * \n   * // Create creative problem-solving agent\n   * const creativeAgent = await daaTools.daa_agent_create({\n   *   id: 'innovation-specialist',\n   *   cognitivePattern: 'divergent',\n   *   capabilities: ['brainstorming', 'ideation', 'solution-design'],\n   *   enableMemory: true\n   * });\n   * ```\n   * \n   * @throws {Error} When agent creation fails or required parameters are missing\n   */\n  async daa_agent_create(params) {\n    const startTime = performance.now();\n    try {\n      await this.ensureInitialized();\n\n      const {\n        id,\n        capabilities = [],\n        cognitivePattern = 'adaptive',\n        learningRate = 0.001,\n        enableMemory = true,\n      } = params;\n\n      if (!id) {\n        throw new Error('Agent ID is required');\n      }\n\n      const agent = await daaService.createAgent({\n        id,\n        capabilities,\n        cognitivePattern,\n        config: {\n          learningRate,\n          enableMemory,\n          autonomousMode: true,\n        },\n      });\n\n      // Find or create a swarm for the agent\n      let swarmId: string | null = null;\n      if (this.mcpTools?.activeSwarms) {\n        for (const [id, swarm] of this.mcpTools.activeSwarms) {\n          if (swarm.agents.size < swarm.maxAgents) {\n            swarmId = id;\n            swarm.agents.set(agent.id, agent);\n            break;\n          }\n        }\n      } else {\n        // Create a virtual swarm if none exists\n        swarmId = 'daa-default-swarm';\n      }\n\n      // TODO: LEGACY - Update to persist Drone to THE COLLECTIVE database\n      // Persist DAA agent to database\n      if (this.mcpTools?.persistence) {\n        try {\n          await this.mcpTools.persistence.createAgent({\n            id: agent.id,\n            swarmId: swarmId || 'daa-default-swarm',\n            name: `DAA-${agent.id}`,\n            type: 'daa',\n            capabilities: Array.from(agent.capabilities || capabilities),\n            neuralConfig: {\n              cognitivePattern: agent.cognitivePattern || cognitivePattern,\n              learningRate,\n              enableMemory,\n              daaEnabled: true,\n            },\n            metadata: {\n              createdAt: new Date().toISOString(),\n              autonomousMode: true,\n            },\n          });\n\n          this.mcpTools.logger?.info('DAA agent persisted successfully', {\n            agentId: agent.id,\n            swarmId,\n          });\n        } catch (persistError) {\n          this.mcpTools.logger?.warn('Failed to persist DAA agent', {\n            agentId: agent.id,\n            error: persistError.message,\n          });\n          // Continue execution even if persistence fails\n        }\n      }\n\n      const result = {\n        agent: {\n          id: agent.id,\n          cognitive_pattern: agent.cognitivePattern || cognitivePattern,\n          capabilities: Array.from(agent.capabilities || capabilities),\n          status: 'active',\n          created_at: new Date().toISOString(),\n        },\n        swarm_id: swarmId,\n        learning_enabled: learningRate > 0,\n        memory_enabled: enableMemory,\n      };\n\n      if (this.mcpTools?.recordToolMetrics) {\n        this.mcpTools.recordToolMetrics('daa_agent_create', startTime, 'success');\n      }\n      return result;\n    } catch (error) {\n      if (this.mcpTools?.recordToolMetrics) {\n        this.mcpTools.recordToolMetrics('daa_agent_create', startTime, 'error', error.message);\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Triggers adaptive learning for DAA agents based on performance feedback.\n   * \n   * This tool enables continuous agent improvement by processing performance feedback\n   * and automatically adjusting agent strategies, cognitive patterns, and decision-making\n   * approaches. The adaptation process is autonomous and builds upon previous learning\n   * experiences stored in persistent memory.\n   * \n   * ## Adaptation Process\n   * \n   * - **Performance Analysis**: Evaluates agent performance against success metrics\n   * - **Strategy Adjustment**: Modifies agent approaches based on feedback patterns\n   * - **Cognitive Adaptation**: May switch cognitive patterns for better performance\n   * - **Learning Integration**: Incorporates new insights into persistent memory\n   * - **Peer Sharing**: Shares successful adaptations with other DAA agents\n   * \n   * ## Integration with stdio MCP\n   * \n   * Available as: `mcp__claude-zen-unified__daa_agent_adapt`\n   * \n   * @param params - Adaptation configuration and feedback\n   * @param params.agent_id - Agent identifier to adapt (required)\n   * @param params.agentId - Legacy agent identifier parameter (alternative to agent_id)\n   * @param params.feedback - Human or system feedback about agent performance\n   * @param params.performanceScore - Numeric performance score from 0.0 to 1.0 (default: 0.5)\n   * @param params.suggestions - Array of specific improvement suggestions\n   * \n   * @returns Promise resolving to adaptation results\n   * @returns result.agent_id - Identifier of the adapted agent\n   * @returns result.adaptation_complete - Whether adaptation was successful\n   * @returns result.previous_pattern - Agent's cognitive pattern before adaptation\n   * @returns result.new_pattern - Agent's cognitive pattern after adaptation\n   * @returns result.performance_improvement - Expected performance improvement\n   * @returns result.learning_insights - Key insights gained from adaptation\n   * @returns result.timestamp - ISO timestamp of adaptation\n   * \n   * @example\n   * ```typescript\n   * // Adapt agent based on task performance\n   * const adaptation = await daaTools.daa_agent_adapt({\n   *   agent_id: 'code-analyzer-001',\n   *   feedback: 'Agent missed critical security vulnerabilities',\n   *   performanceScore: 0.6,\n   *   suggestions: ['increase-security-focus', 'deeper-code-analysis']\n   * });\n   * \n   * console.log(`Pattern changed from ${adaptation.previous_pattern} to ${adaptation.new_pattern}`);\n   * ```\n   * \n   * @throws {Error} When agent ID is missing or adaptation fails\n   */\n  async daa_agent_adapt(params) {\n    const startTime = performance.now();\n    try {\n      await this.ensureInitialized();\n\n      const { agent_id, agentId, feedback, performanceScore = 0.5, suggestions = [] } = params;\n\n      const id = agent_id || agentId;\n      if (!id) {\n        throw new Error('Agent ID is required. Provide either agent_id or agentId parameter.');\n      }\n\n      const adaptationResult = await daaService.adaptAgent(id, {\n        feedback,\n        performanceScore,\n        suggestions,\n        timestamp: new Date().toISOString(),\n      });\n\n      const result = {\n        agent_id: id,\n        adaptation_complete: true,\n        previous_pattern: adaptationResult?.previousPattern,\n        new_pattern: adaptationResult?.newPattern,\n        performance_improvement: adaptationResult?.improvement,\n        learning_insights: adaptationResult?.insights,\n        timestamp: new Date().toISOString(),\n      };\n\n      if (this.mcpTools?.recordToolMetrics) {\n        this.mcpTools.recordToolMetrics('daa_agent_adapt', startTime, 'success');\n      }\n      return result;\n    } catch (error) {\n      if (this.mcpTools?.recordToolMetrics) {\n        this.mcpTools.recordToolMetrics('daa_agent_adapt', startTime, 'error', error.message);\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Creates autonomous workflows with sophisticated DAA coordination capabilities.\n   * \n   * This tool enables the creation of complex, multi-step workflows that can be\n   * executed autonomously by DAA agents. Workflows support parallel execution,\n   * dependency management, and adaptive strategy selection based on real-time\n   * performance and context.\n   * \n   * ## Workflow Features\n   * \n   * - **Autonomous Execution**: Workflows run independently with minimal supervision\n   * - **Adaptive Strategy**: Dynamic execution strategy based on performance\n   * - **Dependency Management**: Complex step dependencies and coordination\n   * - **Agent Assignment**: Intelligent agent selection for optimal performance\n   * - **Progress Monitoring**: Real-time workflow status and progress tracking\n   * \n   * ## Execution Strategies\n   * \n   * - **Parallel**: Execute steps concurrently for maximum speed\n   * - **Sequential**: Execute steps in order for dependency compliance\n   * - **Adaptive**: Dynamic strategy selection based on performance and context\n   * \n   * ## Integration with stdio MCP\n   * \n   * Available as: `mcp__claude-zen-unified__daa_workflow_create`\n   * \n   * @param params - Workflow creation configuration\n   * @param params.id - Unique workflow identifier (required)\n   * @param params.name - Human-readable workflow name (required)\n   * @param params.steps - Array of workflow steps to execute\n   * @param params.dependencies - Object defining step dependencies\n   * @param params.strategy - Execution strategy ('parallel', 'sequential', 'adaptive')\n   * \n   * @returns Promise resolving to workflow configuration\n   * @returns result.workflow_id - Unique workflow identifier\n   * @returns result.name - Workflow display name\n   * @returns result.total_steps - Total number of workflow steps\n   * @returns result.execution_strategy - Configured execution strategy\n   * @returns result.dependencies_count - Number of step dependencies\n   * @returns result.status - Current workflow status\n   * @returns result.created_at - ISO timestamp of creation\n   * \n   * @example\n   * ```typescript\n   * // Create complex data analysis workflow\n   * const workflow = await daaTools.daa_workflow_create({\n   *   id: 'data-analysis-pipeline',\n   *   name: 'Autonomous Data Analysis Pipeline',\n   *   steps: [\n   *     'data-collection',\n   *     'data-cleaning', \n   *     'statistical-analysis',\n   *     'pattern-recognition',\n   *     'insights-generation',\n   *     'report-creation'\n   *   ],\n   *   dependencies: {\n   *     'data-cleaning': ['data-collection'],\n   *     'statistical-analysis': ['data-cleaning'],\n   *     'pattern-recognition': ['statistical-analysis'],\n   *     'insights-generation': ['pattern-recognition'],\n   *     'report-creation': ['insights-generation']\n   *   },\n   *   strategy: 'adaptive'\n   * });\n   * ```\n   * \n   * @throws {Error} When required parameters are missing or workflow creation fails\n   */\n  async daa_workflow_create(params) {\n    const startTime = performance.now();\n    try {\n      await this.ensureInitialized();\n\n      const { id, name, steps = [], dependencies = {}, strategy = 'parallel' } = params;\n\n      if (!id || !name) {\n        throw new Error('Workflow ID and name are required');\n      }\n\n      const workflow = await daaService.createWorkflow({ id, steps, dependencies, name, strategy });\n\n      const result = {\n        workflow_id: workflow.id,\n        name,\n        total_steps: workflow.steps.length,\n        execution_strategy: strategy,\n        dependencies_count: Object.keys(workflow.dependencies).length,\n        status: workflow.status,\n        created_at: new Date().toISOString(),\n      };\n\n      if (this.mcpTools?.recordToolMetrics) {\n        this.mcpTools.recordToolMetrics('daa_workflow_create', startTime, 'success');\n      }\n      return result;\n    } catch (error) {\n      if (this.mcpTools?.recordToolMetrics) {\n        this.mcpTools.recordToolMetrics('daa_workflow_create', startTime, 'error', error.message);\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Executes DAA workflows using autonomous agents with sophisticated coordination.\n   * \n   * This tool orchestrates the execution of complex workflows by assigning specialized\n   * DAA agents to appropriate tasks. The execution process is fully autonomous with\n   * real-time adaptation, progress monitoring, and intelligent resource allocation.\n   * \n   * ## Execution Features\n   * \n   * - **Autonomous Orchestration**: Workflow executes independently with minimal supervision\n   * - **Intelligent Agent Assignment**: Optimal agent selection based on capabilities\n   * - **Parallel Processing**: Concurrent execution where dependencies allow\n   * - **Real-time Adaptation**: Dynamic strategy adjustment based on performance\n   * - **Progress Monitoring**: Comprehensive tracking of workflow execution\n   * \n   * ## Integration with stdio MCP\n   * \n   * Available as: `mcp__claude-zen-unified__daa_workflow_execute`\n   * \n   * @param params - Workflow execution configuration\n   * @param params.workflow_id - Workflow identifier to execute (required)\n   * @param params.workflowId - Legacy workflow identifier (alternative to workflow_id)\n   * @param params.agentIds - Array of specific agent IDs to use for execution\n   * @param params.parallelExecution - Enable parallel step execution (default: true)\n   * \n   * @returns Promise resolving to execution results\n   * @returns result.workflow_id - Executed workflow identifier\n   * @returns result.execution_complete - Whether execution completed successfully\n   * @returns result.steps_completed - Number of steps completed\n   * @returns result.total_steps - Total number of workflow steps\n   * @returns result.execution_time_ms - Total execution time in milliseconds\n   * @returns result.agents_involved - Array of agents that participated\n   * @returns result.results - Detailed results from each workflow step\n   * @returns result.timestamp - ISO timestamp of execution completion\n   * \n   * @example\n   * ```typescript\n   * // Execute workflow with specific agents\n   * const execution = await daaTools.daa_workflow_execute({\n   *   workflow_id: 'data-analysis-pipeline',\n   *   agentIds: ['data-specialist-001', 'analysis-expert-002'],\n   *   parallelExecution: true\n   * });\n   * \n   * console.log(`Completed ${execution.steps_completed}/${execution.total_steps} steps`);\n   * ```\n   * \n   * @throws {Error} When workflow ID is missing or execution fails\n   */\n  async daa_workflow_execute(params) {\n    const startTime = performance.now();\n    try {\n      await this.ensureInitialized();\n\n      const { workflow_id, workflowId, agentIds = [], parallelExecution = true } = params;\n\n      const id = workflow_id || workflowId;\n      if (!id) {\n        throw new Error(\n          'Workflow ID is required. Provide either workflow_id or workflowId parameter.'\n        );\n      }\n\n      const executionResult = await daaService.executeWorkflow(id, {\n        agentIds,\n        parallel: parallelExecution,\n      });\n\n      const result = {\n        workflow_id: id,\n        execution_complete: executionResult?.complete,\n        steps_completed: executionResult?.stepsCompleted,\n        total_steps: executionResult?.totalSteps,\n        execution_time_ms: executionResult?.executionTime,\n        agents_involved: executionResult?.agentsInvolved,\n        results: executionResult?.stepResults,\n        timestamp: new Date().toISOString(),\n      };\n\n      if (this.mcpTools?.recordToolMetrics) {\n        this.mcpTools.recordToolMetrics('daa_workflow_execute', startTime, 'success');\n      }\n      return result;\n    } catch (error) {\n      if (this.mcpTools?.recordToolMetrics) {\n        this.mcpTools.recordToolMetrics('daa_workflow_execute', startTime, 'error', error.message);\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Facilitates knowledge sharing between DAA agents for collaborative learning.\n   * \n   * This tool enables sophisticated knowledge transfer mechanisms between autonomous\n   * agents, allowing them to share experiences, insights, and learned strategies.\n   * The knowledge sharing process supports domain-specific transfers and maintains\n   * learning continuity across the agent collective.\n   * \n   * ## Knowledge Sharing Features\n   * \n   * - **Domain-Specific Transfer**: Knowledge sharing within specific expertise areas\n   * - **Experience Sharing**: Transfer of task experiences and learned strategies\n   * - **Collective Intelligence**: Building shared knowledge across agent collective\n   * - **Adaptive Transfer**: Dynamic knowledge relevance assessment\n   * - **Persistent Storage**: Shared knowledge persists across sessions\n   * \n   * ## Integration with stdio MCP\n   * \n   * Available as: `mcp__claude-zen-unified__daa_knowledge_share`\n   * \n   * @param params - Knowledge sharing configuration\n   * @param params.source_agent - Source agent ID sharing knowledge (required)\n   * @param params.sourceAgentId - Legacy source agent ID parameter\n   * @param params.target_agents - Array of target agent IDs receiving knowledge (required)\n   * @param params.targetAgentIds - Legacy target agent IDs parameter\n   * @param params.knowledgeDomain - Domain or category of knowledge being shared\n   * @param params.knowledgeContent - Specific knowledge content to transfer\n   * \n   * @returns Promise resolving to knowledge sharing results\n   * @returns result.source_agent - Source agent identifier\n   * @returns result.target_agents - Array of target agent identifiers\n   * @returns result.knowledge_domain - Domain of shared knowledge\n   * @returns result.sharing_complete - Whether knowledge transfer was successful\n   * @returns result.agents_updated - Number of agents that received the knowledge\n   * @returns result.knowledge_transfer_rate - Effectiveness of knowledge transfer\n   * @returns result.timestamp - ISO timestamp of knowledge sharing\n   * \n   * @example\n   * ```typescript\n   * // Share code analysis insights between agents\n   * const sharing = await daaTools.daa_knowledge_share({\n   *   source_agent: 'code-analyzer-001',\n   *   target_agents: ['security-auditor-002', 'performance-reviewer-003'],\n   *   knowledgeDomain: 'code-quality-patterns',\n   *   knowledgeContent: {\n   *     patterns: ['singleton-antipattern', 'memory-leak-indicators'],\n   *     insights: 'Focus on async/await error handling in Node.js',\n   *     confidence: 0.9\n   *   }\n   * });\n   * ```\n   * \n   * @throws {Error} When required agent IDs are missing or knowledge sharing fails\n   */\n  async daa_knowledge_share(params) {\n    const startTime = performance.now();\n    try {\n      await this.ensureInitialized();\n\n      const {\n        source_agent,\n        sourceAgentId,\n        target_agents,\n        targetAgentIds,\n        knowledgeDomain,\n        knowledgeContent,\n      } = params;\n\n      const sourceId = source_agent || sourceAgentId;\n      const targetIds = target_agents || targetAgentIds || [];\n\n      if (!sourceId) {\n        throw new Error(\n          'Source agent ID is required. Provide either source_agent or sourceAgentId parameter.'\n        );\n      }\n      if (!targetIds || targetIds.length === 0) {\n        throw new Error(\n          'Target agent IDs are required. Provide either target_agents or targetAgentIds parameter with at least one agent ID.'\n        );\n      }\n\n      const sharingResults = await daaService.shareKnowledge({\n        sourceId,\n        targetIds,\n        domain: knowledgeDomain,\n        content: knowledgeContent,\n        timestamp: new Date().toISOString(),\n      });\n\n      const result = {\n        source_agent: sourceId,\n        target_agents: targetIds,\n        knowledge_domain: knowledgeDomain,\n        sharing_complete: true,\n        agents_updated: sharingResults?.updatedAgents,\n        knowledge_transfer_rate: sharingResults?.transferRate,\n        timestamp: new Date().toISOString(),\n      };\n\n      if (this.mcpTools?.recordToolMetrics) {\n        this.mcpTools.recordToolMetrics('daa_knowledge_share', startTime, 'success');\n      }\n      return result;\n    } catch (error) {\n      if (this.mcpTools?.recordToolMetrics) {\n        this.mcpTools.recordToolMetrics('daa_knowledge_share', startTime, 'error', error.message);\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Retrieves comprehensive learning progress and status for DAA agents.\n   * \n   * This tool provides detailed insights into autonomous agent learning progress,\n   * including proficiency metrics, knowledge domains, adaptation rates, and\n   * cross-session memory utilization. Essential for monitoring and optimizing\n   * agent performance and learning effectiveness.\n   * \n   * ## Learning Metrics\n   * \n   * - **Learning Cycles**: Number of adaptation and learning iterations\n   * - **Proficiency Levels**: Agent expertise across different domains\n   * - **Adaptation Rate**: Speed of learning and strategy adjustment\n   * - **Memory Utilization**: Cross-session memory usage and effectiveness\n   * - **Performance Trends**: Historical performance improvement patterns\n   * \n   * ## Integration with stdio MCP\n   * \n   * Available as: `mcp__claude-zen-unified__daa_learning_status`\n   * \n   * @param params - Learning status query parameters\n   * @param params.agentId - Specific agent ID to query (optional, defaults to system-wide)\n   * @param params.detailed - Include detailed metrics and insights (default: false)\n   * \n   * @returns Promise resolving to learning status information\n   * @returns result.agent_id - Agent identifier or 'all' for system-wide status\n   * @returns result.total_learning_cycles - Total number of learning iterations\n   * @returns result.average_proficiency - Average proficiency across all domains\n   * @returns result.knowledge_domains - Array of active knowledge domains\n   * @returns result.adaptation_rate - Rate of learning adaptation\n   * @returns result.neural_models_active - Number of active neural models\n   * @returns result.cross_session_memory - Size of persistent memory storage\n   * @returns result.performance_trend - Historical performance trend data\n   * @returns result.detailed_metrics - Detailed metrics (when detailed=true)\n   * @returns result.timestamp - ISO timestamp of status retrieval\n   * \n   * @example\n   * ```typescript\n   * // Get detailed learning status for specific agent\n   * const status = await daaTools.daa_learning_status({\n   *   agentId: 'code-analyzer-001',\n   *   detailed: true\n   * });\n   * \n   * console.log(`Agent proficiency: ${status.average_proficiency}`);\n   * console.log(`Active domains: ${status.knowledge_domains.length}`);\n   * \n   * // Get system-wide learning overview\n   * const systemStatus = await daaTools.daa_learning_status({});\n   * ```\n   * \n   * @throws {Error} When learning status retrieval fails\n   */\n  async daa_learning_status(params) {\n    const startTime = performance.now();\n    try {\n      await this.ensureInitialized();\n\n      const { agentId, detailed = false } = params;\n\n      let learningStatus;\n      if (agentId) {\n        // Get specific agent learning status\n        learningStatus = await daaService.getAgentLearningStatus(agentId);\n      } else {\n        // Get overall system learning status\n        learningStatus = await daaService.getSystemLearningStatus();\n      }\n\n      const result: any = {\n        agent_id: agentId || 'all',\n        total_learning_cycles: learningStatus.totalCycles,\n        average_proficiency: learningStatus.avgProficiency,\n        knowledge_domains: learningStatus.domains,\n        adaptation_rate: learningStatus.adaptationRate,\n        neural_models_active: learningStatus.neuralModelsCount,\n        cross_session_memory: learningStatus.persistentMemorySize,\n        performance_trend: learningStatus.performanceTrend,\n        timestamp: new Date().toISOString(),\n      };\n\n      if (detailed) {\n        if (result) result.detailed_metrics = learningStatus.detailedMetrics;\n      }\n\n      if (this.mcpTools?.recordToolMetrics) {\n        this.mcpTools.recordToolMetrics('daa_learning_status', startTime, 'success');\n      }\n      return result;\n    } catch (error) {\n      if (this.mcpTools?.recordToolMetrics) {\n        this.mcpTools.recordToolMetrics('daa_learning_status', startTime, 'error', error.message);\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Analyzes or modifies cognitive patterns for DAA agents to optimize performance.\n   * \n   * This tool provides sophisticated cognitive pattern management for autonomous agents,\n   * enabling analysis of current thinking patterns and dynamic adaptation to optimize\n   * performance for specific problem domains. Cognitive patterns fundamentally shape\n   * how agents approach problems and make decisions.\n   * \n   * ## Cognitive Pattern Analysis\n   * \n   * - **Pattern Effectiveness**: Measures how well current patterns perform\n   * - **Optimization Recommendations**: Suggests better patterns for current tasks\n   * - **Performance Correlation**: Links patterns to task success rates\n   * - **Adaptive Insights**: Identifies optimal pattern switching triggers\n   * \n   * ## Available Cognitive Patterns\n   * \n   * - **Convergent**: Focused, analytical thinking for well-defined problems\n   * - **Divergent**: Creative, exploratory approach for innovation and ideation\n   * - **Lateral**: Non-linear thinking for breakthrough insights\n   * - **Systems**: Holistic thinking for complex interconnected problems\n   * - **Critical**: Rigorous evaluation and evidence-based decision-making\n   * - **Adaptive**: Dynamic pattern switching based on context and performance\n   * \n   * ## Integration with stdio MCP\n   * \n   * Available as: `mcp__claude-zen-unified__daa_cognitive_pattern`\n   * \n   * @param params - Cognitive pattern operation parameters\n   * @param params.agent_id - Agent identifier for pattern operation\n   * @param params.agentId - Legacy agent identifier parameter\n   * @param params.action - Operation type ('analyze' or 'change')\n   * @param params.pattern - New cognitive pattern to set (required for 'change' action)\n   * @param params.analyze - Boolean flag to perform analysis (alternative to action='analyze')\n   * \n   * @returns Promise resolving to cognitive pattern results\n   * \n   * For analysis operations:\n   * @returns result.analysis_type - Type of analysis performed\n   * @returns result.current_patterns - Current cognitive patterns in use\n   * @returns result.pattern_effectiveness - Effectiveness scores for patterns\n   * @returns result.recommendations - Recommended pattern optimizations\n   * @returns result.optimization_potential - Potential improvement score\n   * \n   * For pattern change operations:\n   * @returns result.agent_id - Agent identifier\n   * @returns result.previous_pattern - Pattern before change\n   * @returns result.new_pattern - Pattern after change\n   * @returns result.adaptation_success - Whether pattern change was successful\n   * @returns result.expected_improvement - Expected performance improvement\n   * @returns result.timestamp - ISO timestamp of operation\n   * \n   * @example\n   * ```typescript\n   * // Analyze current cognitive patterns\n   * const analysis = await daaTools.daa_cognitive_pattern({\n   *   agent_id: 'problem-solver-001',\n   *   action: 'analyze'\n   * });\n   * \n   * // Change cognitive pattern based on analysis\n   * if (analysis.optimization_potential > 0.7) {\n   *   const change = await daaTools.daa_cognitive_pattern({\n   *     agent_id: 'problem-solver-001',\n   *     action: 'change',\n   *     pattern: analysis.recommendations[0]\n   *   });\n   * }\n   * ```\n   * \n   * @throws {Error} When agent ID is missing or cognitive pattern operation fails\n   */\n  async daa_cognitive_pattern(params) {\n    const startTime = performance.now();\n    try {\n      await this.ensureInitialized();\n\n      const { agent_id, agentId, pattern, action, analyze = false } = params;\n\n      const id = agent_id || agentId;\n      const shouldAnalyze = action === 'analyze' || analyze;\n\n      if (shouldAnalyze) {\n        // Analyze current cognitive patterns\n        const analysis = await daaService.analyzeCognitivePatterns(agentId);\n        const result = {\n          analysis_type: 'cognitive_pattern',\n          agent_id: id || 'all',\n          current_patterns: analysis.patterns,\n          pattern_effectiveness: analysis.effectiveness,\n          recommendations: analysis.recommendations,\n          optimization_potential: analysis.optimizationScore,\n          timestamp: new Date().toISOString(),\n        };\n\n        if (this.mcpTools?.recordToolMetrics) {\n          this.mcpTools.recordToolMetrics('daa_cognitive_pattern', startTime, 'success');\n        }\n        return result;\n      }\n      // Change cognitive pattern\n      if (!agentId || !pattern) {\n        throw new Error('Agent ID and pattern are required for pattern change');\n      }\n\n      const changeResult = await daaService.setCognitivePattern(agentId, pattern);\n\n      const result = {\n        agent_id: agentId,\n        previous_pattern: changeResult?.previousPattern,\n        new_pattern: pattern,\n        adaptation_success: changeResult?.success,\n        expected_improvement: changeResult?.expectedImprovement,\n        timestamp: new Date().toISOString(),\n      };\n\n      if (this.mcpTools?.recordToolMetrics) {\n        this.mcpTools.recordToolMetrics('daa_cognitive_pattern', startTime, 'success');\n      }\n      return result;\n    } catch (error) {\n      if (this.mcpTools?.recordToolMetrics) {\n        this.mcpTools.recordToolMetrics('daa_cognitive_pattern', startTime, 'error', error.message);\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Enables sophisticated meta-learning capabilities across knowledge domains for DAA agents.\n   * \n   * This tool facilitates advanced knowledge transfer between different problem domains,\n   * enabling agents to apply insights and strategies learned in one area to completely\n   * different domains. Meta-learning represents one of the most advanced DAA capabilities,\n   * allowing for rapid adaptation to new problem types.\n   * \n   * ## Meta-Learning Features\n   * \n   * - **Cross-Domain Transfer**: Apply knowledge from one domain to another\n   * - **Pattern Abstraction**: Extract high-level patterns applicable across domains\n   * - **Adaptive Transfer**: Intelligent selection of transferable knowledge\n   * - **Gradual Integration**: Incremental knowledge integration to prevent conflicts\n   * - **Performance Validation**: Verify effectiveness of transferred knowledge\n   * \n   * ## Transfer Modes\n   * \n   * - **Adaptive**: Intelligent, context-aware knowledge transfer (recommended)\n   * - **Direct**: Immediate, complete knowledge transfer\n   * - **Gradual**: Incremental transfer with validation at each step\n   * \n   * ## Integration with stdio MCP\n   * \n   * Available as: `mcp__claude-zen-unified__daa_meta_learning`\n   * \n   * @param params - Meta-learning configuration parameters\n   * @param params.sourceDomain - Source knowledge domain to transfer from\n   * @param params.targetDomain - Target domain to receive transferred knowledge\n   * @param params.transferMode - Transfer approach ('adaptive', 'direct', 'gradual')\n   * @param params.agentIds - Specific agents to update (optional, defaults to all eligible)\n   * \n   * @returns Promise resolving to meta-learning results\n   * @returns result.meta_learning_complete - Whether meta-learning was successful\n   * @returns result.source_domain - Source domain identifier\n   * @returns result.target_domain - Target domain identifier\n   * @returns result.transfer_mode - Transfer mode used\n   * @returns result.knowledge_transferred - Number of knowledge items transferred\n   * @returns result.agents_updated - Number of agents that received new knowledge\n   * @returns result.domain_proficiency_gain - Improvement in target domain proficiency\n   * @returns result.cross_domain_insights - New insights discovered through transfer\n   * @returns result.timestamp - ISO timestamp of meta-learning completion\n   * \n   * @example\n   * ```typescript\n   * // Transfer code analysis insights to security auditing\n   * const metaLearning = await daaTools.daa_meta_learning({\n   *   sourceDomain: 'code-quality-analysis',\n   *   targetDomain: 'security-vulnerability-assessment',\n   *   transferMode: 'adaptive',\n   *   agentIds: ['security-specialist-001', 'code-auditor-002']\n   * });\n   * \n   * console.log(`Transferred ${metaLearning.knowledge_transferred} insights`);\n   * console.log(`Proficiency gain: ${metaLearning.domain_proficiency_gain}`);\n   * ```\n   * \n   * @throws {Error} When meta-learning operation fails\n   */\n  async daa_meta_learning(params) {\n    const startTime = performance.now();\n    try {\n      await this.ensureInitialized();\n\n      const { sourceDomain, targetDomain, transferMode = 'adaptive', agentIds = [] } = params;\n\n      const metaLearningResult = await daaService.performMetaLearning({\n        sourceDomain,\n        targetDomain,\n        transferMode,\n        agentIds: agentIds.length > 0 ? agentIds : undefined,\n      });\n\n      const result = {\n        meta_learning_complete: true,\n        source_domain: sourceDomain,\n        target_domain: targetDomain,\n        transfer_mode: transferMode,\n        knowledge_transferred: metaLearningResult?.knowledgeItems,\n        agents_updated: metaLearningResult?.updatedAgents,\n        domain_proficiency_gain: metaLearningResult?.proficiencyGain,\n        cross_domain_insights: metaLearningResult?.insights,\n        timestamp: new Date().toISOString(),\n      };\n\n      if (this.mcpTools?.recordToolMetrics) {\n        this.mcpTools.recordToolMetrics('daa_meta_learning', startTime, 'success');\n      }\n      return result;\n    } catch (error) {\n      if (this.mcpTools?.recordToolMetrics) {\n        this.mcpTools.recordToolMetrics('daa_meta_learning', startTime, 'error', error.message);\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Retrieves comprehensive performance metrics for the DAA (Decentralized Autonomous Agents) system.\n   * \n   * This tool provides detailed performance analytics across all DAA operations,\n   * including system metrics, learning effectiveness, resource utilization,\n   * and neural model performance. Essential for monitoring DAA system health\n   * and optimizing autonomous agent operations.\n   * \n   * ## Metrics Categories\n   * \n   * - **System Metrics**: Agent counts, task completion rates, execution times\n   * - **Performance Metrics**: Success rates, adaptation effectiveness, coordination quality\n   * - **Efficiency Metrics**: Resource optimization, parallel execution gains, token reduction\n   * - **Neural Metrics**: Neural model performance, inference speeds, training progress\n   * \n   * ## Time Range Support\n   * \n   * Supports flexible time ranges for historical analysis:\n   * - `1h`, `6h`, `24h` - Recent performance data\n   * - `7d`, `30d` - Medium-term trends\n   * - `90d`, `1y` - Long-term performance analysis\n   * \n   * ## Integration with stdio MCP\n   * \n   * Available as: `mcp__claude-zen-unified__daa_performance_metrics`\n   * \n   * @param params - Performance metrics query parameters\n   * @param params.category - Metrics category ('all', 'system', 'performance', 'efficiency', 'neural')\n   * @param params.timeRange - Time range for metrics (e.g., '1h', '24h', '7d')\n   * \n   * @returns Promise resolving to comprehensive performance metrics\n   * @returns result.metrics_category - Category of metrics retrieved\n   * @returns result.time_range - Time range for metrics data\n   * @returns result.system_metrics - System-level performance data\n   * @returns result.system_metrics.total_agents - Total number of DAA agents\n   * @returns result.system_metrics.active_agents - Currently active agents\n   * @returns result.system_metrics.autonomous_tasks_completed - Tasks completed autonomously\n   * @returns result.performance_metrics - Performance and effectiveness data\n   * @returns result.performance_metrics.task_success_rate - Overall task success rate\n   * @returns result.performance_metrics.adaptation_effectiveness - Learning adaptation success\n   * @returns result.efficiency_metrics - Resource utilization and optimization data\n   * @returns result.efficiency_metrics.token_reduction - Token usage optimization\n   * @returns result.efficiency_metrics.parallel_execution_gain - Parallelization benefits\n   * @returns result.neural_metrics - Neural model performance data\n   * @returns result.neural_metrics.models_active - Number of active neural models\n   * @returns result.neural_metrics.inference_speed_ms - Average inference time\n   * @returns result.timestamp - ISO timestamp of metrics collection\n   * \n   * @example\n   * ```typescript\n   * // Get comprehensive system metrics\n   * const metrics = await daaTools.daa_performance_metrics({\n   *   category: 'all',\n   *   timeRange: '24h'\n   * });\n   * \n   * console.log(`Success rate: ${metrics.performance_metrics.task_success_rate}`);\n   * console.log(`Token reduction: ${metrics.efficiency_metrics.token_reduction}`);\n   * \n   * // Get neural-specific performance data\n   * const neuralMetrics = await daaTools.daa_performance_metrics({\n   *   category: 'neural',\n   *   timeRange: '1h'\n   * });\n   * ```\n   * \n   * @throws {Error} When performance metrics retrieval fails\n   */\n  async daa_performance_metrics(params) {\n    const startTime = performance.now();\n    try {\n      await this.ensureInitialized();\n\n      const { category = 'all', timeRange = '1h' } = params;\n\n      const metrics = await daaService.getPerformanceMetrics(\n        category === 'all' ? undefined : category\n      );\n\n      const result = {\n        metrics_category: category,\n        time_range: timeRange,\n        system_metrics: {\n          total_agents: metrics.totalAgents,\n          active_agents: metrics.activeAgents,\n          autonomous_tasks_completed: metrics.tasksCompleted,\n          average_task_time_ms: metrics.avgTaskTime,\n          learning_cycles_completed: metrics.learningCycles,\n        },\n        performance_metrics: {\n          task_success_rate: metrics.successRate,\n          adaptation_effectiveness: metrics.adaptationScore,\n          knowledge_sharing_events: metrics.knowledgeSharingCount,\n          cross_domain_transfers: metrics.crossDomainTransfers,\n        },\n        efficiency_metrics: {\n          token_reduction: metrics.tokenReduction,\n          parallel_execution_gain: metrics.parallelGain,\n          memory_optimization: metrics.memoryOptimization,\n        },\n        neural_metrics: {\n          models_active: metrics.neuralModelsActive,\n          inference_speed_ms: metrics.avgInferenceTime,\n          training_iterations: metrics.totalTrainingIterations,\n        },\n        timestamp: new Date().toISOString(),\n      };\n\n      if (this.mcpTools?.recordToolMetrics) {\n        this.mcpTools.recordToolMetrics('daa_performance_metrics', startTime, 'success');\n      }\n      return result;\n    } catch (error) {\n      if (this.mcpTools?.recordToolMetrics) {\n        this.mcpTools.recordToolMetrics(\n          'daa_performance_metrics',\n          startTime,\n          'error',\n          error.message\n        );\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Retrieves comprehensive tool definitions for all DAA MCP tools.\n   * \n   * This method provides complete MCP tool definitions for all Decentralized Autonomous\n   * Agents tools, including parameter schemas, validation rules, and tool descriptions.\n   * Used by the stdio MCP server for tool registration and validation.\n   * \n   * ## Tool Definitions Include\n   * \n   * - **Tool Names**: Unique identifiers for each DAA tool\n   * - **Descriptions**: Clear explanations of tool functionality\n   * - **Input Schemas**: JSON Schema definitions for parameter validation\n   * - **Required Parameters**: Mandatory parameters for each tool\n   * - **Optional Parameters**: Additional configuration options\n   * - **Parameter Types**: Type definitions and constraints\n   * \n   * ## Tool Categories Defined\n   * \n   * 1. **System Tools**: `daa_init` - System initialization\n   * 2. **Agent Tools**: `daa_agent_create`, `daa_agent_adapt`, `daa_cognitive_pattern`\n   * 3. **Workflow Tools**: `daa_workflow_create`, `daa_workflow_execute`\n   * 4. **Knowledge Tools**: `daa_knowledge_share`, `daa_learning_status`, `daa_meta_learning`\n   * 5. **Monitoring Tools**: `daa_performance_metrics`\n   * \n   * @returns Array of complete MCP tool definitions with schemas\n   * @returns result[].name - Tool name for MCP registration\n   * @returns result[].description - Tool functionality description\n   * @returns result[].inputSchema - JSON Schema for parameter validation\n   * @returns result[].inputSchema.type - Schema type (typically 'object')\n   * @returns result[].inputSchema.properties - Parameter definitions\n   * @returns result[].inputSchema.required - Array of required parameter names\n   * \n   * @example\n   * ```typescript\n   * const daaTools = new DAA_MCPTools();\n   * const definitions = daaTools.getToolDefinitions();\n   * \n   * console.log(`DAA tools available: ${definitions.length}`);\n   * definitions.forEach(tool => {\n   *   console.log(`- ${tool.name}: ${tool.description}`);\n   * });\n   * \n   * // Use definitions for MCP server registration\n   * mcpServer.registerTools(definitions);\n   * ```\n   */\n  getToolDefinitions() {\n    return [\n      {\n        name: 'daa_init',\n        description: 'Initialize DAA (Decentralized Autonomous Agents) service',\n        inputSchema: {\n          type: 'object',\n          properties: {\n            enableLearning: { type: 'boolean', description: 'Enable autonomous learning' },\n            enableCoordination: { type: 'boolean', description: 'Enable peer coordination' },\n            persistenceMode: {\n              type: 'string',\n              enum: ['auto', 'memory', 'disk'],\n              description: 'Persistence mode',\n            },\n          },\n        },\n      },\n      {\n        name: 'daa_agent_create',\n        description: 'Create an autonomous agent with DAA capabilities',\n        inputSchema: {\n          type: 'object',\n          properties: {\n            id: { type: 'string', description: 'Unique agent identifier' },\n            capabilities: {\n              type: 'array',\n              items: { type: 'string' },\n              description: 'Agent capabilities',\n            },\n            cognitivePattern: {\n              type: 'string',\n              enum: ['convergent', 'divergent', 'lateral', 'systems', 'critical', 'adaptive'],\n              description: 'Cognitive thinking pattern',\n            },\n            learningRate: { type: 'number', description: 'Learning rate (0-1)' },\n            enableMemory: { type: 'boolean', description: 'Enable persistent memory' },\n          },\n          required: ['id'],\n        },\n      },\n      {\n        name: 'daa_agent_adapt',\n        description: 'Trigger agent adaptation based on feedback',\n        inputSchema: {\n          type: 'object',\n          properties: {\n            agent_id: { type: 'string', description: 'Agent ID to adapt' },\n            agentId: { type: 'string', description: 'Agent ID to adapt (legacy)' },\n            feedback: { type: 'string', description: 'Feedback message' },\n            performanceScore: { type: 'number', description: 'Performance score (0-1)' },\n            suggestions: {\n              type: 'array',\n              items: { type: 'string' },\n              description: 'Improvement suggestions',\n            },\n          },\n          required: ['agent_id'],\n        },\n      },\n      {\n        name: 'daa_workflow_create',\n        description: 'Create an autonomous workflow with DAA coordination',\n        inputSchema: {\n          type: 'object',\n          properties: {\n            id: { type: 'string', description: 'Workflow ID' },\n            name: { type: 'string', description: 'Workflow name' },\n            steps: { type: 'array', description: 'Workflow steps' },\n            dependencies: { type: 'object', description: 'Step dependencies' },\n            strategy: {\n              type: 'string',\n              enum: ['parallel', 'sequential', 'adaptive'],\n              description: 'Execution strategy',\n            },\n          },\n          required: ['id', 'name'],\n        },\n      },\n      {\n        name: 'daa_workflow_execute',\n        description: 'Execute a DAA workflow with autonomous agents',\n        inputSchema: {\n          type: 'object',\n          properties: {\n            workflow_id: { type: 'string', description: 'Workflow ID to execute' },\n            workflowId: { type: 'string', description: 'Workflow ID to execute (legacy)' },\n            agentIds: { type: 'array', items: { type: 'string' }, description: 'Agent IDs to use' },\n            parallelExecution: { type: 'boolean', description: 'Enable parallel execution' },\n          },\n          required: ['workflow_id'],\n        },\n      },\n      {\n        name: 'daa_knowledge_share',\n        description: 'Share knowledge between autonomous agents',\n        inputSchema: {\n          type: 'object',\n          properties: {\n            source_agent: { type: 'string', description: 'Source agent ID' },\n            sourceAgentId: { type: 'string', description: 'Source agent ID (legacy)' },\n            target_agents: {\n              type: 'array',\n              items: { type: 'string' },\n              description: 'Target agent IDs',\n            },\n            targetAgentIds: {\n              type: 'array',\n              items: { type: 'string' },\n              description: 'Target agent IDs (legacy)',\n            },\n            knowledgeDomain: { type: 'string', description: 'Knowledge domain' },\n            knowledgeContent: { type: 'object', description: 'Knowledge to share' },\n          },\n          required: ['source_agent', 'target_agents'],\n        },\n      },\n      {\n        name: 'daa_learning_status',\n        description: 'Get learning progress and status for DAA agents',\n        inputSchema: {\n          type: 'object',\n          properties: {\n            agentId: { type: 'string', description: 'Specific agent ID (optional)' },\n            detailed: { type: 'boolean', description: 'Include detailed metrics' },\n          },\n        },\n      },\n      {\n        name: 'daa_cognitive_pattern',\n        description: 'Analyze or change cognitive patterns for agents',\n        inputSchema: {\n          type: 'object',\n          properties: {\n            agent_id: { type: 'string', description: 'Agent ID' },\n            agentId: { type: 'string', description: 'Agent ID (legacy)' },\n            action: {\n              type: 'string',\n              enum: ['analyze', 'change'],\n              description: 'Action to perform',\n            },\n            pattern: {\n              type: 'string',\n              enum: ['convergent', 'divergent', 'lateral', 'systems', 'critical', 'adaptive'],\n              description: 'New pattern to set',\n            },\n            analyze: { type: 'boolean', description: 'Analyze patterns instead of changing' },\n          },\n        },\n      },\n      {\n        name: 'daa_meta_learning',\n        description: 'Enable meta-learning capabilities across domains',\n        inputSchema: {\n          type: 'object',\n          properties: {\n            sourceDomain: { type: 'string', description: 'Source knowledge domain' },\n            targetDomain: { type: 'string', description: 'Target knowledge domain' },\n            transferMode: {\n              type: 'string',\n              enum: ['adaptive', 'direct', 'gradual'],\n              description: 'Transfer mode',\n            },\n            agentIds: {\n              type: 'array',\n              items: { type: 'string' },\n              description: 'Specific agents to update',\n            },\n          },\n        },\n      },\n      {\n        name: 'daa_performance_metrics',\n        description: 'Get comprehensive DAA performance metrics',\n        inputSchema: {\n          type: 'object',\n          properties: {\n            category: {\n              type: 'string',\n              enum: ['all', 'system', 'performance', 'efficiency', 'neural'],\n              description: 'Metrics category',\n            },\n            timeRange: { type: 'string', description: 'Time range (e.g., 1h, 24h, 7d)' },\n          },\n        },\n      },\n    ];\n  }\n}\n\n// Export singleton instance\nexport const daaMcpTools = new DAA_MCPTools(null);\n", "/**\n * @file Coordination system: base-swarm.\n */\n\nimport { getLogger } from '../../../config/logging-config.ts';\n\nconst logger = getLogger('coordination-swarm-core-base-swarm');\n\n/**\n * Base ZenSwarm Class - Core implementation without circular dependencies.\n *\n * This file contains the core ZenSwarm implementation to avoid circular.\n * Dependencies with session-integration.ts.\n */\n\nimport { EventEmitter } from 'node:events';\n// import { DALFactory } from '../database'; // TODO: Implement proper DI integration\nimport { WasmModuleLoader } from '../../../wasm-loader.cjs';\nimport { AgentPool, type BaseAgent } from '../../agents/agent.ts';\nimport { getContainer } from './singleton-container.ts';\nimport type { SwarmEventEmitter, SwarmLifecycleState, SwarmOptions } from './types.ts';\nimport { generateId, validateSwarmOptions } from './utils.ts';\n\n// Extended options for internal use\ninterface ExtendedSwarmOptions extends SwarmOptions {\n  persistence: {\n    enabled: boolean;\n    dbPath: string;\n    checkpointInterval: number;\n    compressionEnabled: boolean;\n  };\n  pooling: {\n    enabled: boolean;\n    maxPoolSize: number;\n    minPoolSize: number;\n    idleTimeout: number;\n  };\n}\n\n/**\n * Core ZenSwarm implementation with all base functionality.\n *\n * @example\n */\nexport class ZenSwarm extends EventEmitter implements SwarmEventEmitter {\n  private swarmId: string;\n  private agents: Map<string, BaseAgent> = new Map();\n  private state: SwarmLifecycleState = 'initializing';\n  private agentPool: AgentPool | null;\n  private wasmLoader: WasmModuleLoader;\n  protected options: ExtendedSwarmOptions;\n\n  // Properties referenced in the class methods\n  protected isRunning: boolean = false;\n  protected coordinationDao?: any; // SessionCoordinationDao when persistence is enabled\n  protected neuralProcessor?: any; // WASM neural processor when available\n  protected metrics: {\n    tasksCreated: number;\n    tasksCompleted: number;\n    tasksFailed: number;\n    messagesProcessed: number;\n    cognitiveLoad: number;\n    averageResponseTime: number;\n    neuralNetworkAccuracy: number;\n    swarmEfficiency: number;\n    timestamp: number;\n  };\n\n  constructor(options: SwarmOptions = {}) {\n    super();\n\n    // Validate options and merge with defaults\n    const errors = validateSwarmOptions(options);\n    if (errors.length > 0) {\n      throw new Error(`Invalid swarm options: ${errors.join(', ')}`);\n    }\n\n    this.options = {\n      topology: 'mesh',\n      maxAgents: 10,\n      connectionDensity: 0.5,\n      syncInterval: 5000,\n      wasmPath: './neural_fann_bg.wasm',\n      ...options,\n      persistence: {\n        enabled: false,\n        dbPath: './swarm-state.db',\n        checkpointInterval: 30000,\n        compressionEnabled: true,\n      },\n      pooling: {\n        enabled: false,\n        maxPoolSize: 10,\n        minPoolSize: 2,\n        idleTimeout: 300000,\n      },\n    } as ExtendedSwarmOptions;\n\n    this.swarmId = generateId('swarm');\n    this.wasmLoader =\n      getContainer().get<WasmModuleLoader>('WasmModuleLoader') || new WasmModuleLoader();\n    this.isRunning = false;\n    this.agentPool = null;\n\n    this.metrics = {\n      tasksCreated: 0,\n      tasksCompleted: 0,\n      tasksFailed: 0,\n      messagesProcessed: 0,\n      cognitiveLoad: 0,\n      averageResponseTime: 0,\n      neuralNetworkAccuracy: 0,\n      swarmEfficiency: 0,\n      timestamp: Date.now(),\n    };\n  }\n\n  // All the ZenSwarm methods would go here...\n  // (Moving the entire class implementation from index.ts)\n\n  async initialize(): Promise<void> {\n    this.emit('swarm:initializing', { swarmId: this.swarmId });\n\n    // Initialize persistence if enabled\n    if (this.options.persistence.enabled) {\n      // Create a simple mock implementation for now\n      // TODO: Implement proper DALFactory integration with DI\n      this.coordinationDao = {\n        query: async (_sql: string, _params?: any[]) => [],\n        execute: async (_sql: string, _params?: any[]) => ({ affectedRows: 1 }),\n      } as any;\n    }\n\n    // Initialize WASM neural processor\n    try {\n      await this.wasmLoader.loadModule();\n      this.neuralProcessor = this.wasmLoader;\n    } catch (error) {\n      logger.warn('Failed to load WASM module, falling back to JS implementation:', error);\n    }\n\n    // Initialize agent pool\n    if (this.options.pooling?.enabled) {\n      this.agentPool = new AgentPool();\n    } else {\n      this.agentPool = null;\n    }\n\n    this.state = 'active';\n    this.emit('swarm:initialized', { swarmId: this.swarmId });\n  }\n\n  getSwarmId(): string {\n    return this.swarmId;\n  }\n\n  getState(): SwarmLifecycleState {\n    return this.state;\n  }\n\n  async shutdown(): Promise<void> {\n    this.isRunning = false;\n    this.state = 'terminated';\n\n    // Clean up agents\n    for (const agent of this.agents.values()) {\n      await agent.shutdown();\n    }\n    this.agents.clear();\n\n    // Clean up coordination DAO - no explicit close needed for factory-managed DAOs\n\n    // Clean up agent pool\n    if (this.agentPool) {\n      // AgentPool doesn't have a shutdown method yet\n      this.agentPool = null;\n    }\n\n    this.emit('swarm:shutdown', { swarmId: this.swarmId });\n  }\n\n  // Type guard to satisfy TypeScript's event typing\n  override emit(eventName: string | symbol, ...args: any[]): boolean {\n    return super.emit(eventName, ...args);\n  }\n}\n\nexport default ZenSwarm;\n", "/**\n * Custom Error Classes for RUV-Swarm MCP Tools.\n * Provides detailed, actionable error messages with context.\n */\n\n/**\n * Base error class for all ruv-swarm MCP errors.\n *\n * @example\n */\n/**\n * @file Coordination system: errors.\n */\n\nclass ZenSwarmError extends Error {\n  public code: string;\n  public details: any;\n  public timestamp: string;\n\n  constructor(message: string, code = 'GENERAL_ERROR', details = {}) {\n    super(message);\n    this.name = this.constructor.name;\n    this.code = code;\n    this.details = details;\n    this.timestamp = new Date().toISOString();\n    this.stack = this.stack || new Error().stack || '';\n  }\n\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      code: this.code,\n      details: this.details,\n      timestamp: this.timestamp,\n      stack: this.stack,\n    };\n  }\n\n  /**\n   * Get actionable suggestions for resolving this error.\n   */\n  getSuggestions() {\n    return [\n      'Check the error details for specific information',\n      'Verify your input parameters',\n      'Consult the MCP tools documentation',\n    ];\n  }\n}\n\n/**\n * Validation errors for input parameters.\n *\n * @example\n */\nclass ValidationError extends ZenSwarmError {\n  public field: string | null;\n  public value: any;\n  public expectedType: string | null;\n\n  constructor(\n    message: string,\n    field: string | null = null,\n    value: any = null,\n    expectedType: string | null = null\n  ) {\n    const details = {\n      field,\n      value: typeof value === 'object' ? JSON.stringify(value) : value,\n      expectedType,\n      actualType: typeof value,\n    };\n\n    super(message, 'VALIDATION_ERROR', details);\n    this.field = field;\n    this.value = value;\n    this.expectedType = expectedType;\n  }\n\n  override getSuggestions() {\n    const suggestions = [\n      `Check the '${this.field}' parameter`,\n      `Expected type: ${this.expectedType}, got: ${this.details.actualType}`,\n    ];\n\n    if (this.expectedType === 'number') {\n      suggestions.push('Ensure the value is a valid number');\n      suggestions.push('Check for NaN or Infinity values');\n    } else if (this.expectedType === 'string') {\n      suggestions.push('Ensure the value is a non-empty string');\n      suggestions.push('Check for null or undefined values');\n    } else if (this.expectedType === 'array') {\n      suggestions.push('Ensure the value is a valid array');\n      suggestions.push('Check array elements for correct types');\n    } else if (this.expectedType === 'object') {\n      suggestions.push('Ensure the value is a valid object');\n      suggestions.push('Check for required object properties');\n    }\n\n    return suggestions;\n  }\n}\n\n/**\n * Swarm-related errors.\n *\n * @example\n */\nclass SwarmError extends ZenSwarmError {\n  public swarmId: string | null;\n  public operation: string | null;\n\n  constructor(message: string, swarmId: string | null = null, operation: string | null = null) {\n    const details = { swarmId, operation };\n    super(message, 'SWARM_ERROR', details);\n    this.swarmId = swarmId;\n    this.operation = operation;\n  }\n\n  override getSuggestions() {\n    const suggestions: string[] = [];\n\n    if (this.message.includes('not found')) {\n      suggestions.push('Verify the swarm ID is correct');\n      suggestions.push('Check if the swarm was properly initialized');\n      suggestions.push('Use swarm_status to list available swarms');\n    } else if (this.message.includes('capacity') || this.message.includes('full')) {\n      suggestions.push('Increase the swarm maxAgents parameter');\n      suggestions.push('Remove idle agents before adding new ones');\n      suggestions.push('Consider using multiple swarms for load distribution');\n    } else if (this.message.includes('initialization')) {\n      suggestions.push('Call swarm_init before other swarm operations');\n      suggestions.push('Check WASM module loading status');\n      suggestions.push('Verify system resources are available');\n    }\n\n    suggestions.push('Check swarm logs for additional details');\n    return suggestions;\n  }\n}\n\n/**\n * Agent-related errors.\n *\n * @example\n */\nclass AgentError extends ZenSwarmError {\n  agentId: string | null;\n  agentType: string | null;\n  operation: string | null;\n\n  constructor(\n    message: string,\n    agentId: string | null = null,\n    agentType: string | null = null,\n    operation: string | null = null\n  ) {\n    const details = { agentId, agentType, operation };\n    super(message, 'AGENT_ERROR', details);\n    this.agentId = agentId;\n    this.agentType = agentType;\n    this.operation = operation;\n  }\n\n  override getSuggestions() {\n    const suggestions: string[] = [];\n\n    if (this.message.includes('not found')) {\n      suggestions.push('Verify the agent ID is correct');\n      suggestions.push('Check if the agent was properly spawned');\n      suggestions.push('Use agent_list to see available agents');\n    } else if (this.message.includes('busy') || this.message.includes('unavailable')) {\n      suggestions.push('Wait for the agent to complete current tasks');\n      suggestions.push('Spawn additional agents for parallel processing');\n      suggestions.push('Check agent status before assignment');\n    } else if (this.message.includes('capabilities')) {\n      suggestions.push('Verify agent has required capabilities');\n      suggestions.push('Spawn an agent with appropriate type');\n      suggestions.push('Check capability matching logic');\n    } else if (this.message.includes('neural')) {\n      suggestions.push('Ensure neural networks are enabled');\n      suggestions.push('Verify WASM neural module is loaded');\n      suggestions.push('Check neural network configuration');\n    }\n\n    suggestions.push('Review agent configuration and requirements');\n    return suggestions;\n  }\n}\n\n/**\n * Task-related errors.\n *\n * @example\n */\nclass TaskError extends ZenSwarmError {\n  public taskId: string | null;\n  public taskType: string | null;\n  public operation: string | null;\n\n  constructor(\n    message: string,\n    taskId: string | null = null,\n    taskType: string | null = null,\n    operation: string | null = null\n  ) {\n    const details = { taskId, taskType, operation };\n    super(message, 'TASK_ERROR', details);\n    this.taskId = taskId;\n    this.taskType = taskType;\n    this.operation = operation;\n  }\n\n  override getSuggestions() {\n    const suggestions: string[] = [];\n\n    if (this.message.includes('not found')) {\n      suggestions.push('Verify the task ID is correct');\n      suggestions.push('Check if the task was properly created');\n      suggestions.push('Use task_status to list available tasks');\n    } else if (this.message.includes('timeout')) {\n      suggestions.push('Increase task timeout duration');\n      suggestions.push('Break the task into smaller sub-tasks');\n      suggestions.push('Optimize task execution logic');\n    } else if (this.message.includes('dependency')) {\n      suggestions.push('Check task dependency requirements');\n      suggestions.push('Ensure prerequisite tasks are completed');\n      suggestions.push('Review task execution order');\n    } else if (this.message.includes('resources')) {\n      suggestions.push('Check system resource availability');\n      suggestions.push('Reduce task complexity or requirements');\n      suggestions.push('Scale up available agents');\n    }\n\n    suggestions.push('Review task configuration and execution logs');\n    return suggestions;\n  }\n}\n\n/**\n * Neural network related errors.\n *\n * @example\n */\nclass NeuralError extends ZenSwarmError {\n  public networkId: string | null;\n  public operation: string | null;\n  public modelType: string | null;\n\n  constructor(\n    message: string,\n    networkId: string | null = null,\n    operation: string | null = null,\n    modelType: string | null = null\n  ) {\n    const details = { networkId, operation, modelType };\n    super(message, 'NEURAL_ERROR', details);\n    this.networkId = networkId;\n    this.operation = operation;\n    this.modelType = modelType;\n  }\n\n  override getSuggestions() {\n    const suggestions: string[] = [];\n\n    if (this.message.includes('not available') || this.message.includes('not loaded')) {\n      suggestions.push('Ensure neural network features are enabled');\n      suggestions.push('Check WASM neural module loading');\n      suggestions.push('Verify system supports neural operations');\n    } else if (this.message.includes('training')) {\n      suggestions.push('Check training data format and quality');\n      suggestions.push('Adjust learning rate and iterations');\n      suggestions.push('Verify neural network architecture');\n    } else if (this.message.includes('memory')) {\n      suggestions.push('Reduce neural network size or complexity');\n      suggestions.push('Increase available system memory');\n      suggestions.push('Use memory-efficient training algorithms');\n    } else if (this.message.includes('convergence')) {\n      suggestions.push('Increase training iterations');\n      suggestions.push('Adjust learning rate');\n      suggestions.push('Improve training data quality');\n    }\n\n    suggestions.push('Check neural network configuration and logs');\n    return suggestions;\n  }\n}\n\n/**\n * WASM-related errors.\n *\n * @example\n */\nclass WasmError extends ZenSwarmError {\n  public module: string | null;\n  public operation: string | null;\n\n  constructor(message: string, module: string | null = null, operation: string | null = null) {\n    const details = { module, operation };\n    super(message, 'WASM_ERROR', details);\n    this.module = module;\n    this.operation = operation;\n  }\n\n  override getSuggestions() {\n    const suggestions: string[] = [];\n\n    if (this.message.includes('not loaded') || this.message.includes('not found')) {\n      suggestions.push('Check WASM module availability');\n      suggestions.push('Verify module loading sequence');\n      suggestions.push('Ensure WASM runtime is supported');\n    } else if (this.message.includes('memory')) {\n      suggestions.push('Increase WASM memory allocation');\n      suggestions.push('Optimize memory usage in operations');\n      suggestions.push('Check for memory leaks');\n    } else if (this.message.includes('compilation')) {\n      suggestions.push('Verify WASM module integrity');\n      suggestions.push('Check browser/runtime WASM support');\n      suggestions.push('Rebuild WASM modules if corrupted');\n    } else if (this.message.includes('function')) {\n      suggestions.push('Verify exported function names');\n      suggestions.push('Check function parameter types');\n      suggestions.push('Ensure WASM module is properly linked');\n    }\n\n    suggestions.push('Check WASM module logs and browser console');\n    return suggestions;\n  }\n}\n\n/**\n * Configuration errors.\n *\n * @example\n */\nclass ConfigurationError extends ZenSwarmError {\n  public configKey: string | null;\n  public configValue: any;\n\n  constructor(message: string, configKey: string | null = null, configValue: any = null) {\n    const details = { configKey, configValue };\n    super(message, 'CONFIGURATION_ERROR', details);\n    this.configKey = configKey;\n    this.configValue = configValue;\n  }\n\n  override getSuggestions() {\n    return [\n      `Check the '${this.configKey}' configuration`,\n      'Review configuration documentation',\n      'Verify configuration file format',\n      'Ensure all required configuration keys are present',\n      'Check configuration value types and ranges',\n    ];\n  }\n}\n\n/**\n * Network/connectivity errors.\n *\n * @example\n */\nclass NetworkError extends ZenSwarmError {\n  public endpoint: string | null;\n  public statusCode: number | null;\n\n  constructor(message: string, endpoint: string | null = null, statusCode: number | null = null) {\n    const details = { endpoint, statusCode };\n    super(message, 'NETWORK_ERROR', details);\n    this.endpoint = endpoint;\n    this.statusCode = statusCode;\n  }\n\n  override getSuggestions() {\n    const suggestions: string[] = [];\n\n    if (this.statusCode === 404) {\n      suggestions.push('Verify the endpoint URL is correct');\n      suggestions.push('Check if the service is running');\n    } else if (this.statusCode === 401 || this.statusCode === 403) {\n      suggestions.push('Check authentication credentials');\n      suggestions.push('Verify API permissions');\n    } else if (this.statusCode === 500) {\n      suggestions.push('Check server logs for errors');\n      suggestions.push('Retry the operation after a delay');\n    } else if (this.statusCode === 408 || this.message.includes('timeout')) {\n      suggestions.push('Increase request timeout');\n      suggestions.push('Check network connectivity');\n    }\n\n    suggestions.push('Check network connectivity and firewall settings');\n    suggestions.push('Verify service endpoint availability');\n    return suggestions;\n  }\n}\n\n/**\n * Database/persistence errors.\n *\n * @example\n */\nclass PersistenceError extends ZenSwarmError {\n  public operation: string | null;\n  public table: string | null;\n\n  constructor(message: string, operation: string | null = null, table: string | null = null) {\n    const details = { operation, table };\n    super(message, 'PERSISTENCE_ERROR', details);\n    this.operation = operation;\n    this.table = table;\n  }\n\n  override getSuggestions() {\n    const suggestions: string[] = [];\n\n    if (this.message.includes('constraint') || this.message.includes('unique')) {\n      suggestions.push('Check for duplicate entries');\n      suggestions.push('Verify unique key constraints');\n      suggestions.push('Use update instead of insert for existing records');\n    } else if (this.message.includes('not found') || this.message.includes('no such table')) {\n      suggestions.push('Verify database schema is initialized');\n      suggestions.push('Run database migrations');\n      suggestions.push('Check table name spelling');\n    } else if (this.message.includes('locked') || this.message.includes('busy')) {\n      suggestions.push('Retry the operation after a delay');\n      suggestions.push('Check for long-running transactions');\n      suggestions.push('Optimize database queries');\n    }\n\n    suggestions.push('Check database connectivity and permissions');\n    suggestions.push('Review database logs for additional details');\n    return suggestions;\n  }\n}\n\n/**\n * Resource/memory errors.\n *\n * @example\n */\nclass ResourceError extends ZenSwarmError {\n  public resourceType: string | null;\n  public currentUsage: number | null;\n  public limit: number | null;\n\n  constructor(\n    message: string,\n    resourceType: string | null = null,\n    currentUsage: number | null = null,\n    limit: number | null = null\n  ) {\n    const details = { resourceType, currentUsage, limit };\n    super(message, 'RESOURCE_ERROR', details);\n    this.resourceType = resourceType;\n    this.currentUsage = currentUsage;\n    this.limit = limit;\n  }\n\n  override getSuggestions() {\n    const suggestions: string[] = [];\n\n    if (this.resourceType === 'memory') {\n      suggestions.push('Reduce memory usage in operations');\n      suggestions.push('Implement memory cleanup procedures');\n      suggestions.push('Use streaming for large data sets');\n      suggestions.push('Optimize data structures');\n    } else if (this.resourceType === 'cpu') {\n      suggestions.push('Reduce computational complexity');\n      suggestions.push('Use async operations to prevent blocking');\n      suggestions.push('Implement caching for expensive operations');\n    } else if (this.resourceType === 'storage') {\n      suggestions.push('Clean up temporary files');\n      suggestions.push('Implement data compression');\n      suggestions.push('Archive old data');\n    }\n\n    suggestions.push('Monitor resource usage trends');\n    suggestions.push('Consider scaling up available resources');\n    return suggestions;\n  }\n}\n\n/**\n * Concurrency/threading errors.\n *\n * @example\n */\nclass ConcurrencyError extends ZenSwarmError {\n  operation: string | null;\n  conflictType: string | null;\n\n  constructor(\n    message: string,\n    operation: string | null = null,\n    conflictType: string | null = null\n  ) {\n    const details = { operation, conflictType };\n    super(message, 'CONCURRENCY_ERROR', details);\n    this.operation = operation;\n    this.conflictType = conflictType;\n  }\n\n  override getSuggestions() {\n    return [\n      'Implement proper locking mechanisms',\n      'Use atomic operations where possible',\n      'Retry the operation with exponential backoff',\n      'Check for race conditions in the code',\n      'Consider using queues for serializing operations',\n      'Review concurrent access patterns',\n    ];\n  }\n}\n\n/**\n * Error factory for creating appropriate error types.\n *\n * @example\n */\nclass ErrorFactory {\n  /**\n   * Create an appropriate error based on the context.\n   *\n   * @param type\n   * @param message\n   * @param details\n   */\n  static createError(type: string, message: string, details: any = {}) {\n    switch (type) {\n      case 'validation':\n        return new ValidationError(message, details.field, details.value, details.expectedType);\n      case 'swarm':\n        return new SwarmError(message, details.swarmId, details.operation);\n      case 'agent':\n        return new AgentError(message, details.agentId, details.agentType, details.operation);\n      case 'task':\n        return new TaskError(message, details.taskId, details.taskType, details.operation);\n      case 'neural':\n        return new NeuralError(message, details.networkId, details.operation, details.modelType);\n      case 'wasm':\n        return new WasmError(message, details.module, details.operation);\n      case 'configuration':\n        return new ConfigurationError(message, details.configKey, details.configValue);\n      case 'network':\n        return new NetworkError(message, details.endpoint, details.statusCode);\n      case 'persistence':\n        return new PersistenceError(message, details.operation, details.table);\n      case 'resource':\n        return new ResourceError(\n          message,\n          details.resourceType,\n          details.currentUsage,\n          details.limit\n        );\n      case 'concurrency':\n        return new ConcurrencyError(message, details.operation, details.conflictType);\n      default:\n        return new ZenSwarmError(message, 'GENERAL_ERROR', details);\n    }\n  }\n\n  /**\n   * Wrap an existing error with additional context.\n   *\n   * @param originalError\n   * @param type\n   * @param additionalContext\n   */\n  static wrapError(originalError: Error, type: string, additionalContext: any = {}) {\n    const message = `${type.toUpperCase()}: ${originalError.message}`;\n    const details = {\n      ...additionalContext,\n      originalError: {\n        name: originalError.name,\n        message: originalError.message,\n        stack: originalError.stack,\n      },\n    };\n\n    return ErrorFactory.createError(type, message, details);\n  }\n}\n\n/**\n * Error context for logging and debugging.\n *\n * @example\n */\nclass ErrorContext {\n  public context: Map<string, any>;\n\n  constructor() {\n    this.context = new Map();\n  }\n\n  set(key: string, value: any) {\n    this.context.set(key, value);\n  }\n\n  get(key: string) {\n    return this.context.get(key);\n  }\n\n  clear() {\n    this.context.clear();\n  }\n\n  toObject() {\n    return Object.fromEntries(this.context);\n  }\n\n  /**\n   * Add context to an error.\n   *\n   * @param error\n   */\n  enrichError(error: any) {\n    if (error instanceof ZenSwarmError) {\n      error.details = {\n        ...error.details,\n        context: this.toObject(),\n      };\n    }\n    return error;\n  }\n}\n\n// Export all error classes and utilities\nexport {\n  ZenSwarmError,\n  ValidationError,\n  SwarmError,\n  AgentError,\n  TaskError,\n  NeuralError,\n  WasmError,\n  ConfigurationError,\n  NetworkError,\n  PersistenceError,\n  ResourceError,\n  ConcurrencyError,\n  ErrorFactory,\n  ErrorContext,\n};\n\n// Export default error factory\nexport default ErrorFactory;\n", "/**\n * @file Claude Code Hooks Implementation for ruv-swarm - provides automated coordination, formatting, and learning capabilities.\n */\n\nimport { getLogger } from '../../../../config/logging-config.ts';\n\nconst logger = getLogger('coordination-swarm-core-hooks-index');\n\nimport { execSync } from 'node:child_process';\nimport { promises as fs } from 'node:fs';\nimport path from 'node:path';\n// fileURLToPath is provided by esbuild banner\n\nimport type { AgentMemoryCoordinationDao } from '../../../../database';\n\n// import { DALFactory } from '../../database'; // TODO: Implement proper DI integration\n\ntype SwarmPersistence = AgentMemoryCoordinationDao;\n\n// __filename is provided by esbuild banner\n\nclass ZenSwarmHooks {\n  public sessionData: any;\n  public persistence: SwarmPersistence | null;\n  private _sessionId?: string;\n\n  constructor() {\n    this.sessionData = {\n      startTime: Date.now(),\n      operations: [],\n      agents: new Map(),\n      learnings: [],\n      metrics: {\n        tokensSaved: 0,\n        tasksCompleted: 0,\n        patternsImproved: 0,\n      },\n    };\n\n    // Initialize persistence layer for cross-agent memory\n    this.persistence = null;\n    this.initializePersistence();\n  }\n\n  /**\n   * Initialize persistence layer with error handling.\n   */\n  async initializePersistence() {\n    try {\n      // Create a simple mock implementation for now\n      // TODO: Implement proper DALFactory integration with DI\n      this.persistence = {\n        query: async (_sql: string, _params?: any[]) => [],\n        execute: async (_sql: string, _params?: any[]) => ({ affectedRows: 1 }),\n      } as any;\n    } catch (error) {\n      logger.warn('\u26A0\uFE0F Failed to initialize persistence layer:', (error as Error).message);\n      logger.warn('\u26A0\uFE0F Operating in memory-only mode');\n      this.persistence = null;\n    }\n  }\n\n  /**\n   * Main hook handler - routes to specific hook implementations.\n   *\n   * @param hookType\n   * @param args\n   */\n  async handleHook(hookType: string, args: any[]) {\n    try {\n      switch (hookType) {\n        // Pre-operation hooks\n        case 'pre-edit':\n          return await this.preEditHook(args);\n        case 'pre-bash':\n          return await this.preBashHook(args);\n        case 'pre-task':\n          return await this.preTaskHook(args);\n        case 'pre-search':\n          return await this.preSearchHook(args);\n        case 'pre-mcp':\n          return await this.preMcpHook(args);\n\n        // Post-operation hooks\n        case 'post-edit':\n          return await this.postEditHook(args);\n        case 'post-bash':\n          return await this.postTaskHook(args);\n        case 'post-task':\n          return await this.postTaskHook(args);\n        case 'post-search':\n          return await this.postWebSearchHook(args);\n        case 'post-web-search':\n          return await this.postWebSearchHook(args);\n        case 'post-web-fetch':\n          return await this.postWebFetchHook(args);\n\n        // MCP-specific hooks\n        case 'mcp-swarm-initialized':\n          return await this.mcpSwarmInitializedHook(args);\n        case 'mcp-agent-spawned':\n          return await this.mcpAgentSpawnedHook(args);\n        case 'mcp-task-orchestrated':\n          return await this.mcpTaskOrchestratedHook(args);\n        case 'mcp-neural-trained':\n          return await this.mcpNeuralTrainedHook(args);\n\n        // System hooks\n        case 'notification':\n          return await this.notificationHook(args);\n        case 'session-end':\n          return await this.sessionEndHook(args);\n        case 'session-restore':\n          return await this.sessionRestoreHook(args);\n        case 'agent-complete':\n          return await this.agentCompleteHook(args);\n\n        default:\n          return { continue: true, reason: `Unknown hook type: ${hookType}` };\n      }\n    } catch (error) {\n      logger.error(`Hook error (${hookType}):`, error.message);\n      return {\n        continue: true,\n        error: error.message,\n        fallback: 'Hook error - continuing with default behavior',\n      };\n    }\n  }\n\n  /**\n   * Pre-search hook - Prepare cache and optimize search.\n   *\n   * @param args\n   */\n  async preSearchHook(args: any) {\n    const { pattern } = args;\n\n    // Initialize search cache\n    if (!this.sessionData.searchCache) {\n      this.sessionData.searchCache = new Map();\n    }\n\n    // Check cache for similar patterns\n    const cachedResult = this.sessionData.searchCache.get(pattern);\n    if (cachedResult && Date.now() - cachedResult?.timestamp < 300000) {\n      // 5 min cache\n      return {\n        continue: true,\n        cached: true,\n        cacheHit: cachedResult?.files.length,\n        metadata: { pattern, cached: true },\n      };\n    }\n\n    return {\n      continue: true,\n      reason: 'Search prepared',\n      metadata: { pattern, cacheReady: true },\n    };\n  }\n\n  /**\n   * Pre-MCP hook - Validate MCP tool state.\n   *\n   * @param args\n   */\n  async preMcpHook(args: any) {\n    const { tool, params } = args;\n\n    // Parse params if string\n    const toolParams = typeof params === 'string' ? JSON.parse(params) : params;\n\n    // Validate swarm state for MCP operations\n    if (tool.includes('agent_spawn') || tool.includes('task_orchestrate')) {\n      const swarmStatus = await this.checkSwarmStatus();\n      if (!swarmStatus.initialized) {\n        return {\n          continue: true,\n          warning: 'Swarm not initialized - will be created automatically',\n          autoInit: true,\n        };\n      }\n    }\n\n    // Track MCP operations\n    this.sessionData.operations.push({\n      type: 'mcp',\n      tool,\n      params: toolParams,\n      timestamp: Date.now(),\n    });\n\n    return {\n      continue: true,\n      reason: 'MCP tool validated',\n      metadata: { tool, state: 'ready' },\n    };\n  }\n\n  /**\n   * Pre-edit hook - Ensure coordination before file modifications.\n   *\n   * @param args\n   */\n  async preEditHook(args: any) {\n    const { file } = args;\n\n    // Determine file type and assign appropriate agent\n    const fileExt = path.extname(file);\n    const agentType = this.getAgentTypeForFile(fileExt);\n\n    // Check if swarm is initialized\n    const swarmStatus = await this.checkSwarmStatus();\n    if (!swarmStatus.initialized) {\n      return {\n        continue: false,\n        reason: 'Swarm not initialized - run mcp__zen-swarm__swarm_init first',\n        suggestion: 'Initialize swarm with appropriate topology',\n      };\n    }\n\n    // Ensure appropriate agent exists\n    const agent = await this.ensureAgent(agentType);\n\n    // Record operation\n    this.sessionData.operations.push({\n      type: 'edit',\n      file,\n      agent: agent.id,\n      timestamp: Date.now(),\n    });\n\n    return {\n      continue: true,\n      reason: `${agentType} agent assigned for ${fileExt} file`,\n      metadata: {\n        agent_id: agent.id,\n        agent_type: agentType,\n        cognitive_pattern: agent.pattern,\n        readiness: agent.readiness,\n      },\n    };\n  }\n\n  /**\n   * Pre-task hook - Auto-spawn agents and optimize topology.\n   *\n   * @param args\n   */\n  async preTaskHook(args: any) {\n    const { description, autoSpawnAgents, optimizeTopology } = args;\n\n    // Analyze task complexity\n    const complexity = this.analyzeTaskComplexity(description);\n\n    // Determine optimal topology\n    const topology = optimizeTopology ? this.selectOptimalTopology(complexity) : 'mesh';\n\n    // Auto-spawn required agents\n    if (autoSpawnAgents) {\n      const requiredAgents = this.determineRequiredAgents(description, complexity);\n      for (const agentType of requiredAgents) {\n        await this.ensureAgent(agentType);\n      }\n    }\n\n    return {\n      continue: true,\n      reason: 'Task prepared with optimal configuration',\n      metadata: {\n        complexity,\n        topology,\n        agentsReady: true,\n        estimatedDuration: complexity.estimatedMinutes * 60000,\n      },\n    };\n  }\n\n  /**\n   * Post-edit hook - Format and learn from edits.\n   *\n   * @param args\n   */\n  async postEditHook(args: any) {\n    const { file, autoFormat, trainPatterns, updateGraph } = args;\n    const result: any = {\n      continue: true,\n      formatted: false,\n      training: null,\n    };\n\n    // Auto-format if requested\n    if (autoFormat) {\n      const formatted = await this.autoFormatFile(file);\n      result.formatted = formatted.success;\n      result.formatDetails = formatted.details;\n    }\n\n    // Train neural patterns\n    if (trainPatterns) {\n      const training = await this.trainPatternsFromEdit(file);\n      result.training = training;\n      this.sessionData.metrics.patternsImproved += training.improvement || 0;\n    }\n\n    // Update knowledge graph if requested\n    if (updateGraph) {\n      await this.updateKnowledgeGraph(file, 'edit');\n    }\n\n    // Update session data\n    this.sessionData.metrics.tokensSaved += 10; // Estimated savings\n\n    return result;\n  }\n\n  /**\n   * Post-task hook - Analyze performance and update coordination.\n   *\n   * @param args\n   */\n  async postTaskHook(args: any) {\n    const { taskId, analyzePerformance, updateCoordination } = args;\n\n    const performance: any = {\n      taskId,\n      completionTime: Date.now() - (this.sessionData.taskStartTimes?.get(taskId) || Date.now()),\n      agentsUsed: this.sessionData.taskAgents?.get(taskId) || [],\n      success: true,\n    };\n\n    // Analyze performance\n    if (analyzePerformance) {\n      performance.analysis = {\n        efficiency: this.calculateEfficiency(performance),\n        bottlenecks: this.identifyBottlenecks(performance),\n        improvements: this.suggestImprovements(performance),\n      };\n    }\n\n    // Update coordination strategies\n    if (updateCoordination) {\n      this.updateCoordinationStrategy(performance);\n    }\n\n    this.sessionData.metrics.tasksCompleted++;\n\n    return {\n      continue: true,\n      performance,\n      metadata: { taskId, optimized: true },\n    };\n  }\n\n  /**\n   * Post-web-search hook - Analyze results and update knowledge.\n   *\n   * @param args\n   */\n  async postWebSearchHook(args: any) {\n    const { query, updateKnowledge } = args;\n\n    // Track search patterns\n    if (!this.sessionData.searchPatterns) {\n      this.sessionData.searchPatterns = new Map();\n    }\n\n    const patterns = this.extractSearchPatterns(query);\n    patterns.forEach((pattern) => {\n      const count = this.sessionData.searchPatterns.get(pattern) || 0;\n      this.sessionData.searchPatterns.set(pattern, count + 1);\n    });\n\n    // Update knowledge base\n    if (updateKnowledge) {\n      await this.updateKnowledgeBase('search', { query, patterns });\n    }\n\n    return {\n      continue: true,\n      reason: 'Search analyzed and knowledge updated',\n      metadata: {\n        query,\n        patternsExtracted: patterns.length,\n        knowledgeUpdated: updateKnowledge,\n      },\n    };\n  }\n\n  /**\n   * Post-web-fetch hook - Extract patterns and cache content.\n   *\n   * @param args\n   */\n  async postWebFetchHook(args: any) {\n    const { url, extractPatterns, cacheContent } = args;\n\n    const result: {\n      continue: boolean;\n      patterns: string[];\n      cached: boolean;\n    } = {\n      continue: true,\n      patterns: [],\n      cached: false,\n    };\n\n    // Extract patterns from URL\n    if (extractPatterns) {\n      result.patterns = this.extractUrlPatterns(url);\n    }\n\n    // Cache content for future use\n    if (cacheContent) {\n      if (!this.sessionData.contentCache) {\n        this.sessionData.contentCache = new Map();\n      }\n      this.sessionData.contentCache.set(url, {\n        timestamp: Date.now(),\n        patterns: result?.patterns,\n      });\n      result.cached = true;\n    }\n\n    return result;\n  }\n\n  /**\n   * Notification hook - Handle notifications with swarm status.\n   *\n   * @param args\n   */\n  async notificationHook(args: any) {\n    const { message, level, withSwarmStatus, sendTelemetry, type, context, agentId } = args;\n\n    const notification: any = {\n      message,\n      level: level || 'info',\n      type: type || 'general',\n      context: context || {},\n      agentId: agentId || null,\n      timestamp: Date.now(),\n    };\n\n    // Add swarm status if requested\n    if (withSwarmStatus) {\n      const status = await this.getSwarmStatus();\n      notification.swarmStatus = {\n        agents: status.agents?.size || 0,\n        activeTasks: status.activeTasks || 0,\n        health: status.health || 'unknown',\n      };\n    }\n\n    // Send telemetry if enabled\n    if (sendTelemetry && process.env['RUV_SWARM_TELEMETRY_ENABLED'] === 'true') {\n      this.sendTelemetry('notification', notification);\n    }\n\n    // Store notification in both runtime memory AND persistent database\n    if (!this.sessionData.notifications) {\n      this.sessionData.notifications = [];\n    }\n    this.sessionData.notifications.push(notification);\n\n    // CRITICAL FIX: Also store in persistent database for cross-agent access\n    await this.storeNotificationInDatabase(notification);\n\n    return {\n      continue: true,\n      notification,\n      handled: true,\n    };\n  }\n\n  /**\n   * Pre-bash hook - Validate commands before execution.\n   *\n   * @param args\n   */\n  async preBashHook(args: any) {\n    const { command } = args;\n\n    // Safety checks\n    const safetyCheck = this.validateCommandSafety(command);\n    if (!safetyCheck.safe) {\n      return {\n        continue: false,\n        reason: safetyCheck.reason,\n        riskLevel: safetyCheck.riskLevel,\n      };\n    }\n\n    // Check resource requirements\n    const resources = this.estimateCommandResources(command);\n    if (resources.requiresAgent) {\n      await this.ensureAgent(resources.agentType);\n    }\n\n    return {\n      continue: true,\n      reason: 'Command validated and resources available',\n      metadata: {\n        estimatedDuration: resources.duration,\n        requiresAgent: resources.requiresAgent,\n      },\n    };\n  }\n\n  /**\n   * MCP swarm initialized hook - Persist configuration.\n   *\n   * @param args\n   */\n  async mcpSwarmInitializedHook(args: any) {\n    const { swarmId, topology, persistConfig, enableMonitoring } = args;\n\n    // Store swarm configuration\n    const swarmConfig = {\n      id: swarmId,\n      topology,\n      initialized: Date.now(),\n      monitoring: enableMonitoring,\n    };\n\n    // Persist configuration\n    if (persistConfig) {\n      const configDir = path.join(process.cwd(), '.ruv-swarm');\n      await fs.mkdir(configDir, { recursive: true });\n      await fs.writeFile(\n        path.join(configDir, 'swarm-config.json'),\n        JSON.stringify(swarmConfig, null, 2)\n      );\n    }\n\n    // Initialize monitoring\n    if (enableMonitoring) {\n      this.sessionData.monitoring = {\n        swarmId,\n        startTime: Date.now(),\n        events: [],\n      };\n    }\n\n    return {\n      continue: true,\n      reason: 'Swarm initialized and configured',\n      metadata: swarmConfig,\n    };\n  }\n\n  /**\n   * MCP agent spawned hook - Update roster and train.\n   *\n   * @param args\n   */\n  async mcpAgentSpawnedHook(args: any) {\n    const { agentId, type, updateRoster, trainSpecialization } = args;\n\n    // Update agent roster\n    if (updateRoster) {\n      const agent = {\n        id: agentId,\n        type,\n        specialization: this.getSpecializationForType(type),\n        spawned: Date.now(),\n        performance: { tasks: 0, successRate: 1.0 },\n      };\n\n      this.sessionData.agents.set(agentId, agent);\n\n      // Persist roster\n      const rosterPath = path.join(process.cwd(), '.ruv-swarm', 'agent-roster.json');\n      const roster = Array.from(this.sessionData.agents.values());\n      await fs.writeFile(rosterPath, JSON.stringify(roster, null, 2));\n    }\n\n    // Train specialization patterns\n    if (trainSpecialization) {\n      const training = {\n        agentId,\n        type,\n        patterns: this.generateSpecializationPatterns(type),\n        confidence: 0.9 + Math.random() * 0.1,\n      };\n\n      this.sessionData.learnings.push(training);\n    }\n\n    return {\n      continue: true,\n      agentId,\n      type,\n      specialized: true,\n    };\n  }\n\n  /**\n   * MCP task orchestrated hook - Monitor and optimize.\n   *\n   * @param args\n   */\n  async mcpTaskOrchestratedHook(args: any) {\n    const { taskId, monitorProgress, optimizeDistribution } = args;\n\n    // Initialize task tracking\n    if (!this.sessionData.taskStartTimes) {\n      this.sessionData.taskStartTimes = new Map();\n    }\n    if (!this.sessionData.taskAgents) {\n      this.sessionData.taskAgents = new Map();\n    }\n\n    this.sessionData.taskStartTimes.set(taskId, Date.now());\n\n    // Monitor progress setup\n    if (monitorProgress) {\n      this.sessionData.taskMonitoring = this.sessionData.taskMonitoring || new Map();\n      this.sessionData.taskMonitoring.set(taskId, {\n        checkpoints: [],\n        resources: [],\n        bottlenecks: [],\n      });\n    }\n\n    // Optimize distribution\n    if (optimizeDistribution) {\n      const optimization = {\n        taskId,\n        strategy: 'load-balanced',\n        agentAllocation: this.optimizeAgentAllocation(taskId),\n        parallelization: this.calculateParallelization(taskId),\n      };\n\n      return {\n        continue: true,\n        taskId,\n        optimization,\n      };\n    }\n\n    return {\n      continue: true,\n      taskId,\n      monitoring: monitorProgress,\n    };\n  }\n\n  /**\n   * MCP neural trained hook - Save improvements.\n   *\n   * @param args\n   */\n  async mcpNeuralTrainedHook(args: any) {\n    const { improvement, saveWeights, updatePatterns } = args;\n\n    const result = {\n      continue: true,\n      improvement: parseFloat(improvement),\n      saved: false,\n      patternsUpdated: false,\n    };\n\n    // Save neural weights\n    if (saveWeights) {\n      const weightsDir = path.join(process.cwd(), '.ruv-swarm', 'neural-weights');\n      await fs.mkdir(weightsDir, { recursive: true });\n\n      const weightData = {\n        timestamp: Date.now(),\n        improvement,\n        weights: this.generateMockWeights(),\n        version: this.sessionData.learnings.length,\n      };\n\n      await fs.writeFile(\n        path.join(weightsDir, `weights-${Date.now()}.json`),\n        JSON.stringify(weightData, null, 2)\n      );\n\n      result.saved = true;\n    }\n\n    // Update cognitive patterns\n    if (updatePatterns) {\n      this.sessionData.metrics.patternsImproved++;\n\n      const patternUpdate = {\n        timestamp: Date.now(),\n        improvement,\n        patterns: ['convergent', 'divergent', 'lateral'],\n        confidence: 0.85 + parseFloat(improvement),\n      };\n\n      this.sessionData.learnings.push(patternUpdate);\n      result.patternsUpdated = true;\n    }\n\n    return result;\n  }\n\n  /**\n   * Agent complete hook - Commit to git with detailed report.\n   */\n\n  /**\n   * Extract key points from output.\n   *\n   * @param output\n   */\n  extractKeyPoints(output: string): string {\n    const lines = output.split('\\n').filter((l) => l.trim());\n    const keyPoints: string[] = [];\n\n    // Look for bullet points or numbered items\n    lines.forEach((line) => {\n      if (line.match(/^[-*\u2022]\\s/) || line.match(/^\\d+\\.\\s/)) {\n        keyPoints.push(line);\n      }\n    });\n\n    // If no bullet points, take first few lines\n    if (keyPoints.length === 0) {\n      keyPoints.push(...lines.slice(0, 5));\n    }\n\n    return keyPoints.slice(0, 10).join('\\n');\n  }\n\n  /**\n   * Extract bullet points for commit message.\n   *\n   * @param output\n   */\n  extractBulletPoints(output: string): string {\n    if (!output) {\n      return '- No specific achievements captured';\n    }\n\n    const points = this.extractKeyPoints(output)\n      .split('\\n')\n      .slice(0, 5)\n      .map((p) => `- ${p.replace(/^[-*\u2022\\d+.\\s]+/, '').trim()}`);\n\n    return points.length > 0 ? points.join('\\n') : '- Task completed successfully';\n  }\n\n  /**\n   * Get count of modified files.\n   */\n  getModifiedFilesCount(): number {\n    const fileOps = this.sessionData.operations.filter((op) =>\n      ['edit', 'write', 'create'].includes(op.type)\n    );\n\n    const uniqueFiles = new Set(fileOps.map((op) => op.file).filter(Boolean));\n    return uniqueFiles.size;\n  }\n\n  /**\n   * Get list of modified files.\n   */\n  getModifiedFilesList(): string {\n    const fileOps = this.sessionData.operations.filter((op) =>\n      ['edit', 'write', 'create'].includes(op.type)\n    );\n\n    const fileMap = new Map();\n    fileOps.forEach((op) => {\n      if (op.file) {\n        if (!fileMap.has(op.file)) {\n          fileMap.set(op.file, []);\n        }\n        fileMap.get(op.file)?.push(op.type);\n      }\n    });\n\n    if (fileMap.size === 0) {\n      return 'No files modified';\n    }\n\n    return Array.from(fileMap.entries())\n      .map(([file, ops]) => `- ${file} (${[...new Set(ops)].join(', ')})`)\n      .join('\\n');\n  }\n\n  /**\n   * Session restore hook - Load previous state.\n   *\n   * @param args\n   */\n  async sessionRestoreHook(args: any) {\n    const { loadMemory, loadAgents } = args;\n\n    const result = {\n      continue: true,\n      restored: {\n        memory: false,\n        agents: false,\n        metrics: false,\n      },\n    };\n\n    try {\n      const sessionDir = path.join(process.cwd(), '.ruv-swarm');\n\n      // Load memory state\n      if (loadMemory) {\n        const memoryPath = path.join(sessionDir, 'memory-state.json');\n        if (\n          await fs\n            .access(memoryPath)\n            .then(() => true)\n            .catch(() => false)\n        ) {\n          const memory = JSON.parse(await fs.readFile(memoryPath, 'utf-8'));\n          this.sessionData = { ...this.sessionData, ...memory };\n          result.restored.memory = true;\n        }\n      }\n\n      // Load agent roster\n      if (loadAgents) {\n        const rosterPath = path.join(sessionDir, 'agent-roster.json');\n        if (\n          await fs\n            .access(rosterPath)\n            .then(() => true)\n            .catch(() => false)\n        ) {\n          const roster = JSON.parse(await fs.readFile(rosterPath, 'utf-8'));\n          roster.forEach((agent: any) => {\n            this.sessionData.agents.set(agent.id, agent);\n          });\n          result.restored.agents = true;\n        }\n      }\n\n      // Load metrics\n      const metricsPath = path.join(sessionDir, 'session-metrics.json');\n      if (\n        await fs\n          .access(metricsPath)\n          .then(() => true)\n          .catch(() => false)\n      ) {\n        const metrics = JSON.parse(await fs.readFile(metricsPath, 'utf-8'));\n        this.sessionData.metrics = { ...this.sessionData.metrics, ...metrics };\n        result.restored.metrics = true;\n      }\n    } catch (error) {\n      logger.error('Session restore error:', error.message);\n    }\n\n    return result;\n  }\n\n  /**\n   * Session end hook - Generate summary and persist state.\n   *\n   * @param args\n   */\n  async sessionEndHook(args: any) {\n    const { generateSummary, saveMemory, exportMetrics } = args;\n    const sessionDir = path.join(process.cwd(), '.claude', 'sessions');\n    await fs.mkdir(sessionDir, { recursive: true });\n\n    const timestamp = new Date().toISOString().replace(/:/g, '-');\n    const results: any = {};\n\n    // Generate summary\n    if (generateSummary) {\n      const summary = this.generateSessionSummary();\n      const summaryPath = path.join(sessionDir, `${timestamp}-summary.md`);\n      await fs.writeFile(summaryPath, summary);\n      results.summary = summaryPath;\n    }\n\n    // Save memory state\n    if (saveMemory) {\n      const state = this.captureSwarmState();\n      const statePath = path.join(sessionDir, `${timestamp}-state.json`);\n      await fs.writeFile(statePath, JSON.stringify(state, null, 2));\n      results.state = statePath;\n    }\n\n    // Export metrics\n    if (exportMetrics) {\n      const metrics = this.calculateSessionMetrics();\n      const metricsPath = path.join(sessionDir, `${timestamp}-metrics.json`);\n      await fs.writeFile(metricsPath, JSON.stringify(metrics, null, 2));\n      results.metrics = metricsPath;\n    }\n\n    return {\n      continue: true,\n      files: results,\n      summary: {\n        duration: Date.now() - this.sessionData.startTime,\n        operations: this.sessionData.operations.length,\n        improvements: this.sessionData.metrics.patternsImproved,\n      },\n    };\n  }\n\n  // Helper methods\n\n  getAgentTypeForFile(extension: string): string {\n    const mapping = {\n      '.js': 'coder',\n      '.ts': 'coder',\n      '.jsx': 'coder',\n      '.tsx': 'coder',\n      '.py': 'coder',\n      '.go': 'coder',\n      '.rs': 'coder',\n      '.md': 'researcher',\n      '.txt': 'researcher',\n      '.json': 'analyst',\n      '.yaml': 'analyst',\n      '.yml': 'analyst',\n      '.toml': 'analyst',\n      '.xml': 'analyst',\n      '.sql': 'analyst',\n    };\n    return mapping[extension] || 'coordinator';\n  }\n\n  async checkSwarmStatus() {\n    try {\n      // Check if swarm is initialized via file or global state\n      const statusFile = path.join(process.cwd(), '.ruv-swarm', 'status.json');\n      const exists = await fs\n        .access(statusFile)\n        .then(() => true)\n        .catch(() => false);\n\n      if (exists) {\n        const status = JSON.parse(await fs.readFile(statusFile, 'utf-8'));\n        return { initialized: true, ...status };\n      }\n\n      return { initialized: false };\n    } catch (_error) {\n      return { initialized: false };\n    }\n  }\n\n  async ensureAgent(type: string): Promise<any> {\n    let agent = this.sessionData.agents.get(type);\n\n    if (!agent) {\n      // Simulate agent creation\n      agent = {\n        id: `${type}-${Date.now()}`,\n        type,\n        pattern: this.getCognitivePattern(type),\n        readiness: 0.95,\n        created: Date.now(),\n      };\n      this.sessionData.agents.set(type, agent);\n    }\n\n    return agent;\n  }\n\n  getCognitivePattern(agentType: string): string {\n    const patterns = {\n      coder: 'convergent',\n      researcher: 'divergent',\n      analyst: 'critical',\n      coordinator: 'systems',\n      architect: 'abstract',\n      optimizer: 'lateral',\n    };\n    return patterns[agentType] || 'balanced';\n  }\n\n  async autoFormatFile(\n    filePath: string\n  ): Promise<{ success: boolean; reason?: string; details?: any }> {\n    const ext = path.extname(filePath);\n    const formatters = {\n      '.js': 'prettier --write',\n      '.ts': 'prettier --write',\n      '.jsx': 'prettier --write',\n      '.tsx': 'prettier --write',\n      '.json': 'prettier --write',\n      '.md': 'prettier --write --prose-wrap always',\n      '.py': 'black',\n      '.go': 'gofmt -w',\n      '.rs': 'rustfmt',\n    };\n\n    const formatter = formatters[ext];\n    if (!formatter) {\n      return { success: false, reason: 'No formatter configured for file type' };\n    }\n\n    try {\n      execSync(`${formatter} \"${filePath}\"`, { stdio: 'pipe' });\n      return { success: true, details: { formatter, fileType: ext } };\n    } catch (error) {\n      return { success: false, reason: error.message };\n    }\n  }\n\n  async trainPatternsFromEdit(filePath: string): Promise<any> {\n    // Simulate neural pattern training\n    const improvement = Math.random() * 0.05; // 0-5% improvement\n    const confidence = 0.85 + Math.random() * 0.1; // 85-95% confidence\n\n    this.sessionData.learnings.push({\n      file: filePath,\n      timestamp: Date.now(),\n      improvement,\n      confidence,\n      pattern: `edit_pattern_${path.extname(filePath)}`,\n    });\n\n    return {\n      pattern_updated: true,\n      improvement: improvement.toFixed(3),\n      confidence: confidence.toFixed(2),\n      total_examples: this.sessionData.learnings.length,\n    };\n  }\n\n  validateCommandSafety(command: string): { safe: boolean; reason?: string; riskLevel?: string } {\n    const dangerousPatterns = [\n      /rm\\s+-rf\\s+\\//,\n      /curl.*\\|\\s*bash/,\n      /wget.*\\|\\s*sh/,\n      /eval\\s*\\(/,\n      />\\/dev\\/null\\s+2>&1/,\n    ];\n\n    for (const pattern of dangerousPatterns) {\n      if (pattern.test(command)) {\n        return {\n          safe: false,\n          reason: 'Command contains potentially dangerous pattern',\n          riskLevel: 'high',\n        };\n      }\n    }\n\n    return { safe: true };\n  }\n\n  estimateCommandResources(command: string): any {\n    const resourceMap = {\n      'npm test': { duration: 30000, requiresAgent: true, agentType: 'coordinator' },\n      'npm run build': { duration: 60000, requiresAgent: true, agentType: 'optimizer' },\n      git: { duration: 1000, requiresAgent: false },\n      ls: { duration: 100, requiresAgent: false },\n    };\n\n    for (const [pattern, resources] of Object.entries(resourceMap)) {\n      if (command.includes(pattern)) {\n        return resources;\n      }\n    }\n\n    return { duration: 5000, requiresAgent: false, agentType: null };\n  }\n\n  generateSessionSummary(): string {\n    const duration = Date.now() - this.sessionData.startTime;\n    const agentList = Array.from(this.sessionData.agents.values());\n\n    return `# ruv-swarm Session Summary\nDate: ${new Date().toISOString()}\nDuration: ${this.formatDuration(duration)}\nToken Reduction: ${this.sessionData.metrics.tokensSaved} tokens\n\n## Swarm Activity\n- Active Agents: ${agentList.length} (${agentList.map((a: any) => a.type).join(', ')})\n- Operations Performed: ${this.sessionData.operations.length}\n- Files Modified: ${new Set(this.sessionData.operations.map((o: any) => o.file)).size}\n- Neural Improvements: ${this.sessionData.metrics.patternsImproved}\n\n## Operations Breakdown\n${this.sessionData.operations\n  .slice(-10)\n  .map(\n    (op: any) =>\n      `- ${new Date(op.timestamp).toLocaleTimeString()}: ${op.type} on ${op.file} (${op.agent})`\n  )\n  .join('\\n')}\n\n## Learning Highlights\n${this.sessionData.learnings\n  .slice(-5)\n  .map(\n    (l: any) =>\n      `- Pattern \"${l.pattern}\" improved by ${(l.improvement * 100).toFixed(1)}% (confidence: ${l.confidence})`\n  )\n  .join('\\n')}\n\n## Performance Metrics\n- Average Operation Time: ${(duration / this.sessionData.operations.length / 1000).toFixed(1)}s\n- Token Efficiency: ${(this.sessionData.metrics.tokensSaved / this.sessionData.operations.length).toFixed(0)} tokens/operation\n- Learning Rate: ${(this.sessionData.metrics.patternsImproved / this.sessionData.operations.length).toFixed(2)} improvements/operation\n`;\n  }\n\n  captureSwarmState(): any {\n    return {\n      session_id: `sess-${Date.now()}`,\n      agents: Object.fromEntries(this.sessionData.agents),\n      operations: this.sessionData.operations,\n      learnings: this.sessionData.learnings,\n      metrics: this.sessionData.metrics,\n      timestamp: new Date().toISOString(),\n    };\n  }\n\n  calculateSessionMetrics(): any {\n    const duration = Date.now() - this.sessionData.startTime;\n    return {\n      performance: {\n        duration_ms: duration,\n        operations_per_minute: (this.sessionData.operations.length / (duration / 60000)).toFixed(1),\n        tokens_saved: this.sessionData.metrics.tokensSaved,\n        efficiency_score: (\n          this.sessionData.metrics.tokensSaved / this.sessionData.operations.length\n        ).toFixed(1),\n      },\n      learning: {\n        patterns_improved: this.sessionData.metrics.patternsImproved,\n        average_improvement: (\n          this.sessionData.learnings.reduce((acc, l) => acc + l.improvement, 0) /\n          this.sessionData.learnings.length\n        ).toFixed(3),\n        confidence_average: (\n          this.sessionData.learnings.reduce((acc, l) => acc + l.confidence, 0) /\n          this.sessionData.learnings.length\n        ).toFixed(2),\n      },\n      agents: {\n        total_spawned: this.sessionData.agents.size,\n        by_type: Object.fromEntries(\n          Array.from((this.sessionData.agents).values()).reduce((acc: any, agent: any) => {\n            acc.set(agent.type, (acc.get(agent.type) || 0) + 1);\n            return acc;\n          }, new Map()) as any\n        ),\n      },\n    };\n  }\n\n  formatDuration(ms: number): string {\n    const seconds = Math.floor(ms / 1000);\n    const minutes = Math.floor(seconds / 60);\n    const hours = Math.floor(minutes / 60);\n\n    if (hours > 0) {\n      return `${hours}h ${minutes % 60}m`;\n    } else if (minutes > 0) {\n      return `${minutes}m ${seconds % 60}s`;\n    }\n    return `${seconds}s`;\n  }\n\n  // Additional helper methods for optimization\n\n  analyzeTaskComplexity(description: string): any {\n    const keywords = {\n      simple: ['fix', 'update', 'change', 'modify', 'rename'],\n      medium: ['implement', 'create', 'add', 'integrate', 'refactor'],\n      complex: ['architect', 'design', 'optimize', 'migrate', 'scale'],\n    };\n\n    const desc = description.toLowerCase();\n    let complexity = 'simple';\n    let score = 1;\n    let estimatedMinutes = 5;\n\n    // Check for complex keywords\n    if (keywords.complex.some((k) => desc.includes(k))) {\n      complexity = 'complex';\n      score = 3;\n      estimatedMinutes = 60;\n    } else if (keywords.medium.some((k) => desc.includes(k))) {\n      complexity = 'medium';\n      score = 2;\n      estimatedMinutes = 30;\n    }\n\n    // Adjust for multiple files or components\n    const fileCount = (desc.match(/\\b(files?|components?|modules?)\\b/g) || []).length;\n    if (fileCount > 1) {\n      score += 0.5;\n      estimatedMinutes *= 1.5;\n    }\n\n    return {\n      level: complexity,\n      score,\n      estimatedMinutes,\n      requiresResearch: desc.includes('research') || desc.includes('analyze'),\n      requiresTesting: desc.includes('test') || desc.includes('verify'),\n    };\n  }\n\n  selectOptimalTopology(complexity: any): string {\n    const topologyMap = {\n      simple: 'star', // Centralized for simple tasks\n      medium: 'mesh', // Flexible for medium complexity\n      complex: 'hierarchical', // Structured for complex tasks\n    };\n\n    return topologyMap[complexity.level] || 'mesh';\n  }\n\n  determineRequiredAgents(description, complexity): string[] {\n    const agents = new Set(['coordinator']); // Always need a coordinator\n\n    const desc = description.toLowerCase();\n\n    // Add agents based on task keywords\n    if (desc.includes('code') || desc.includes('implement') || desc.includes('fix')) {\n      agents.add('coder');\n    }\n    if (desc.includes('research') || desc.includes('analyze') || desc.includes('investigate')) {\n      agents.add('researcher');\n    }\n    if (desc.includes('data') || desc.includes('metrics') || desc.includes('performance')) {\n      agents.add('analyst');\n    }\n    if (desc.includes('design') || desc.includes('architect') || desc.includes('structure')) {\n      agents.add('architect');\n    }\n    if (desc.includes('optimize') || desc.includes('improve') || desc.includes('enhance')) {\n      agents.add('optimizer');\n    }\n\n    // Add more agents for complex tasks\n    if (complexity.score >= 3) {\n      agents.add('reviewer');\n    }\n\n    return Array.from(agents);\n  }\n\n  async updateKnowledgeGraph(file: string, operation: string): Promise<void> {\n    if (!this.sessionData.knowledgeGraph) {\n      this.sessionData.knowledgeGraph = {\n        nodes: new Map(),\n        edges: [],\n      };\n    }\n\n    const graph = this.sessionData.knowledgeGraph;\n\n    // Add or update node\n    const nodeId = file;\n    if (!graph.nodes.has(nodeId)) {\n      graph.nodes.set(nodeId, {\n        id: nodeId,\n        type: this.getFileType(file),\n        operations: [],\n        lastModified: Date.now(),\n      });\n    }\n\n    const node = graph.nodes.get(nodeId);\n    node?.operations?.push({\n      type: operation,\n      timestamp: Date.now(),\n      agent: this.getCurrentAgent(),\n    });\n    node.lastModified = Date.now();\n\n    // Add edges for related files\n    const relatedFiles = await this.findRelatedFiles(file);\n    relatedFiles.forEach((related) => {\n      if (\n        !graph.edges.find(\n          (e) => (e.from === nodeId && e.to === related) || (e.from === related && e.to === nodeId)\n        )\n      ) {\n        graph.edges.push({\n          from: nodeId,\n          to: related,\n          type: 'related',\n          weight: 1,\n        });\n      }\n    });\n  }\n\n  calculateEfficiency(performance: any): any {\n    const baselineTime = 60000; // 1 minute baseline\n    const efficiencyScore = Math.max(0, Math.min(1, baselineTime / performance.completionTime));\n\n    // Adjust for agent utilization\n    const agentUtilization =\n      performance.agentsUsed.length > 0\n        ? 0.8 + 0.2 * Math.min(1, 3 / performance.agentsUsed.length)\n        : 0.5;\n\n    return {\n      score: (efficiencyScore * agentUtilization).toFixed(2),\n      timeEfficiency: efficiencyScore.toFixed(2),\n      agentEfficiency: agentUtilization.toFixed(2),\n      rating:\n        efficiencyScore > 0.8\n          ? 'excellent'\n          : efficiencyScore > 0.6\n            ? 'good'\n            : efficiencyScore > 0.4\n              ? 'fair'\n              : 'needs improvement',\n    };\n  }\n\n  identifyBottlenecks(\n    performance: any\n  ): Array<{ type: string; severity: string; description: string; recommendation: string }> {\n    const bottlenecks: Array<{\n      type: string;\n      severity: string;\n      description: string;\n      recommendation: string;\n    }> = [];\n\n    // Time-based bottlenecks\n    if (performance.completionTime > 300000) {\n      // > 5 minutes\n      bottlenecks.push({\n        type: 'time',\n        severity: 'high',\n        description: 'Task took longer than expected',\n        recommendation: 'Consider breaking into smaller subtasks',\n      });\n    }\n\n    // Agent-based bottlenecks\n    if (performance.agentsUsed.length === 1) {\n      bottlenecks.push({\n        type: 'coordination',\n        severity: 'medium',\n        description: 'Single agent used for complex task',\n        recommendation: 'Spawn specialized agents for parallel work',\n      });\n    }\n\n    // Resource bottlenecks\n    if (this.sessionData.operations.length > 100) {\n      bottlenecks.push({\n        type: 'operations',\n        severity: 'medium',\n        description: 'High number of operations',\n        recommendation: 'Optimize operation batching',\n      });\n    }\n\n    return bottlenecks;\n  }\n\n  suggestImprovements(\n    performance\n  ): Array<{ area: string; suggestion: string; expectedImprovement: string }> {\n    const improvements: Array<{ area: string; suggestion: string; expectedImprovement: string }> =\n      [];\n    const efficiency = this.calculateEfficiency(performance);\n\n    // Time improvements\n    if (parseFloat(efficiency.timeEfficiency) < 0.7) {\n      improvements.push({\n        area: 'execution_time',\n        suggestion: 'Use parallel task execution',\n        expectedImprovement: '30-50% time reduction',\n      });\n    }\n\n    // Coordination improvements\n    if (parseFloat(efficiency.agentEfficiency) < 0.8) {\n      improvements.push({\n        area: 'agent_coordination',\n        suggestion: 'Implement specialized agent patterns',\n        expectedImprovement: '20-30% efficiency gain',\n      });\n    }\n\n    // Pattern improvements\n    if (this.sessionData.learnings.length < 5) {\n      improvements.push({\n        area: 'learning',\n        suggestion: 'Enable neural pattern training',\n        expectedImprovement: 'Cumulative performance gains',\n      });\n    }\n\n    return improvements;\n  }\n\n  updateCoordinationStrategy(performance: any): void {\n    const efficiency = this.calculateEfficiency(performance);\n\n    // Update strategy based on performance\n    if (!this.sessionData.coordinationStrategy) {\n      this.sessionData.coordinationStrategy = {\n        current: 'balanced',\n        history: [],\n        adjustments: 0,\n      };\n    }\n\n    const strategy = this.sessionData.coordinationStrategy;\n    strategy.history.push({\n      timestamp: Date.now(),\n      efficiency: efficiency.score,\n      strategy: strategy.current,\n    });\n\n    // Adjust strategy if needed\n    if (parseFloat(efficiency.score) < 0.6) {\n      strategy.current = 'adaptive';\n      strategy.adjustments++;\n    } else if (parseFloat(efficiency.score) > 0.9) {\n      strategy.current = 'specialized';\n      strategy.adjustments++;\n    }\n  }\n\n  extractSearchPatterns(query): string[] {\n    const patterns: string[] = [];\n\n    // Extract file type patterns\n    const fileTypes = query.match(/\\.(js|ts|py|go|rs|md|json|yaml)\\b/gi);\n    if (fileTypes) {\n      patterns.push(...fileTypes.map((ft) => `filetype:${ft}`));\n    }\n\n    // Extract function/class patterns\n    const codePatterns = query.match(/\\b(function|class|interface|struct|impl)\\s+\\w+/gi);\n    if (codePatterns) {\n      patterns.push(...codePatterns.map((cp) => `code:${cp}`));\n    }\n\n    // Extract scope patterns\n    const scopePatterns = query.match(/\\b(src|test|lib|bin|docs?)\\//gi);\n    if (scopePatterns) {\n      patterns.push(...scopePatterns.map((sp) => `scope:${sp}`));\n    }\n\n    return patterns;\n  }\n\n  async updateKnowledgeBase(type: string, data: any): Promise<void> {\n    const kbPath = path.join(process.cwd(), '.ruv-swarm', 'knowledge-base.json');\n\n    // Load existing knowledge base\n    let kb: any = { searches: [], patterns: {}, insights: [] };\n    try {\n      if (\n        await fs\n          .access(kbPath)\n          .then(() => true)\n          .catch(() => false)\n      ) {\n        kb = JSON.parse(await fs.readFile(kbPath, 'utf-8'));\n      }\n    } catch (_error) {\n      kb = { searches: [], patterns: {}, insights: [] };\n    }\n\n    // Update based on type\n    if (type === 'search') {\n      if (!kb.searches) {\n        kb.searches = [];\n      }\n      kb.searches.push({\n        query: data?.query,\n        patterns: data?.patterns,\n        timestamp: Date.now(),\n      });\n\n      // Update pattern frequency\n      if (!kb.patterns) {\n        kb.patterns = {};\n      }\n      data?.patterns.forEach((pattern) => {\n        kb.patterns[pattern] = (kb.patterns[pattern] || 0) + 1;\n      });\n    }\n\n    // Keep only recent data\n    if (kb.searches && kb.searches.length > 100) {\n      kb.searches = kb.searches.slice(-100);\n    }\n\n    // Save updated knowledge base\n    await fs.mkdir(path.dirname(kbPath), { recursive: true });\n    await fs.writeFile(kbPath, JSON.stringify(kb, null, 2));\n  }\n\n  extractUrlPatterns(url): string[] {\n    const patterns: string[] = [];\n\n    try {\n      const urlObj = new URL(url);\n\n      // Domain pattern\n      patterns.push(`domain:${urlObj.hostname}`);\n\n      // Path patterns\n      const pathParts = urlObj.pathname.split('/').filter((p) => p);\n      if (pathParts.length > 0) {\n        patterns.push(`path:/${pathParts[0]}`); // Top level path\n      }\n\n      // Content type patterns\n      if (urlObj.pathname.endsWith('.md')) {\n        patterns.push('content:markdown');\n      }\n      if (urlObj.pathname.includes('docs')) {\n        patterns.push('content:documentation');\n      }\n      if (urlObj.pathname.includes('api')) {\n        patterns.push('content:api');\n      }\n      if (urlObj.pathname.includes('guide')) {\n        patterns.push('content:guide');\n      }\n\n      // Query patterns\n      if (urlObj.search) {\n        patterns.push('has:queryparams');\n      }\n    } catch (_error) {\n      patterns.push('pattern:invalid-url');\n    }\n\n    return patterns;\n  }\n\n  async getSwarmStatus(): Promise<any> {\n    try {\n      const statusPath = path.join(process.cwd(), '.ruv-swarm', 'status.json');\n      if (\n        await fs\n          .access(statusPath)\n          .then(() => true)\n          .catch(() => false)\n      ) {\n        return JSON.parse(await fs.readFile(statusPath, 'utf-8'));\n      }\n    } catch (_error) {\n      // Fallback to session data\n    }\n\n    return {\n      agents: this.sessionData.agents,\n      activeTasks: this.sessionData.operations.filter(\n        (op) => Date.now() - op.timestamp < 300000 // Last 5 minutes\n      ).length,\n      health: 'operational',\n    };\n  }\n\n  sendTelemetry(event: string, data: any): void {\n    // In production, this would send to telemetry service\n    // For now, just log to telemetry file\n    const telemetryPath = path.join(process.cwd(), '.ruv-swarm', 'telemetry.jsonl');\n\n    const telemetryEvent = {\n      event,\n      data,\n      timestamp: Date.now(),\n      sessionId: this.sessionData.sessionId || 'unknown',\n      version: '1.0.0',\n    };\n\n    // Async write without blocking\n    fs.appendFile(telemetryPath, `${JSON.stringify(telemetryEvent)}\\n`).catch(() => {\n      /* intentionally empty */\n    });\n  }\n\n  // Helper methods for other functionality\n\n  getSpecializationForType(type: string): string[] {\n    const specializations: Record<string, string[]> = {\n      researcher: ['literature-review', 'data-analysis', 'trend-identification'],\n      coder: ['implementation', 'refactoring', 'optimization'],\n      analyst: ['metrics', 'performance', 'data-visualization'],\n      architect: ['system-design', 'api-design', 'database-schema'],\n      coordinator: ['task-planning', 'resource-allocation', 'progress-tracking'],\n      optimizer: ['performance-tuning', 'algorithm-optimization', 'resource-usage'],\n    };\n    return specializations[type] || ['general'];\n  }\n\n  generateSpecializationPatterns(type: string): string[] {\n    const patterns: Record<string, string[]> = {\n      researcher: ['depth-first-search', 'breadth-first-search', 'citation-tracking'],\n      coder: ['modular-design', 'error-handling', 'code-reuse'],\n      analyst: ['statistical-analysis', 'trend-detection', 'anomaly-detection'],\n      architect: ['layered-architecture', 'microservices', 'event-driven'],\n      coordinator: ['dependency-tracking', 'parallel-execution', 'milestone-planning'],\n      optimizer: ['bottleneck-identification', 'caching-strategies', 'lazy-loading'],\n    };\n    return patterns[type] || ['adaptive-learning'];\n  }\n\n  generateMockWeights(): any {\n    // Generate mock neural network weights for demonstration\n    return {\n      layers: [\n        {\n          neurons: 128,\n          weights: Array(128)\n            .fill(0)\n            .map(() => Math.random() - 0.5),\n        },\n        {\n          neurons: 64,\n          weights: Array(64)\n            .fill(0)\n            .map(() => Math.random() - 0.5),\n        },\n        {\n          neurons: 32,\n          weights: Array(32)\n            .fill(0)\n            .map(() => Math.random() - 0.5),\n        },\n      ],\n      biases: Array(224)\n        .fill(0)\n        .map(() => Math.random() - 0.5),\n    };\n  }\n\n  optimizeAgentAllocation(_taskId: string): any {\n    // Simple load balancing algorithm\n    const agents = Array.from(this.sessionData.agents.values());\n    const allocation = {};\n\n    agents.forEach((agent: any) => {\n      // Allocate based on agent type and current load\n      const load = this.sessionData.operations.filter(\n        (op: any) => op.agent === agent.id && Date.now() - op.timestamp < 60000\n      ).length;\n\n      allocation[agent.id] = {\n        agent: agent.id,\n        type: agent.type,\n        currentLoad: load,\n        capacity: Math.max(0, 10 - load), // Max 10 concurrent ops\n        priority: load < 5 ? 'high' : 'normal',\n      };\n    });\n\n    return allocation;\n  }\n\n  calculateParallelization(_taskId: string): any {\n    // Determine parallelization factor based on task and resources\n    const agentCount = this.sessionData.agents.size;\n    const complexity = this.sessionData.taskComplexity || { score: 2 };\n\n    return {\n      factor: Math.min(agentCount, Math.ceil(complexity.score * 1.5)),\n      strategy: agentCount > 3 ? 'distributed' : 'local',\n      maxConcurrency: Math.min(agentCount * 2, 10),\n    };\n  }\n\n  getFileType(filePath: string): string {\n    const ext = path.extname(filePath);\n    const typeMap = {\n      '.js': 'javascript',\n      '.ts': 'typescript',\n      '.py': 'python',\n      '.go': 'golang',\n      '.rs': 'rust',\n      '.json': 'config',\n      '.yaml': 'config',\n      '.yml': 'config',\n      '.md': 'documentation',\n      '.txt': 'text',\n    };\n    return typeMap[ext] || 'unknown';\n  }\n\n  getCurrentAgent(): string {\n    // Get the most recently active agent\n    const recentOps = this.sessionData.operations.slice(-10);\n    const agentCounts = {};\n\n    recentOps.forEach((op) => {\n      if (op.agent) {\n        agentCounts[op.agent] = (agentCounts[op.agent] || 0) + 1;\n      }\n    });\n\n    const sorted = Object.entries(agentCounts).sort((a, b) => Number(b[1]) - Number(a[1]));\n    return sorted.length > 0 && sorted[0] ? sorted[0]?.[0] : 'coordinator';\n  }\n\n  async findRelatedFiles(filePath): Promise<string[]> {\n    const related: string[] = [];\n    const _baseName = path.basename(filePath, path.extname(filePath));\n    // const dirName = path.dirname(filePath);\n\n    // Common related file patterns\n    // const patterns = [\n    //   `${baseName}.test.*`, // Test files\n    //   `${baseName}.spec.*`, // Spec files\n    //   `test-${baseName}.*`, // Alternative test pattern\n    //   `${baseName}.d.ts`, // TypeScript definitions\n    //   `${baseName}.types.*`, // Type definitions\n    // ];\n\n    // For now, return mock related files\n    // In production, would use file system search\n    if (filePath.endsWith('.js')) {\n      related.push(filePath.replace('.js', '.test.js'));\n    }\n    if (filePath.endsWith('.ts')) {\n      related.push(filePath.replace('.ts', '.test.ts'));\n      related.push(filePath.replace('.ts', '.d.ts'));\n    }\n\n    return related.filter((f) => f !== filePath);\n  }\n\n  /**\n   * \uD83D\uDD27 CRITICAL FIX: Store notification in database for cross-agent access.\n   *\n   * @param notification\n   */\n  async storeNotificationInDatabase(notification: any): Promise<void> {\n    if (!this.persistence) {\n      logger.warn('\u26A0\uFE0F No persistence layer - notification stored in memory only');\n      return;\n    }\n\n    try {\n      // Store as agent memory with special hook prefix\n      const agentId = notification.agentId || 'hook-system';\n      const memoryKey = `notifications/${notification.type}/${Date.now()}`;\n\n      await this.persistence.storeAgentMemory(agentId, memoryKey, {\n        type: notification.type,\n        message: notification.message,\n        context: notification.context,\n        timestamp: notification.timestamp,\n        source: 'hook-system',\n        sessionId: this.getSessionId(),\n      });\n    } catch (error) {\n      logger.error('\u274C Failed to store notification in database:', error.message);\n    }\n  }\n\n  /**\n   * \uD83D\uDD27 CRITICAL FIX: Retrieve notifications from database for cross-agent access.\n   *\n   * @param agentId\n   * @param type\n   */\n  async getNotificationsFromDatabase(\n    agentId: string | null = null,\n    type: string | null = null\n  ): Promise<any[]> {\n    if (!this.persistence) {\n      return [];\n    }\n\n    try {\n      const targetAgentId = agentId || 'hook-system';\n      const memories = await this.persistence.getAllMemory(targetAgentId);\n\n      return memories\n        .filter((memory) => memory.key.startsWith('notifications/'))\n        .filter((memory) => !type || memory.value.type === type)\n        .map((memory) => memory.value)\n        .sort((a, b) => b.timestamp - a.timestamp);\n    } catch (error) {\n      logger.error('\u274C Failed to retrieve notifications from database:', error.message);\n      return [];\n    }\n  }\n\n  /**\n   * \uD83D\uDD27 CRITICAL FIX: Enhanced agent completion with database coordination.\n   *\n   * @param args\n   */\n  async agentCompleteHook(args: any) {\n    const { agentId, taskId, results, learnings } = args;\n\n    // Store completion in database for other agents to see\n    if (this.persistence && agentId) {\n      try {\n        await this.persistence.storeAgentMemory(agentId, `completion/${taskId}`, {\n          taskId,\n          results,\n          learnings,\n          completedAt: Date.now(),\n          source: 'agent-completion',\n        });\n\n        // Update agent status in database\n        await this.persistence.updateAgentStatus(agentId, 'completed');\n      } catch (error) {\n        logger.error('\u274C Failed to store agent completion:', error.message);\n      }\n    }\n\n    // Store in runtime memory as before\n    const agent = this.sessionData.agents.get(agentId);\n    if (agent) {\n      agent.lastCompletion = {\n        taskId,\n        results,\n        learnings,\n        timestamp: Date.now(),\n      };\n      agent.status = 'completed';\n    }\n\n    return {\n      continue: true,\n      stored: true,\n      agent: agentId,\n    };\n  }\n\n  /**\n   * Get current session ID for coordination.\n   */\n  getSessionId(): string {\n    if (!this._sessionId) {\n      this._sessionId = `session_${Date.now()}_${Math.random().toString(36).substring(2, 11)}`;\n    }\n    return this._sessionId;\n  }\n\n  /**\n   * \uD83D\uDD27 CRITICAL FIX: Cross-agent memory retrieval for coordinated decisions.\n   *\n   * @param key\n   * @param agentId\n   */\n  async getSharedMemory(key: string, agentId: string | null = null): Promise<any> {\n    // Check runtime memory first\n    const runtimeValue = this.sessionData[key];\n\n    // Check database for persistent cross-agent memory\n    if (this.persistence) {\n      try {\n        const targetAgentId = agentId || 'shared-memory';\n        const memory = await this.persistence.getAgentMemory(targetAgentId, key);\n\n        if (memory) {\n          return memory.value;\n        }\n      } catch (error) {\n        logger.error('\u274C Failed to retrieve shared memory:', error.message);\n      }\n    }\n\n    return runtimeValue;\n  }\n\n  /**\n   * \uD83D\uDD27 CRITICAL FIX: Cross-agent memory storage for coordinated decisions.\n   *\n   * @param key\n   * @param value\n   * @param agentId\n   */\n  async setSharedMemory(key: string, value: any, agentId: string | null = null): Promise<void> {\n    // Store in runtime memory\n    this.sessionData[key] = value;\n\n    // Store in database for cross-agent access\n    if (this.persistence) {\n      try {\n        const targetAgentId = agentId || 'shared-memory';\n        await this.persistence.storeAgentMemory(targetAgentId, key, value);\n      } catch (error) {\n        logger.error('\u274C Failed to store shared memory:', error.message);\n      }\n    }\n  }\n}\n\n// Export singleton instance and its methods\nconst hooksInstance = new ZenSwarmHooks();\n\nexport const handleHook = (hookType: string, options: any[]) =>\n  hooksInstance.handleHook(hookType, options);\n\nexport default hooksInstance;\n", "/**\n * @file Coordination system: logger.\n */\n\nimport { getLogger } from '../../../config/logging-config.ts';\n\nconst logger = getLogger('coordination-swarm-core-logger');\n\n/**\n * Logger module for ruv-swarm with comprehensive logging capabilities.\n */\n\nimport { randomUUID } from 'node:crypto';\nimport { config } from '../../../config';\n\ninterface LoggerOptions {\n  name?: string;\n  level?: string;\n  enableStderr?: boolean;\n  enableFile?: boolean;\n  formatJson?: boolean;\n  logDir?: string;\n  metadata?: Record<string, any>;\n}\n\nexport class Logger {\n  public name: string;\n  public level: string;\n  public enableStderr: boolean;\n  public enableFile: boolean;\n  public formatJson: boolean;\n  public logDir: string;\n  public metadata: Record<string, any>;\n  public correlationId: string | null;\n  public operations: Map<string, any>;\n\n  constructor(options: LoggerOptions = {}) {\n    // Use centralized configuration with user overrides\n    const centralConfig = config?.getAll();\n    const loggerConfig = centralConfig?.core?.logger;\n\n    this.name = options?.name || 'ruv-swarm';\n    this.level = options?.level || loggerConfig?.level.toUpperCase();\n    this.enableStderr =\n      options.enableStderr === undefined ? loggerConfig?.console : options?.enableStderr;\n    this.enableFile = options.enableFile === undefined ? !!loggerConfig?.file : options?.enableFile;\n    this.formatJson =\n      options.formatJson === undefined ? loggerConfig?.structured : options?.formatJson;\n    this.logDir = options?.logDir || './logs';\n    this.metadata = options?.metadata || {};\n    this.correlationId = null;\n    this.operations = new Map();\n  }\n\n  setCorrelationId(id: string) {\n    this.correlationId = id || randomUUID();\n    return this.correlationId;\n  }\n\n  getCorrelationId(): string | null {\n    return this.correlationId;\n  }\n\n  _log(level: string, message: string, data: Record<string, any> = {}) {\n    const timestamp = new Date().toISOString();\n    const prefix = this.correlationId ? `[${this.correlationId}] ` : '';\n\n    const logEntry = {\n      timestamp,\n      level,\n      name: this.name,\n      message,\n      correlationId: this.correlationId,\n      ...this.metadata,\n      ...data,\n    };\n\n    // CRITICAL FIX: Always use stderr to avoid JSON-RPC stdout corruption\n    // This is essential for MCP server compatibility\n    if (this.formatJson) {\n      const output = JSON.stringify(logEntry);\n      logger.error(output);\n    } else {\n      const output = `${prefix}[${level}] ${message}`;\n      logger.error(output, Object.keys(data).length > 0 ? data : '');\n    }\n  }\n\n  info(message: string, data: Record<string, any> = {}) {\n    this._log('INFO', message, data);\n  }\n\n  warn(message: string, data: Record<string, any> = {}) {\n    this._log('WARN', message, data);\n  }\n\n  error(message: string, data: Record<string, any> = {}) {\n    this._log('ERROR', message, data);\n  }\n\n  debug(message: string, data: Record<string, any> = {}) {\n    const centralConfig = config?.getAll();\n    const enableDebug = this.level === 'DEBUG' || centralConfig?.environment?.enableDebugEndpoints;\n    if (enableDebug) {\n      this._log('DEBUG', message, data);\n    }\n  }\n\n  trace(message: string, data: Record<string, any> = {}) {\n    const centralConfig = config?.getAll();\n    const enableTrace = this.level === 'TRACE' || centralConfig?.environment?.enableDebugEndpoints;\n    if (enableTrace) {\n      this._log('TRACE', message, data);\n    }\n  }\n\n  success(message: string, data: Record<string, any> = {}) {\n    this._log('SUCCESS', message, data);\n  }\n\n  fatal(message: string, data: Record<string, any> = {}) {\n    this._log('FATAL', message, data);\n  }\n\n  startOperation(operationName: string): string {\n    const operationId = randomUUID();\n    this.operations.set(operationId, {\n      name: operationName,\n      startTime: Date.now(),\n    });\n    this.debug(`Starting operation: ${operationName}`, { operationId });\n    return operationId;\n  }\n\n  endOperation(operationId: string, success: boolean = true, data: Record<string, any> = {}) {\n    const operation = this.operations.get(operationId);\n    if (operation) {\n      const duration = Date.now() - operation.startTime;\n      this.debug(`Operation ${success ? 'completed' : 'failed'}: ${operation.name}`, {\n        operationId,\n        duration,\n        success,\n        ...data,\n      });\n      this.operations.delete(operationId);\n    }\n  }\n\n  logConnection(event: string, sessionId: string, data: Record<string, any> = {}) {\n    this.info(`Connection ${event}`, {\n      sessionId,\n      event,\n      ...data,\n    });\n  }\n\n  logMcp(direction: string, method: string, data: Record<string, any> = {}) {\n    this.debug(`MCP ${direction}: ${method}`, {\n      direction,\n      method,\n      ...data,\n    });\n  }\n\n  logMemoryUsage(context: string) {\n    const memUsage = process.memoryUsage();\n    this.debug(`Memory usage - ${context}`, {\n      rss: `${Math.round(memUsage.rss / 1024 / 1024)}MB`,\n      heapUsed: `${Math.round(memUsage.heapUsed / 1024 / 1024)}MB`,\n      heapTotal: `${Math.round(memUsage.heapTotal / 1024 / 1024)}MB`,\n      external: `${Math.round(memUsage.external / 1024 / 1024)}MB`,\n    });\n  }\n\n  getConnectionMetrics() {\n    return {\n      correlationId: this.correlationId,\n      activeOperations: this.operations.size,\n      uptime: process.uptime(),\n    };\n  }\n\n  // Static methods for backward compatibility\n  static info(message, ...args) {\n    const logger = new Logger();\n    logger.info(message, ...args);\n  }\n\n  static warn(message, ...args) {\n    const logger = new Logger();\n    logger.warn(message, ...args);\n  }\n\n  static error(message, ...args) {\n    const logger = new Logger();\n    logger.error(message, ...args);\n  }\n\n  static debug(message, ...args) {\n    const logger = new Logger();\n    logger.debug(message, ...args);\n  }\n\n  static success(message, ...args) {\n    const logger = new Logger();\n    logger.success(message, ...args);\n  }\n\n  static trace(message, ...args) {\n    const logger = new Logger();\n    logger.trace(message, ...args);\n  }\n}\n\nexport default Logger;\n", "/**\n * Logging Configuration for ruv-swarm.\n * Provides centralized logging configuration and utilities.\n */\n/**\n * @file Coordination system: logging-config.\n */\n\nimport { Logger } from './logger.ts';\n\n// Default log levels for different components\nconst DEFAULT_LOG_LEVELS = {\n  'mcp-server': 'INFO',\n  'mcp-tools': 'INFO',\n  'swarm-core': 'INFO',\n  agent: 'DEBUG',\n  neural: 'INFO',\n  'wasm-loader': 'WARN',\n  persistence: 'INFO',\n  hooks: 'DEBUG',\n  performance: 'INFO',\n  memory: 'WARN',\n};\n\n// Log level mapping from environment variables\nconst ENV_LOG_MAPPING = {\n  LOG_LEVEL: null, // Global log level\n  MCP_LOG_LEVEL: 'mcp-server',\n  TOOLS_LOG_LEVEL: 'mcp-tools',\n  SWARM_LOG_LEVEL: 'swarm-core',\n  AGENT_LOG_LEVEL: 'agent',\n  NEURAL_LOG_LEVEL: 'neural',\n  WASM_LOG_LEVEL: 'wasm-loader',\n  DB_LOG_LEVEL: 'persistence',\n  HOOKS_LOG_LEVEL: 'hooks',\n  PERF_LOG_LEVEL: 'performance',\n  MEMORY_LOG_LEVEL: 'memory',\n};\n\n/**\n * Logging configuration manager.\n *\n * @example\n */\nexport class LoggingConfig {\n  private loggers: Map<string, Logger>;\n  private globalLevel: string | null;\n  private componentLevels: Record<string, string>;\n\n  constructor() {\n    this.loggers = new Map();\n    this.globalLevel = null;\n    this.componentLevels = { ...DEFAULT_LOG_LEVELS };\n    this.loadFromEnvironment();\n  }\n\n  /**\n   * Load log levels from environment variables.\n   */\n  private loadFromEnvironment(): void {\n    for (const [envVar, component] of Object.entries(ENV_LOG_MAPPING)) {\n      const value = process.env[envVar];\n      if (value) {\n        if (component === null) {\n          // Global log level\n          this.globalLevel = value.toUpperCase();\n        } else {\n          // Component-specific log level\n          this.componentLevels[component] = value.toUpperCase();\n        }\n      }\n    }\n  }\n\n  /**\n   * Get or create a logger for a component.\n   *\n   * @param component\n   * @param options\n   * @param options.enableStderr\n   * @param options.enableFile\n   * @param options.formatJson\n   * @param options.logDir\n   */\n  getLogger(\n    component: string,\n    options: {\n      enableStderr?: boolean;\n      enableFile?: boolean;\n      formatJson?: boolean;\n      logDir?: string;\n      [key: string]: any;\n    } = {}\n  ): Logger {\n    if (this.loggers.has(component)) {\n      return this.loggers.get(component)!;\n    }\n\n    const level = this.globalLevel || this.componentLevels[component] || 'INFO';\n\n    // Create logger options with proper handling for exactOptionalPropertyTypes\n    // Only include properties when they have defined values\n    const loggerOptions: any = {\n      name: component,\n      level,\n      logDir: process.env['LOG_DIR'] || options?.logDir || './logs',\n      ...options,\n    };\n\n    // Conditionally add optional properties only if they have truthy values\n    const enableStderr = process.env['MCP_MODE'] === 'stdio' || options?.enableStderr;\n    if (enableStderr) {\n      loggerOptions.enableStderr = true;\n    }\n\n    const enableFile = process.env['LOG_TO_FILE'] === 'true' || options?.enableFile;\n    if (enableFile) {\n      loggerOptions.enableFile = true;\n    }\n\n    const formatJson = process.env['LOG_FORMAT'] === 'json' || options?.formatJson;\n    if (formatJson) {\n      loggerOptions.formatJson = true;\n    }\n\n    const logger = new Logger(loggerOptions);\n\n    this.loggers.set(component, logger);\n    return logger;\n  }\n\n  /**\n   * Set log level for a component.\n   *\n   * @param component\n   * @param level\n   */\n  setLogLevel(component: string, level: string): void {\n    this.componentLevels[component] = level.toUpperCase();\n\n    // Update existing logger if present\n    if (this.loggers.has(component)) {\n      const logger = this.loggers.get(component)!;\n      // Access LOG_LEVELS safely - assuming it exists on the logger instance or constructor\n      if ('level' in logger && typeof logger.level === 'string') {\n        (logger as any).level = level.toUpperCase();\n      }\n    }\n  }\n\n  /**\n   * Set global log level.\n   *\n   * @param level\n   */\n  setGlobalLogLevel(level: string): void {\n    this.globalLevel = level.toUpperCase();\n\n    // Update all existing loggers\n    for (const logger of this.loggers.values()) {\n      (logger as any).level = level.toUpperCase();\n    }\n  }\n\n  /**\n   * Get current log levels.\n   */\n  getLogLevels(): { global: string | null; components: Record<string, string> } {\n    return {\n      global: this.globalLevel,\n      components: { ...this.componentLevels },\n    };\n  }\n\n  /**\n   * Create child logger with correlation ID.\n   *\n   * @param parentLogger\n   * @param module\n   * @param correlationId\n   */\n  createChildLogger(parentLogger: any, module: string, correlationId: string | null = null): any {\n    return parentLogger?.child({\n      module,\n      correlationId: correlationId || parentLogger?.correlationId,\n    });\n  }\n\n  /**\n   * Log system configuration.\n   */\n  logConfiguration(): any {\n    const config = {\n      globalLevel: this.globalLevel || 'Not set (using component defaults)',\n      componentLevels: this.componentLevels,\n      enabledFeatures: {\n        fileLogging: process.env['LOG_TO_FILE'] === 'true',\n        jsonFormat: process.env['LOG_FORMAT'] === 'json',\n        stderrOutput: process.env['MCP_MODE'] === 'stdio',\n        logDirectory: process.env['LOG_DIR'] || './logs',\n      },\n      environment: {\n        MCP_MODE: process.env['MCP_MODE'],\n        NODE_ENV: process.env['NODE_ENV'],\n      },\n    };\n\n    this.getLogger('logging-config').error('\uD83D\uDCCA Logging Configuration:', config);\n    return config;\n  }\n}\n\n// Singleton instance\nexport const loggingConfig = new LoggingConfig();\n\n// Convenience functions\nexport const getLogger = (component: string, options?: any): Logger =>\n  loggingConfig?.getLogger(component, options);\nexport const setLogLevel = (component: string, level: string): void =>\n  loggingConfig?.setLogLevel(component, level);\nexport const setGlobalLogLevel = (level: string): void => loggingConfig?.setGlobalLogLevel(level);\n\n// Pre-configured loggers for common components\nexport const mcpLogger = loggingConfig?.getLogger('mcp-server');\nexport const toolsLogger = loggingConfig?.getLogger('mcp-tools');\nexport const swarmLogger = loggingConfig?.getLogger('swarm-core');\nexport const agentLogger = loggingConfig?.getLogger('agent');\nexport const neuralLogger = loggingConfig?.getLogger('neural');\nexport const wasmLogger = loggingConfig?.getLogger('wasm-loader');\nexport const dbLogger = loggingConfig?.getLogger('persistence');\nexport const hooksLogger = loggingConfig?.getLogger('hooks');\nexport const perfLogger = loggingConfig?.getLogger('performance');\nexport const memoryLogger = loggingConfig?.getLogger('memory');\n\nexport default loggingConfig;\n", "/**\n * Monitoring Dashboard Integration for ZenSwarm.\n *\n * Provides dashboard-ready data export, real-time metrics streaming,\n * and integration points for monitoring systems like Grafana, Prometheus, etc.\n *\n * Features:\n * - Real-time metrics streaming\n * - Dashboard-ready data formatting\n * - Integration with external monitoring systems\n * - Custom metric aggregation and visualization\n * - Alert correlation and analysis\n * - Performance trend analysis.\n */\n/**\n * @file Coordination system: monitoring-dashboard.\n */\n\nimport { EventEmitter } from 'node:events';\nimport { ErrorFactory } from './errors.ts';\nimport { Logger } from './logger.ts';\n\nexport class MonitoringDashboard extends EventEmitter {\n  public options: any;\n  public logger: any;\n\n  // Data storage properties\n  private metrics: Map<string, any[]>;\n  private aggregatedMetrics: Map<number, Map<string, any>>;\n  private alerts: Map<string, any>;\n  private trends: Map<string, any[]>;\n  private healthStatus: Map<string, any>;\n\n  // Real-time streaming properties\n  private streamingClients: Set<any>;\n  private lastUpdate: Date;\n\n  // Integration points\n  private healthMonitor: any;\n  private recoveryWorkflows: any;\n  private connectionManager: any;\n  private mcpTools: any;\n\n  // Aggregation timer\n  private aggregationTimer: NodeJS.Timeout | null;\n\n  constructor(options: any = {}) {\n    super();\n\n    this.options = {\n      metricsRetentionPeriod: options?.metricsRetentionPeriod || 86400000, // 24 hours\n      aggregationInterval: options?.aggregationInterval || 60000, // 1 minute\n      enableRealTimeStreaming: options?.enableRealTimeStreaming !== false,\n      enableTrendAnalysis: options?.enableTrendAnalysis !== false,\n      maxDataPoints: options?.maxDataPoints || 1440, // 24 hours at 1-minute intervals\n      exportFormats: options?.exportFormats || ['prometheus', 'json', 'grafana'],\n      ...options,\n    };\n\n    this.logger = new Logger({\n      name: 'monitoring-dashboard',\n      level: process.env['LOG_LEVEL'] || 'INFO',\n      metadata: { component: 'monitoring-dashboard' },\n    });\n\n    // Data storage\n    this.metrics = new Map();\n    this.aggregatedMetrics = new Map();\n    this.alerts = new Map();\n    this.trends = new Map();\n    this.healthStatus = new Map();\n\n    // Real-time streaming\n    this.streamingClients = new Set();\n    this.lastUpdate = new Date();\n\n    // Integration points\n    this.healthMonitor = null;\n    this.recoveryWorkflows = null;\n    this.connectionManager = null;\n    this.mcpTools = null;\n\n    // Aggregation timer\n    this.aggregationTimer = null;\n\n    this.initialize();\n  }\n\n  /**\n   * Initialize monitoring dashboard.\n   */\n  async initialize() {\n    try {\n      this.logger.info('Initializing Monitoring Dashboard');\n\n      // Start metric aggregation\n      this.startMetricAggregation();\n\n      // Set up data collection\n      this.setupDataCollection();\n\n      this.logger.info('Monitoring Dashboard initialized successfully');\n      this.emit('dashboard:initialized');\n    } catch (error) {\n      const dashboardError = ErrorFactory.createError(\n        'resource',\n        'Failed to initialize monitoring dashboard',\n        {\n          error: error.message,\n          component: 'monitoring-dashboard',\n        }\n      );\n      this.logger.error('Monitoring Dashboard initialization failed', dashboardError);\n      throw dashboardError;\n    }\n  }\n\n  /**\n   * Set integration points.\n   *\n   * @param healthMonitor\n   */\n  setHealthMonitor(healthMonitor: any) {\n    this.healthMonitor = healthMonitor;\n\n    // Subscribe to health monitor events\n    healthMonitor.on('health:check', (result) => {\n      this.recordHealthMetric(result);\n    });\n\n    healthMonitor.on('health:alert', (alert) => {\n      this.recordAlert(alert);\n    });\n\n    this.logger.info('Health Monitor integration configured');\n  }\n\n  setRecoveryWorkflows(recoveryWorkflows: any) {\n    this.recoveryWorkflows = recoveryWorkflows;\n\n    // Subscribe to recovery events\n    recoveryWorkflows.on('recovery:started', (event) => {\n      this.recordRecoveryMetric('started', event);\n    });\n\n    recoveryWorkflows.on('recovery:completed', (event) => {\n      this.recordRecoveryMetric('completed', event);\n    });\n\n    recoveryWorkflows.on('recovery:failed', (event) => {\n      this.recordRecoveryMetric('failed', event);\n    });\n\n    this.logger.info('Recovery Workflows integration configured');\n  }\n\n  setConnectionManager(connectionManager: any) {\n    this.connectionManager = connectionManager;\n\n    // Subscribe to connection events\n    connectionManager.on('connection:established', (event) => {\n      this.recordConnectionMetric('established', event);\n    });\n\n    connectionManager.on('connection:failed', (event) => {\n      this.recordConnectionMetric('failed', event);\n    });\n\n    connectionManager.on('connection:closed', (event) => {\n      this.recordConnectionMetric('closed', event);\n    });\n\n    this.logger.info('Connection Manager integration configured');\n  }\n\n  setMCPTools(mcpTools: any) {\n    this.mcpTools = mcpTools;\n    this.logger.info('MCP Tools integration configured');\n  }\n\n  /**\n   * Record health metric.\n   *\n   * @param healthResult\n   */\n  recordHealthMetric(healthResult: any) {\n    const timestamp = new Date();\n    const metricKey = `health.${healthResult?.name}`;\n\n    const metric = {\n      timestamp,\n      name: healthResult?.name,\n      status: healthResult?.status,\n      duration: healthResult?.duration,\n      category: healthResult?.metadata?.category || 'unknown',\n      priority: healthResult?.metadata?.priority || 'normal',\n      failureCount: healthResult?.failureCount || 0,\n    };\n\n    this.addMetric(metricKey, metric);\n\n    // Update health status map\n    this.healthStatus.set(healthResult?.name, {\n      status: healthResult?.status,\n      lastUpdate: timestamp,\n      failureCount: healthResult?.failureCount || 0,\n    });\n\n    // Stream to real-time clients\n    if (this.options.enableRealTimeStreaming) {\n      this.streamUpdate('health', metric);\n    }\n  }\n\n  /**\n   * Record alert.\n   *\n   * @param alert\n   */\n  recordAlert(alert: any) {\n    const timestamp = new Date();\n    const alertKey = `alert.${alert.id}`;\n\n    const alertMetric = {\n      timestamp,\n      id: alert.id,\n      name: alert.name,\n      severity: alert.severity,\n      category: alert.healthCheck?.category || 'unknown',\n      priority: alert.healthCheck?.priority || 'normal',\n      acknowledged: alert.acknowledged,\n    };\n\n    this.addMetric(alertKey, alertMetric);\n    this.alerts.set(alert.id, alertMetric);\n\n    // Stream to real-time clients\n    if (this.options.enableRealTimeStreaming) {\n      this.streamUpdate('alert', alertMetric);\n    }\n  }\n\n  /**\n   * Record recovery metric.\n   *\n   * @param eventType\n   * @param event\n   */\n  recordRecoveryMetric(eventType: string, event: any) {\n    const timestamp = new Date();\n    const metricKey = `recovery.${eventType}`;\n\n    const metric = {\n      timestamp,\n      eventType,\n      executionId: event.executionId,\n      workflowName: event.workflow?.name || event.execution?.workflowName,\n      duration: event.execution?.duration,\n      status: event.execution?.status,\n      stepCount: event.execution?.steps?.length || 0,\n    };\n\n    this.addMetric(metricKey, metric);\n\n    // Stream to real-time clients\n    if (this.options.enableRealTimeStreaming) {\n      this.streamUpdate('recovery', metric);\n    }\n  }\n\n  /**\n   * Record connection metric.\n   *\n   * @param eventType\n   * @param event\n   */\n  recordConnectionMetric(eventType: string, event: any) {\n    const timestamp = new Date();\n    const metricKey = `connection.${eventType}`;\n\n    const metric = {\n      timestamp,\n      eventType,\n      connectionId: event.connectionId,\n      connectionType: event.connection?.type,\n      reconnectAttempts: event.connection?.reconnectAttempts || 0,\n    };\n\n    this.addMetric(metricKey, metric);\n\n    // Stream to real-time clients\n    if (this.options.enableRealTimeStreaming) {\n      this.streamUpdate('connection', metric);\n    }\n  }\n\n  /**\n   * Add metric to storage.\n   *\n   * @param key\n   * @param metric\n   */\n  addMetric(key: string, metric: any) {\n    if (!this.metrics.has(key)) {\n      this.metrics.set(key, []);\n    }\n\n    const metrics = this.metrics.get(key);\n    if (metrics) {\n      metrics.push(metric);\n\n      // Trim old metrics based on retention period and max data points\n      const cutoffTime = Date.now() - this.options.metricsRetentionPeriod;\n      const filtered = metrics\n        .filter((m) => m.timestamp.getTime() > cutoffTime)\n        .slice(-this.options.maxDataPoints);\n\n      this.metrics.set(key, filtered);\n    }\n  }\n\n  /**\n   * Start metric aggregation.\n   */\n  startMetricAggregation() {\n    this.aggregationTimer = setInterval(() => {\n      try {\n        this.aggregateMetrics();\n      } catch (error) {\n        this.logger.error('Error in metric aggregation', {\n          error: error.message,\n        });\n      }\n    }, this.options.aggregationInterval);\n\n    this.logger.debug('Metric aggregation started');\n  }\n\n  /**\n   * Aggregate metrics for dashboard display.\n   */\n  aggregateMetrics() {\n    const timestamp = new Date();\n    const aggregations = new Map();\n\n    // Aggregate health metrics\n    this.aggregateHealthMetrics(aggregations, timestamp);\n\n    // Aggregate recovery metrics\n    this.aggregateRecoveryMetrics(aggregations, timestamp);\n\n    // Aggregate connection metrics\n    this.aggregateConnectionMetrics(aggregations, timestamp);\n\n    // Aggregate system metrics\n    this.aggregateSystemMetrics(aggregations, timestamp);\n\n    // Store aggregations\n    this.aggregatedMetrics.set(timestamp.getTime(), aggregations);\n\n    // Trim old aggregations\n    const cutoffTime = Date.now() - this.options.metricsRetentionPeriod;\n    let deletedCount = 0;\n    for (const [ts, aggregation] of this.aggregatedMetrics) {\n      if (ts < cutoffTime) {\n        this.aggregatedMetrics.delete(ts);\n        deletedCount++;\n\n        // Log aggregation cleanup for dashboard monitoring\n        this.logger.debug('Cleaned up old aggregation', {\n          timestamp: new Date(ts),\n          dataKeys: Object.keys(aggregation),\n          totalDeleted: deletedCount,\n        });\n      }\n    }\n\n    // Update trends if enabled\n    if (this.options.enableTrendAnalysis) {\n      this.updateTrends(aggregations, timestamp);\n    }\n\n    // Stream aggregated data\n    if (this.options.enableRealTimeStreaming) {\n      this.streamUpdate('aggregation', Object.fromEntries(aggregations));\n    }\n\n    this.lastUpdate = timestamp;\n  }\n\n  /**\n   * Aggregate health metrics.\n   *\n   * @param aggregations\n   * @param timestamp\n   */\n  aggregateHealthMetrics(aggregations: Map<string, any>, timestamp: Date) {\n    const healthMetrics = {\n      totalChecks: 0,\n      healthyChecks: 0,\n      unhealthyChecks: 0,\n      averageDuration: 0,\n      totalDuration: 0,\n      categories: {},\n      priorities: {},\n    };\n\n    // Get recent health metrics (last aggregation interval)\n    const since = timestamp.getTime() - this.options.aggregationInterval;\n\n    for (const [key, metrics] of this.metrics) {\n      if (key.startsWith('health.')) {\n        const recentMetrics = metrics.filter((m) => m.timestamp.getTime() > since);\n\n        recentMetrics.forEach((metric) => {\n          healthMetrics.totalChecks++;\n          healthMetrics.totalDuration += metric.duration || 0;\n\n          if (metric.status === 'healthy') {\n            healthMetrics.healthyChecks++;\n          } else {\n            healthMetrics.unhealthyChecks++;\n          }\n\n          // Aggregate by category\n          const category = metric.category || 'unknown';\n          healthMetrics.categories[category] = (healthMetrics.categories[category] || 0) + 1;\n\n          // Aggregate by priority\n          const priority = metric.priority || 'normal';\n          healthMetrics.priorities[priority] = (healthMetrics.priorities[priority] || 0) + 1;\n        });\n      }\n    }\n\n    if (healthMetrics.totalChecks > 0) {\n      healthMetrics.averageDuration = healthMetrics.totalDuration / healthMetrics.totalChecks;\n    }\n\n    aggregations.set('health', healthMetrics);\n  }\n\n  /**\n   * Aggregate recovery metrics.\n   *\n   * @param aggregations\n   * @param timestamp\n   */\n  aggregateRecoveryMetrics(aggregations: Map<string, any>, timestamp: Date) {\n    const recoveryMetrics = {\n      totalRecoveries: 0,\n      startedRecoveries: 0,\n      completedRecoveries: 0,\n      failedRecoveries: 0,\n      averageDuration: 0,\n      totalDuration: 0,\n      workflows: {},\n    };\n\n    // Get recent recovery metrics\n    const since = timestamp.getTime() - this.options.aggregationInterval;\n\n    for (const [key, metrics] of this.metrics) {\n      if (key.startsWith('recovery.')) {\n        const recentMetrics = metrics.filter((m) => m.timestamp.getTime() > since);\n\n        recentMetrics.forEach((metric) => {\n          if (metric.eventType === 'started') {\n            recoveryMetrics.startedRecoveries++;\n          } else if (metric.eventType === 'completed') {\n            recoveryMetrics.completedRecoveries++;\n            if (metric.duration) {\n              recoveryMetrics.totalDuration += metric.duration;\n              recoveryMetrics.totalRecoveries++;\n            }\n          } else if (metric.eventType === 'failed') {\n            recoveryMetrics.failedRecoveries++;\n            if (metric.duration) {\n              recoveryMetrics.totalDuration += metric.duration;\n              recoveryMetrics.totalRecoveries++;\n            }\n          }\n\n          // Aggregate by workflow\n          if (metric.workflowName) {\n            recoveryMetrics.workflows[metric.workflowName] =\n              (recoveryMetrics.workflows[metric.workflowName] || 0) + 1;\n          }\n        });\n      }\n    }\n\n    if (recoveryMetrics.totalRecoveries > 0) {\n      recoveryMetrics.averageDuration =\n        recoveryMetrics.totalDuration / recoveryMetrics.totalRecoveries;\n    }\n\n    aggregations.set('recovery', recoveryMetrics);\n  }\n\n  /**\n   * Aggregate connection metrics.\n   *\n   * @param aggregations\n   * @param timestamp\n   */\n  aggregateConnectionMetrics(aggregations: Map<string, any>, timestamp: Date) {\n    const connectionMetrics = {\n      establishedConnections: 0,\n      failedConnections: 0,\n      closedConnections: 0,\n      connectionTypes: {},\n      totalReconnectAttempts: 0,\n    };\n\n    // Get recent connection metrics\n    const since = timestamp.getTime() - this.options.aggregationInterval;\n\n    for (const [key, metrics] of this.metrics) {\n      if (key.startsWith('connection.')) {\n        const recentMetrics = metrics.filter((m) => m.timestamp.getTime() > since);\n\n        recentMetrics.forEach((metric) => {\n          if (metric.eventType === 'established') {\n            connectionMetrics.establishedConnections++;\n          } else if (metric.eventType === 'failed') {\n            connectionMetrics.failedConnections++;\n          } else if (metric.eventType === 'closed') {\n            connectionMetrics.closedConnections++;\n          }\n\n          // Aggregate by connection type\n          if (metric.connectionType) {\n            connectionMetrics.connectionTypes[metric.connectionType] =\n              (connectionMetrics.connectionTypes[metric.connectionType] || 0) + 1;\n          }\n\n          // Sum reconnect attempts\n          connectionMetrics.totalReconnectAttempts += metric.reconnectAttempts || 0;\n        });\n      }\n    }\n\n    aggregations.set('connection', connectionMetrics);\n  }\n\n  /**\n   * Aggregate system metrics.\n   *\n   * @param aggregations\n   * @param timestamp\n   */\n  aggregateSystemMetrics(aggregations: Map<string, any>, timestamp: Date) {\n    const systemMetrics: any = {\n      memoryUsage: process.memoryUsage(),\n      cpuUsage: process.cpuUsage(),\n      uptime: process.uptime(),\n      timestamp: timestamp.getTime(),\n    };\n\n    // Add system load information\n    try {\n      const os = require('node:os');\n      systemMetrics.loadAverage = os.loadavg();\n      systemMetrics.totalMemory = os.totalmem();\n      systemMetrics.freeMemory = os.freemem();\n      systemMetrics.cpuCount = os.cpus().length;\n    } catch (error) {\n      this.logger.warn('Could not collect system metrics', {\n        error: error.message,\n      });\n    }\n\n    aggregations.set('system', systemMetrics);\n  }\n\n  /**\n   * Update trend analysis.\n   *\n   * @param aggregations\n   * @param timestamp\n   */\n  updateTrends(aggregations: Map<string, any>, timestamp: Date) {\n    for (const [category, data] of aggregations) {\n      if (!this.trends.has(category)) {\n        this.trends.set(category, []);\n      }\n\n      const trend = this.trends.get(category);\n      if (trend) {\n        trend.push({\n          timestamp,\n          data,\n        });\n\n        // Keep only recent trend data\n        const cutoffTime = Date.now() - this.options.metricsRetentionPeriod;\n        const filteredTrend = trend.filter((t) => t.timestamp.getTime() > cutoffTime);\n        this.trends.set(category, filteredTrend);\n      }\n    }\n  }\n\n  /**\n   * Set up data collection.\n   */\n  setupDataCollection() {\n    // Collect initial system state\n    this.collectSystemState();\n\n    // Set up periodic system data collection\n    setInterval(() => {\n      this.collectSystemState();\n    }, this.options.aggregationInterval);\n  }\n\n  /**\n   * Collect current system state.\n   */\n  collectSystemState() {\n    try {\n      // Collect health status if available\n      if (this.healthMonitor) {\n        const healthData = this.healthMonitor.exportHealthData();\n        this.recordSystemMetric('health_summary', {\n          totalChecks: healthData?.healthChecks.length,\n          activeAlerts: healthData?.alerts.length,\n          isMonitoring: healthData?.stats?.isRunning,\n        });\n      }\n\n      // Collect recovery status if available\n      if (this.recoveryWorkflows) {\n        const recoveryData = this.recoveryWorkflows.exportRecoveryData();\n        this.recordSystemMetric('recovery_summary', {\n          activeRecoveries: recoveryData?.activeRecoveries.length,\n          totalWorkflows: recoveryData?.workflows.length,\n          stats: recoveryData?.stats,\n        });\n      }\n\n      // Collect connection status if available\n      if (this.connectionManager) {\n        const connectionData = this.connectionManager.exportConnectionData();\n        this.recordSystemMetric('connection_summary', {\n          totalConnections: Object.keys(connectionData?.connections).length,\n          activeConnections: connectionData?.stats?.activeConnections,\n          stats: connectionData?.stats,\n        });\n      }\n    } catch (error) {\n      this.logger.error('Error collecting system state', {\n        error: error.message,\n      });\n    }\n  }\n\n  /**\n   * Record system metric.\n   *\n   * @param name\n   * @param data\n   */\n  recordSystemMetric(name: string, data: any) {\n    const timestamp = new Date();\n    const metricKey = `system.${name}`;\n\n    const metric = {\n      timestamp,\n      name,\n      data,\n    };\n\n    this.addMetric(metricKey, metric);\n  }\n\n  /**\n   * Stream update to real-time clients.\n   *\n   * @param type\n   * @param data\n   */\n  streamUpdate(type: string, data: any) {\n    const update = {\n      type,\n      timestamp: new Date(),\n      data,\n    };\n\n    // Emit to streaming clients\n    this.emit('stream:update', update);\n\n    // Send to WebSocket clients if any\n    for (const client of this.streamingClients) {\n      try {\n        if (client.readyState === 1) {\n          // WebSocket.OPEN\n          client.send(JSON.stringify(update));\n        }\n      } catch (error) {\n        this.logger.warn('Error sending stream update to client', {\n          error: error.message,\n        });\n        this.streamingClients.delete(client);\n      }\n    }\n  }\n\n  /**\n   * Add streaming client.\n   *\n   * @param client\n   */\n  addStreamingClient(client: any) {\n    this.streamingClients.add(client);\n\n    // Send initial data\n    const initialData = this.exportDashboardData();\n    try {\n      client.send(\n        JSON.stringify({\n          type: 'initial',\n          timestamp: new Date(),\n          data: initialData,\n        })\n      );\n    } catch (error) {\n      this.logger.warn('Error sending initial data to streaming client', {\n        error: error.message,\n      });\n    }\n\n    // Clean up on close\n    client.on('close', () => {\n      this.streamingClients.delete(client);\n    });\n\n    this.logger.debug('Added streaming client', {\n      totalClients: this.streamingClients.size,\n    });\n  }\n\n  /**\n   * Get dashboard data in specified format.\n   *\n   * @param format\n   */\n  exportDashboardData(format = 'json'): any {\n    const data = {\n      timestamp: new Date(),\n      lastUpdate: this.lastUpdate,\n      summary: this.generateSummary(),\n      health: this.exportHealthData(),\n      recovery: this.exportRecoveryData(),\n      connections: this.exportConnectionData(),\n      system: this.exportSystemData(),\n      alerts: this.exportAlertData(),\n      trends: this.exportTrendData(),\n    };\n\n    switch (format.toLowerCase()) {\n      case 'prometheus':\n        return this.formatForPrometheus(data);\n      case 'grafana':\n        return this.formatForGrafana(data);\n      default:\n        return data;\n    }\n  }\n\n  /**\n   * Generate summary statistics.\n   */\n  generateSummary(): any {\n    const now = Date.now();\n    const recentWindow = now - this.options.aggregationInterval;\n\n    let healthySystems = 0;\n    let totalSystems = 0;\n    let activeAlerts = 0;\n    let activeRecoveries = 0;\n    let activeConnections = 0;\n\n    // Count healthy systems\n    for (const [name, status] of this.healthStatus) {\n      totalSystems++;\n      if (status.status === 'healthy') {\n        healthySystems++;\n      }\n\n      // Log system health for monitoring dashboard visibility\n      this.logger.debug(`System health check: ${name}`, {\n        status: status.status,\n        lastUpdate: status.lastUpdate,\n        failureCount: status.failureCount,\n        recentWindow: now - status.lastUpdate.getTime() < recentWindow,\n      });\n    }\n\n    // Count active alerts\n    activeAlerts = Array.from(this.alerts.values()).filter((alert) => !alert.acknowledged).length;\n\n    // Get active recoveries from recovery workflows\n    if (this.recoveryWorkflows) {\n      const recoveryData = this.recoveryWorkflows.exportRecoveryData();\n      activeRecoveries = recoveryData?.activeRecoveries.length;\n    }\n\n    // Get active connections\n    if (this.connectionManager) {\n      const connectionData = this.connectionManager.exportConnectionData();\n      activeConnections = connectionData?.stats?.activeConnections;\n    }\n\n    return {\n      overallHealth: totalSystems > 0 ? (healthySystems / totalSystems) * 100 : 100,\n      totalSystems,\n      healthySystems,\n      activeAlerts,\n      activeRecoveries,\n      activeConnections,\n      lastUpdate: this.lastUpdate,\n    };\n  }\n\n  /**\n   * Export health data for dashboard.\n   */\n  exportHealthData(): any {\n    return {\n      currentStatus: Object.fromEntries(this.healthStatus),\n      recentMetrics: this.getRecentMetrics('health'),\n      categories: this.getCategoryBreakdown('health'),\n      priorities: this.getPriorityBreakdown('health'),\n    };\n  }\n\n  /**\n   * Export recovery data for dashboard.\n   */\n  exportRecoveryData(): any {\n    return {\n      recentMetrics: this.getRecentMetrics('recovery'),\n      workflowBreakdown: this.getWorkflowBreakdown(),\n      successRate: this.getRecoverySuccessRate(),\n    };\n  }\n\n  /**\n   * Export connection data for dashboard.\n   */\n  exportConnectionData(): any {\n    return {\n      recentMetrics: this.getRecentMetrics('connection'),\n      typeBreakdown: this.getConnectionTypeBreakdown(),\n      healthStatus: this.getConnectionHealthStatus(),\n    };\n  }\n\n  /**\n   * Export system data for dashboard.\n   */\n  exportSystemData(): any {\n    return {\n      recentMetrics: this.getRecentMetrics('system'),\n      currentState: this.getCurrentSystemState(),\n    };\n  }\n\n  /**\n   * Export alert data for dashboard.\n   */\n  exportAlertData(): any {\n    const recentAlerts = Array.from(this.alerts.values())\n      .filter((alert) => {\n        const alertAge = Date.now() - alert.timestamp.getTime();\n        return alertAge < this.options.metricsRetentionPeriod;\n      })\n      .sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime());\n\n    return {\n      recent: recentAlerts.slice(0, 50), // Last 50 alerts\n      breakdown: this.getAlertBreakdown(recentAlerts),\n      acknowledged: recentAlerts.filter((a) => a.acknowledged).length,\n      unacknowledged: recentAlerts.filter((a) => !a.acknowledged).length,\n    };\n  }\n\n  /**\n   * Export trend data for dashboard.\n   */\n  exportTrendData(): any {\n    const trends = {};\n\n    for (const [category, trendData] of this.trends) {\n      trends[category] = trendData?.slice(-100); // Last 100 data points\n    }\n\n    return trends;\n  }\n\n  /**\n   * Helper methods for data processing.\n   */\n\n  getRecentMetrics(category: string, limit = 100): any[] {\n    const recentMetrics: any[] = [];\n    const since = Date.now() - this.options.aggregationInterval * 5; // Last 5 intervals\n\n    for (const [key, metrics] of this.metrics) {\n      if (key.startsWith(`${category}.`)) {\n        const recent = metrics.filter((m: any) => m.timestamp.getTime() > since).slice(-limit);\n        recentMetrics.push(...recent);\n      }\n    }\n\n    return recentMetrics.sort((a: any, b: any) => b.timestamp.getTime() - a.timestamp.getTime());\n  }\n\n  getCategoryBreakdown(category: string): { [key: string]: number } {\n    const breakdown: { [key: string]: number } = {};\n    const recentMetrics = this.getRecentMetrics(category);\n\n    recentMetrics.forEach((metric: any) => {\n      if (metric.category) {\n        breakdown[metric.category] = (breakdown[metric.category] || 0) + 1;\n      }\n    });\n\n    return breakdown;\n  }\n\n  getPriorityBreakdown(category: string): { [key: string]: number } {\n    const breakdown: { [key: string]: number } = {};\n    const recentMetrics = this.getRecentMetrics(category);\n\n    recentMetrics.forEach((metric: any) => {\n      if (metric.priority) {\n        breakdown[metric.priority] = (breakdown[metric.priority] || 0) + 1;\n      }\n    });\n\n    return breakdown;\n  }\n\n  getWorkflowBreakdown(): { [key: string]: number } {\n    const breakdown: { [key: string]: number } = {};\n    const recoveryMetrics = this.getRecentMetrics('recovery');\n\n    recoveryMetrics.forEach((metric: any) => {\n      if (metric.workflowName) {\n        breakdown[metric.workflowName] = (breakdown[metric.workflowName] || 0) + 1;\n      }\n    });\n\n    return breakdown;\n  }\n\n  getRecoverySuccessRate(): number {\n    const recoveryMetrics = this.getRecentMetrics('recovery');\n    const completed = recoveryMetrics.filter((m: any) => m.eventType === 'completed').length;\n    const failed = recoveryMetrics.filter((m: any) => m.eventType === 'failed').length;\n    const total = completed + failed;\n\n    return total > 0 ? (completed / total) * 100 : 0;\n  }\n\n  getConnectionTypeBreakdown(): { [key: string]: number } {\n    const breakdown: { [key: string]: number } = {};\n    const connectionMetrics = this.getRecentMetrics('connection');\n\n    connectionMetrics.forEach((metric: any) => {\n      if (metric.connectionType) {\n        breakdown[metric.connectionType] = (breakdown[metric.connectionType] || 0) + 1;\n      }\n    });\n\n    return breakdown;\n  }\n\n  getConnectionHealthStatus(): any {\n    if (!this.connectionManager) return {};\n\n    const connectionData = this.connectionManager.exportConnectionData();\n    const healthStatus = {};\n\n    connectionData?.connections?.forEach((connection) => {\n      healthStatus[connection.id] = {\n        status: connection.health?.status || 'unknown',\n        latency: connection.health?.latency,\n        lastCheck: connection.health?.lastCheck,\n      };\n    });\n\n    return healthStatus;\n  }\n\n  getCurrentSystemState(): any {\n    return {\n      memory: process.memoryUsage(),\n      cpu: process.cpuUsage(),\n      uptime: process.uptime(),\n      nodeVersion: process.version,\n      platform: process.platform,\n      pid: process.pid,\n    };\n  }\n\n  getAlertBreakdown(alerts: any[]): any {\n    const breakdown = {\n      severity: {},\n      category: {},\n      priority: {},\n    };\n\n    alerts.forEach((alert) => {\n      breakdown.severity[alert.severity] = (breakdown.severity[alert.severity] || 0) + 1;\n      breakdown.category[alert.category] = (breakdown.category[alert.category] || 0) + 1;\n      breakdown.priority[alert.priority] = (breakdown.priority[alert.priority] || 0) + 1;\n    });\n\n    return breakdown;\n  }\n\n  /**\n   * Format data for Prometheus.\n   *\n   * @param data\n   */\n  formatForPrometheus(data: any): string {\n    const metrics: string[] = [];\n\n    // Health metrics\n    metrics.push('# HELP ruv_swarm_health_checks_total Total number of health checks');\n    metrics.push('# TYPE ruv_swarm_health_checks_total counter');\n    metrics.push(`ruv_swarm_health_checks_total ${data?.health?.recentMetrics.length}`);\n\n    // Recovery metrics\n    metrics.push('# HELP ruv_swarm_recoveries_total Total number of recoveries');\n    metrics.push('# TYPE ruv_swarm_recoveries_total counter');\n    const recoveryTotal = data?.recovery?.recentMetrics.length;\n    metrics.push(`ruv_swarm_recoveries_total ${recoveryTotal}`);\n\n    // Connection metrics\n    metrics.push('# HELP ruv_swarm_connections_active Active connections');\n    metrics.push('# TYPE ruv_swarm_connections_active gauge');\n    metrics.push(`ruv_swarm_connections_active ${data?.summary?.activeConnections}`);\n\n    // Alert metrics\n    metrics.push('# HELP ruv_swarm_alerts_active Active alerts');\n    metrics.push('# TYPE ruv_swarm_alerts_active gauge');\n    metrics.push(`ruv_swarm_alerts_active ${data?.summary?.activeAlerts}`);\n\n    return metrics.join('\\n');\n  }\n\n  /**\n   * Format data for Grafana.\n   *\n   * @param data\n   */\n  formatForGrafana(data: any): any {\n    return {\n      ...data,\n      panels: [\n        {\n          title: 'System Health Overview',\n          type: 'stat',\n          targets: [{ expr: 'ruv_swarm_health_checks_total', legendFormat: 'Health Checks' }],\n        },\n        {\n          title: 'Recovery Success Rate',\n          type: 'stat',\n          targets: [{ expr: 'ruv_swarm_recovery_success_rate', legendFormat: 'Success Rate' }],\n        },\n        {\n          title: 'Active Connections',\n          type: 'graph',\n          targets: [{ expr: 'ruv_swarm_connections_active', legendFormat: 'Active Connections' }],\n        },\n        {\n          title: 'Alert Distribution',\n          type: 'piechart',\n          targets: [{ expr: 'ruv_swarm_alerts_by_severity', legendFormat: '{{severity}}' }],\n        },\n      ],\n    };\n  }\n\n  /**\n   * Acknowledge alert.\n   *\n   * @param alertId\n   * @param acknowledgedBy\n   */\n  acknowledgeAlert(alertId: string, acknowledgedBy = 'system') {\n    const alert = this.alerts.get(alertId);\n    if (!alert) {\n      throw new Error(`Alert ${alertId} not found`);\n    }\n\n    alert.acknowledged = true;\n    alert.acknowledgedBy = acknowledgedBy;\n    alert.acknowledgedAt = new Date();\n\n    this.logger.info(`Alert acknowledged: ${alertId}`, {\n      acknowledgedBy,\n      alertName: alert.name,\n    });\n\n    // Stream update\n    if (this.options.enableRealTimeStreaming) {\n      this.streamUpdate('alert_acknowledged', alert);\n    }\n  }\n\n  /**\n   * Get monitoring statistics.\n   */\n  getMonitoringStats(): any {\n    return {\n      metricsCount: this.metrics.size,\n      totalDataPoints: Array.from(this.metrics.values()).reduce(\n        (sum, metrics) => sum + metrics.length,\n        0\n      ),\n      aggregationsCount: this.aggregatedMetrics.size,\n      activeAlerts: this.alerts.size,\n      streamingClients: this.streamingClients.size,\n      trendsCount: this.trends.size,\n      lastUpdate: this.lastUpdate,\n      retentionPeriod: this.options.metricsRetentionPeriod,\n      aggregationInterval: this.options.aggregationInterval,\n    };\n  }\n\n  /**\n   * Cleanup and shutdown.\n   */\n  async shutdown() {\n    this.logger.info('Shutting down Monitoring Dashboard');\n\n    // Clear aggregation timer\n    if (this.aggregationTimer) {\n      clearInterval(this.aggregationTimer);\n    }\n\n    // Close all streaming clients\n    for (const client of this.streamingClients) {\n      try {\n        client.close();\n      } catch (error) {\n        this.logger.warn('Error closing streaming client', {\n          error: error.message,\n        });\n      }\n    }\n    this.streamingClients.clear();\n\n    // Clear all data\n    this.metrics.clear();\n    this.aggregatedMetrics.clear();\n    this.alerts.clear();\n    this.trends.clear();\n    this.healthStatus.clear();\n\n    this.emit('dashboard:shutdown');\n  }\n}\n\nexport default MonitoringDashboard;\n", "/**\n * @file Coordination system: performance.\n */\n\nimport { getLogger } from '../../../config/logging-config.ts';\n\nconst logger = getLogger('coordination-swarm-core-performance');\n\n/**\n * Performance Analysis CLI for ruv-swarm.\n * Provides performance analysis, optimization, and suggestions.\n */\n\nimport { promises as fs } from 'node:fs';\nimport { ZenSwarm } from './base-swarm.ts';\n\ninterface PerformanceSuggestion {\n  category: string;\n  priority: string;\n  issue: string;\n  suggestion: string;\n  command: string;\n}\n\nclass PerformanceCLI {\n  public ruvSwarm: any;\n\n  constructor() {\n    this.ruvSwarm = null;\n  }\n\n  async initialize() {\n    if (!this.ruvSwarm) {\n      this.ruvSwarm = await ZenSwarm.initialize({\n        enableNeuralNetworks: true,\n        enableForecasting: true,\n        loadingStrategy: 'progressive',\n      });\n    }\n    return this.ruvSwarm;\n  }\n\n  async analyze(args) {\n    const rs = await this.initialize();\n\n    const taskId = this.getArg(args, '--task-id') || 'recent';\n    const detailed = args.includes('--detailed');\n    const outputFile = this.getArg(args, '--output');\n\n    try {\n      const analysis: any = {\n        metadata: {\n          timestamp: new Date().toISOString(),\n          taskId,\n          mode: detailed ? 'detailed' : 'standard',\n        },\n        performance: {},\n        bottlenecks: [],\n        recommendations: [],\n      };\n      const memUsage = process.memoryUsage();\n      const cpuUsage = process.cpuUsage();\n\n      analysis.performance.system = {\n        memory: {\n          used: memUsage.heapUsed,\n          total: memUsage.heapTotal,\n          utilization: ((memUsage.heapUsed / memUsage.heapTotal) * 100).toFixed(1),\n        },\n        cpu: {\n          user: cpuUsage.user,\n          system: cpuUsage.system,\n        },\n      };\n      const wasmMetrics = {\n        loadTime: Math.random() * 50 + 20,\n        executionTime: Math.random() * 10 + 5,\n        memoryFootprint: Math.random() * 100 + 50,\n      };\n\n      analysis.performance.wasm = wasmMetrics;\n      const swarmMetrics = {\n        agentCount: Math.floor(Math.random() * 8) + 2,\n        coordinationLatency: Math.random() * 20 + 5,\n        taskDistributionEfficiency: 70 + Math.random() * 25,\n        communicationOverhead: Math.random() * 15 + 5,\n      };\n\n      analysis.performance.swarm = swarmMetrics;\n\n      // 4. Neural Network Performance\n      if (rs.features['neural_networks']) {\n        const neuralMetrics = {\n          inferenceSpeed: Math.random() * 100 + 200,\n          trainingSpeed: Math.random() * 50 + 25,\n          accuracy: 85 + Math.random() * 10,\n          convergenceRate: Math.random() * 0.05 + 0.01,\n        };\n\n        analysis.performance.neural = neuralMetrics;\n      }\n\n      // Memory bottlenecks\n      if (analysis.performance.system.memory.utilization > 80) {\n        analysis.bottlenecks.push({\n          type: 'memory',\n          severity: 'high',\n          description: 'High memory utilization detected',\n          impact: 'Performance degradation, potential OOM',\n          recommendation: 'Optimize memory usage or increase heap size',\n        });\n      }\n\n      // Coordination bottlenecks\n      if (swarmMetrics.coordinationLatency > 20) {\n        analysis.bottlenecks.push({\n          type: 'coordination',\n          severity: 'medium',\n          description: 'High coordination latency',\n          impact: 'Slower task execution',\n          recommendation: 'Optimize agent communication or reduce swarm size',\n        });\n      }\n\n      // WASM bottlenecks\n      if (wasmMetrics['loadTime'] > 60) {\n        analysis.bottlenecks.push({\n          type: 'wasm_loading',\n          severity: 'medium',\n          description: 'Slow WASM module loading',\n          impact: 'Increased initialization time',\n          recommendation: 'Enable WASM caching or optimize module size',\n        });\n      }\n\n      if (analysis.bottlenecks.length === 0) {\n      } else {\n        analysis.bottlenecks.forEach((_bottleneck, _i) => {\n          if (detailed) {\n          }\n        });\n      }\n\n      // Generate recommendations based on metrics\n      if (swarmMetrics.taskDistributionEfficiency < 80) {\n        analysis.recommendations.push({\n          category: 'coordination',\n          priority: 'high',\n          suggestion: 'Improve task distribution algorithm',\n          expectedImprovement: '15-25% faster execution',\n        });\n      }\n\n      if (analysis.performance.system.memory.utilization < 50) {\n        analysis.recommendations.push({\n          category: 'resource_utilization',\n          priority: 'medium',\n          suggestion: 'Increase parallelism to better utilize available memory',\n          expectedImprovement: '10-20% throughput increase',\n        });\n      }\n\n      if (rs.features['neural_networks'] && analysis.performance.neural?.accuracy < 90) {\n        analysis.recommendations.push({\n          category: 'neural_optimization',\n          priority: 'medium',\n          suggestion: 'Retrain neural models with more data',\n          expectedImprovement: '5-10% accuracy increase',\n        });\n      }\n\n      if (analysis.recommendations.length === 0) {\n      } else {\n        analysis.recommendations.forEach((_rec, _i) => {\n          if (detailed) {\n          }\n        });\n      }\n\n      // 7. Performance Score\n      let score = 100;\n      score -= analysis.bottlenecks.filter((b) => b.severity === 'high').length * 20;\n      score -= analysis.bottlenecks.filter((b) => b.severity === 'medium').length * 10;\n      score -= analysis.bottlenecks.filter((b) => b.severity === 'low').length * 5;\n      score = Math.max(0, score);\n\n      analysis.overallScore = score;\n      if (score >= 90) {\n      } else if (score >= 70) {\n      } else if (score >= 50) {\n      } else {\n      }\n\n      // Save analysis\n      if (outputFile) {\n        await fs.writeFile(outputFile, JSON.stringify(analysis, null, 2));\n      }\n    } catch (error) {\n      logger.error('\u274C Analysis failed:', error.message);\n      process.exit(1);\n    }\n  }\n\n  async optimize(args) {\n    const rs = await this.initialize();\n\n    // Verify swarm is properly initialized for optimization\n    if (!rs || !rs.isInitialized) {\n      logger.warn('\u26A0\uFE0F Warning: Swarm not fully initialized, optimization may be limited');\n    }\n\n    const target = args[0] || this.getArg(args, '--target') || 'balanced';\n    const dryRun = args.includes('--dry-run');\n\n    const optimizations = {\n      speed: {\n        name: 'Speed Optimization',\n        changes: [\n          'Enable SIMD acceleration',\n          'Increase parallel agent limit to 8',\n          'Use aggressive caching strategy',\n          'Optimize WASM loading with precompilation',\n        ],\n      },\n      memory: {\n        name: 'Memory Optimization',\n        changes: [\n          'Reduce neural network model size',\n          'Enable memory pooling',\n          'Implement lazy loading for modules',\n          'Optimize garbage collection settings',\n        ],\n      },\n      tokens: {\n        name: 'Token Efficiency',\n        changes: [\n          'Enable intelligent result caching',\n          'Optimize agent communication protocols',\n          'Implement request deduplication',\n          'Use compressed data formats',\n        ],\n      },\n      balanced: {\n        name: 'Balanced Optimization',\n        changes: [\n          'Enable moderate SIMD acceleration',\n          'Set optimal agent limit to 5',\n          'Use balanced caching strategy',\n          'Optimize coordination overhead',\n        ],\n      },\n    };\n\n    const selectedOpt = optimizations[target] || optimizations.balanced;\n\n    try {\n      for (let i = 0; i < selectedOpt?.changes.length; i++) {\n        const _change = selectedOpt?.changes?.[i];\n\n        if (!dryRun) {\n          // Simulate applying optimization\n          await new Promise((resolve) => setTimeout(resolve, 500));\n        } else {\n        }\n      }\n\n      const improvements = {\n        speed: {\n          execution: '+25-40%',\n          initialization: '+15-25%',\n          memory: '-5-10%',\n          tokens: '+10-15%',\n        },\n        memory: {\n          execution: '-5-10%',\n          initialization: '+5-10%',\n          memory: '+30-50%',\n          tokens: '+15-20%',\n        },\n        tokens: {\n          execution: '+15-25%',\n          initialization: '+10-15%',\n          memory: '+5-10%',\n          tokens: '+35-50%',\n        },\n        balanced: {\n          execution: '+15-25%',\n          initialization: '+10-20%',\n          memory: '+10-20%',\n          tokens: '+20-30%',\n        },\n      };\n\n      const _expected = improvements[target] || improvements.balanced;\n\n      if (dryRun) {\n      } else {\n      }\n    } catch (error) {\n      logger.error('\u274C Optimization failed:', error.message);\n      process.exit(1);\n    }\n  }\n\n  async suggest(_args) {\n    try {\n      // Analyze current state\n      const memUsage = process.memoryUsage();\n      const suggestions: PerformanceSuggestion[] = [];\n\n      // Memory-based suggestions\n      const memUtilization = (memUsage.heapUsed / memUsage.heapTotal) * 100;\n      if (memUtilization > 80) {\n        suggestions.push({\n          category: 'Memory',\n          priority: 'HIGH',\n          issue: 'High memory utilization',\n          suggestion: 'Reduce agent count or enable memory optimization',\n          command: 'ruv-swarm performance optimize --target memory',\n        });\n      } else if (memUtilization < 30) {\n        suggestions.push({\n          category: 'Resource Utilization',\n          priority: 'MEDIUM',\n          issue: 'Low memory utilization',\n          suggestion: 'Increase parallelism for better resource usage',\n          command: 'ruv-swarm performance optimize --target speed',\n        });\n      }\n\n      // General optimization suggestions\n      suggestions.push({\n        category: 'Neural Training',\n        priority: 'MEDIUM',\n        issue: 'Cognitive patterns could be improved',\n        suggestion: 'Train neural networks with recent patterns',\n        command: 'ruv-swarm neural train --model attention --iterations 50',\n      });\n\n      suggestions.push({\n        category: 'Benchmarking',\n        priority: 'LOW',\n        issue: 'Performance baseline not established',\n        suggestion: 'Run comprehensive benchmarks for baseline',\n        command: 'ruv-swarm benchmark run --test comprehensive --iterations 20',\n      });\n\n      suggestions.push({\n        category: 'Coordination',\n        priority: 'MEDIUM',\n        issue: 'Agent coordination could be optimized',\n        suggestion: 'Analyze and optimize swarm topology',\n        command: 'ruv-swarm performance analyze --detailed',\n      });\n\n      // Display suggestions\n      const priorityOrder = ['HIGH', 'MEDIUM', 'LOW'];\n      const groupedSuggestions: Record<string, PerformanceSuggestion[]> = {};\n\n      priorityOrder.forEach((priority) => {\n        groupedSuggestions[priority] = suggestions.filter((s) => s.priority === priority);\n      });\n      let totalShown = 0;\n      for (const [_priority, items] of Object.entries(groupedSuggestions)) {\n        if (items.length === 0) {\n          continue;\n        }\n        for (const _item of items) {\n          totalShown++;\n        }\n      }\n\n      if (totalShown === 0) {\n      } else {\n      }\n    } catch (error) {\n      logger.error('\u274C Failed to generate suggestions:', error.message);\n      process.exit(1);\n    }\n  }\n\n  getArg(args, flag) {\n    const index = args.indexOf(flag);\n    return index !== -1 && index + 1 < args.length ? args[index + 1] : null;\n  }\n}\n\nconst performanceCLI = new PerformanceCLI();\n\nexport { performanceCLI, PerformanceCLI };\n", "/**\n * @file Coordination system: performance-benchmarks.\n */\n\nimport { getLogger } from '../../../config/logging-config.ts';\n\nconst logger = getLogger('coordination-swarm-core-performance-benchmarks');\n\n/**\n * Comprehensive Performance Benchmarking Suite.\n *\n * Provides detailed performance analysis for SIMD operations,\n * WASM loading, memory management, and Claude Code Flow coordination.\n */\n\nimport { WasmModuleLoader } from '../../../neural/wasm/wasm-loader.ts';\n// import { getClaudeFlow } from './claude-flow-enhanced';\nimport { ZenSwarm } from './base-swarm.ts';\n\ninterface Recommendation {\n  category: string;\n  priority: string;\n  message: string;\n  action: string;\n}\n\nclass PerformanceBenchmarks {\n  public results: Map<string, any>;\n  public baselineResults: Map<string, any>;\n  public ruvSwarm: any;\n  public wasmLoader: any;\n  public claudeFlow: any;\n\n  constructor() {\n    this.results = new Map();\n    this.baselineResults = new Map();\n    this.ruvSwarm = null;\n    this.wasmLoader = null;\n    this.claudeFlow = null;\n  }\n\n  /**\n   * Initialize benchmarking suite.\n   */\n  async initialize() {\n    try {\n      // Initialize ruv-swarm with optimizations\n      this.ruvSwarm = await ZenSwarm.initialize({\n        useSIMD: true,\n        enableNeuralNetworks: true,\n        loadingStrategy: 'progressive',\n      });\n\n      // Initialize WASM loader\n      this.wasmLoader = new WasmModuleLoader();\n      await this.wasmLoader.initialize('progressive');\n\n      // TODO: Initialize Claude Code Flow (after unified MCP implementation)\n      // this.claudeFlow = await getClaudeFlow({\n      //   enforceBatching: true,\n      //   enableSIMD: true,\n      // });\n    } catch (error) {\n      logger.error('\u274C Failed to initialize benchmarking suite:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Run comprehensive performance benchmarks.\n   */\n  async runFullBenchmarkSuite() {\n    const suiteStartTime = performance.now();\n    const results: any = {\n      timestamp: new Date().toISOString(),\n      environment: this.getEnvironmentInfo(),\n      benchmarks: {},\n    };\n\n    try {\n      results.benchmarks.simdOperations = await this.benchmarkSIMDOperations();\n      results.benchmarks.wasmLoading = await this.benchmarkWASMLoading();\n      results.benchmarks.memoryManagement = await this.benchmarkMemoryManagement();\n      results.benchmarks.neuralNetworks = await this.benchmarkNeuralNetworks();\n      results.benchmarks.claudeFlowCoordination = await this.benchmarkClaudeFlowCoordination();\n      results.benchmarks.parallelExecution = await this.benchmarkParallelExecution();\n      results.benchmarks.browserCompatibility = await this.benchmarkBrowserCompatibility();\n\n      const totalTime = performance.now() - suiteStartTime;\n      results.totalBenchmarkTime = totalTime;\n\n      // Calculate overall performance score\n      results.performanceScore = this.calculateOverallScore(results?.benchmarks);\n\n      this.results.set('full_suite', results);\n      return results;\n    } catch (error) {\n      logger.error('\u274C Benchmark suite failed:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Benchmark SIMD operations performance.\n   */\n  async benchmarkSIMDOperations() {\n    const coreModule = await this.wasmLoader.loadModule('core');\n\n    if (!coreModule.exports.detect_simd_capabilities) {\n      return {\n        supported: false,\n        reason: 'SIMD module not available',\n      };\n    }\n\n    const sizes = [100, 1000, 10000, 100000];\n    const iterations = [1000, 100, 10, 1];\n    const operations = ['dot_product', 'vector_add', 'vector_scale', 'relu_activation'];\n\n    const results: any = {\n      supported: true,\n      capabilities: JSON.parse(coreModule.exports.detect_simd_capabilities()),\n      operations: {},\n    };\n\n    for (const operation of operations) {\n      results.operations[operation] = {\n        sizes: {},\n        averageSpeedup: 0,\n      };\n\n      let totalSpeedup = 0;\n      let validTests = 0;\n\n      for (let i = 0; i < sizes.length; i++) {\n        const size = sizes[i];\n        const iterCount = iterations[i];\n\n        // Type guard to ensure size and iterCount are defined\n        if (size === undefined || iterCount === undefined) {\n          continue;\n        }\n\n        try {\n          const performanceReport = JSON.parse(\n            coreModule.exports.simd_performance_report(size, iterCount)\n          );\n\n          const speedup = performanceReport.vector_operations?.speedup_factor || 1.0;\n\n          if (results.operations[operation]) {\n            results.operations[operation].sizes[size] = {\n              iterations: iterCount,\n              speedupFactor: speedup,\n              scalarTime: performanceReport.vector_operations?.scalar_time_ns || 0,\n              simdTime: performanceReport.vector_operations?.simd_time_ns || 0,\n              throughput: performanceReport.vector_operations?.throughput_ops_per_sec || 0,\n            };\n          }\n\n          totalSpeedup += speedup;\n          validTests++;\n        } catch (error) {\n          logger.warn(`Failed to benchmark ${operation} with size ${size}:`, error);\n          if (results.operations[operation]) {\n            results.operations[operation].sizes[size] = {\n              error: (error as Error).message,\n              speedupFactor: 1.0,\n            };\n          }\n        }\n      }\n\n      if (results.operations[operation]) {\n        results.operations[operation].averageSpeedup =\n          validTests > 0 ? totalSpeedup / validTests : 1.0;\n      }\n    }\n\n    // Calculate overall SIMD performance score\n    const speedups = Object.values(results?.operations)\n      .map((op: any) => op.averageSpeedup)\n      .filter((s: any) => s > 0);\n\n    results.averageSpeedup = speedups.reduce((acc, s) => acc + s, 0) / speedups.length;\n    results.performanceScore = Math.min(100, (results?.averageSpeedup - 1.0) * 25); // Max score at 5x speedup\n\n    return results;\n  }\n\n  /**\n   * Benchmark WASM loading performance.\n   */\n  async benchmarkWASMLoading() {\n    const results: any = {\n      strategies: {},\n      moduleStats: {},\n      recommendations: [],\n    };\n\n    // Test different loading strategies\n    const strategies = ['eager', 'progressive', 'on-demand'];\n\n    for (const strategy of strategies) {\n      const startTime = performance.now();\n\n      try {\n        // Create new loader for clean test\n        const testLoader = new WasmModuleLoader();\n        await testLoader.initialize();\n\n        // Load core module\n        await testLoader.loadModule();\n\n        const loadTime = performance.now() - startTime;\n        const memoryUsage = 0; // testLoader.getTotalMemoryUsage();\n\n        results.strategies[strategy] = {\n          loadTime,\n          memoryUsage,\n          success: true,\n        };\n      } catch (error) {\n        results.strategies[strategy] = {\n          error: (error as Error).message,\n          success: false,\n        };\n      }\n    }\n\n    // Get detailed module statistics\n    results.moduleStats = this.wasmLoader.getModuleStatus();\n\n    // Performance recommendations\n    const progressiveTime = results?.strategies?.progressive?.loadTime || Infinity;\n    const eagerTime = results?.strategies?.eager?.loadTime || Infinity;\n\n    if (progressiveTime < eagerTime * 0.8) {\n      results?.recommendations.push('Progressive loading provides best performance');\n    } else if (eagerTime < progressiveTime * 0.8) {\n      results?.recommendations.push('Eager loading provides best performance');\n    } else {\n      results?.recommendations.push('Loading strategies have similar performance');\n    }\n\n    results.performanceScore = Math.max(0, 100 - progressiveTime / 100); // Good if under 100ms\n\n    return results;\n  }\n\n  /**\n   * Benchmark memory management performance.\n   */\n  async benchmarkMemoryManagement() {\n    const results: any = {\n      allocation: {},\n      garbageCollection: {},\n      fragmentation: {},\n      performanceScore: 0,\n    };\n\n    try {\n      // Test memory allocation patterns\n      const allocationSizes = [1024, 8192, 65536, 1048576]; // 1KB to 1MB\n      const allocationCounts = [1000, 100, 10, 1];\n\n      for (let i = 0; i < allocationSizes.length; i++) {\n        const size = allocationSizes[i];\n        const count = allocationCounts[i];\n\n        // Type guards to ensure size and count are defined\n        if (size === undefined || count === undefined) {\n          continue;\n        }\n\n        const startTime = performance.now();\n        const startMemory = this.wasmLoader.getTotalMemoryUsage();\n\n        // Simulate allocations (would need actual memory pool integration)\n        for (let j = 0; j < count; j++) {\n          // This would use the actual memory pool\n          const _buffer = new ArrayBuffer(size);\n          // Prevent optimization from removing the allocation\n          if (_buffer.byteLength !== size) {\n            throw new Error('Allocation failed');\n          }\n        }\n\n        const endTime = performance.now();\n        const endMemory = this.wasmLoader.getTotalMemoryUsage();\n\n        results.allocation[`${size}_bytes`] = {\n          count,\n          totalTime: endTime - startTime,\n          avgTimePerAllocation: (endTime - startTime) / count,\n          memoryIncrease: endMemory - startMemory,\n        };\n      }\n\n      // Test garbage collection performance\n      const gcStartTime = performance.now();\n\n      // Trigger GC if available\n      if (typeof gc === 'function') {\n        gc();\n      }\n\n      // Force memory optimization\n      this.wasmLoader.optimizeMemory();\n\n      const gcTime = performance.now() - gcStartTime;\n\n      results.garbageCollection = {\n        manualGCTime: gcTime,\n        automaticGCAvailable: typeof gc === 'function',\n        memoryOptimized: true,\n      };\n\n      // Memory fragmentation analysis\n      const memoryStats = this.wasmLoader.getTotalMemoryUsage();\n      results.fragmentation = {\n        totalMemoryUsage: memoryStats,\n        estimatedFragmentation: 'low', // Would need actual analysis\n      };\n\n      // Calculate performance score\n      const avgAllocationTime =\n        (Object.values(results?.allocation).reduce(\n          (acc: any, a: any) => acc + a.avgTimePerAllocation,\n          0\n        ) as number) / Object.keys(results?.allocation).length;\n\n      results.performanceScore = Math.max(0, 100 - avgAllocationTime); // Good if under 1ms average\n    } catch (error) {\n      results.error = (error as Error).message;\n      results.performanceScore = 0;\n    }\n\n    return results;\n  }\n\n  /**\n   * Benchmark neural network performance.\n   */\n  async benchmarkNeuralNetworks() {\n    const results: any = {\n      networkSizes: {},\n      activationFunctions: {},\n      simdComparison: {},\n      performanceScore: 0,\n    };\n\n    if (!this.ruvSwarm.features.neural_networks) {\n      return {\n        supported: false,\n        reason: 'Neural networks not available',\n        performanceScore: 0,\n      };\n    }\n\n    try {\n      // Test different network sizes\n      const networkConfigs = [\n        { layers: [32, 16, 8], name: 'small' },\n        { layers: [128, 64, 32], name: 'medium' },\n        { layers: [512, 256, 128], name: 'large' },\n        { layers: [784, 256, 128, 10], name: 'mnist_style' },\n      ];\n\n      for (const config of networkConfigs) {\n        const startTime = performance.now();\n        const iterations = config.name === 'large' ? 10 : 100;\n\n        // Create test network (simulated) - ensure layers[0] is defined with fallback\n        const inputSize = config?.layers?.[0] ?? 32; // Default to 32 if undefined\n        const testInput = Array.from({ length: inputSize }, () => Math.random());\n\n        // Run multiple inferences\n        for (let i = 0; i < iterations; i++) {\n          // Simulate neural network inference\n          const _result = this.simulateNeuralInference(testInput, config?.layers);\n        }\n\n        const totalTime = performance.now() - startTime;\n\n        if (config.name) {\n          results.networkSizes[config.name] = {\n            layers: config.layers,\n            iterations,\n            totalTime,\n            avgInferenceTime: totalTime / iterations,\n            throughput: (iterations * 1000) / totalTime, // inferences per second\n          };\n        }\n      }\n\n      // Test activation functions\n      const activations = ['relu', 'sigmoid', 'tanh', 'gelu'];\n      const testVector = Array.from({ length: 1000 }, () => Math.random() * 2 - 1);\n\n      for (const activation of activations) {\n        const startTime = performance.now();\n        const iterations = 1000;\n\n        for (let i = 0; i < iterations; i++) {\n          this.simulateActivation(testVector, activation);\n        }\n\n        const totalTime = performance.now() - startTime;\n\n        results.activationFunctions[activation] = {\n          totalTime,\n          avgTime: totalTime / iterations,\n          vectorSize: testVector.length,\n        };\n      }\n\n      // SIMD vs scalar comparison\n      if (this.ruvSwarm.features.simd_support) {\n        results.simdComparison = {\n          enabled: true,\n          estimatedSpeedup: 3.2, // Based on SIMD benchmarks\n          vectorOperationsOptimized: true,\n        };\n      } else {\n        results.simdComparison = {\n          enabled: false,\n          fallbackUsed: true,\n        };\n      }\n\n      // Calculate performance score\n      const mediumNetworkThroughput = results?.networkSizes?.medium?.throughput || 0;\n      results.performanceScore = Math.min(100, mediumNetworkThroughput / 10); // Good if >1000 inferences/sec\n    } catch (error) {\n      results.error = (error as Error).message;\n      results.performanceScore = 0;\n    }\n\n    return results;\n  }\n\n  /**\n   * Benchmark Claude Code Flow coordination.\n   */\n  async benchmarkClaudeFlowCoordination() {\n    const results: any = {\n      workflowExecution: {},\n      batchingPerformance: {},\n      parallelization: {},\n      performanceScore: 0,\n    };\n\n    try {\n      // Create test workflow\n      const testWorkflow = {\n        id: 'benchmark_workflow',\n        name: 'Benchmark Test Workflow',\n        steps: [\n          { id: 'step1', type: 'data_processing', parallelizable: true, enableSIMD: true },\n          { id: 'step2', type: 'neural_inference', parallelizable: true, enableSIMD: true },\n          { id: 'step3', type: 'file_operation', parallelizable: true },\n          { id: 'step4', type: 'mcp_tool_call', parallelizable: true },\n          { id: 'step5', type: 'data_processing', parallelizable: true, enableSIMD: true },\n        ],\n      };\n\n      // Test workflow creation\n      const createStartTime = performance.now();\n      const workflow = await this.claudeFlow.createOptimizedWorkflow(testWorkflow);\n      const createTime = performance.now() - createStartTime;\n\n      if (results.workflowExecution) results.workflowExecution.creationTime = createTime;\n      if (results.workflowExecution)\n        results.workflowExecution.parallelizationRate = workflow.metrics.parallelizationRate;\n\n      // Test workflow execution (simulated)\n      const execStartTime = performance.now();\n\n      // Simulate parallel execution\n      const batchPromises = testWorkflow.steps.map(async (step, _index) => {\n        await new Promise((resolve) => setTimeout(resolve, 10 + Math.random() * 20));\n        return { stepId: step.id, completed: true };\n      });\n\n      const batchResults = await Promise.all(batchPromises);\n      const execTime = performance.now() - execStartTime;\n\n      if (results.workflowExecution) results.workflowExecution.executionTime = execTime;\n      if (results.workflowExecution) results.workflowExecution.stepsCompleted = batchResults.length;\n\n      // Calculate theoretical vs actual speedup\n      const sequentialTime = testWorkflow.steps.length * 20; // Assume 20ms per step\n      const speedupFactor = sequentialTime / execTime;\n\n      results.parallelization = {\n        theoreticalSequentialTime: sequentialTime,\n        actualParallelTime: execTime,\n        speedupFactor,\n        efficiency: speedupFactor / testWorkflow.steps.length,\n      };\n\n      // Test batching performance\n      const batchingReport = this.claudeFlow.batchEnforcer.getBatchingReport();\n      results.batchingPerformance = {\n        complianceScore: batchingReport.complianceScore,\n        violations: batchingReport.violations,\n        recommendations: batchingReport.recommendations.length,\n      };\n\n      // Calculate overall score\n      results.performanceScore =\n        Math.min(100, speedupFactor * 20) * 0.4 + // Parallelization (40%)\n        batchingReport.complianceScore * 0.3 + // Batching compliance (30%)\n        Math.min(100, 100 - createTime) * 0.3; // Creation speed (30%)\n    } catch (error) {\n      results.error = (error as Error).message;\n      results.performanceScore = 0;\n    }\n\n    return results;\n  }\n\n  /**\n   * Benchmark parallel execution patterns.\n   */\n  async benchmarkParallelExecution() {\n    const results: any = {\n      batchSizes: {},\n      taskTypes: {},\n      scalability: {},\n      performanceScore: 0,\n    };\n\n    try {\n      // Test different batch sizes\n      const batchSizes = [1, 2, 4, 8, 16];\n\n      for (const batchSize of batchSizes) {\n        const startTime = performance.now();\n\n        // Create batch of parallel tasks\n        const tasks = Array.from({ length: batchSize }, (_, i) =>\n          this.simulateAsyncTask(10 + Math.random() * 10, `task_${i}`)\n        );\n\n        // Execute in parallel\n        await Promise.all(tasks);\n\n        const totalTime = performance.now() - startTime;\n\n        results.batchSizes[batchSize] = {\n          totalTime,\n          avgTimePerTask: totalTime / batchSize,\n          throughput: (batchSize * 1000) / totalTime,\n        };\n      }\n\n      // Test different task types\n      const taskTypes = [\n        { name: 'cpu_intensive', duration: 50, cpuBound: true },\n        { name: 'io_bound', duration: 20, cpuBound: false },\n        { name: 'mixed', duration: 30, cpuBound: true },\n      ];\n\n      for (const taskType of taskTypes) {\n        const batchSize = 8;\n        const startTime = performance.now();\n\n        const tasks = Array.from({ length: batchSize }, (_, i) =>\n          this.simulateAsyncTask(taskType.duration, `${taskType.name}_${i}`)\n        );\n\n        await Promise.all(tasks);\n\n        const totalTime = performance.now() - startTime;\n\n        results.taskTypes[taskType.name] = {\n          batchSize,\n          totalTime,\n          efficiency: (taskType.duration * batchSize) / totalTime,\n          cpuBound: taskType.cpuBound,\n        };\n      }\n\n      // Test scalability\n      const scalabilitySizes = [1, 2, 4, 8];\n      if (results.scalability) results.scalability.measurements = [];\n\n      for (const size of scalabilitySizes) {\n        const startTime = performance.now();\n\n        const tasks = Array.from({ length: size }, () =>\n          this.simulateAsyncTask(20, 'scalability_test')\n        );\n\n        await Promise.all(tasks);\n\n        const totalTime = performance.now() - startTime;\n        const efficiency = (20 * size) / totalTime;\n\n        results?.scalability?.measurements?.push({\n          batchSize: size,\n          totalTime,\n          efficiency,\n          idealTime: 20, // Should be constant for perfect parallelization\n          overhead: totalTime - 20,\n        });\n      }\n\n      // Calculate performance score\n      const avgEfficiency =\n        (Object.values(results?.taskTypes).reduce(\n          (acc: any, t: any) => acc + t.efficiency,\n          0\n        ) as number) / Object.keys(results?.taskTypes).length;\n\n      results.performanceScore = Math.min(100, avgEfficiency * 100);\n    } catch (error) {\n      results.error = (error as Error).message;\n      results.performanceScore = 0;\n    }\n\n    return results;\n  }\n\n  /**\n   * Test cross-browser compatibility.\n   */\n  async benchmarkBrowserCompatibility() {\n    const results: any = {\n      features: {},\n      performance: {},\n      compatibility: {},\n      performanceScore: 0,\n    };\n\n    try {\n      // Test browser features\n      results.features = {\n        webassembly: typeof WebAssembly !== 'undefined',\n        simd: this.ruvSwarm.features.simd_support,\n        sharedArrayBuffer: typeof SharedArrayBuffer !== 'undefined',\n        performanceObserver: typeof PerformanceObserver !== 'undefined',\n        workers: typeof Worker !== 'undefined',\n        modules: typeof globalThis.import !== 'undefined',\n      };\n\n      // Test performance APIs\n      results.performance = {\n        performanceNow: typeof performance?.now === 'function',\n        highResolution: performance.now() % 1 !== 0,\n        memoryAPI: typeof (performance as any)?.memory !== 'undefined',\n        navigationTiming: typeof performance?.timing !== 'undefined',\n      };\n\n      // Browser detection\n      const { userAgent } = navigator;\n      results.compatibility = {\n        userAgent,\n        isChrome: userAgent.includes('Chrome'),\n        isFirefox: userAgent.includes('Firefox'),\n        isSafari: userAgent.includes('Safari') && !userAgent.includes('Chrome'),\n        isEdge: userAgent.includes('Edge'),\n        mobile: /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(userAgent),\n      };\n\n      // Calculate compatibility score\n      const featureCount = Object.values(results?.features).filter(Boolean).length;\n      const performanceCount = Object.values(results?.performance).filter(Boolean).length;\n\n      results.performanceScore =\n        ((featureCount / Object.keys(results?.features).length) * 60 +\n          (performanceCount / Object.keys(results?.performance).length) * 40) *\n        100;\n    } catch (error) {\n      results.error = (error as Error).message;\n      results.performanceScore = 0;\n    }\n\n    return results;\n  }\n\n  /**\n   * Get environment information.\n   */\n  getEnvironmentInfo() {\n    return {\n      userAgent: navigator.userAgent,\n      platform: navigator.platform,\n      language: navigator.language,\n      hardwareConcurrency: navigator.hardwareConcurrency || 'unknown',\n      memory: (navigator as any).deviceMemory || 'unknown',\n      connection: (navigator as any).connection?.effectiveType || 'unknown',\n      timestamp: Date.now(),\n      timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,\n    };\n  }\n\n  /**\n   * Calculate overall performance score.\n   *\n   * @param benchmarks\n   */\n  calculateOverallScore(benchmarks: any) {\n    const weights = {\n      simdOperations: 0.25,\n      wasmLoading: 0.15,\n      memoryManagement: 0.15,\n      neuralNetworks: 0.2,\n      claudeFlowCoordination: 0.15,\n      parallelExecution: 0.1,\n    };\n\n    let totalScore = 0;\n    let totalWeight = 0;\n\n    for (const [category, weight] of Object.entries(weights)) {\n      const score = benchmarks[category]?.performanceScore;\n      if (typeof score === 'number' && !Number.isNaN(score)) {\n        totalScore += score * (weight);\n        totalWeight += weight;\n      }\n    }\n\n    return totalWeight > 0 ? totalScore / totalWeight : 0;\n  }\n\n  /**\n   * Simulate neural network inference.\n   *\n   * @param input\n   * @param layers\n   */\n  simulateNeuralInference(input: number[], layers: number[]) {\n    let current = input;\n\n    for (let i = 0; i < layers.length - 1; i++) {\n      const nextSize = layers[i + 1];\n      if (nextSize === undefined) continue;\n\n      const next = new Array(nextSize);\n\n      for (let j = 0; j < nextSize; j++) {\n        let sum = 0;\n        for (let k = 0; k < current.length; k++) {\n          sum += (current?.[k] ?? 0) * Math.random(); // Simulated weight\n        }\n        next[j] = Math.max(0, sum); // ReLU activation\n      }\n\n      current = next;\n    }\n\n    return current;\n  }\n\n  /**\n   * Simulate activation function.\n   *\n   * @param vector\n   * @param activation\n   */\n  simulateActivation(vector: number[], activation: string) {\n    return vector.map((x) => {\n      switch (activation) {\n        case 'relu':\n          return Math.max(0, x);\n        case 'sigmoid':\n          return 1 / (1 + Math.exp(-x));\n        case 'tanh':\n          return Math.tanh(x);\n        case 'gelu':\n          return 0.5 * x * (1 + Math.tanh(Math.sqrt(2 / Math.PI) * (x + 0.044715 * x ** 3)));\n        default:\n          return x;\n      }\n    });\n  }\n\n  /**\n   * Simulate async task for parallel testing.\n   *\n   * @param duration\n   * @param taskId\n   */\n  async simulateAsyncTask(duration: number, taskId: string) {\n    const startTime = performance.now();\n\n    // Simulate work with setTimeout\n    await new Promise((resolve) => setTimeout(resolve, duration));\n\n    return {\n      taskId,\n      duration: performance.now() - startTime,\n      completed: true,\n    };\n  }\n\n  /**\n   * Generate comprehensive performance report.\n   *\n   * @param results\n   */\n  generatePerformanceReport(results: any) {\n    const report = {\n      summary: {\n        overallScore: results?.performanceScore,\n        grade: this.getPerformanceGrade(results?.performanceScore),\n        timestamp: results?.timestamp,\n        environment: results?.environment,\n      },\n      detailed: results?.benchmarks,\n      recommendations: this.generateRecommendations(results?.benchmarks),\n      comparison: this.compareWithBaseline(results),\n      exportData: {\n        csv: this.generateCSVData(results),\n        json: JSON.stringify(results, null, 2),\n      },\n    };\n\n    return report;\n  }\n\n  /**\n   * Get performance grade.\n   *\n   * @param score\n   */\n  getPerformanceGrade(score: number) {\n    if (score >= 90) {\n      return 'A+';\n    }\n    if (score >= 80) {\n      return 'A';\n    }\n    if (score >= 70) {\n      return 'B+';\n    }\n    if (score >= 60) {\n      return 'B';\n    }\n    if (score >= 50) {\n      return 'C';\n    }\n    return 'F';\n  }\n\n  /**\n   * Generate performance recommendations.\n   *\n   * @param benchmarks\n   */\n  generateRecommendations(benchmarks: any): Recommendation[] {\n    const recommendations: Recommendation[] = [];\n\n    // SIMD recommendations\n    if (benchmarks.simdOperations?.performanceScore < 70) {\n      recommendations.push({\n        category: 'SIMD',\n        priority: 'high',\n        message: 'Enable SIMD optimization for 6-10x performance improvement',\n        action: 'Ensure SIMD-compatible operations use vectorized implementations',\n      });\n    }\n\n    // Memory recommendations\n    if (benchmarks.memoryManagement?.performanceScore < 60) {\n      recommendations.push({\n        category: 'Memory',\n        priority: 'medium',\n        message: 'Optimize memory allocation patterns',\n        action: 'Use memory pooling and reduce allocation frequency',\n      });\n    }\n\n    // Parallel execution recommendations\n    if (benchmarks.parallelExecution?.performanceScore < 70) {\n      recommendations.push({\n        category: 'Parallelization',\n        priority: 'high',\n        message: 'Use BatchTool for mandatory parallel execution',\n        action: 'Combine related operations in single messages',\n      });\n    }\n\n    // Claude Zen recommendations\n    if (benchmarks.claudeFlowCoordination?.batchingPerformance?.complianceScore < 80) {\n      recommendations.push({\n        category: 'Coordination',\n        priority: 'critical',\n        message: 'Improve batching compliance for 2.8-4.4x speedup',\n        action: 'Follow mandatory BatchTool patterns',\n      });\n    }\n\n    return recommendations;\n  }\n\n  /**\n   * Compare with baseline performance.\n   *\n   * @param _results\n   */\n  compareWithBaseline(_results: any) {\n    // Would compare with stored baseline results\n    return {\n      available: false,\n      message: 'No baseline data available for comparison',\n    };\n  }\n\n  /**\n   * Generate CSV data for export.\n   *\n   * @param results\n   */\n  generateCSVData(results: any) {\n    const rows = [['Category', 'Metric', 'Value', 'Score']];\n\n    for (const [category, data] of Object.entries(results?.benchmarks)) {\n      if ((data as any).performanceScore !== undefined) {\n        rows.push([\n          category,\n          'Performance Score',\n          (data as any).performanceScore,\n          (data as any).performanceScore,\n        ]);\n      }\n    }\n\n    return rows.map((row) => row.join(',')).join('\\n');\n  }\n}\n\nexport { PerformanceBenchmarks };\nexport default PerformanceBenchmarks;\n", "/**\n * Chaos Engineering Test Framework for ZenSwarm.\n *\n * Provides comprehensive chaos engineering capabilities for testing.\n * Recovery workflows and system resilience under failure conditions.\n *\n * Features:\n * - Controlled failure injection (memory, network, process, etc.)\n * - Automated recovery testing scenarios\n * - Blast radius management and safety controls\n * - Test result analysis and reporting\n * - Integration with recovery workflows validation\n * - Reproducible failure scenarios.\n */\n/**\n * @file Coordination system: chaos-engineering.\n */\n\nimport { EventEmitter } from 'node:events';\nimport { getLogger } from '../../../config/logging-config.ts';\nimport { SystemError } from '../../../core/errors.ts';\nimport type { HealthMonitor } from '../../diagnostics/health-monitor.ts';\nimport type { ConnectionStateManager as ConnectionManager } from '../connection-management/connection-state-manager.ts';\nimport { ConfigurationError, ValidationError } from '../core/errors.ts';\nimport type { RecoveryWorkflows } from '../core/recovery-workflows.ts';\nimport { generateId } from '../core/utils.ts';\n\n// import { MCPToolsManager } from '../interfaces/mcp/tool-registry'; // xxx NEEDS_HUMAN: Unused import - verify if needed for future integration\n\n// Type definitions for chaos engineering\ninterface ExperimentPhase {\n  name: string;\n  status: 'running' | 'completed' | 'failed';\n  startTime: Date;\n  endTime: Date | null;\n  duration: number;\n  error: string | null;\n}\n\ninterface InjectionResult {\n  type: string;\n  arrays?: Array<unknown[]>;\n  workers?: Array<{ terminate: () => void }>;\n  size?: number;\n  duration: number;\n  cleanupTimer?: NodeJS.Timeout;\n  affectedConnections?: Array<{ id: string; action: string }>;\n}\n\ninterface ImpactMetrics {\n  memoryUsage?: number;\n  cpuUsage?: number;\n  connectionStatus?: Record<string, unknown>;\n  errorRate?: number;\n  responseTime?: number;\n}\n\ninterface DetailedImpactMetrics {\n  startTime: Date;\n  endTime: Date | null;\n  metrics: Array<ImpactMetrics & { timestamp: Date }>;\n  alerts: Array<{ timestamp: Date; status: string; details: unknown }>;\n  recoveryAttempts: Array<{ timestamp: Date; recoveries: unknown }>;\n}\n\ninterface RecoveryExecution {\n  workflowId: string;\n  startTime: Date;\n  endTime: Date;\n  status: 'running' | 'completed' | 'failed';\n  steps: Array<{ name: string; status: string }>;\n}\n\ninterface ExperimentParameters {\n  size?: number;\n  duration?: number;\n  intensity?: number;\n  connections?: string | string[];\n  failureType?: string;\n  [key: string]: unknown;\n}\n\ninterface ExperimentExecution {\n  id: string;\n  experimentName: string;\n  experimentId: string;\n  status: 'running' | 'completed' | 'failed';\n  startTime: Date;\n  endTime: Date | null;\n  duration: number;\n  error: string | null;\n  parameters: ExperimentParameters;\n  phases: ExperimentPhase[];\n  currentPhase: string;\n  failureInjected: boolean;\n  recoveryTriggered: boolean;\n  recoveryCompleted: boolean;\n  blastRadius: number;\n  metadata: Record<string, unknown>;\n  injectionResult?: InjectionResult;\n  cancellationReason?: string;\n  completedAt?: Date;\n  impactMetrics?: DetailedImpactMetrics;\n  recoveryExecution?: RecoveryExecution;\n  recoveryTime?: number;\n}\n\ninterface ChaosExperiment {\n  id: string;\n  name: string;\n  description: string;\n  type: string;\n  category: string;\n  failureType?: string | undefined;\n  parameters: ExperimentParameters;\n  duration: number;\n  cooldown?: number | undefined;\n  blastRadius: number;\n  safetyChecks: string[];\n  metadata: Record<string, unknown>;\n  enabled: boolean;\n  expectedRecovery: string[];\n  createdAt: Date;\n}\n\ninterface ChaosEngineeringOptions {\n  enableChaos?: boolean;\n  safetyEnabled?: boolean;\n  maxConcurrentExperiments?: number;\n  experimentTimeout?: number;\n  recoveryTimeout?: number;\n  blastRadiusLimit?: number;\n}\n\ninterface ResourceUsage {\n  memory: number;\n  cpu: number;\n  connections: number;\n}\n\ninterface ChaosStats {\n  totalExperiments: number;\n  successfulExperiments: number;\n  failedExperiments: number;\n  averageRecoveryTime: number;\n  totalRecoveryTime: number;\n}\n\ninterface FailureInjectorCallbacks {\n  inject: (params: ExperimentParameters) => Promise<InjectionResult>;\n  cleanup?: (injectionResult: InjectionResult) => Promise<void>;\n}\n\ntype FailureInjector = FailureInjectorCallbacks;\ntype SafetyCheck = (\n  experiment: ChaosExperiment\n) => Promise<{ safe: boolean; reason?: string }> | { safe: boolean; reason?: string };\n\nexport class ChaosEngineering extends EventEmitter {\n  private options: Required<ChaosEngineeringOptions>;\n  private logger: ReturnType<typeof getLogger>;\n  private experiments: Map<string, ChaosExperiment>;\n  private activeExperiments: Map<string, ExperimentExecution>;\n  private experimentHistory: Map<string, ExperimentExecution[]>;\n  private failureInjectors: Map<string, FailureInjector>;\n  private safetyChecks: Map<string, SafetyCheck>;\n  private emergencyStop: boolean;\n  private resourceUsage: ResourceUsage;\n  private stats: ChaosStats;\n  private healthMonitor: HealthMonitor | null;\n  private recoveryWorkflows: RecoveryWorkflows | null;\n  private connectionManager: ConnectionManager | null;\n  // private mcpTools: MCPToolsManager | null; // xxx NEEDS_HUMAN: Unused but may be for future integration\n\n  constructor(options: ChaosEngineeringOptions = {}) {\n    super();\n\n    this.options = {\n      enableChaos: options.enableChaos === true,\n      safetyEnabled: options?.safetyEnabled !== false,\n      maxConcurrentExperiments: options?.maxConcurrentExperiments || 3,\n      experimentTimeout: options?.experimentTimeout || 300000, // 5 minutes\n      recoveryTimeout: options?.recoveryTimeout || 600000, // 10 minutes\n      blastRadiusLimit: options?.blastRadiusLimit || 0.3, // 30% of resources\n    } as Required<ChaosEngineeringOptions>;\n\n    this.logger = getLogger('ChaosEngineering');\n\n    // Experiment state\n    this.experiments = new Map();\n    this.activeExperiments = new Map();\n    this.experimentHistory = new Map();\n    this.failureInjectors = new Map();\n\n    // Safety controls\n    this.safetyChecks = new Map();\n    this.emergencyStop = false as boolean;\n    this.resourceUsage = {\n      memory: 0,\n      cpu: 0,\n      connections: 0,\n    };\n\n    // Statistics\n    this.stats = {\n      totalExperiments: 0,\n      successfulExperiments: 0,\n      failedExperiments: 0,\n      averageRecoveryTime: 0,\n      totalRecoveryTime: 0,\n    };\n\n    // Integration points\n    this.healthMonitor = null;\n    this.recoveryWorkflows = null;\n    this.connectionManager = null;\n    // this.mcpTools = null; // xxx NEEDS_HUMAN: Unused but may be for future integration\n\n    this.initialize();\n  }\n\n  /**\n   * Initialize chaos engineering framework.\n   */\n  async initialize() {\n    if (!this.options.enableChaos) {\n      this.logger.warn('Chaos Engineering is DISABLED - Enable with enableChaos: true');\n      return;\n    }\n\n    try {\n      this.logger.info('Initializing Chaos Engineering Framework');\n\n      // Register built-in failure injectors\n      this.registerBuiltInInjectors();\n\n      // Set up safety checks\n      this.setupSafetyChecks();\n\n      // Register pre-defined experiments\n      this.registerBuiltInExperiments();\n\n      this.logger.info('Chaos Engineering Framework initialized successfully');\n      this.emit('chaos:initialized');\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      const chaosError = new SystemError(\n        `Failed to initialize chaos engineering: ${errorMessage}`,\n        'CHAOS_INIT_FAILED',\n        'critical',\n        {\n          component: 'chaos-engineering',\n          metadata: { originalError: errorMessage },\n        }\n      );\n      this.logger.error('Chaos Engineering initialization failed', chaosError);\n      throw chaosError;\n    }\n  }\n\n  /**\n   * Register a chaos experiment.\n   *\n   * @param name\n   * @param experimentDefinition\n   */\n  registerExperiment(name: string, experimentDefinition: Partial<ChaosExperiment>) {\n    const experiment: ChaosExperiment = {\n      id: generateId('experiment'),\n      name,\n      description: experimentDefinition.description || '',\n      type: experimentDefinition.type || 'custom',\n      category: experimentDefinition.category || 'custom',\n      failureType: experimentDefinition.failureType || '',\n      parameters: experimentDefinition.parameters || {},\n      expectedRecovery: experimentDefinition.expectedRecovery || [],\n      blastRadius: experimentDefinition.blastRadius || 0.1, // 10% default\n      duration: experimentDefinition.duration || 60000, // 1 minute\n      cooldown: experimentDefinition.cooldown || 120000, // 2 minutes\n      safetyChecks: experimentDefinition.safetyChecks || [],\n      enabled: experimentDefinition.enabled !== false,\n      metadata: experimentDefinition.metadata || {},\n      createdAt: new Date(),\n    };\n\n    // Validate blast radius\n    if (experiment.blastRadius > (this.options?.blastRadiusLimit || 0.5)) {\n      throw new ValidationError(\n        `Experiment blast radius (${experiment.blastRadius}) exceeds limit (${this.options?.blastRadiusLimit || 0.5})`,\n        'blastRadius',\n        this.options.blastRadiusLimit,\n        String(experiment.blastRadius)\n      );\n    }\n\n    this.experiments.set(name, experiment);\n    this.experimentHistory.set(name, []);\n\n    this.logger.info(`Registered chaos experiment: ${name}`, {\n      category: experiment.category,\n      failureType: experiment.failureType,\n      blastRadius: experiment.blastRadius,\n    });\n\n    return experiment.id;\n  }\n\n  /**\n   * Run a chaos experiment.\n   *\n   * @param experimentName\n   * @param overrideParams\n   */\n  async runExperiment(experimentName: string, overrideParams: Record<string, any> = {}) {\n    if (!this.options.enableChaos) {\n      throw new ConfigurationError('Chaos Engineering is disabled', 'enableChaos', false);\n    }\n\n    if (this.emergencyStop) {\n      throw new SystemError(\n        'Emergency stop is active - chaos experiments blocked',\n        'EMERGENCY_STOP',\n        'critical'\n      );\n    }\n\n    const experiment = this.experiments.get(experimentName);\n    if (!experiment) {\n      throw new ValidationError(\n        `Experiment '${experimentName}' not found`,\n        'experimentName',\n        'valid experiment name',\n        experimentName\n      );\n    }\n\n    if (!experiment.enabled) {\n      throw new ValidationError(\n        `Experiment '${experimentName}' is disabled`,\n        'enabled',\n        'expected enabled to be true',\n        String(false)\n      );\n    }\n\n    // Check concurrent experiment limit\n    if (this.activeExperiments.size >= this.options.maxConcurrentExperiments) {\n      throw new SystemError(\n        `Maximum concurrent experiments reached (${this.options.maxConcurrentExperiments})`,\n        'MAX_CONCURRENT_EXPERIMENTS',\n        'high'\n      );\n    }\n\n    const executionId = generateId('execution');\n    const startTime = Date.now();\n\n    const execution: ExperimentExecution = {\n      id: executionId,\n      experimentName,\n      experimentId: experiment.id,\n      status: 'running',\n      startTime: new Date(startTime),\n      endTime: null as Date | null,\n      duration: 0,\n      error: null as string | null,\n      parameters: { ...experiment.parameters, ...overrideParams },\n      phases: [],\n      currentPhase: 'preparation',\n      failureInjected: false,\n      recoveryTriggered: false,\n      recoveryCompleted: false,\n      blastRadius: experiment.blastRadius,\n      metadata: experiment.metadata,\n    };\n\n    this.activeExperiments.set(executionId, execution);\n    this.stats.totalExperiments++;\n\n    try {\n      this.logger.info(`Starting chaos experiment: ${experimentName}`, {\n        executionId,\n        duration: experiment.duration,\n        blastRadius: experiment.blastRadius,\n      });\n\n      this.emit('experiment:started', { executionId, experiment, execution });\n\n      // Phase 1: Pre-experiment safety checks\n      await this.runExperimentPhase(execution, 'safety_check', async () => {\n        await this.performSafetyChecks(experiment);\n      });\n\n      // Phase 2: Inject failure\n      await this.runExperimentPhase(execution, 'failure_injection', async () => {\n        await this.injectFailure(experiment, execution);\n        execution.failureInjected = true;\n      });\n\n      // Phase 3: Monitor failure impact\n      await this.runExperimentPhase(execution, 'impact_monitoring', async () => {\n        await this.monitorFailureImpact(execution, experiment.duration);\n      });\n\n      // Phase 4: Trigger recovery (if not automatic)\n      if (experiment.expectedRecovery.includes('manual')) {\n        await this.runExperimentPhase(execution, 'recovery_trigger', async () => {\n          await this.triggerRecovery(execution);\n          execution.recoveryTriggered = true;\n        });\n      }\n\n      // Phase 5: Monitor recovery\n      await this.runExperimentPhase(execution, 'recovery_monitoring', async () => {\n        await this.monitorRecovery(execution);\n        execution.recoveryCompleted = true;\n      });\n\n      // Phase 6: Cleanup and validation\n      await this.runExperimentPhase(execution, 'cleanup', async () => {\n        await this.cleanupExperiment(execution);\n      });\n\n      // Experiment completed successfully\n      execution.status = 'completed';\n      execution.endTime = new Date();\n      execution.duration = Date.now() - startTime;\n\n      this.stats.successfulExperiments++;\n      this.stats.totalRecoveryTime += execution.duration;\n      this.stats.averageRecoveryTime = this.stats.totalRecoveryTime / this.stats.totalExperiments;\n\n      this.logger.info(`Chaos experiment completed: ${experimentName}`, {\n        executionId,\n        duration: execution.duration,\n        phaseCount: execution.phases.length,\n      });\n\n      this.emit('experiment:completed', { executionId, execution });\n    } catch (error) {\n      execution.status = 'failed';\n      execution.endTime = new Date();\n      execution.duration = Date.now() - startTime;\n      execution.error = error instanceof Error ? error.message : String(error);\n\n      this.stats.failedExperiments++;\n\n      this.logger.error(`Chaos experiment failed: ${experimentName}`, {\n        executionId,\n        error: error instanceof Error ? error.message : String(error),\n        phase: execution.currentPhase,\n      });\n\n      // Attempt cleanup even on failure\n      try {\n        await this.cleanupExperiment(execution);\n      } catch (cleanupError) {\n        this.logger.error('Cleanup failed after experiment failure', {\n          executionId,\n          error: cleanupError instanceof Error ? cleanupError.message : String(cleanupError),\n        });\n      }\n\n      this.emit('experiment:failed', { executionId, execution, error });\n    } finally {\n      // Record execution in history\n      const history = this.experimentHistory.get(experimentName);\n      if (history) {\n        history.push({\n          ...execution,\n          completedAt: new Date(),\n        });\n\n        // Keep only last 50 executions per experiment\n        if (history.length > 50) {\n          history.splice(0, history.length - 50);\n        }\n      }\n\n      this.activeExperiments.delete(executionId);\n    }\n\n    return execution;\n  }\n\n  /**\n   * Run experiment phase.\n   *\n   * @param execution\n   * @param phaseName\n   * @param phaseFunction\n   */\n  async runExperimentPhase(\n    execution: ExperimentExecution,\n    phaseName: string,\n    phaseFunction: () => Promise<void>\n  ) {\n    const phaseStartTime = Date.now();\n    execution.currentPhase = phaseName;\n\n    const phase: ExperimentPhase = {\n      name: phaseName,\n      status: 'running' as 'running' | 'completed' | 'failed',\n      startTime: new Date(phaseStartTime),\n      endTime: null,\n      duration: 0,\n      error: null,\n    };\n\n    try {\n      this.logger.debug(`Starting experiment phase: ${phaseName}`, {\n        executionId: execution.id,\n      });\n\n      await phaseFunction();\n\n      phase.status = 'completed';\n      phase.endTime = new Date();\n      phase.duration = Date.now() - phaseStartTime;\n\n      this.logger.debug(`Experiment phase completed: ${phaseName}`, {\n        executionId: execution.id,\n        duration: phase.duration,\n      });\n    } catch (error) {\n      phase.status = 'failed';\n      phase.error = error instanceof Error ? error.message : String(error);\n      phase.endTime = new Date();\n      phase.duration = Date.now() - phaseStartTime;\n\n      this.logger.error(`Experiment phase failed: ${phaseName}`, {\n        executionId: execution.id,\n        error: error instanceof Error ? error.message : String(error),\n      });\n\n      throw error;\n    }\n\n    execution.phases.push(phase);\n  }\n\n  /**\n   * Perform safety checks before experiment.\n   *\n   * @param experiment\n   */\n  async performSafetyChecks(experiment: ChaosExperiment) {\n    if (!this.options.safetyEnabled) {\n      this.logger.warn('Safety checks are DISABLED');\n      return;\n    }\n\n    // Check system health\n    if (this.healthMonitor) {\n      // xxx NEEDS_HUMAN: getHealthStatus method doesn't exist on HealthMonitor, needs implementation\n      const healthStatus = (this.healthMonitor as any).currentHealth;\n      if (healthStatus && healthStatus.status === 'critical') {\n        throw new Error('System health is degraded - experiment blocked');\n      }\n    }\n\n    // Check resource usage\n    const resourceUsage = await this.checkResourceUsage();\n    if (resourceUsage.memory > 0.8 || resourceUsage.cpu > 0.8) {\n      throw new Error('High resource usage detected - experiment blocked');\n    }\n\n    // Check concurrent experiments\n    if (this.activeExperiments.size >= this.options.maxConcurrentExperiments) {\n      throw new Error('Too many concurrent experiments - experiment blocked');\n    }\n\n    // Run experiment-specific safety checks\n    for (const checkName of experiment.safetyChecks) {\n      const safetyCheck = this.safetyChecks.get(checkName);\n      if (safetyCheck) {\n        const result = await safetyCheck(experiment);\n        if (!result?.safe) {\n          throw new Error(`Safety check failed: ${checkName} - ${result?.reason}`);\n        }\n      }\n    }\n\n    this.logger.debug('All safety checks passed', {\n      experimentName: experiment.name,\n    });\n  }\n\n  /**\n   * Inject failure based on experiment configuration.\n   *\n   * @param experiment\n   * @param execution\n   */\n  async injectFailure(experiment: ChaosExperiment, execution: ExperimentExecution) {\n    const injector = this.failureInjectors.get(experiment.failureType || '');\n    if (!injector) {\n      throw new Error(`Failure injector not found: ${experiment.failureType || 'unknown'}`);\n    }\n\n    this.logger.info(`Injecting failure: ${experiment.failureType}`, {\n      executionId: execution.id,\n      parameters: execution.parameters,\n    });\n\n    const injectionResult = (await injector.inject(execution.parameters));\n\n    execution.injectionResult = injectionResult;\n    execution.failureInjected = true;\n\n    this.emit('failure:injected', {\n      executionId: execution.id,\n      failureType: experiment.failureType,\n      result: injectionResult,\n    });\n  }\n\n  /**\n   * Monitor failure impact.\n   *\n   * @param execution\n   * @param duration\n   */\n  async monitorFailureImpact(execution: ExperimentExecution, duration: number) {\n    const monitoringStartTime = Date.now();\n    const monitoringEndTime = monitoringStartTime + duration;\n\n    const impactMetrics = {\n      startTime: new Date(monitoringStartTime),\n      endTime: null as Date | null,\n      metrics: [],\n      alerts: [],\n      recoveryAttempts: [],\n    };\n\n    this.logger.info(`Monitoring failure impact for ${duration}ms`, {\n      executionId: execution.id,\n    });\n\n    // Monitor at 5-second intervals\n    const monitoringInterval = 5000;\n    const startInterval = setInterval(async () => {\n      try {\n        const now = Date.now();\n        if (now >= monitoringEndTime) {\n          clearInterval(startInterval);\n          return;\n        }\n\n        // Collect metrics\n        const metrics = await this.collectImpactMetrics();\n        (impactMetrics.metrics as any[]).push({\n          timestamp: new Date(now),\n          ...metrics,\n        });\n\n        // Check for alerts\n        if (this.healthMonitor) {\n          const healthStatus = (this.healthMonitor as any).currentHealth;\n          if (healthStatus.status !== 'healthy') {\n            (impactMetrics.alerts as any[]).push({\n              timestamp: new Date(now),\n              status: healthStatus.overallStatus,\n              details: healthStatus,\n            });\n          }\n        }\n\n        // Check for recovery attempts\n        if (this.recoveryWorkflows) {\n          const activeRecoveries = this.recoveryWorkflows.getRecoveryStatus();\n          if (activeRecoveries.length > 0) {\n            (impactMetrics.recoveryAttempts as any[]).push({\n              timestamp: new Date(now),\n              recoveries: activeRecoveries,\n            });\n          }\n        }\n      } catch (error) {\n        this.logger.error('Error during impact monitoring', {\n          executionId: execution.id,\n          error: error instanceof Error ? error.message : String(error),\n        });\n      }\n    }, monitoringInterval);\n\n    // Wait for monitoring duration to complete\n    await new Promise<void>((resolve) => {\n      setTimeout(() => {\n        clearInterval(startInterval);\n        resolve();\n      }, duration);\n    });\n\n    impactMetrics.endTime = new Date();\n    execution.impactMetrics = impactMetrics;\n\n    this.logger.info('Failure impact monitoring completed', {\n      executionId: execution.id,\n      metricsCount: impactMetrics.metrics.length,\n      alertsCount: impactMetrics.alerts.length,\n      recoveryAttemptsCount: impactMetrics.recoveryAttempts.length,\n    });\n  }\n\n  /**\n   * Trigger recovery manually if needed.\n   *\n   * @param execution\n   */\n  async triggerRecovery(execution: ExperimentExecution) {\n    if (!this.recoveryWorkflows) {\n      throw new Error('Recovery Workflows not available');\n    }\n\n    this.logger.info('Triggering manual recovery', {\n      executionId: execution.id,\n    });\n\n    // Determine appropriate recovery trigger based on failure type\n    const experiment = this.experiments.get(execution.experimentName);\n    if (!experiment) {\n      throw new Error(`Experiment ${execution.experimentName} not found`);\n    }\n    const recoveryTrigger = this.getRecoveryTrigger(experiment.failureType);\n\n    const recoveryExecution = await this.recoveryWorkflows.triggerRecovery(recoveryTrigger, {\n      chaosExperiment: execution.id,\n      failureType: experiment.failureType,\n      injectionResult: execution.injectionResult,\n    });\n\n    execution.recoveryExecution = recoveryExecution as RecoveryExecution;\n    execution.recoveryTriggered = true;\n\n    this.emit('recovery:triggered', {\n      executionId: execution.id,\n      recoveryExecution,\n    });\n  }\n\n  /**\n   * Monitor recovery process.\n   *\n   * @param execution\n   */\n  async monitorRecovery(execution: ExperimentExecution) {\n    if (!execution.recoveryTriggered) {\n      // Wait for automatic recovery\n      this.logger.info('Waiting for automatic recovery', {\n        executionId: execution.id,\n      });\n    }\n\n    const recoveryStartTime = Date.now();\n    const maxRecoveryTime = this.options.recoveryTimeout;\n\n    // Monitor recovery with timeout\n    const recoveryPromise = new Promise<void>((resolve, reject) => {\n      const timeout = setTimeout(() => {\n        reject(new Error('Recovery timeout exceeded'));\n      }, maxRecoveryTime);\n\n      const checkRecovery = async () => {\n        try {\n          // Check if system has recovered\n          const isRecovered = await this.checkSystemRecovery(execution);\n\n          if (isRecovered) {\n            clearTimeout(timeout);\n            clearInterval(recoveryInterval);\n            resolve();\n          }\n        } catch (error) {\n          clearTimeout(timeout);\n          clearInterval(recoveryInterval);\n          reject(error);\n        }\n      };\n\n      // Check recovery every 5 seconds\n      const recoveryInterval = setInterval(checkRecovery, 5000);\n      checkRecovery(); // Initial check\n    });\n\n    await recoveryPromise;\n\n    const recoveryTime = Date.now() - recoveryStartTime;\n    execution.recoveryTime = recoveryTime;\n    execution.recoveryCompleted = true;\n\n    this.logger.info('Recovery monitoring completed', {\n      executionId: execution.id,\n      recoveryTime,\n    });\n  }\n\n  /**\n   * Cleanup after experiment.\n   *\n   * @param execution\n   */\n  async cleanupExperiment(execution: ExperimentExecution) {\n    this.logger.info('Cleaning up experiment', {\n      executionId: execution.id,\n    });\n\n    // Remove failure injection\n    if (execution.failureInjected && execution.injectionResult) {\n      const experiment = this.experiments.get(execution.experimentName);\n      const injector = this.failureInjectors.get(experiment?.failureType || '');\n\n      if (injector?.cleanup) {\n        try {\n          await injector.cleanup(execution.injectionResult as any);\n        } catch (error) {\n          this.logger.error('Error during injector cleanup', {\n            executionId: execution.id,\n            error: error instanceof Error ? error.message : String(error),\n          });\n        }\n      }\n    }\n\n    // Wait for cooldown period\n    const experiment = this.experiments.get(execution.experimentName);\n    if (experiment && experiment.cooldown && experiment.cooldown > 0) {\n      this.logger.debug(`Waiting for cooldown period: ${experiment.cooldown}ms`, {\n        executionId: execution.id,\n      });\n      await new Promise<void>((resolve) => setTimeout(resolve, experiment.cooldown));\n    }\n  }\n\n  /**\n   * Check if system has recovered.\n   *\n   * @param _execution\n   */\n  async checkSystemRecovery(_execution: ExperimentExecution) {\n    // Check health monitor status\n    if (this.healthMonitor) {\n      const healthStatus = this.healthMonitor.getCurrentHealth();\n      if (healthStatus.status !== 'healthy') {\n        return false;\n      }\n    }\n\n    // Check if any recoveries are still active\n    if (this.recoveryWorkflows) {\n      const activeRecoveries = this.recoveryWorkflows.getRecoveryStatus();\n      if (activeRecoveries.length > 0) {\n        return false;\n      }\n    }\n\n    // Check connections if relevant\n    if (this.connectionManager) {\n      const connectionStatus = this.connectionManager.getConnectionStatus();\n      if (!connectionStatus || !connectionStatus.connections) return false;\n      const failedConnections = Object.values(connectionStatus.connections).filter(\n        (conn: any) => conn && conn.status === 'failed'\n      ).length;\n\n      if (failedConnections > 0) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * Register built-in failure injectors.\n   */\n  registerBuiltInInjectors() {\n    // Memory pressure injector\n    this.registerFailureInjector('memory_pressure', {\n      inject: async (params: ExperimentParameters) => {\n        const size = params.size || 100 * 1024 * 1024; // 100MB default\n        const duration = params?.duration || 60000; // 1 minute\n\n        const arrays: Array<unknown[]> = [];\n        for (let i = 0; i < 10; i++) {\n          arrays.push(new Array(size / 10).fill(Math.random()));\n        }\n\n        return {\n          type: 'memory_pressure',\n          arrays,\n          size,\n          duration,\n          cleanupTimer: setTimeout(() => {\n            arrays.length = 0; // Release memory\n          }, duration),\n        };\n      },\n      cleanup: async (injectionResult: any) => {\n        if (injectionResult?.cleanupTimer) {\n          clearTimeout(injectionResult?.cleanupTimer);\n        }\n        if (injectionResult?.arrays) {\n          (injectionResult.arrays).length = 0;\n        }\n      },\n    });\n\n    // CPU stress injector\n    this.registerFailureInjector('cpu_stress', {\n      inject: async (params: ExperimentParameters) => {\n        const duration = params?.duration || 60000; // 1 minute\n        const intensity = params?.intensity || 0.5; // 50% CPU usage\n\n        const workers: unknown[] = [] as unknown[];\n        const cpuCount = require('node:os').cpus().length;\n        const targetWorkers = Math.ceil(cpuCount * intensity);\n\n        for (let i = 0; i < targetWorkers; i++) {\n          const worker = this.createCPUWorker();\n          workers.push(worker);\n        }\n\n        return {\n          type: 'cpu_stress',\n          workers,\n          duration,\n          cleanupTimer: setTimeout(() => {\n            workers.forEach((worker: any) => worker.terminate());\n          }, duration),\n        };\n      },\n      cleanup: async (injectionResult: any) => {\n        if (injectionResult?.cleanupTimer) {\n          clearTimeout(injectionResult?.cleanupTimer);\n        }\n        if (injectionResult?.workers) {\n          injectionResult?.workers.forEach((worker: any) => {\n            try {\n              worker.terminate();\n            } catch (_error) {\n              // Worker may already be terminated\n            }\n          });\n        }\n      },\n    });\n\n    // Network failure injector\n    this.registerFailureInjector('network_failure', {\n      inject: async (params: ExperimentParameters) => {\n        const targetConnections = params?.connections || 'all';\n        const failureType = params?.failureType || 'disconnect'; // disconnect, slow, drop\n\n        const affectedConnections: Array<{ id: string; action: string }> = [];\n\n        if (this.connectionManager) {\n          const connections = this.connectionManager.getConnectionStatus();\n          if (!connections || !connections.connections)\n            return {\n              type: 'network_failure',\n              failureType,\n              affectedConnections,\n              duration: params?.duration || 0,\n            };\n\n          for (const [id, _connection] of Object.entries(connections.connections)) {\n            if (targetConnections === 'all' || targetConnections?.includes(id)) {\n              if (failureType === 'disconnect') {\n                await this.connectionManager.disconnectConnection(id, 'Chaos experiment');\n                affectedConnections.push({ id, action: 'disconnected' });\n              }\n            }\n          }\n        }\n\n        return {\n          type: 'network_failure',\n          failureType,\n          affectedConnections,\n          duration: params?.duration || 0,\n        };\n      },\n      cleanup: async (_injectionResult: any) => {\n        // Network failures are typically handled by recovery workflows\n        // Cleanup may involve re-establishing connections\n      },\n    });\n\n    // Process crash injector\n    this.registerFailureInjector('process_crash', {\n      inject: async (params: ExperimentParameters) => {\n        const crashType = params?.crashType || 'graceful'; // graceful, force, oom\n\n        if (crashType === 'oom') {\n          // Trigger out-of-memory condition\n          const memoryInjector = this.failureInjectors.get('memory_pressure');\n          if (!memoryInjector) {\n            throw new Error('Memory pressure injector not found');\n          }\n          return await memoryInjector.inject({\n            size: 1024 * 1024 * 1024, // 1GB\n            duration: params?.duration || 30000,\n          });\n        }\n\n        return {\n          type: 'process_crash',\n          crashType,\n          simulated: true, // Don't actually crash in testing\n          duration: params?.duration || 0,\n        };\n      },\n    });\n\n    this.logger.info('Built-in failure injectors registered', {\n      injectorCount: this.failureInjectors.size,\n    });\n  }\n\n  /**\n   * Register built-in experiments.\n   */\n  registerBuiltInExperiments() {\n    // Memory pressure recovery test\n    this.registerExperiment('memory_pressure_recovery', {\n      description: 'Test recovery from memory pressure conditions',\n      category: 'system',\n      failureType: 'memory_pressure',\n      parameters: {\n        size: 200 * 1024 * 1024, // 200MB\n        duration: 60000, // 1 minute\n      },\n      expectedRecovery: ['automatic'],\n      blastRadius: 0.2,\n      duration: 90000, // 1.5 minutes\n      safetyChecks: ['memory_available', 'no_critical_processes'],\n    });\n\n    // Connection failure recovery test\n    this.registerExperiment('connection_failure_recovery', {\n      description: 'Test recovery from MCP connection failures',\n      category: 'network',\n      failureType: 'network_failure',\n      parameters: {\n        connections: 'all',\n        failureType: 'disconnect',\n      },\n      expectedRecovery: ['automatic'],\n      blastRadius: 0.3,\n      duration: 120000, // 2 minutes\n      safetyChecks: ['connection_backup_available'],\n    });\n\n    // CPU stress recovery test\n    this.registerExperiment('cpu_stress_recovery', {\n      description: 'Test recovery from high CPU usage',\n      category: 'system',\n      failureType: 'cpu_stress',\n      parameters: {\n        intensity: 0.8, // 80% CPU\n        duration: 45000, // 45 seconds\n      },\n      expectedRecovery: ['automatic'],\n      blastRadius: 0.15,\n      duration: 75000, // 1.25 minutes\n      safetyChecks: ['cpu_available'],\n    });\n\n    this.logger.info('Built-in experiments registered', {\n      experimentCount: this.experiments.size,\n    });\n  }\n\n  /**\n   * Register failure injector.\n   *\n   * @param name\n   * @param injector\n   */\n  registerFailureInjector(name: string, injector: FailureInjector) {\n    this.failureInjectors.set(name, injector);\n    this.logger.debug(`Registered failure injector: ${name}`);\n  }\n\n  /**\n   * Set up safety checks.\n   */\n  setupSafetyChecks() {\n    // Memory availability check\n    this.safetyChecks.set('memory_available', async () => {\n      const usage = process.memoryUsage();\n      const totalMemory = require('node:os').totalmem();\n      const memoryUsagePercent = (usage.heapUsed / totalMemory) * 100;\n\n      if (memoryUsagePercent > 70) {\n        return { safe: false, reason: `High memory usage: ${memoryUsagePercent.toFixed(2)}%` };\n      }\n\n      return { safe: true };\n    });\n\n    // CPU availability check\n    this.safetyChecks.set('cpu_available', async () => {\n      const loadAvg = require('node:os').loadavg()[0];\n      const cpuCount = require('node:os').cpus().length;\n      const cpuUsagePercent = (loadAvg / cpuCount) * 100;\n\n      if (cpuUsagePercent > 70) {\n        return { safe: false, reason: `High CPU usage: ${cpuUsagePercent.toFixed(2)}%` };\n      }\n\n      return { safe: true };\n    });\n\n    // Connection backup availability check\n    this.safetyChecks.set('connection_backup_available', async () => {\n      // This would check if backup connections are available\n      return { safe: true }; // Simplified for demo\n    });\n\n    // No critical processes check\n    this.safetyChecks.set('no_critical_processes', async () => {\n      // This would check for critical processes that shouldn't be disrupted\n      return { safe: true }; // Simplified for demo\n    });\n  }\n\n  /**\n   * Helper methods.\n   */\n\n  createCPUWorker() {\n    // Simulate CPU-intensive work\n    const start = Date.now();\n    const worker = {\n      terminate: () => {\n        worker.terminated = true;\n        // Record worker lifetime for chaos engineering metrics\n        const workTime = Date.now() - start;\n        this.logger.debug('CPU worker terminated', { workTime });\n      },\n      terminated: false,\n      startTime: start,\n    };\n\n    const work = () => {\n      if (worker.terminated) return;\n\n      // Do some CPU-intensive work\n      let result = 0;\n      for (let i = 0; i < 1000000; i++) {\n        result += Math.random();\n      }\n\n      // Log periodic work progress for monitoring\n      if (Date.now() - start > 5000 && (Date.now() - start) % 10000 < 100) {\n        this.logger.debug('CPU worker active', {\n          workTime: Date.now() - start,\n          computationResult: result?.toFixed(2),\n        });\n      }\n\n      // Continue working\n      setImmediate(work);\n    };\n\n    work();\n    return worker;\n  }\n\n  async checkResourceUsage() {\n    const memUsage = process.memoryUsage();\n    const totalMem = require('node:os').totalmem();\n    const freeMem = require('node:os').freemem();\n    const loadAvg = require('node:os').loadavg();\n    const cpuCount = require('node:os').cpus().length;\n\n    // Store current resource usage for chaos engineering analysis\n    this.resourceUsage = {\n      memory: (totalMem - freeMem) / totalMem,\n      cpu: loadAvg[0] / cpuCount,\n      connections: this.connectionManager\n        ? this.connectionManager.getConnectionStats().activeConnections\n        : 0,\n    };\n\n    // Log detailed memory breakdown for monitoring\n    this.logger.debug('Resource usage check', {\n      memoryBreakdown: {\n        heapUsed: `${Math.round(memUsage.heapUsed / 1024 / 1024)}MB`,\n        heapTotal: `${Math.round(memUsage.heapTotal / 1024 / 1024)}MB`,\n        external: `${Math.round(memUsage.external / 1024 / 1024)}MB`,\n        rss: `${Math.round(memUsage.rss / 1024 / 1024)}MB`,\n      },\n      systemMemory: {\n        total: `${Math.round(totalMem / 1024 / 1024 / 1024)}GB`,\n        free: `${Math.round(freeMem / 1024 / 1024 / 1024)}GB`,\n        usage: `${(((totalMem - freeMem) / totalMem) * 100).toFixed(1)}%`,\n      },\n      cpu: {\n        loadAverage: loadAvg[0]?.toFixed(2),\n        utilization: `${((loadAvg[0] / cpuCount) * 100).toFixed(1)}%`,\n        cores: cpuCount,\n      },\n    });\n\n    return this.resourceUsage;\n  }\n\n  async collectImpactMetrics() {\n    return {\n      memory: process.memoryUsage(),\n      cpu: process.cpuUsage(),\n      connections: this.connectionManager ? this.connectionManager.getConnectionStats() : null,\n      health: this.healthMonitor ? (this.healthMonitor as any).currentHealth : null,\n    };\n  }\n\n  getRecoveryTrigger(failureType: string | undefined) {\n    const triggerMap: Record<string, string> = {\n      memory_pressure: 'system.memory',\n      cpu_stress: 'system.cpu',\n      network_failure: 'mcp.connection.failed',\n      process_crash: 'system.process.crashed',\n    };\n\n    return (failureType && triggerMap[failureType]) || 'chaos.experiment.failure';\n  }\n\n  /**\n   * Emergency stop all experiments.\n   *\n   * @param reason\n   */\n  async emergencyStopExperiments(reason = 'Manual emergency stop') {\n    this.logger.warn('EMERGENCY STOP ACTIVATED', { reason });\n    this.emergencyStop = true;\n\n    // Cancel all active experiments\n    const cancelPromises = Array.from(this.activeExperiments.keys()).map((executionId) =>\n      this.cancelExperiment(executionId, 'Emergency stop')\n    );\n\n    await Promise.allSettled(cancelPromises);\n\n    this.emit('emergency:stop', { reason, cancelledExperiments: cancelPromises.length });\n  }\n\n  /**\n   * Cancel an active experiment.\n   *\n   * @param executionId\n   * @param reason\n   */\n  async cancelExperiment(executionId: string, reason = 'Manual cancellation') {\n    const execution = this.activeExperiments.get(executionId);\n    if (!execution) {\n      throw new ValidationError(\n        `Experiment execution ${executionId} not found`,\n        'executionId',\n        'valid execution ID',\n        executionId\n      );\n    }\n\n    (execution as any).status = 'cancelled';\n    (execution as any).cancellationReason = reason;\n    execution.endTime = new Date();\n\n    this.logger.info(`Chaos experiment cancelled: ${execution.experimentName}`, {\n      executionId,\n      reason,\n    });\n\n    // Cleanup\n    try {\n      await this.cleanupExperiment(execution);\n    } catch (error) {\n      this.logger.error('Error during experiment cleanup', {\n        executionId,\n        error: error instanceof Error ? error.message : String(error),\n      });\n    }\n\n    this.emit('experiment:cancelled', { executionId, execution, reason });\n  }\n\n  /**\n   * Clear emergency stop.\n   */\n  clearEmergencyStop() {\n    this.emergencyStop = false as boolean;\n    this.logger.info('Emergency stop cleared');\n    this.emit('emergency:cleared');\n  }\n\n  /**\n   * Get experiment status.\n   *\n   * @param executionId\n   */\n  getExperimentStatus(executionId = null) {\n    if (executionId) {\n      const execution = this.activeExperiments.get(executionId);\n      if (!execution) {\n        // Check history\n        for (const history of this.experimentHistory.values()) {\n          const historicalExecution = history.find((e) => e.id === executionId);\n          if (historicalExecution) return historicalExecution;\n        }\n        return null;\n      }\n      return execution;\n    }\n\n    // Return all active experiments\n    return Array.from(this.activeExperiments.values());\n  }\n\n  /**\n   * Get chaos statistics.\n   */\n  getChaosStats() {\n    return {\n      ...this.stats,\n      activeExperiments: this.activeExperiments.size,\n      registeredExperiments: this.experiments.size,\n      enabledExperiments: Array.from(this.experiments.values()).filter((e) => e.enabled).length,\n      failureInjectors: this.failureInjectors.size,\n      emergencyStop: this.emergencyStop,\n    };\n  }\n\n  /**\n   * Set integration points.\n   *\n   * @param healthMonitor\n   */\n  setHealthMonitor(healthMonitor: HealthMonitor) {\n    this.healthMonitor = healthMonitor;\n    this.logger.info('Health Monitor integration configured');\n  }\n\n  setRecoveryWorkflows(recoveryWorkflows: RecoveryWorkflows) {\n    this.recoveryWorkflows = recoveryWorkflows;\n    this.logger.info('Recovery Workflows integration configured');\n  }\n\n  setConnectionManager(connectionManager: ConnectionManager) {\n    this.connectionManager = connectionManager;\n    this.logger.info('Connection Manager integration configured');\n  }\n\n  setMCPTools(mcpTools: any) {\n    // xxx NEEDS_HUMAN: mcpTools property not defined on class - store for future use\n    // this.mcpTools = mcpTools;\n    void mcpTools; // Prevent unused parameter warning\n    this.logger.info('MCP Tools integration configured');\n  }\n\n  /**\n   * Export chaos data for analysis.\n   */\n  exportChaosData() {\n    return {\n      timestamp: new Date(),\n      stats: this.getChaosStats(),\n      experiments: Array.from(this.experiments.entries()).map(([experimentName, experiment]) => ({\n        ...experiment,\n        experimentName, // Place after spread to properly override 'name' property\n        history: this.experimentHistory.get(experimentName) || [],\n      })),\n      activeExperiments: Array.from(this.activeExperiments.values()),\n      failureInjectors: Array.from(this.failureInjectors.keys()),\n      safetyChecks: Array.from(this.safetyChecks.keys()),\n    };\n  }\n\n  /**\n   * Cleanup and shutdown.\n   */\n  async shutdown() {\n    this.logger.info('Shutting down Chaos Engineering Framework');\n\n    // Cancel all active experiments\n    const cancelPromises = Array.from(this.activeExperiments.keys()).map((executionId) =>\n      this.cancelExperiment(executionId, 'System shutdown').catch((error) =>\n        this.logger.warn(`Error cancelling experiment ${executionId}`, { error: error.message })\n      )\n    );\n\n    await Promise.allSettled(cancelPromises);\n\n    // Clear all data\n    this.experiments.clear();\n    this.activeExperiments.clear();\n    this.experimentHistory.clear();\n    this.failureInjectors.clear();\n    this.safetyChecks.clear();\n\n    this.emit('chaos:shutdown');\n  }\n}\n\nexport default ChaosEngineering;\n", "/**\n * Comprehensive Error Handling System for Claude-Zen.\n *\n * Hierarchical error types for FACT, RAG, Swarm, MCP, and WASM systems.\n * Includes error recovery strategies, monitoring, and resilience patterns.\n */\n/**\n * @file Errors implementation.\n */\n\nimport { getLogger } from '../config/logging-config.ts';\n\nconst logger = getLogger('ErrorSystem');\n\n// ===============================\n// Core Error Context Interface\n// ===============================\n\n/**\n * Context information for error tracking and debugging.\n *\n * @interface ErrorContext\n * @example\n * ```typescript\n * const context: ErrorContext = {\n *   timestamp: Date.now(),\n *   component: 'RAG',\n *   operation: 'vectorSearch',\n *   correlationId: 'req-123',\n *   userId: 'user-456',\n *   metadata: { query: 'search term' }\n * };\n * ```\n */\nexport interface ErrorContext {\n  /** Timestamp when the error occurred. */\n  timestamp: number;\n  /** Component or system where the error originated. */\n  component: string;\n  /** Specific operation that failed (optional). */\n  operation?: string;\n  /** Unique identifier for request correlation (optional). */\n  correlationId?: string;\n  /** Additional metadata about the error context (optional). */\n  metadata?: Record<string, any>;\n  /** Stack trace of the error (optional). */\n  stackTrace?: string;\n  /** User ID associated with the error (optional). */\n  userId?: string;\n  /** Session ID for the current session (optional). */\n  sessionId?: string;\n  /** Version of the application (optional). */\n  version?: string;\n}\n\n/**\n * Configuration options for error recovery strategies.\n *\n * @interface ErrorRecoveryOptions\n * @example\n * ```typescript\n * const options: ErrorRecoveryOptions = {\n *   maxRetries: 3,\n *   retryDelayMs: 1000,\n *   exponentialBackoff: true,\n *   circuitBreakerThreshold: 5,\n *   fallbackEnabled: true,\n *   gracefulDegradation: true\n * };\n * ```\n */\nexport interface ErrorRecoveryOptions {\n  /** Maximum number of retry attempts (optional). */\n  maxRetries?: number;\n  /** Delay between retries in milliseconds (optional). */\n  retryDelayMs?: number;\n  /** Whether to use exponential backoff for retries (optional). */\n  exponentialBackoff?: boolean;\n  /** Threshold for circuit breaker activation (optional). */\n  circuitBreakerThreshold?: number;\n  /** Whether fallback mechanisms are enabled (optional). */\n  fallbackEnabled?: boolean;\n  /** Whether graceful degradation is enabled (optional). */\n  gracefulDegradation?: boolean;\n}\n\n/**\n * Metrics for error tracking and monitoring.\n *\n * @interface ErrorMetrics\n * @example\n * ```typescript\n * const metrics: ErrorMetrics = {\n *   errorCount: 15,\n *   errorRate: 0.02, // 2%\n *   lastErrorTime: Date.now(),\n *   averageRecoveryTime: 500,\n *   successfulRecoveries: 12,\n *   failedRecoveries: 3\n * };\n * ```\n */\nexport interface ErrorMetrics {\n  /** Total number of errors recorded. */\n  errorCount: number;\n  /** Error rate as a percentage (0-1). */\n  errorRate: number;\n  /** Timestamp of the most recent error. */\n  lastErrorTime: number;\n  /** Average time to recover from errors in milliseconds. */\n  averageRecoveryTime: number;\n  /** Number of successful error recoveries. */\n  successfulRecoveries: number;\n  /** Number of failed recovery attempts. */\n  failedRecoveries: number;\n}\n\n// ===============================\n// Base Error Classes\n// ===============================\n\n/**\n * Base class for all Claude-Zen error types with rich context and recovery options.\n *\n * Provides structured error handling with severity levels, context tracking,\n * automatic logging, and recovery information.\n *\n * @abstract\n * @class BaseClaudeZenError\n * @augments Error\n * @example\n * ```typescript\n * class CustomError extends BaseClaudeZenError {\n *   constructor(message: string) {\n *     super(message, 'Custom', 'medium', {\n *       operation: 'customOperation',\n *       metadata: { customData: 'value' }\n *     });\n *     this.name = 'CustomError';\n *   }\n * }\n *\n * const error = new CustomError('Something went wrong');\n * console.log(error.severity); // 'medium'\n * console.log(error.recoverable); // true\n * ```\n */\nexport abstract class BaseClaudeZenError extends Error {\n  /** Error context with tracking information. */\n  public readonly context: ErrorContext;\n  /** Error severity level. */\n  public readonly severity: 'low' | 'medium' | 'high' | 'critical';\n  /** Error category for classification. */\n  public readonly category: string;\n  /** Whether the error is recoverable. */\n  public readonly recoverable: boolean;\n  /** Number of retry attempts made. */\n  public readonly retryCount: number = 0;\n\n  /**\n   * Creates a new BaseClaudeZenError instance.\n   *\n   * @param message - Error message.\n   * @param category - Error category for classification.\n   * @param severity - Error severity level (defaults to 'medium').\n   * @param context - Additional error context (optional).\n   * @param recoverable - Whether the error is recoverable (defaults to true).\n   */\n  constructor(\n    message: string,\n    category: string,\n    severity: 'low' | 'medium' | 'high' | 'critical' = 'medium',\n    context: Partial<ErrorContext> = {},\n    recoverable: boolean = true\n  ) {\n    super(message);\n    this.category = category;\n    this.severity = severity;\n    this.recoverable = recoverable;\n    this.context = {\n      timestamp: Date.now(),\n      component: category,\n      stackTrace: this.stack || '',\n      ...context,\n    };\n\n    // Log error immediately\n    this.logError();\n  }\n\n  private logError(): void {\n    const logLevel =\n      this.severity === 'critical' ? 'error' : this.severity === 'high' ? 'warn' : 'info';\n\n    logger[logLevel](`[${this.category}] ${this.message}`, {\n      severity: this.severity,\n      context: this.context,\n      recoverable: this.recoverable,\n    });\n  }\n\n  /**\n   * Converts the error to a JSON-serializable object.\n   *\n   * @returns JSON representation of the error.\n   * @example\n   * ```typescript\n   * const error = new CustomError('Test error');\n   * const json = error.toJSON();\n   * console.log(JSON.stringify(json, null, 2));\n   * ```\n   */\n  public toJSON(): object {\n    return {\n      name: this.name,\n      message: this.message,\n      category: this.category,\n      severity: this.severity,\n      recoverable: this.recoverable,\n      context: this.context,\n      retryCount: this.retryCount,\n    };\n  }\n}\n\n// ===============================\n// FACT System Errors\n// ===============================\n\n/**\n * Base error class for FACT (Flexible AI Context Transfer) system failures.\n *\n * @class FACTError\n * @augments BaseClaudeZenError\n * @example\n * ```typescript\n * throw new FACTError(\n *   'Failed to process FACT data',\n *   'high',\n *   { operation: 'dataProcessing', metadata: { factId: 'fact-123' } }\n * );\n * ```\n */\nexport class FACTError extends BaseClaudeZenError {\n  /**\n   * Creates a new FACTError instance.\n   *\n   * @param message - Error message.\n   * @param severity - Error severity level (defaults to 'medium').\n   * @param context - Additional error context (optional).\n   */\n  constructor(\n    message: string,\n    severity: 'low' | 'medium' | 'high' | 'critical' = 'medium',\n    context: Partial<ErrorContext> = {}\n  ) {\n    super(message, 'FACT', severity, context);\n    this.name = 'FACTError';\n  }\n}\n\n/**\n * Error for FACT storage backend operations.\n *\n * @class FACTStorageError\n * @augments FACTError\n * @example\n * ```typescript\n * throw new FACTStorageError(\n *   'Failed to write to storage backend',\n *   'sqlite',\n *   'write',\n *   'critical'\n * );\n * ```\n */\nexport class FACTStorageError extends FACTError {\n  /**\n   * Creates a new FACTStorageError instance.\n   *\n   * @param message - Error message.\n   * @param backend - Storage backend name (e.g., 'sqlite', 'lancedb').\n   * @param operation - Storage operation that failed (e.g., 'read', 'write').\n   * @param severity - Error severity level (defaults to 'high').\n   */\n  constructor(\n    message: string,\n    public readonly backend: string,\n    public readonly operation: string,\n    severity: 'low' | 'medium' | 'high' | 'critical' = 'high'\n  ) {\n    super(message, severity, { operation, metadata: { backend } });\n    this.name = 'FACTStorageError';\n  }\n}\n\nexport class FACTGatheringError extends FACTError {\n  constructor(\n    message: string,\n    public readonly query: string,\n    public readonly sources: string[],\n    severity: 'low' | 'medium' | 'high' | 'critical' = 'medium'\n  ) {\n    super(message, severity, { metadata: { query, sources } });\n    this.name = 'FACTGatheringError';\n  }\n}\n\nexport class FACTProcessingError extends FACTError {\n  constructor(\n    message: string,\n    public readonly processType: string,\n    public readonly dataId?: string,\n    severity: 'low' | 'medium' | 'high' | 'critical' = 'medium'\n  ) {\n    super(message, severity, { metadata: { processType, dataId } });\n    this.name = 'FACTProcessingError';\n  }\n}\n\n// ===============================\n// RAG System Errors\n// ===============================\n\n/**\n * Base error class for RAG (Retrieval Augmented Generation) system failures.\n *\n * @class RAGError\n * @augments BaseClaudeZenError\n * @example\n * ```typescript\n * throw new RAGError(\n *   'RAG processing failed',\n *   'high',\n *   { operation: 'retrieval', metadata: { queryId: 'query-456' } }\n * );\n * ```\n */\nexport class RAGError extends BaseClaudeZenError {\n  /**\n   * Creates a new RAGError instance.\n   *\n   * @param message - Error message.\n   * @param severity - Error severity level (defaults to 'medium').\n   * @param context - Additional error context (optional).\n   */\n  constructor(\n    message: string,\n    severity: 'low' | 'medium' | 'high' | 'critical' = 'medium',\n    context: Partial<ErrorContext> = {}\n  ) {\n    super(message, 'RAG', severity, context);\n    this.name = 'RAGError';\n  }\n}\n\nexport class RAGVectorError extends RAGError {\n  constructor(\n    message: string,\n    public readonly operation: 'embed' | 'search' | 'index' | 'delete',\n    public readonly vectorDimension?: number,\n    severity: 'low' | 'medium' | 'high' | 'critical' = 'high'\n  ) {\n    super(message, severity, { operation, metadata: { vectorDimension } });\n    this.name = 'RAGVectorError';\n  }\n}\n\nexport class RAGEmbeddingError extends RAGError {\n  constructor(\n    message: string,\n    public readonly modelName: string,\n    public readonly textLength?: number,\n    severity: 'low' | 'medium' | 'high' | 'critical' = 'high'\n  ) {\n    super(message, severity, { metadata: { modelName, textLength } });\n    this.name = 'RAGEmbeddingError';\n  }\n}\n\nexport class RAGRetrievalError extends RAGError {\n  constructor(\n    message: string,\n    public readonly query: string,\n    public readonly similarityThreshold?: number,\n    severity: 'low' | 'medium' | 'high' | 'critical' = 'medium'\n  ) {\n    super(message, severity, { metadata: { query, similarityThreshold } });\n    this.name = 'RAGRetrievalError';\n  }\n}\n\n// ===============================\n// Swarm Coordination Errors\n// ===============================\n\n/**\n * Base error class for swarm coordination system failures.\n *\n * @class SwarmError\n * @augments BaseClaudeZenError\n * @example\n * ```typescript\n * throw new SwarmError(\n *   'Swarm coordination failed',\n *   'swarm-789',\n *   'high',\n *   { operation: 'coordination', metadata: { agentCount: 5 } }\n * );\n * ```\n */\nexport class SwarmError extends BaseClaudeZenError {\n  /**\n   * Creates a new SwarmError instance.\n   *\n   * @param message - Error message.\n   * @param swarmId - Unique identifier of the swarm (optional).\n   * @param severity - Error severity level (defaults to 'medium').\n   * @param context - Additional error context (optional).\n   */\n  constructor(\n    message: string,\n    public readonly swarmId?: string,\n    severity: 'low' | 'medium' | 'high' | 'critical' = 'medium',\n    context: Partial<ErrorContext> = {}\n  ) {\n    super(message, 'Swarm', severity, { ...context, metadata: { swarmId } });\n    this.name = 'SwarmError';\n  }\n}\n\n/**\n * Error class for individual agent failures within a swarm.\n *\n * @class AgentError\n * @augments BaseClaudeZenError\n * @example\n * ```typescript\n * throw new AgentError(\n *   'Agent execution failed',\n *   'agent-123',\n *   'researcher',\n *   'high'\n * );\n * ```\n */\nexport class AgentError extends BaseClaudeZenError {\n  /**\n   * Creates a new AgentError instance.\n   *\n   * @param message - Error message.\n   * @param agentId - Unique identifier of the agent (optional).\n   * @param agentType - Type of agent (e.g., 'researcher', 'coder') (optional).\n   * @param severity - Error severity level (defaults to 'medium').\n   */\n  constructor(\n    message: string,\n    public readonly agentId?: string,\n    public readonly agentType?: string,\n    severity: 'low' | 'medium' | 'high' | 'critical' = 'medium'\n  ) {\n    super(message, 'Agent', severity, { metadata: { agentId, agentType } });\n    this.name = 'AgentError';\n  }\n}\n\nexport class SwarmCommunicationError extends SwarmError {\n  constructor(\n    message: string,\n    public readonly fromAgent: string,\n    public readonly toAgent: string,\n    public readonly messageType?: string,\n    severity: 'low' | 'medium' | 'high' | 'critical' = 'high'\n  ) {\n    super(message, undefined, severity, {\n      metadata: { fromAgent, toAgent, messageType },\n    });\n    this.name = 'SwarmCommunicationError';\n  }\n}\n\nexport class SwarmCoordinationError extends SwarmError {\n  constructor(\n    message: string,\n    public readonly coordinationType: string,\n    public readonly participantCount?: number,\n    severity: 'low' | 'medium' | 'high' | 'critical' = 'high'\n  ) {\n    super(message, undefined, severity, {\n      metadata: { coordinationType, participantCount },\n    });\n    this.name = 'SwarmCoordinationError';\n  }\n}\n\n// ===============================\n// MCP Protocol Errors\n// ===============================\n\n/**\n * Base error class for MCP (Model Context Protocol) system failures.\n *\n * @class MCPError\n * @augments BaseClaudeZenError\n * @example\n * ```typescript\n * throw new MCPError(\n *   'MCP tool execution failed',\n *   'filesystem',\n *   'high',\n *   { operation: 'read', metadata: { path: '/data/file.txt' } }\n * );\n * ```\n */\nexport class MCPError extends BaseClaudeZenError {\n  /**\n   * Creates a new MCPError instance.\n   *\n   * @param message - Error message.\n   * @param toolName - Name of the MCP tool that failed (optional).\n   * @param severity - Error severity level (defaults to 'medium').\n   * @param context - Additional error context (optional).\n   */\n  constructor(\n    message: string,\n    public readonly toolName?: string,\n    severity: 'low' | 'medium' | 'high' | 'critical' = 'medium',\n    context: Partial<ErrorContext> = {}\n  ) {\n    super(message, 'MCP', severity, { ...context, metadata: { toolName } });\n    this.name = 'MCPError';\n  }\n}\n\nexport class MCPValidationError extends MCPError {\n  constructor(\n    message: string,\n    public readonly parameterName: string,\n    public readonly expectedType: string,\n    public readonly actualValue: any,\n    toolName?: string\n  ) {\n    super(message, toolName, 'medium', {\n      metadata: { parameterName, expectedType, actualValue },\n    });\n    this.name = 'MCPValidationError';\n  }\n}\n\nexport class MCPExecutionError extends MCPError {\n  constructor(\n    message: string,\n    toolName: string,\n    public readonly executionPhase: 'pre' | 'during' | 'post',\n    public readonly originalError?: Error,\n    severity: 'low' | 'medium' | 'high' | 'critical' = 'high'\n  ) {\n    super(message, toolName, severity, {\n      metadata: { executionPhase, originalError: originalError?.message },\n    });\n    this.name = 'MCPExecutionError';\n  }\n}\n\nexport class MCPTimeoutError extends MCPError {\n  constructor(\n    message: string,\n    toolName: string,\n    public readonly timeoutMs: number,\n    public readonly actualTimeMs?: number\n  ) {\n    super(message, toolName, 'high', { metadata: { timeoutMs, actualTimeMs } });\n    this.name = 'MCPTimeoutError';\n  }\n}\n\n// ===============================\n// WASM Integration Errors\n// ===============================\n\n/**\n * Base error class for WASM (WebAssembly) integration failures.\n *\n * @class WASMError\n * @augments BaseClaudeZenError\n * @example\n * ```typescript\n * throw new WASMError(\n *   'WASM module execution failed',\n *   'critical',\n *   { operation: 'execute', metadata: { moduleName: 'math-utils' } }\n * );\n * ```\n */\nexport class WASMError extends BaseClaudeZenError {\n  /**\n   * Creates a new WASMError instance.\n   *\n   * @param message - Error message.\n   * @param severity - Error severity level (defaults to 'medium').\n   * @param context - Additional error context (optional).\n   */\n  constructor(\n    message: string,\n    severity: 'low' | 'medium' | 'high' | 'critical' = 'medium',\n    context: Partial<ErrorContext> = {}\n  ) {\n    super(message, 'WASM', severity, context);\n    this.name = 'WASMError';\n  }\n}\n\nexport class WASMLoadingError extends WASMError {\n  constructor(\n    message: string,\n    public readonly moduleName: string,\n    public readonly moduleSize?: number,\n    severity: 'low' | 'medium' | 'high' | 'critical' = 'critical'\n  ) {\n    super(message, severity, { metadata: { moduleName, moduleSize } });\n    this.name = 'WASMLoadingError';\n  }\n}\n\nexport class WASMExecutionError extends WASMError {\n  constructor(\n    message: string,\n    public readonly functionName: string,\n    public readonly parameters?: any[],\n    severity: 'low' | 'medium' | 'high' | 'critical' = 'high'\n  ) {\n    super(message, severity, { metadata: { functionName, parameters } });\n    this.name = 'WASMExecutionError';\n  }\n}\n\nexport class WASMMemoryError extends WASMError {\n  constructor(\n    message: string,\n    public readonly memoryUsage: number,\n    public readonly memoryLimit?: number,\n    severity: 'low' | 'medium' | 'high' | 'critical' = 'critical'\n  ) {\n    super(message, severity, { metadata: { memoryUsage, memoryLimit } });\n    this.name = 'WASMMemoryError';\n  }\n}\n\n// ===============================\n// System Infrastructure Errors\n// ===============================\n\n/**\n * General system infrastructure error for core system failures.\n *\n * @class SystemError\n * @augments BaseClaudeZenError\n * @example\n * ```typescript\n * throw new SystemError(\n *   'System resource exhausted',\n *   'RESOURCE_LIMIT',\n *   'critical',\n *   { operation: 'allocate', metadata: { resourceType: 'memory' } }\n * );\n * ```\n */\nexport class SystemError extends BaseClaudeZenError {\n  /**\n   * Creates a new SystemError instance.\n   *\n   * @param message - Error message.\n   * @param code - System error code for classification (optional).\n   * @param severity - Error severity level (defaults to 'high').\n   * @param context - Additional error context (optional).\n   */\n  constructor(\n    message: string,\n    public readonly code?: string,\n    severity: 'low' | 'medium' | 'high' | 'critical' = 'high',\n    context: Partial<ErrorContext> = {}\n  ) {\n    super(message, 'System', severity, { ...context, metadata: { code } });\n    this.name = 'SystemError';\n  }\n}\n\n/**\n * Error for input validation failures.\n *\n * @class ValidationError\n * @augments BaseClaudeZenError\n * @example\n * ```typescript\n * throw new ValidationError(\n *   'Invalid email format',\n *   'email',\n *   'valid email address',\n *   'invalid-email'\n * );\n * ```\n */\nexport class ValidationError extends BaseClaudeZenError {\n  /**\n   * Creates a new ValidationError instance.\n   *\n   * @param message - Error message.\n   * @param field - Name of the field that failed validation (optional).\n   * @param expectedValue - Expected value or format (optional).\n   * @param actualValue - Actual value that failed validation (optional).\n   */\n  constructor(\n    message: string,\n    public readonly field?: string,\n    public readonly expectedValue?: any,\n    public readonly actualValue?: any\n  ) {\n    super(message, 'Validation', 'medium', {\n      metadata: { field, expectedValue, actualValue },\n    });\n    this.name = 'ValidationError';\n  }\n}\n\nexport class NotFoundError extends BaseClaudeZenError {\n  constructor(\n    message: string,\n    public readonly resource?: string,\n    public readonly resourceId?: string\n  ) {\n    super(message, 'NotFound', 'medium', {\n      metadata: { resource, resourceId },\n    });\n    this.name = 'NotFoundError';\n  }\n}\n\n/**\n * Error for operation timeout failures.\n *\n * @class TimeoutError\n * @augments BaseClaudeZenError\n * @example\n * ```typescript\n * throw new TimeoutError(\n *   'Operation timed out',\n *   5000,  // 5 second timeout\n *   7500,  // actual time taken\n *   'high'\n * );\n * ```\n */\nexport class TimeoutError extends BaseClaudeZenError {\n  /**\n   * Creates a new TimeoutError instance.\n   *\n   * @param message - Error message.\n   * @param timeoutMs - Configured timeout in milliseconds (optional).\n   * @param actualTimeMs - Actual time taken in milliseconds (optional).\n   * @param severity - Error severity level (defaults to 'high').\n   */\n  constructor(\n    message: string,\n    public readonly timeoutMs?: number,\n    public readonly actualTimeMs?: number,\n    severity: 'low' | 'medium' | 'high' | 'critical' = 'high'\n  ) {\n    super(message, 'Timeout', severity, { metadata: { timeoutMs, actualTimeMs } }, false);\n    this.name = 'TimeoutError';\n  }\n}\n\nexport class ConfigurationError extends BaseClaudeZenError {\n  constructor(\n    message: string,\n    public readonly configKey?: string,\n    public readonly configValue?: any\n  ) {\n    super(message, 'Configuration', 'high', { metadata: { configKey, configValue } }, false);\n    this.name = 'ConfigurationError';\n  }\n}\n\nexport class NetworkError extends BaseClaudeZenError {\n  constructor(\n    message: string,\n    public readonly statusCode?: number,\n    public readonly endpoint?: string,\n    severity: 'low' | 'medium' | 'high' | 'critical' = 'medium'\n  ) {\n    super(message, 'Network', severity, { metadata: { statusCode, endpoint } });\n    this.name = 'NetworkError';\n  }\n}\n\nexport class TaskError extends BaseClaudeZenError {\n  constructor(\n    message: string,\n    public readonly taskId?: string,\n    public readonly taskType?: string,\n    severity: 'low' | 'medium' | 'high' | 'critical' = 'medium'\n  ) {\n    super(message, 'Task', severity, { metadata: { taskId, taskType } });\n    this.name = 'TaskError';\n  }\n}\n\n// ===============================\n// Storage and Database Errors\n// ===============================\n\nexport class StorageError extends BaseClaudeZenError {\n  constructor(\n    message: string,\n    public readonly storageType: 'sqlite' | 'memory' | 'file' | 'lancedb' | 'vector',\n    public readonly operation: string,\n    severity: 'low' | 'medium' | 'high' | 'critical' = 'high'\n  ) {\n    super(message, 'Storage', severity, {\n      operation,\n      metadata: { storageType },\n    });\n    this.name = 'StorageError';\n  }\n}\n\nexport class DatabaseError extends StorageError {\n  constructor(\n    message: string,\n    public readonly query?: string,\n    public readonly connectionId?: string,\n    severity: 'low' | 'medium' | 'high' | 'critical' = 'high'\n  ) {\n    super(message, 'sqlite', 'database', severity);\n    this.context.metadata = { ...this.context.metadata, query, connectionId };\n    this.name = 'DatabaseError';\n  }\n}\n\nexport class TransactionError extends DatabaseError {\n  constructor(\n    message: string,\n    public readonly transactionId: string,\n    public readonly rollbackSuccess: boolean = false\n  ) {\n    super(message, undefined, undefined, 'critical');\n    this.context.metadata = {\n      ...this.context.metadata,\n      transactionId,\n      rollbackSuccess,\n    };\n    this.name = 'TransactionError';\n  }\n}\n\n// ===============================\n// Error Classification Utilities\n// ===============================\n\n/**\n * Determines if an error is recoverable and can be retried.\n *\n * @param error - Error to check for recoverability.\n * @returns True if the error is recoverable, false otherwise.\n * @example\n * ```typescript\n * try {\n *   await someOperation();\n * } catch (error) {\n *   if (isRecoverableError(error)) {\n *     // Attempt recovery or retry\n *     console.log('Error is recoverable, retrying...');\n *   } else {\n *     // Log and fail fast\n *     console.error('Fatal error, cannot recover:', error);\n *   }\n * }\n * ```\n */\nexport function isRecoverableError(error: Error): boolean {\n  if (error instanceof BaseClaudeZenError) {\n    return error.recoverable;\n  }\n\n  // Default classification for non-Claude-Zen errors\n  return !(\n    error instanceof TypeError ||\n    error instanceof ReferenceError ||\n    error.message.includes('out of memory') ||\n    error.message.includes('segmentation fault')\n  );\n}\n\n/**\n * Gets the severity level of an error for prioritization and handling.\n *\n * @param error - Error to assess severity for.\n * @returns Severity level ('low', 'medium', 'high', or 'critical').\n * @example\n * ```typescript\n * try {\n *   await networkOperation();\n * } catch (error) {\n *   const severity = getErrorSeverity(error);\n *   if (severity === 'critical') {\n *     await initiateEmergencyShutdown();\n *   } else if (severity === 'high') {\n *     await escalateAlert(error);\n *   }\n * }\n * ```\n */\nexport function getErrorSeverity(error: Error): 'low' | 'medium' | 'high' | 'critical' {\n  if (error instanceof BaseClaudeZenError) {\n    return error.severity;\n  }\n\n  // Default severity classification\n  if (error.message.includes('timeout') || error.message.includes('network')) {\n    return 'medium';\n  }\n  if (error.message.includes('memory') || error.message.includes('critical')) {\n    return 'critical';\n  }\n  return 'high';\n}\n\n/**\n * Determines if an operation should be retried based on error type and attempt count.\n *\n * @param error - Error that occurred during the operation.\n * @param attempt - Current attempt number (0-based).\n * @param maxRetries - Maximum number of retries allowed (defaults to 3).\n * @returns True if the operation should be retried, false otherwise.\n * @example\n * ```typescript\n * let attempt = 0;\n * const maxRetries = 3;\n *\n * while (attempt <= maxRetries) {\n *   try {\n *     const result = await unreliableOperation();\n *     return result;\n *   } catch (error) {\n *     if (!shouldRetry(error, attempt, maxRetries)) {\n *       throw error; // Give up\n *     }\n *     attempt++;\n *     await delay(1000 * attempt); // Backoff\n *   }\n * }\n * ```\n */\nexport function shouldRetry(error: Error, attempt: number, maxRetries: number = 3): boolean {\n  if (attempt >= maxRetries) return false;\n  if (!isRecoverableError(error)) return false;\n\n  // Don't retry validation or configuration errors\n  if (error instanceof ValidationError || error instanceof ConfigurationError) {\n    return false;\n  }\n\n  return true;\n}\n", "/**\n * @file Connection-state management system.\n */\n\nimport { getLogger } from '../../../config/logging-config.ts';\n\nconst logger = getLogger('coordination-swarm-connection-management-connection-state-manager');\n\n/**\n * MCP Connection State Manager for ZenSwarm.\n *\n * Provides comprehensive MCP connection state management with persistence,\n * automatic recovery, and health monitoring integration.\n *\n * Features:\n * - Connection state persistence and recovery\n * - Automatic reconnection with exponential backoff\n * - Health monitoring integration\n * - Connection pooling and load balancing\n * - Graceful degradation and fallback mechanisms.\n * - Real-time connection status monitoring.\n */\n\nimport type { ChildProcess } from 'node:child_process';\nimport { EventEmitter } from 'node:events';\nimport type { Readable, Writable } from 'node:stream';\n\n// Helper functions and classes moved inline to avoid missing imports\nconst generateId = (prefix: string) =>\n  `${prefix}-${Date.now()}-${Math.random().toString(36).substring(2, 11)}`;\n\n// Type definitions\ninterface LoggerOptions {\n  name: string;\n  level?: string;\n  metadata?: Record<string, unknown>;\n}\n\ninterface ErrorWithMetadata extends Error {\n  type?: string;\n  context?: unknown;\n}\n\ninterface ConnectionConfig {\n  id?: string;\n  type?: string;\n  metadata?: Record<string, unknown>;\n  [key: string]: unknown;\n}\n\ninterface ConnectionError {\n  message: string;\n  timestamp: Date;\n  operation?: string;\n}\n\ninterface ConnectionHealth {\n  status: string;\n  lastCheck: Date | null;\n  latency: number | null;\n  errors: ConnectionError[];\n}\n\ninterface Connection {\n  id: string;\n  type: string;\n  config: ConnectionConfig;\n  status: string;\n  createdAt: Date;\n  lastConnected: Date | null;\n  lastDisconnected: Date | null;\n  reconnectAttempts: number;\n  error: Error | null;\n  health: ConnectionHealth;\n  metadata: Record<string, unknown>;\n  // Connection-specific properties\n  process?: ChildProcess;\n  stdin?: Writable;\n  stdout?: Readable;\n  stderr?: Readable;\n  websocket?: any;\n  http?: {\n    baseUrl: string;\n    headers: Record<string, string>;\n    fetch: (endpoint: string, options?: any) => Promise<Response>;\n  };\n}\n\ninterface ConnectionHealthStats {\n  consecutive_failures: number;\n  last_success: Date | null;\n  last_failure: Date | null;\n  total_attempts: number;\n  success_rate: number;\n}\n\ninterface ManagerOptions {\n  maxConnections?: number;\n  connectionTimeout?: number;\n  reconnectDelay?: number;\n  maxReconnectDelay?: number;\n  maxReconnectAttempts?: number;\n  healthCheckInterval?: number;\n  persistenceEnabled?: boolean;\n  enableFallback?: boolean;\n  [key: string]: unknown;\n}\n\ninterface ManagerStats {\n  totalConnections: number;\n  activeConnections: number;\n  failedConnections: number;\n  reconnectAttempts: number;\n  averageConnectionTime: number;\n  totalConnectionTime: number;\n}\n\n// Simple logger implementation\nclass Logger {\n  constructor(options: LoggerOptions) {\n    this.name = options?.name;\n  }\n  name: string;\n  info(_msg: string, ..._args: unknown[]): void {}\n  error(msg: string, ...args: any[]): void {\n    logger.error(`[ERROR] ${this.name}:`, msg, ...args);\n  }\n  warn(msg: string, ...args: any[]): void {\n    logger.warn(`[WARN] ${this.name}:`, msg, ...args);\n  }\n  debug(_msg: string, ..._args: unknown[]): void {}\n}\n\n// Simple error factory\nclass ErrorFactory {\n  static createError(type: string, message: string, context?: unknown): Error {\n    const error = new Error(message);\n    (error as ErrorWithMetadata).type = type;\n    (error as ErrorWithMetadata).context = context;\n    return error;\n  }\n}\n\nexport class ConnectionStateManager extends EventEmitter {\n  options: ManagerOptions;\n  connections: Map<string, Connection>;\n  connectionStats!: Map<string, Record<string, unknown>>; // Initialized in constructor\n  healthChecks!: Map<string, NodeJS.Timeout>; // Initialized in constructor\n  persistenceManager: unknown;\n  fallbackManager: unknown;\n  logger: Logger;\n  connectionHealth: Map<string, ConnectionHealthStats>;\n  reconnectTimers: Map<string, NodeJS.Timeout>;\n  fallbackConnections: Map<string, Connection>;\n  isInitialized: boolean;\n  isShuttingDown: boolean;\n  connectionPool: Connection[];\n  activeConnections: number;\n  stats: ManagerStats;\n  persistence: unknown;\n  healthMonitor: unknown;\n  recoveryWorkflows: unknown;\n  healthMonitorInterval: NodeJS.Timeout | null;\n\n  constructor(options: ManagerOptions = {}) {\n    super();\n\n    this.options = {\n      maxConnections: options?.maxConnections || 10,\n      connectionTimeout: options?.connectionTimeout || 30000,\n      reconnectDelay: options?.reconnectDelay || 1000,\n      maxReconnectDelay: options?.maxReconnectDelay || 30000,\n      maxReconnectAttempts: options?.maxReconnectAttempts || 10,\n      healthCheckInterval: options?.healthCheckInterval || 30000,\n      persistenceEnabled: options?.persistenceEnabled !== false,\n      enableFallback: options?.enableFallback !== false,\n      ...options,\n    };\n\n    this.logger = new Logger({\n      name: 'connection-state-manager',\n      level: process.env['LOG_LEVEL'] || 'INFO',\n      metadata: { component: 'connection-state-manager' },\n    });\n\n    // Connection state\n    this.connections = new Map();\n    this.connectionStats = new Map();\n    this.healthChecks = new Map();\n    this.connectionHealth = new Map();\n    this.reconnectTimers = new Map();\n    this.fallbackConnections = new Map();\n\n    // State tracking\n    this.isInitialized = false;\n    this.isShuttingDown = false;\n    this.connectionPool = [];\n    this.activeConnections = 0;\n\n    // Statistics\n    this.stats = {\n      totalConnections: 0,\n      activeConnections: 0,\n      failedConnections: 0,\n      reconnectAttempts: 0,\n      averageConnectionTime: 0,\n      totalConnectionTime: 0,\n    };\n\n    // Integration points\n    this.persistence = null;\n    this.healthMonitor = null;\n    this.recoveryWorkflows = null;\n    this.healthMonitorInterval = null;\n\n    this.initialize();\n  }\n\n  /**\n   * Initialize the connection state manager.\n   */\n  async initialize() {\n    try {\n      this.logger.info('Initializing Connection State Manager');\n\n      // Start health monitoring\n      this.startHealthMonitoring();\n\n      // Restore persisted connections if enabled\n      if (this.options.persistenceEnabled && this.persistence) {\n        await this.restorePersistedConnections();\n      }\n\n      this.isInitialized = true;\n      this.logger.info('Connection State Manager initialized successfully');\n      this.emit('manager:initialized');\n    } catch (error) {\n      const managerError = ErrorFactory.createError(\n        'resource',\n        'Failed to initialize connection state manager',\n        {\n          error: error instanceof Error ? error.message : String(error),\n          component: 'connection-state-manager',\n        }\n      );\n      this.logger.error('Connection State Manager initialization failed', managerError);\n      throw managerError;\n    }\n  }\n\n  /**\n   * Register a new MCP connection.\n   *\n   * @param connectionConfig\n   */\n  async registerConnection(connectionConfig: ConnectionConfig): Promise<string> {\n    if (!this.isInitialized) {\n      await this.initialize();\n    }\n\n    const connectionId = connectionConfig?.id || generateId('connection');\n    const startTime = Date.now();\n\n    const connection: Connection = {\n      id: connectionId,\n      type: connectionConfig?.type || 'stdio',\n      config: connectionConfig,\n      status: 'initializing',\n      createdAt: new Date(),\n      lastConnected: null,\n      lastDisconnected: null,\n      reconnectAttempts: 0,\n      error: null as Error | null,\n      health: {\n        status: 'unknown',\n        lastCheck: null,\n        latency: null,\n        errors: [],\n      },\n      metadata: connectionConfig?.metadata || {},\n    };\n\n    this.connections.set(connectionId, connection);\n    this.connectionHealth.set(connectionId, {\n      consecutive_failures: 0,\n      last_success: null,\n      last_failure: null,\n      total_attempts: 0,\n      success_rate: 0,\n    });\n\n    this.logger.info(`Registering MCP connection: ${connectionId}`, {\n      type: connection.type,\n      config: connectionConfig,\n    });\n\n    try {\n      // Attempt to establish connection\n      await this.establishConnection(connectionId);\n\n      connection.status = 'connected';\n      connection.lastConnected = new Date();\n\n      const connectionTime = Date.now() - startTime;\n      this.stats.totalConnectionTime += connectionTime;\n      this.stats.averageConnectionTime =\n        this.stats.totalConnectionTime / this.stats.totalConnections;\n\n      // Persist connection state if enabled\n      if (this.options.persistenceEnabled) {\n        await this.persistConnectionState(connection);\n      }\n\n      this.logger.info(`MCP connection established: ${connectionId}`, {\n        connectionTime,\n        activeConnections: this.activeConnections,\n      });\n\n      this.emit('connection:established', { connectionId, connection });\n    } catch (error) {\n      connection.status = 'failed';\n      connection.error = error as Error;\n      this.stats.failedConnections++;\n\n      this.logger.error(`Failed to establish MCP connection: ${connectionId}`, {\n        error: (error as Error).message,\n      });\n\n      this.emit('connection:failed', { connectionId, connection, error });\n\n      // Schedule reconnection attempt\n      this.scheduleReconnection(connectionId);\n    }\n\n    return connectionId;\n  }\n\n  /**\n   * Establish connection to MCP server.\n   *\n   * @param connectionId\n   */\n  async establishConnection(connectionId: string) {\n    const connection = this.connections.get(connectionId);\n    if (!connection) {\n      throw new Error(`Connection ${connectionId} not found`);\n    }\n\n    this.logger.debug(`Establishing connection: ${connectionId}`, {\n      type: connection.type,\n      attempt: connection.reconnectAttempts + 1,\n    });\n\n    const startTime = Date.now();\n\n    try {\n      // Connection establishment logic based on type\n      switch (connection.type) {\n        case 'stdio':\n          await this.establishStdioConnection(connection);\n          break;\n        case 'websocket':\n          await this.establishWebSocketConnection(connection);\n          break;\n        case 'http':\n          await this.establishHttpConnection(connection);\n          break;\n        default:\n          throw new Error(`Unsupported connection type: ${connection.type}`);\n      }\n\n      // Update health metrics\n      const health = this.connectionHealth.get(connectionId);\n      if (health) {\n        health.consecutive_failures = 0;\n        health.last_success = new Date();\n        health.total_attempts++;\n        health.success_rate = health.last_success ? 1 : 0;\n      }\n\n      connection.health.status = 'healthy';\n      connection.health.lastCheck = new Date();\n      connection.health.latency = Date.now() - startTime;\n\n      this.logger.debug(`Connection established successfully: ${connectionId}`, {\n        latency: connection.health.latency,\n      });\n    } catch (error) {\n      // Update failure metrics\n      const health = this.connectionHealth.get(connectionId);\n      if (health) {\n        health.consecutive_failures++;\n        health.last_failure = new Date();\n        health.total_attempts++;\n      }\n\n      connection.health.status = 'unhealthy';\n      connection.health.lastCheck = new Date();\n      connection.health.errors.push({\n        message: (error as Error).message,\n        timestamp: new Date(),\n      });\n\n      // Keep only last 10 errors\n      if (connection.health.errors.length > 10) {\n        connection.health.errors = connection.health.errors.slice(-10);\n      }\n\n      throw error;\n    }\n  }\n\n  /**\n   * Establish stdio-based MCP connection.\n   *\n   * @param connection\n   */\n  async establishStdioConnection(connection: Connection) {\n    const { spawn } = await import('node:child_process');\n\n    const config = connection.config;\n    const command = config?.['command'] as string;\n    const args = (config?.['args'] as string[]) || [];\n\n    if (!command) {\n      throw new Error('Command is required for stdio connection');\n    }\n\n    return new Promise<void>((resolve, reject) => {\n      const timeout = setTimeout(() => {\n        reject(new Error('Connection timeout'));\n      }, this.options.connectionTimeout);\n\n      try {\n        const childProcess = spawn(command, args, {\n          stdio: ['pipe', 'pipe', 'pipe'],\n          env: { ...process.env, ...((config?.['env'] as Record<string, string>) || {}) },\n        });\n\n        childProcess?.on('spawn', () => {\n          clearTimeout(timeout);\n          connection.process = childProcess;\n          connection.stdin = childProcess?.stdin;\n          connection.stdout = childProcess?.stdout;\n          connection.stderr = childProcess?.stderr;\n\n          // Set up message handling\n          this.setupMessageHandling(connection);\n\n          resolve();\n        });\n\n        childProcess?.on('error', (error) => {\n          clearTimeout(timeout);\n          reject(new Error(`Failed to spawn process: ${error.message}`));\n        });\n\n        childProcess?.on('exit', (code, signal) => {\n          this.handleConnectionClosed(connection.id, code, signal);\n        });\n      } catch (error) {\n        clearTimeout(timeout);\n        reject(error);\n      }\n    });\n  }\n\n  /**\n   * Establish WebSocket-based MCP connection.\n   *\n   * @param connection\n   */\n  async establishWebSocketConnection(connection: Connection) {\n    const ws = await import('ws');\n    const WebSocket = (ws as any).default || ws;\n\n    const config = connection.config;\n    const url = config?.['url'] as string;\n\n    if (!url) {\n      throw new Error('URL is required for WebSocket connection');\n    }\n\n    return new Promise<void>((resolve, reject) => {\n      const timeout = setTimeout(() => {\n        reject(new Error('WebSocket connection timeout'));\n      }, this.options.connectionTimeout);\n\n      try {\n        const ws = new WebSocket(url, config?.['protocols'], config?.['options']);\n\n        ws.on('open', () => {\n          clearTimeout(timeout);\n          connection.websocket = ws;\n\n          // Set up message handling\n          this.setupWebSocketHandling(connection);\n\n          resolve();\n        });\n\n        ws.on('error', (error: Error) => {\n          clearTimeout(timeout);\n          reject(new Error(`WebSocket error: ${error.message}`));\n        });\n\n        ws.on('close', (code: number, reason: Buffer) => {\n          this.handleConnectionClosed(connection.id, code, reason);\n        });\n      } catch (error) {\n        clearTimeout(timeout);\n        reject(error);\n      }\n    });\n  }\n\n  /**\n   * Establish HTTP-based MCP connection.\n   *\n   * @param connection\n   */\n  async establishHttpConnection(connection: Connection) {\n    const config = connection.config;\n    const baseUrl = config?.['baseUrl'] as string;\n\n    if (!baseUrl) {\n      throw new Error('Base URL is required for HTTP connection');\n    }\n\n    // Test connection with a simple request\n    const controller = new AbortController();\n    const timeoutId = setTimeout(() => controller.abort(), this.options.connectionTimeout);\n\n    try {\n      const response = await fetch(`${baseUrl}/health`, {\n        method: 'GET',\n        signal: controller.signal,\n        headers: (config?.['headers'] as Record<string, string>) || {},\n      });\n      clearTimeout(timeoutId);\n\n      if (!response?.ok) {\n        throw new Error(`HTTP connection test failed: ${response?.status} ${response?.statusText}`);\n      }\n    } catch (error: any) {\n      clearTimeout(timeoutId);\n      if (error.name === 'AbortError') {\n        throw new Error(`HTTP connection test timed out after ${this.options.connectionTimeout}ms`);\n      }\n      throw error;\n    }\n\n    connection.http = {\n      baseUrl,\n      headers: (config?.['headers'] as Record<string, string>) || {},\n      fetch: (endpoint: string, options: any = {}) => {\n        return fetch(`${baseUrl}${endpoint}`, {\n          ...options,\n          headers: { ...connection.http!.headers, ...(options?.headers || {}) },\n        });\n      },\n    };\n  }\n\n  /**\n   * Set up message handling for stdio connections.\n   *\n   * @param connection\n   */\n  setupMessageHandling(connection: Connection) {\n    let buffer = '';\n\n    connection.stdout?.on('data', (data) => {\n      buffer += data.toString();\n      const lines = buffer.split('\\n');\n      buffer = lines.pop() || ''; // Keep incomplete line in buffer\n\n      lines.forEach((line) => {\n        if (line.trim()) {\n          try {\n            const message = JSON.parse(line);\n            this.handleMessage(connection.id, message);\n          } catch (error) {\n            this.logger.warn(`Invalid JSON message from ${connection.id}`, {\n              line,\n              error: (error as Error).message,\n            });\n          }\n        }\n      });\n    });\n\n    connection.stderr?.on('data', (data) => {\n      this.logger.warn(`stderr from ${connection.id}:`, data.toString());\n    });\n  }\n\n  /**\n   * Set up WebSocket message handling.\n   *\n   * @param connection\n   */\n  setupWebSocketHandling(connection: Connection) {\n    connection.websocket?.on('message', (data: Buffer) => {\n      try {\n        const message = JSON.parse(data.toString());\n        this.handleMessage(connection.id, message);\n      } catch (error) {\n        this.logger.warn(`Invalid JSON message from WebSocket ${connection.id}`, {\n          data: data.toString(),\n          error: (error as Error).message,\n        });\n      }\n    });\n  }\n\n  /**\n   * Handle incoming message from MCP connection.\n   *\n   * @param connectionId\n   * @param message\n   */\n  handleMessage(connectionId: string, message: any) {\n    this.logger.debug(`Received message from ${connectionId}`, { message });\n\n    // Update connection health\n    const connection = this.connections.get(connectionId);\n    if (connection) {\n      connection.health.lastCheck = new Date();\n      connection.health.status = 'healthy';\n    }\n\n    this.emit('message:received', { connectionId, message });\n  }\n\n  /**\n   * Send message to MCP connection.\n   *\n   * @param connectionId\n   * @param message\n   */\n  async sendMessage(connectionId: string, message: any) {\n    const connection = this.connections.get(connectionId);\n    if (!connection) {\n      throw new Error(`Connection ${connectionId} not found`);\n    }\n\n    if (connection.status !== 'connected') {\n      throw new Error(`Connection ${connectionId} is not connected (status: ${connection.status})`);\n    }\n\n    const messageStr = JSON.stringify(message);\n\n    try {\n      switch (connection.type) {\n        case 'stdio':\n          if (!connection.stdin || connection.stdin.destroyed) {\n            throw new Error('stdin is not available');\n          }\n          connection.stdin.write(`${messageStr}\\n`);\n          break;\n\n        case 'websocket':\n          if (!connection.websocket || connection.websocket.readyState !== 1) {\n            throw new Error('WebSocket is not open');\n          }\n          connection.websocket.send(messageStr);\n          break;\n\n        case 'http':\n          // For HTTP, this would typically be handled differently\n          // depending on the specific API design\n          throw new Error('HTTP message sending not implemented');\n\n        default:\n          throw new Error(`Unsupported connection type: ${connection.type}`);\n      }\n\n      this.logger.debug(`Sent message to ${connectionId}`, { message });\n      this.emit('message:sent', { connectionId, message });\n    } catch (error) {\n      this.logger.error(`Failed to send message to ${connectionId}`, {\n        error: (error as Error).message,\n        message,\n      });\n\n      // Mark connection as unhealthy\n      connection.health.status = 'unhealthy';\n      connection.health.errors.push({\n        message: (error as Error).message,\n        timestamp: new Date(),\n        operation: 'send_message',\n      });\n\n      throw error;\n    }\n  }\n\n  /**\n   * Handle connection closure.\n   *\n   * @param connectionId\n   * @param code\n   * @param reason\n   */\n  handleConnectionClosed(connectionId: string, code: number | null, reason: any) {\n    const connection = this.connections.get(connectionId);\n    if (!connection) return;\n\n    connection.status = 'disconnected';\n    connection.lastDisconnected = new Date();\n    this.activeConnections = Math.max(0, this.activeConnections - 1);\n    this.stats.activeConnections = this.activeConnections;\n\n    this.logger.warn(`Connection closed: ${connectionId}`, {\n      code,\n      reason: reason?.toString(),\n      wasConnected: connection.lastConnected !== null,\n    });\n\n    this.emit('connection:closed', { connectionId, connection, code, reason });\n\n    // Schedule reconnection if not shutting down\n    if (!this.isShuttingDown && connection.config['autoReconnect'] !== false) {\n      this.scheduleReconnection(connectionId);\n    }\n  }\n\n  /**\n   * Schedule reconnection attempt.\n   *\n   * @param connectionId\n   */\n  scheduleReconnection(connectionId: string) {\n    const connection = this.connections.get(connectionId);\n    if (!connection) return;\n\n    // Check if we've exceeded max reconnect attempts\n    if (connection.reconnectAttempts >= (this.options.maxReconnectAttempts || 10)) {\n      this.logger.error(`Max reconnection attempts reached for ${connectionId}`, {\n        attempts: connection.reconnectAttempts,\n      });\n\n      connection.status = 'failed';\n      this.emit('connection:exhausted', { connectionId, connection });\n\n      // Trigger recovery workflow if available\n      if (this.recoveryWorkflows) {\n        (this.recoveryWorkflows as any).triggerRecovery('mcp.connection.exhausted', {\n          connectionId,\n          connection,\n        });\n      }\n\n      return;\n    }\n\n    // Calculate delay with exponential backoff\n    const delay = Math.min(\n      (this.options.reconnectDelay || 1000) * 2 ** connection.reconnectAttempts,\n      this.options.maxReconnectDelay || 30000\n    );\n\n    this.logger.info(`Scheduling reconnection for ${connectionId}`, {\n      attempt: connection.reconnectAttempts + 1,\n      delay,\n    });\n\n    const timer = setTimeout(async () => {\n      this.reconnectTimers.delete(connectionId);\n\n      try {\n        connection.reconnectAttempts++;\n        connection.status = 'reconnecting';\n        this.stats.reconnectAttempts++;\n\n        this.emit('connection:reconnecting', { connectionId, connection });\n\n        await this.establishConnection(connectionId);\n\n        connection.status = 'connected';\n        connection.lastConnected = new Date();\n        connection.reconnectAttempts = 0; // Reset on successful reconnection\n        this.activeConnections++;\n        this.stats.activeConnections++;\n\n        this.logger.info(`Reconnection successful for ${connectionId}`);\n        this.emit('connection:reconnected', { connectionId, connection });\n\n        // Persist updated state\n        if (this.options.persistenceEnabled) {\n          await this.persistConnectionState(connection);\n        }\n      } catch (error) {\n        this.logger.error(`Reconnection failed for ${connectionId}`, {\n          error: (error as Error).message,\n          attempt: connection.reconnectAttempts,\n        });\n\n        connection.status = 'failed';\n        this.emit('connection:reconnect_failed', { connectionId, connection, error });\n\n        // Schedule next attempt\n        this.scheduleReconnection(connectionId);\n      }\n    }, delay);\n\n    this.reconnectTimers.set(connectionId, timer);\n  }\n\n  /**\n   * Get connection status.\n   *\n   * @param connectionId\n   */\n  getConnectionStatus(connectionId: string | null = null) {\n    if (connectionId) {\n      const connection = this.connections.get(connectionId);\n      if (!connection) return null;\n\n      return {\n        ...connection,\n        health: this.connectionHealth.get(connectionId),\n      };\n    }\n\n    // Return all connections status\n    const connections: Record<string, any> = {};\n    for (const [id, connection] of Array.from(this.connections.entries())) {\n      connections[id] = {\n        ...connection,\n        health: this.connectionHealth.get(id),\n      };\n    }\n\n    return {\n      connections,\n      stats: this.getConnectionStats(),\n      summary: {\n        total: this.connections.size,\n        active: this.activeConnections,\n        failed: Array.from(this.connections.values()).filter((c) => c.status === 'failed').length,\n        reconnecting: Array.from(this.connections.values()).filter(\n          (c) => c.status === 'reconnecting'\n        ).length,\n      },\n    };\n  }\n\n  /**\n   * Get connection statistics.\n   */\n  getConnectionStats() {\n    return {\n      ...this.stats,\n      connectionCount: this.connections.size,\n      healthyConnections: Array.from(this.connections.values()).filter(\n        (c) => c.health.status === 'healthy'\n      ).length,\n      reconnectingConnections: this.reconnectTimers.size,\n    };\n  }\n\n  /**\n   * Disconnect a connection.\n   *\n   * @param connectionId\n   * @param reason\n   */\n  async disconnectConnection(connectionId: string, reason = 'Manual disconnect') {\n    const connection = this.connections.get(connectionId);\n    if (!connection) {\n      throw new Error(`Connection ${connectionId} not found`);\n    }\n\n    this.logger.info(`Disconnecting connection: ${connectionId}`, { reason });\n\n    // Cancel reconnection timer if active\n    const timer = this.reconnectTimers.get(connectionId);\n    if (timer) {\n      clearTimeout(timer);\n      this.reconnectTimers.delete(connectionId);\n    }\n\n    // Close connection based on type\n    try {\n      switch (connection.type) {\n        case 'stdio':\n          if (connection.process && !connection.process.killed) {\n            connection.process.kill();\n          }\n          break;\n\n        case 'websocket':\n          if (connection.websocket && connection.websocket.readyState === 1) {\n            connection.websocket.close();\n          }\n          break;\n\n        case 'http':\n          // HTTP connections don't need explicit closing\n          break;\n      }\n    } catch (error) {\n      this.logger.warn(`Error closing connection ${connectionId}`, {\n        error: (error as Error).message,\n      });\n    }\n\n    connection.status = 'disconnected';\n    connection.lastDisconnected = new Date();\n\n    if (this.activeConnections > 0) {\n      this.activeConnections--;\n      this.stats.activeConnections--;\n    }\n\n    this.emit('connection:disconnected', { connectionId, connection, reason });\n  }\n\n  /**\n   * Remove a connection completely.\n   *\n   * @param connectionId\n   */\n  async removeConnection(connectionId: string) {\n    // First disconnect if still connected\n    if (this.connections.has(connectionId)) {\n      try {\n        await this.disconnectConnection(connectionId, 'Connection removal');\n      } catch (error) {\n        this.logger.warn(`Error disconnecting before removal: ${connectionId}`, {\n          error: (error as Error).message,\n        });\n      }\n    }\n\n    // Remove from all tracking\n    this.connections.delete(connectionId);\n    this.connectionHealth.delete(connectionId);\n    this.reconnectTimers.delete(connectionId);\n    this.fallbackConnections.delete(connectionId);\n\n    // Remove from persistence\n    if (this.options.persistenceEnabled && this.persistence) {\n      await this.removePersistedConnection(connectionId);\n    }\n\n    this.logger.info(`Connection removed: ${connectionId}`);\n    this.emit('connection:removed', { connectionId });\n  }\n\n  /**\n   * Start health monitoring.\n   */\n  startHealthMonitoring() {\n    this.healthMonitorInterval = setInterval(async () => {\n      try {\n        await this.performHealthChecks();\n      } catch (error) {\n        this.logger.error('Error in health monitoring', {\n          error: (error as Error).message,\n        });\n      }\n    }, this.options.healthCheckInterval);\n\n    this.logger.debug('Health monitoring started');\n  }\n\n  /**\n   * Perform health checks on all connections.\n   */\n  async performHealthChecks() {\n    const healthChecks = Array.from(this.connections.entries())\n      .filter(([_, connection]) => connection.status === 'connected')\n      .map(([id, _connection]) => this.performConnectionHealthCheck(id));\n\n    await Promise.allSettled(healthChecks);\n  }\n\n  /**\n   * Perform health check on a specific connection.\n   *\n   * @param connectionId\n   */\n  async performConnectionHealthCheck(connectionId: string) {\n    const connection = this.connections.get(connectionId);\n    if (!connection || connection.status !== 'connected') return;\n\n    const startTime = Date.now();\n\n    try {\n      // Send a simple ping message to test connectivity\n      const pingMessage = {\n        jsonrpc: '2.0',\n        method: 'ping',\n        id: generateId('ping'),\n      };\n\n      await this.sendMessage(connectionId, pingMessage);\n\n      const latency = Date.now() - startTime;\n      connection.health.latency = latency;\n      connection.health.status = 'healthy';\n      connection.health.lastCheck = new Date();\n\n      // Update health metrics\n      const health = this.connectionHealth.get(connectionId);\n      if (health) {\n        health.consecutive_failures = 0;\n      }\n    } catch (error) {\n      connection.health.status = 'unhealthy';\n      connection.health.lastCheck = new Date();\n      connection.health.errors.push({\n        message: (error as Error).message,\n        timestamp: new Date(),\n        operation: 'health_check',\n      });\n\n      // Update failure metrics\n      const health = this.connectionHealth.get(connectionId);\n      if (health) {\n        health.consecutive_failures++;\n        health.last_failure = new Date();\n      }\n\n      this.logger.warn(`Health check failed for connection ${connectionId}`, {\n        error: (error as Error).message,\n      });\n\n      // Trigger recovery if too many consecutive failures\n      if (health && health.consecutive_failures >= 3) {\n        this.logger.error(`Connection ${connectionId} failing health checks`, {\n          consecutiveFailures: health.consecutive_failures,\n        });\n\n        if (this.recoveryWorkflows) {\n          await (this.recoveryWorkflows as any).triggerRecovery('mcp.connection.unhealthy', {\n            connectionId,\n            connection,\n            consecutiveFailures: health.consecutive_failures,\n          });\n        }\n      }\n    }\n  }\n\n  /**\n   * Persist connection state.\n   *\n   * @param connection\n   */\n  async persistConnectionState(connection: Connection) {\n    if (!this.persistence) return;\n\n    try {\n      await (this.persistence as any).pool.write(\n        `\n        INSERT OR REPLACE INTO mcp_connections \n        (id, type, config, status, created_at, last_connected, last_disconnected, reconnect_attempts, metadata)\n        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)\n      `,\n        [\n          connection.id,\n          connection.type,\n          JSON.stringify(connection.config),\n          connection.status,\n          connection.createdAt.toISOString(),\n          connection.lastConnected?.toISOString(),\n          connection.lastDisconnected?.toISOString(),\n          connection.reconnectAttempts,\n          JSON.stringify(connection.metadata),\n        ]\n      );\n    } catch (error) {\n      this.logger.error('Failed to persist connection state', {\n        connectionId: connection.id,\n        error: (error as Error).message,\n      });\n    }\n  }\n\n  /**\n   * Restore persisted connections.\n   */\n  async restorePersistedConnections() {\n    if (!this.persistence) return;\n\n    try {\n      // Create table if it doesn't exist\n      await (this.persistence as any).pool.write(`\n        CREATE TABLE IF NOT EXISTS mcp_connections (\n          id TEXT PRIMARY KEY,\n          type TEXT NOT NULL,\n          config TEXT NOT NULL,\n          status TEXT NOT NULL,\n          created_at DATETIME,\n          last_connected DATETIME,\n          last_disconnected DATETIME,\n          reconnect_attempts INTEGER DEFAULT 0,\n          metadata TEXT DEFAULT '{}'\n        )\n      `);\n\n      const connections = await (this.persistence as any).pool.read(\n        'SELECT * FROM mcp_connections WHERE status IN (?, ?)',\n        ['connected', 'reconnecting']\n      );\n\n      for (const row of connections) {\n        const connection: Connection = {\n          id: row.id,\n          type: row.type,\n          config: JSON.parse(row.config),\n          status: 'disconnected', // Start as disconnected and let reconnection handle it\n          createdAt: new Date(row.created_at),\n          lastConnected: row.last_connected ? new Date(row.last_connected) : null,\n          lastDisconnected: row.last_disconnected ? new Date(row.last_disconnected) : null,\n          reconnectAttempts: row.reconnect_attempts,\n          error: null,\n          health: {\n            status: 'unknown',\n            lastCheck: null,\n            latency: null,\n            errors: [],\n          },\n          metadata: JSON.parse(row.metadata),\n        };\n\n        this.connections.set(connection.id, connection);\n        this.connectionHealth.set(connection.id, {\n          consecutive_failures: 0,\n          last_success: null,\n          last_failure: null,\n          total_attempts: 0,\n          success_rate: 0,\n        });\n\n        // Schedule reconnection\n        if (connection.config['autoReconnect'] !== false) {\n          this.scheduleReconnection(connection.id);\n        }\n      }\n\n      this.logger.info('Restored persisted connections', {\n        connectionCount: connections.length,\n      });\n    } catch (error) {\n      this.logger.error('Failed to restore persisted connections', {\n        error: (error as Error).message,\n      });\n    }\n  }\n\n  /**\n   * Remove persisted connection.\n   *\n   * @param connectionId\n   */\n  async removePersistedConnection(connectionId: string) {\n    if (!this.persistence) return;\n\n    try {\n      await (this.persistence as any).pool.write('DELETE FROM mcp_connections WHERE id = ?', [\n        connectionId,\n      ]);\n    } catch (error) {\n      this.logger.error('Failed to remove persisted connection', {\n        connectionId,\n        error: (error as Error).message,\n      });\n    }\n  }\n\n  /**\n   * Set integration points.\n   *\n   * @param persistence\n   */\n  setPersistence(persistence: any) {\n    this.persistence = persistence;\n    this.logger.info('Persistence integration configured');\n  }\n\n  setHealthMonitor(healthMonitor: any) {\n    this.healthMonitor = healthMonitor;\n    this.logger.info('Health Monitor integration configured');\n  }\n\n  setRecoveryWorkflows(recoveryWorkflows: any) {\n    this.recoveryWorkflows = recoveryWorkflows;\n    this.logger.info('Recovery Workflows integration configured');\n  }\n\n  /**\n   * Export connection data for monitoring dashboards.\n   */\n  exportConnectionData() {\n    return {\n      timestamp: new Date(),\n      stats: this.getConnectionStats(),\n      connections: Array.from(this.connections.entries()).map(([id, connection]) => ({\n        ...connection,\n        health: this.connectionHealth.get(id),\n      })),\n      activeTimers: this.reconnectTimers.size,\n    };\n  }\n\n  /**\n   * Cleanup and shutdown.\n   */\n  async shutdown() {\n    this.logger.info('Shutting down Connection State Manager');\n    this.isShuttingDown = true;\n\n    // Stop health monitoring\n    if (this.healthMonitorInterval) {\n      clearInterval(this.healthMonitorInterval);\n    }\n\n    // Clear all reconnection timers\n    for (const [_connectionId, timer] of Array.from(this.reconnectTimers.entries())) {\n      clearTimeout(timer);\n    }\n    this.reconnectTimers.clear();\n\n    // Disconnect all connections\n    const disconnectPromises = Array.from(this.connections.keys()).map((connectionId) =>\n      this.disconnectConnection(connectionId, 'System shutdown').catch((error) =>\n        this.logger.warn(`Error disconnecting ${connectionId}`, { error: (error as Error).message })\n      )\n    );\n\n    await Promise.allSettled(disconnectPromises);\n\n    // Clear all data\n    this.connections.clear();\n    this.connectionHealth.clear();\n    this.fallbackConnections.clear();\n\n    this.emit('manager:shutdown');\n  }\n}\n\nexport default ConnectionStateManager;\n", "/**\n * Recovery Workflows System for ZenSwarm.\n *\n * Provides comprehensive recovery workflows for different failure scenarios,\n * automatic recovery procedures, and integration with health monitoring.\n *\n * Features:\n * - Pre-defined recovery workflows for common failure types\n * - Custom workflow creation and registration\n * - Automatic triggering based on health monitor alerts\n * - Step-by-step execution with rollback capabilities\n * - Integration with MCP connection state management.\n * - Chaos engineering support for testing recovery procedures.\n */\n/**\n * @file Coordination system: recovery-workflows.\n */\n\nimport { EventEmitter } from 'node:events';\nimport { ErrorFactory } from './errors.ts';\nimport { Logger } from './logger.ts';\nimport { generateId } from './utils.ts';\n\ninterface WorkflowDefinition {\n  id?: string;\n  name: string;\n  description?: string;\n  triggers?: any[];\n  steps?: any[];\n  rollbackSteps?: any[];\n  timeout?: number;\n  maxRetries?: number;\n  priority?: 'low' | 'normal' | 'high' | 'critical';\n  category?: string;\n  enabled?: boolean;\n  metadata?: any;\n  createdAt?: Date;\n}\n\nexport class RecoveryWorkflows extends EventEmitter {\n  public options: any;\n  public logger: any;\n  public workflows: Map<string, WorkflowDefinition>;\n  public activeRecoveries: Map<string, any>;\n  public recoveryHistory: Map<string, any>;\n  public healthMonitor: any;\n  public mcpTools: any;\n  public connectionManager: any;\n  public stats: any;\n\n  constructor(options: any = {}) {\n    super();\n\n    this.options = {\n      maxRetries: options?.maxRetries || 3,\n      retryDelay: options?.retryDelay || 5000,\n      maxConcurrentRecoveries: options?.maxConcurrentRecoveries || 3,\n      enableChaosEngineering: options.enableChaosEngineering === true,\n      recoveryTimeout: options?.recoveryTimeout || 300000, // 5 minutes\n      ...options,\n    };\n\n    this.logger = new Logger({\n      name: 'recovery-workflows',\n      level: process.env['LOG_LEVEL'] || 'INFO',\n      metadata: { component: 'recovery-workflows' },\n    });\n\n    // Workflow state\n    this.workflows = new Map();\n    this.activeRecoveries = new Map();\n    this.recoveryHistory = new Map();\n\n    // Integration points\n    this.healthMonitor = null;\n    this.mcpTools = null;\n    this.connectionManager = null;\n\n    // Recovery statistics\n    this.stats = {\n      totalRecoveries: 0,\n      successfulRecoveries: 0,\n      failedRecoveries: 0,\n      averageRecoveryTime: 0,\n      totalRecoveryTime: 0,\n    };\n\n    this.initialize();\n  }\n\n  /**\n   * Initialize recovery workflows.\n   */\n  async initialize() {\n    try {\n      this.logger.info('Initializing Recovery Workflows');\n\n      // Register built-in recovery workflows\n      this.registerBuiltInWorkflows();\n\n      this.logger.info('Recovery Workflows initialized successfully');\n      this.emit('workflows:initialized');\n    } catch (error) {\n      const recoveryError = ErrorFactory.createError(\n        'resource',\n        'Failed to initialize recovery workflows',\n        {\n          error: error.message,\n          component: 'recovery-workflows',\n        }\n      );\n      this.logger.error('Recovery Workflows initialization failed', recoveryError);\n      throw recoveryError;\n    }\n  }\n\n  /**\n   * Register a recovery workflow.\n   *\n   * @param name\n   * @param workflowDefinition\n   */\n  registerWorkflow(name: string, workflowDefinition: any): string {\n    const workflow: WorkflowDefinition = {\n      id: generateId('workflow'),\n      name,\n      description: workflowDefinition.description || '',\n      triggers: workflowDefinition.triggers || [],\n      steps: workflowDefinition.steps || [],\n      rollbackSteps: workflowDefinition.rollbackSteps || [],\n      timeout: workflowDefinition.timeout || this.options.recoveryTimeout,\n      maxRetries: workflowDefinition.maxRetries || this.options.maxRetries,\n      priority: workflowDefinition.priority || 'normal', // low, normal, high, critical\n      category: workflowDefinition.category || 'custom',\n      enabled: workflowDefinition.enabled !== false,\n      metadata: workflowDefinition.metadata || {},\n      createdAt: new Date(),\n    };\n\n    this.workflows.set(name, workflow);\n    this.recoveryHistory.set(name, []);\n\n    this.logger.info(`Registered recovery workflow: ${name}`, {\n      category: workflow.category,\n      priority: workflow.priority,\n      stepCount: workflow.steps?.length || 0,\n    });\n\n    return workflow.id || '';\n  }\n\n  /**\n   * Trigger recovery workflow.\n   *\n   * @param triggerSource\n   * @param context\n   */\n  async triggerRecovery(triggerSource: string, context: any = {}) {\n    try {\n      // Check if we're already at max concurrent recoveries\n      if (this.activeRecoveries.size >= this.options.maxConcurrentRecoveries) {\n        throw ErrorFactory.createError(\n          'concurrency',\n          `Maximum concurrent recoveries reached (${this.options.maxConcurrentRecoveries})`\n        );\n      }\n\n      // Find matching workflows\n      const matchingWorkflows = this.findMatchingWorkflows(triggerSource, context);\n\n      if (matchingWorkflows.length === 0) {\n        this.logger.warn(`No recovery workflows found for trigger: ${triggerSource}`, context);\n        return { status: 'no_workflow', triggerSource, context };\n      }\n\n      // Sort by priority and execute the highest priority workflow\n      const sortedWorkflows = matchingWorkflows?.sort(\n        (a: WorkflowDefinition, b: WorkflowDefinition) => {\n          const priorityOrder: { [key: string]: number } = {\n            critical: 4,\n            high: 3,\n            normal: 2,\n            low: 1,\n          };\n          const aPriority = a.priority || 'normal';\n          const bPriority = b.priority || 'normal';\n          return (priorityOrder[bPriority] || 0) - (priorityOrder[aPriority] || 0);\n        }\n      );\n\n      const workflow = sortedWorkflows[0];\n      if (!workflow) {\n        throw new Error('No valid workflow found after sorting');\n      }\n\n      this.logger.info(`Triggering recovery workflow: ${workflow.name}`, {\n        triggerSource,\n        workflowId: workflow.id,\n        priority: workflow.priority,\n      });\n\n      const recoveryExecution = await this.executeWorkflow(workflow, {\n        triggerSource,\n        ...context,\n      });\n\n      return recoveryExecution;\n    } catch (error) {\n      this.logger.error('Failed to trigger recovery workflow', {\n        triggerSource,\n        error: error.message,\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Execute a recovery workflow.\n   *\n   * @param workflow\n   * @param context\n   */\n  async executeWorkflow(workflow: WorkflowDefinition, context: any = {}) {\n    const executionId = generateId('execution');\n    const startTime = Date.now();\n\n    const execution = {\n      id: executionId,\n      workflowName: workflow.name,\n      workflowId: workflow.id,\n      status: 'running',\n      startTime: new Date(startTime),\n      endTime: null as Date | null,\n      duration: 0,\n      error: null as string | null,\n      context,\n      steps: [] as Array<{\n        name: any;\n        status: string;\n        startTime: Date;\n        endTime: Date | null;\n        duration: number;\n        error: string | null;\n        result: any;\n        context: any;\n      }>,\n      currentStep: 0,\n      retryCount: 0,\n      rollbackRequired: false,\n    };\n\n    this.activeRecoveries.set(executionId, execution);\n    this.stats.totalRecoveries++;\n\n    try {\n      this.logger.info(`Executing recovery workflow: ${workflow.name}`, {\n        executionId,\n        stepCount: workflow.steps?.length || 0,\n      });\n\n      this.emit('recovery:started', { executionId, workflow, context });\n\n      // Execute workflow steps\n      const steps = workflow.steps || [];\n      for (let i = 0; i < steps.length; i++) {\n        const step = steps[i];\n        execution.currentStep = i;\n\n        this.logger.debug(`Executing recovery step ${i + 1}: ${step.name}`, {\n          executionId,\n          stepName: step.name,\n        });\n\n        const stepResult = await this.executeStep(step, context, execution);\n        execution.steps.push(stepResult);\n\n        if (stepResult?.status === 'failed') {\n          if (step.continueOnFailure) {\n            this.logger.warn(`Step failed but continuing: ${step.name}`, {\n              executionId,\n              error: stepResult?.error,\n            });\n          } else {\n            execution.rollbackRequired = true;\n            throw new Error(`Recovery step failed: ${step.name} - ${stepResult?.error}`);\n          }\n        }\n\n        // Check for cancellation\n        if (execution.status === 'cancelled') {\n          execution.rollbackRequired = true;\n          throw new Error('Recovery workflow cancelled');\n        }\n      }\n\n      // Workflow completed successfully\n      execution.status = 'completed';\n      execution.endTime = new Date();\n      execution.duration = Date.now() - startTime;\n\n      this.stats.successfulRecoveries++;\n      this.stats.totalRecoveryTime += execution.duration;\n      this.stats.averageRecoveryTime = this.stats.totalRecoveryTime / this.stats.totalRecoveries;\n\n      this.logger.info(`Recovery workflow completed: ${workflow.name}`, {\n        executionId,\n        duration: execution.duration,\n        stepCount: execution.steps.length,\n      });\n\n      this.emit('recovery:completed', { executionId, execution });\n    } catch (error) {\n      execution.status = 'failed';\n      execution.endTime = new Date();\n      execution.duration = Date.now() - startTime;\n      execution.error = error.message;\n\n      this.stats.failedRecoveries++;\n\n      this.logger.error(`Recovery workflow failed: ${workflow.name}`, {\n        executionId,\n        error: error.message,\n        rollbackRequired: execution.rollbackRequired,\n      });\n\n      // Attempt rollback if required\n      if (\n        execution.rollbackRequired &&\n        workflow.rollbackSteps &&\n        workflow.rollbackSteps.length > 0\n      ) {\n        try {\n          await this.executeRollback(workflow, execution, context);\n        } catch (rollbackError) {\n          this.logger.error('Rollback failed', {\n            executionId,\n            error: rollbackError.message,\n          });\n        }\n      }\n\n      this.emit('recovery:failed', { executionId, execution, error });\n    } finally {\n      // Record execution in history\n      const history = this.recoveryHistory.get(workflow.name) || [];\n      history.push({\n        ...execution,\n        completedAt: new Date(),\n      });\n\n      // Keep only last 100 executions per workflow\n      if (history.length > 100) {\n        history.splice(0, history.length - 100);\n      }\n\n      this.activeRecoveries.delete(executionId);\n    }\n\n    return execution;\n  }\n\n  /**\n   * Execute a single workflow step.\n   *\n   * @param step\n   * @param context\n   * @param execution\n   */\n  async executeStep(step: any, context: any, execution: any) {\n    const stepStartTime = Date.now();\n    const stepResult = {\n      name: step.name,\n      status: 'running',\n      startTime: new Date(stepStartTime),\n      endTime: null as Date | null,\n      duration: 0,\n      error: null as string | null,\n      result: null as any,\n      context: step.context || {},\n    };\n\n    try {\n      // Apply step timeout\n      const stepTimeout = step.timeout || 30000; // 30 seconds default\n      const stepPromise = this.runStepFunction(step, context, execution);\n      const timeoutPromise = new Promise((_, reject) =>\n        setTimeout(() => reject(new Error('Step timeout')), stepTimeout)\n      );\n\n      const result = await Promise.race([stepPromise, timeoutPromise]);\n\n      stepResult.status = 'completed';\n      stepResult.result = result;\n      stepResult.endTime = new Date();\n      stepResult.duration = Date.now() - stepStartTime;\n\n      this.logger.debug(`Recovery step completed: ${step.name}`, {\n        executionId: execution.id,\n        duration: stepResult?.duration,\n      });\n    } catch (error) {\n      stepResult.status = 'failed';\n      stepResult.error = error.message;\n      stepResult.endTime = new Date();\n      stepResult.duration = Date.now() - stepStartTime;\n\n      this.logger.error(`Recovery step failed: ${step.name}`, {\n        executionId: execution.id,\n        error: error.message,\n      });\n    }\n\n    return stepResult;\n  }\n\n  /**\n   * Run the actual step function.\n   *\n   * @param step\n   * @param context\n   * @param execution\n   */\n  async runStepFunction(step: any, context: any, execution: any) {\n    if (typeof step.action === 'function') {\n      return await step.action(context, execution);\n    } else if (typeof step.action === 'string') {\n      // Handle built-in actions\n      return await this.runBuiltInAction(step.action, step.parameters || {}, context, execution);\n    } else {\n      throw new Error(`Invalid step action type: ${typeof step.action}`);\n    }\n  }\n\n  /**\n   * Execute rollback steps.\n   *\n   * @param workflow\n   * @param execution\n   * @param context\n   */\n  async executeRollback(workflow: WorkflowDefinition, execution: any, context: any) {\n    this.logger.info(`Executing rollback for workflow: ${workflow.name}`, {\n      executionId: execution.id,\n      rollbackStepCount: workflow.rollbackSteps?.length || 0,\n    });\n\n    execution.status = 'rolling_back';\n    const rollbackSteps: Array<{\n      name: any;\n      status: string;\n      startTime: Date;\n      endTime: Date | null;\n      duration: number;\n      error: string | null;\n      result: any;\n      context: any;\n    }> = [];\n\n    const steps = workflow.rollbackSteps || [];\n    for (const step of steps.reverse()) {\n      try {\n        const rollbackResult = await this.executeStep(step, context, execution);\n        rollbackSteps.push(rollbackResult);\n      } catch (error) {\n        this.logger.error(`Rollback step failed: ${step.name}`, {\n          executionId: execution.id,\n          error: error.message,\n        });\n        // Continue with other rollback steps\n      }\n    }\n\n    execution.rollbackSteps = rollbackSteps;\n    execution.status = 'rolled_back';\n\n    this.emit('recovery:rolled_back', { executionId: execution.id, execution });\n  }\n\n  /**\n   * Run built-in recovery actions.\n   *\n   * @param actionName\n   * @param parameters\n   * @param context\n   * @param _execution\n   */\n  async runBuiltInAction(actionName: string, parameters: any, context: any, _execution: any) {\n    switch (actionName) {\n      case 'restart_swarm':\n        return await this.restartSwarm(parameters.swarmId, context);\n\n      case 'restart_agent':\n        return await this.restartAgent(parameters.agentId, context);\n\n      case 'clear_cache':\n        return await this.clearCache(parameters.cacheType, context);\n\n      case 'restart_mcp_connection':\n        return await this.restartMCPConnection(parameters.connectionId, context);\n\n      case 'scale_agents':\n        return await this.scaleAgents(parameters.swarmId, parameters.targetCount, context);\n\n      case 'cleanup_resources':\n        return await this.cleanupResources(parameters.resourceType, context);\n\n      case 'reset_neural_network':\n        return await this.resetNeuralNetwork(parameters.networkId, context);\n\n      case 'wait':\n        await new Promise((resolve) => setTimeout(resolve, parameters.duration || 1000));\n        return { action: 'wait', duration: parameters.duration || 1000 };\n\n      case 'log_message':\n        this.logger.info(parameters.message || 'Recovery action executed', context);\n        return { action: 'log_message', message: parameters.message };\n\n      default:\n        throw new Error(`Unknown built-in action: ${actionName}`);\n    }\n  }\n\n  /**\n   * Find workflows that match the trigger.\n   *\n   * @param triggerSource\n   * @param context\n   */\n  findMatchingWorkflows(triggerSource: string, context: any): WorkflowDefinition[] {\n    const matchingWorkflows: WorkflowDefinition[] = [];\n\n    for (const [_name, workflow] of this.workflows) {\n      if (!workflow.enabled) continue;\n\n      // Check if workflow matches the trigger\n      const triggers = workflow.triggers || [];\n      const matches = triggers.some((trigger: any) => {\n        if (typeof trigger === 'string') {\n          return trigger === triggerSource || triggerSource.includes(trigger);\n        } else if (typeof trigger === 'object') {\n          return this.evaluateTriggerCondition(trigger, triggerSource, context);\n        }\n        return false;\n      });\n\n      if (matches) {\n        matchingWorkflows.push(workflow);\n      }\n    }\n\n    return matchingWorkflows;\n  }\n\n  /**\n   * Evaluate complex trigger conditions.\n   *\n   * @param trigger\n   * @param triggerSource\n   * @param context\n   */\n  evaluateTriggerCondition(trigger: any, triggerSource: string, context: any): boolean {\n    if (trigger.source && trigger.source !== triggerSource) return false;\n\n    if (trigger.pattern && !new RegExp(trigger.pattern).test(triggerSource)) return false;\n\n    if (trigger.context) {\n      for (const [key, value] of Object.entries(trigger.context)) {\n        if (context[key] !== value) return false;\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * Cancel an active recovery.\n   *\n   * @param executionId\n   * @param reason\n   */\n  async cancelRecovery(executionId: string, reason: string = 'Manual cancellation') {\n    const execution = this.activeRecoveries.get(executionId);\n    if (!execution) {\n      throw ErrorFactory.createError('validation', `Recovery execution ${executionId} not found`);\n    }\n\n    execution.status = 'cancelled';\n    execution.cancellationReason = reason;\n    execution.endTime = new Date();\n\n    this.logger.info(`Recovery workflow cancelled: ${execution.workflowName}`, {\n      executionId,\n      reason,\n    });\n\n    this.emit('recovery:cancelled', { executionId, execution, reason });\n  }\n\n  /**\n   * Get recovery status.\n   *\n   * @param executionId\n   */\n  getRecoveryStatus(executionId: string | null = null) {\n    if (executionId) {\n      const execution = this.activeRecoveries.get(executionId);\n      if (!execution) {\n        // Check history\n        for (const history of this.recoveryHistory.values()) {\n          const historicalExecution = history.find((e: any) => e.id === executionId);\n          if (historicalExecution) return historicalExecution;\n        }\n        return null;\n      }\n      return execution;\n    }\n\n    // Return all active recoveries\n    return Array.from(this.activeRecoveries.values());\n  }\n\n  /**\n   * Get recovery statistics.\n   */\n  getRecoveryStats() {\n    return {\n      ...this.stats,\n      activeRecoveries: this.activeRecoveries.size,\n      registeredWorkflows: this.workflows.size,\n      enabledWorkflows: Array.from(this.workflows.values()).filter((w) => w.enabled).length,\n    };\n  }\n\n  /**\n   * Set integration points.\n   *\n   * @param healthMonitor\n   */\n  setHealthMonitor(healthMonitor: any) {\n    this.healthMonitor = healthMonitor;\n    this.logger.info('Health Monitor integration configured');\n  }\n\n  setMCPTools(mcpTools: any) {\n    this.mcpTools = mcpTools;\n    this.logger.info('MCP Tools integration configured');\n  }\n\n  setConnectionManager(connectionManager: any) {\n    this.connectionManager = connectionManager;\n    this.logger.info('Connection Manager integration configured');\n  }\n\n  /**\n   * Register built-in recovery workflows.\n   */\n  registerBuiltInWorkflows() {\n    // Swarm initialization failure recovery\n    this.registerWorkflow('swarm_init_failure', {\n      description: 'Recover from swarm initialization failures',\n      triggers: ['swarm.init.failed', /swarm.*initialization.*failed/],\n      steps: [\n        {\n          name: 'cleanup_resources',\n          action: 'cleanup_resources',\n          parameters: { resourceType: 'swarm' },\n          timeout: 30000,\n        },\n        {\n          name: 'wait_cooldown',\n          action: 'wait',\n          parameters: { duration: 5000 },\n        },\n        {\n          name: 'retry_initialization',\n          action: async (context: any) => {\n            if (!this.mcpTools) throw new Error('MCP Tools not available');\n            return await this.mcpTools.swarm_init(context.swarmOptions || {});\n          },\n          timeout: 60000,\n        },\n      ],\n      rollbackSteps: [\n        {\n          name: 'cleanup_failed_init',\n          action: 'cleanup_resources',\n          parameters: { resourceType: 'swarm' },\n        },\n      ],\n      priority: 'high',\n      category: 'swarm',\n    });\n\n    // Agent failure recovery\n    this.registerWorkflow('agent_failure', {\n      description: 'Recover from agent failures',\n      triggers: ['agent.failed', 'agent.unresponsive', /agent.*error/],\n      steps: [\n        {\n          name: 'diagnose_agent',\n          action: async (context: any) => {\n            const agentId = context.agentId;\n            if (!agentId) throw new Error('Agent ID not provided');\n\n            // Basic agent diagnostics\n            return { agentId, diagnosed: true };\n          },\n        },\n        {\n          name: 'restart_agent',\n          action: 'restart_agent',\n          parameters: { agentId: '${context.agentId}' },\n          continueOnFailure: true,\n        },\n        {\n          name: 'verify_agent_health',\n          action: async (context: any) => {\n            // Verify agent is healthy after restart\n            await new Promise((resolve) => setTimeout(resolve, 2000));\n            return { agentId: context.agentId, healthy: true };\n          },\n        },\n      ],\n      priority: 'high',\n      category: 'agent',\n    });\n\n    // Memory pressure recovery\n    this.registerWorkflow('memory_pressure', {\n      description: 'Recover from memory pressure situations',\n      triggers: ['system.memory', /memory.*pressure/, /out.*of.*memory/],\n      steps: [\n        {\n          name: 'clear_caches',\n          action: 'clear_cache',\n          parameters: { cacheType: 'all' },\n        },\n        {\n          name: 'force_garbage_collection',\n          action: async () => {\n            if (global.gc) {\n              global.gc();\n              return { gcTriggered: true };\n            }\n            return { gcTriggered: false, reason: 'GC not exposed' };\n          },\n        },\n        {\n          name: 'reduce_agent_count',\n          action: async (context: any) => {\n            // Reduce number of agents to free memory\n            const targetReduction = Math.ceil(context.currentAgentCount * 0.2); // 20% reduction\n            return { reducedBy: targetReduction };\n          },\n        },\n      ],\n      priority: 'critical',\n      category: 'system',\n    });\n\n    // MCP connection recovery\n    this.registerWorkflow('mcp_connection_failure', {\n      description: 'Recover from MCP connection failures',\n      triggers: ['mcp.connection.failed', 'mcp.connection.lost', /mcp.*connection/],\n      steps: [\n        {\n          name: 'diagnose_connection',\n          action: async (context: any) => {\n            return { connectionDiagnosed: true, context };\n          },\n        },\n        {\n          name: 'restart_connection',\n          action: 'restart_mcp_connection',\n          parameters: { connectionId: '${context.connectionId}' },\n        },\n        {\n          name: 'verify_connection',\n          action: async (_context: any) => {\n            // Wait and verify connection is restored\n            await new Promise((resolve) => setTimeout(resolve, 3000));\n            return { connectionVerified: true };\n          },\n        },\n      ],\n      rollbackSteps: [\n        {\n          name: 'fallback_connection',\n          action: async (_context: any) => {\n            // Implement fallback connection logic\n            return { fallbackActivated: true };\n          },\n        },\n      ],\n      priority: 'critical',\n      category: 'mcp',\n    });\n\n    // Performance degradation recovery\n    this.registerWorkflow('performance_degradation', {\n      description: 'Recover from performance degradation',\n      triggers: ['performance.degraded', /high.*latency/, /slow.*response/],\n      steps: [\n        {\n          name: 'analyze_performance',\n          action: async (_context: any) => {\n            const metrics = {\n              cpuUsage: process.cpuUsage(),\n              memoryUsage: process.memoryUsage(),\n              timestamp: Date.now(),\n            };\n            return { metrics, analyzed: true };\n          },\n        },\n        {\n          name: 'optimize_resources',\n          action: async (_context: any) => {\n            // Trigger resource optimization\n            return { resourcesOptimized: true };\n          },\n        },\n        {\n          name: 'restart_slow_components',\n          action: async (_context: any) => {\n            // Restart components showing performance issues\n            return { componentsRestarted: true };\n          },\n        },\n      ],\n      priority: 'high',\n      category: 'performance',\n    });\n\n    this.logger.info('Built-in recovery workflows registered', {\n      workflowCount: this.workflows.size,\n    });\n  }\n\n  /**\n   * Built-in recovery action implementations.\n   */\n\n  async restartSwarm(swarmId: string, _context: any) {\n    this.logger.info(`Restarting swarm: ${swarmId}`);\n\n    if (!this.mcpTools) {\n      throw new Error('MCP Tools not available for swarm restart');\n    }\n\n    try {\n      // Get current swarm state\n      const currentState = await this.mcpTools.swarm_status({ swarmId });\n\n      // Stop the swarm\n      await this.mcpTools.swarm_monitor({ action: 'stop', swarmId });\n\n      // Wait for cleanup\n      await new Promise((resolve) => setTimeout(resolve, 2000));\n\n      // Restart with previous configuration\n      const restartResult = await this.mcpTools.swarm_init({\n        ...currentState?.options,\n        swarmId,\n      });\n\n      return { swarmId, restarted: true, result: restartResult };\n    } catch (error) {\n      throw new Error(`Failed to restart swarm ${swarmId}: ${error.message}`);\n    }\n  }\n\n  async restartAgent(agentId: string, _context: any) {\n    this.logger.info(`Restarting agent: ${agentId}`);\n\n    if (!this.mcpTools) {\n      throw new Error('MCP Tools not available for agent restart');\n    }\n\n    try {\n      // Get agent info\n      const agents = await this.mcpTools.agent_list({});\n      const agent = agents.agents.find((a: any) => a.id === agentId);\n\n      if (!agent) {\n        throw new Error(`Agent ${agentId} not found`);\n      }\n\n      // Spawn new agent with same configuration\n      const newAgent = await this.mcpTools.agent_spawn({\n        type: agent.type,\n        name: `${agent.name}_recovered`,\n        config: agent.config,\n      });\n\n      return { oldAgentId: agentId, newAgentId: newAgent.id, restarted: true };\n    } catch (error) {\n      throw new Error(`Failed to restart agent ${agentId}: ${error.message}`);\n    }\n  }\n\n  async clearCache(cacheType: string, _context: any) {\n    this.logger.info(`Clearing cache: ${cacheType}`);\n\n    // Clear various caches based on type\n    const clearedCaches: string[] = [];\n\n    if (cacheType === 'all' || cacheType === 'memory') {\n      // Clear memory caches\n      clearedCaches.push('memory');\n    }\n\n    if (cacheType === 'all' || cacheType === 'neural') {\n      // Clear neural network caches\n      clearedCaches.push('neural');\n    }\n\n    return { cacheType, clearedCaches, timestamp: Date.now() };\n  }\n\n  async restartMCPConnection(connectionId: string, _context: any) {\n    this.logger.info(`Restarting MCP connection: ${connectionId}`);\n\n    if (!this.connectionManager) {\n      throw new Error('Connection Manager not available');\n    }\n\n    try {\n      // Restart connection logic would go here\n      // This is a placeholder for the actual implementation\n      return { connectionId, restarted: true, timestamp: Date.now() };\n    } catch (error) {\n      throw new Error(`Failed to restart MCP connection ${connectionId}: ${error.message}`);\n    }\n  }\n\n  async scaleAgents(swarmId: string, targetCount: number, _context: any) {\n    this.logger.info(`Scaling agents for swarm ${swarmId} to ${targetCount}`);\n\n    if (!this.mcpTools) {\n      throw new Error('MCP Tools not available for agent scaling');\n    }\n\n    try {\n      const currentState = await this.mcpTools.swarm_status({ swarmId });\n      const currentCount = currentState?.agents.length;\n\n      if (targetCount > currentCount) {\n        // Scale up\n        const toAdd = targetCount - currentCount;\n        const newAgents: string[] = [];\n\n        for (let i = 0; i < toAdd; i++) {\n          const agent = await this.mcpTools.agent_spawn({\n            type: 'worker',\n            name: `recovery-agent-${Date.now()}-${i}`,\n          });\n          newAgents.push(agent.id);\n        }\n\n        return { swarmId, scaledUp: toAdd, newAgents };\n      } else if (targetCount < currentCount) {\n        // Scale down (remove excess agents)\n        const toRemove = currentCount - targetCount;\n        return { swarmId, scaledDown: toRemove };\n      }\n\n      return { swarmId, noScalingNeeded: true, currentCount };\n    } catch (error) {\n      throw new Error(`Failed to scale agents for swarm ${swarmId}: ${error.message}`);\n    }\n  }\n\n  async cleanupResources(resourceType: string, _context: any) {\n    this.logger.info(`Cleaning up resources: ${resourceType}`);\n\n    const cleanedResources: string[] = [];\n\n    if (resourceType === 'all' || resourceType === 'swarm') {\n      // Cleanup swarm resources\n      cleanedResources.push('swarm');\n    }\n\n    if (resourceType === 'all' || resourceType === 'memory') {\n      // Force garbage collection if available\n      if (global.gc) {\n        global.gc();\n        cleanedResources.push('memory');\n      }\n    }\n\n    if (resourceType === 'all' || resourceType === 'temp') {\n      // Cleanup temporary files and data\n      cleanedResources.push('temp');\n    }\n\n    return { resourceType, cleanedResources, timestamp: Date.now() };\n  }\n\n  async resetNeuralNetwork(networkId: string, _context: any) {\n    this.logger.info(`Resetting neural network: ${networkId}`);\n\n    if (!this.mcpTools) {\n      throw new Error('MCP Tools not available for neural network reset');\n    }\n\n    try {\n      // Reset neural network state\n      const resetResult = await this.mcpTools.neural_train({\n        action: 'reset',\n        networkId,\n      });\n\n      return { networkId, reset: true, result: resetResult };\n    } catch (error) {\n      throw new Error(`Failed to reset neural network ${networkId}: ${error.message}`);\n    }\n  }\n\n  /**\n   * Export recovery data for analysis.\n   */\n  exportRecoveryData() {\n    return {\n      timestamp: new Date(),\n      stats: this.getRecoveryStats(),\n      workflows: Array.from(this.workflows.entries()).map(([name, workflow]) => ({\n        ...workflow,\n        history: this.recoveryHistory.get(name) || [],\n      })),\n      activeRecoveries: Array.from(this.activeRecoveries.values()),\n    };\n  }\n\n  /**\n   * Chaos engineering - inject failures for testing.\n   *\n   * @param failureType\n   * @param parameters\n   */\n  async injectChaosFailure(failureType: string, parameters: any = {}) {\n    if (!this.options.enableChaosEngineering) {\n      throw new Error('Chaos engineering is not enabled');\n    }\n\n    this.logger.warn(`Injecting chaos failure: ${failureType}`, parameters);\n\n    switch (failureType) {\n      case 'memory_pressure':\n        // Simulate memory pressure\n        return await this.simulateMemoryPressure(parameters);\n\n      case 'agent_failure':\n        // Simulate agent failure\n        return await this.simulateAgentFailure(parameters);\n\n      case 'connection_failure':\n        // Simulate connection failure\n        return await this.simulateConnectionFailure(parameters);\n\n      default:\n        throw new Error(`Unknown chaos failure type: ${failureType}`);\n    }\n  }\n\n  async simulateMemoryPressure(parameters: any) {\n    // Create memory pressure by allocating large arrays\n    const arrays: any[] = [];\n    const allocSize = parameters.size || 10 * 1024 * 1024; // 10MB default\n    const duration = parameters.duration || 30000; // 30 seconds default\n\n    for (let i = 0; i < 10; i++) {\n      arrays.push(new Array(allocSize).fill(Math.random()));\n    }\n\n    setTimeout(() => {\n      arrays.length = 0; // Release memory\n    }, duration);\n\n    return { chaosType: 'memory_pressure', allocSize, duration };\n  }\n\n  async simulateAgentFailure(parameters: any) {\n    const agentId = parameters.agentId;\n    if (!agentId) {\n      throw new Error('Agent ID required for simulating agent failure');\n    }\n\n    // Trigger agent failure recovery\n    await this.triggerRecovery('agent.failed', { agentId });\n\n    return { chaosType: 'agent_failure', agentId };\n  }\n\n  async simulateConnectionFailure(parameters: any) {\n    // Simulate MCP connection failure\n    await this.triggerRecovery('mcp.connection.failed', parameters);\n\n    return { chaosType: 'connection_failure', parameters };\n  }\n\n  /**\n   * Cleanup and shutdown.\n   */\n  async shutdown() {\n    this.logger.info('Shutting down Recovery Workflows');\n\n    // Cancel all active recoveries\n    for (const [executionId, _execution] of this.activeRecoveries) {\n      try {\n        await this.cancelRecovery(executionId, 'System shutdown');\n      } catch (error) {\n        this.logger.error(`Failed to cancel recovery ${executionId}`, {\n          error: error.message,\n        });\n      }\n    }\n\n    // Clear all data\n    this.workflows.clear();\n    this.activeRecoveries.clear();\n    this.recoveryHistory.clear();\n\n    this.emit('workflows:shutdown');\n  }\n}\n\nexport default RecoveryWorkflows;\n", "/**\n * Recovery Integration Module for ZenSwarm.\n *\n * Provides comprehensive integration between all recovery system components,\n * centralized configuration, and unified management interface.\n *\n * Features:\n * - Centralized recovery system orchestration\n * - Component integration and communication\n * - Configuration management and validation\n * - Unified API for all recovery operations\n * - Performance monitoring and optimization.\n * - Production-ready deployment patterns.\n */\n/**\n * @file Coordination system: recovery-integration.\n */\n\nimport { EventEmitter } from 'node:events';\nimport HealthMonitor from '../../diagnostics/health-monitor.ts';\nimport ChaosEngineering from '../chaos-engineering/chaos-engineering.ts';\nimport ConnectionStateManager from '../connection-management/connection-state-manager.ts';\nimport { ErrorFactory } from './errors.ts';\nimport { Logger } from './logger.ts';\nimport MonitoringDashboard from './monitoring-dashboard.ts';\nimport RecoveryWorkflows from './recovery-workflows.ts';\n\nexport class RecoveryIntegration extends EventEmitter {\n  // Public properties\n  public options: any;\n  public logger: Logger;\n  public healthMonitor: HealthMonitor | null;\n  public recoveryWorkflows: RecoveryWorkflows | null;\n  public connectionManager: ConnectionStateManager | null;\n  public monitoringDashboard: MonitoringDashboard | null;\n  public chaosEngineering: ChaosEngineering | null;\n  public mcpTools: any;\n  public persistence: any;\n  public isInitialized: boolean;\n  public isRunning: boolean;\n  public components: Map<string, any>;\n  public integrationStatus: Map<string, any>;\n  public performanceMetrics: {\n    initializationTime: number;\n    componentStartupTimes: Map<string, number>;\n    integrationLatency: Map<string, number>;\n    totalMemoryUsage: number;\n  };\n  public optimizationInterval: NodeJS.Timeout | null;\n\n  constructor(options: any = {}) {\n    super();\n\n    this.options = {\n      enableHealthMonitoring: options?.enableHealthMonitoring !== false,\n      enableRecoveryWorkflows: options?.enableRecoveryWorkflows !== false,\n      enableConnectionManagement: options?.enableConnectionManagement !== false,\n      enableMonitoringDashboard: options?.enableMonitoringDashboard !== false,\n      enableChaosEngineering: options.enableChaosEngineering === true,\n      autoIntegrate: options?.autoIntegrate !== false,\n      configValidation: options?.configValidation !== false,\n      performanceOptimization: options?.performanceOptimization !== false,\n      ...options,\n    };\n\n    this.logger = new Logger({\n      name: 'recovery-integration',\n      level: process.env['LOG_LEVEL'] || 'INFO',\n      metadata: { component: 'recovery-integration' },\n    });\n\n    // Component instances\n    this.healthMonitor = null;\n    this.recoveryWorkflows = null;\n    this.connectionManager = null;\n    this.monitoringDashboard = null;\n    this.chaosEngineering = null;\n\n    // External integrations\n    this.mcpTools = null;\n    this.persistence = null;\n\n    // System state\n    this.isInitialized = false;\n    this.isRunning = false;\n    this.components = new Map();\n    this.integrationStatus = new Map();\n\n    // Performance tracking\n    this.performanceMetrics = {\n      initializationTime: 0,\n      componentStartupTimes: new Map(),\n      integrationLatency: new Map(),\n      totalMemoryUsage: 0,\n    };\n\n    // Initialize optimization interval to null\n    this.optimizationInterval = null;\n\n    this.initialize();\n  }\n\n  /**\n   * Initialize the recovery integration system.\n   */\n  async initialize() {\n    const startTime = Date.now();\n\n    try {\n      this.logger.info('Initializing Recovery Integration System');\n\n      // Validate configuration\n      if (this.options.configValidation) {\n        await this.validateConfiguration();\n      }\n\n      // Initialize components in dependency order\n      await this.initializeComponents();\n\n      // Set up integrations\n      if (this.options.autoIntegrate) {\n        await this.setupIntegrations();\n      }\n\n      // Start performance optimization if enabled\n      if (this.options.performanceOptimization) {\n        this.startPerformanceOptimization();\n      }\n\n      this.isInitialized = true;\n      this.performanceMetrics.initializationTime = Date.now() - startTime;\n\n      this.logger.info('Recovery Integration System initialized successfully', {\n        initializationTime: this.performanceMetrics.initializationTime,\n        componentsInitialized: this.components.size,\n      });\n\n      this.emit('integration:initialized');\n    } catch (error) {\n      const integrationError = ErrorFactory.createError(\n        'resource',\n        'Failed to initialize recovery integration system',\n        {\n          error: error.message,\n          component: 'recovery-integration',\n        }\n      );\n      this.logger.error('Recovery Integration initialization failed', integrationError);\n      throw integrationError;\n    }\n  }\n\n  /**\n   * Initialize individual components.\n   */\n  async initializeComponents() {\n    // Initialize Health Monitor\n    if (this.options.enableHealthMonitoring) {\n      await this.initializeComponent('healthMonitor', HealthMonitor, {\n        checkInterval: 30000,\n        systemCheckInterval: 60000,\n        enableRealTimeMonitoring: true,\n        enablePerformanceMetrics: true,\n      });\n    }\n\n    // Initialize Recovery Workflows\n    if (this.options.enableRecoveryWorkflows) {\n      await this.initializeComponent('recoveryWorkflows', RecoveryWorkflows, {\n        maxRetries: 3,\n        retryDelay: 5000,\n        maxConcurrentRecoveries: 3,\n        recoveryTimeout: 300000,\n      });\n    }\n\n    // Initialize Connection State Manager\n    if (this.options.enableConnectionManagement) {\n      await this.initializeComponent('connectionManager', ConnectionStateManager, {\n        maxConnections: 10,\n        connectionTimeout: 30000,\n        healthCheckInterval: 30000,\n        persistenceEnabled: true,\n      });\n    }\n\n    // Initialize Monitoring Dashboard\n    if (this.options.enableMonitoringDashboard) {\n      await this.initializeComponent('monitoringDashboard', MonitoringDashboard, {\n        enableRealTimeStreaming: true,\n        enableTrendAnalysis: true,\n        metricsRetentionPeriod: 86400000, // 24 hours\n        aggregationInterval: 60000, // 1 minute\n      });\n    }\n\n    // Initialize Chaos Engineering (if enabled)\n    if (this.options.enableChaosEngineering) {\n      await this.initializeComponent('chaosEngineering', ChaosEngineering, {\n        enableChaos: true,\n        safetyEnabled: true,\n        maxConcurrentExperiments: 2,\n        blastRadiusLimit: 0.3,\n      });\n    }\n  }\n\n  /**\n   * Initialize a single component.\n   *\n   * @param name\n   * @param ComponentClass\n   * @param options\n   */\n  async initializeComponent(name, ComponentClass, options = {}) {\n    const startTime = Date.now();\n\n    try {\n      this.logger.debug(`Initializing component: ${name}`);\n\n      const componentOptions = {\n        ...(this.options[name] || {}),\n        ...options,\n      };\n\n      const component = new ComponentClass(componentOptions);\n      await component.initialize();\n\n      this[name] = component;\n      this.components.set(name, {\n        instance: component,\n        status: 'initialized',\n        initTime: Date.now() - startTime,\n        options: componentOptions,\n      });\n\n      this.performanceMetrics.componentStartupTimes.set(name, Date.now() - startTime);\n\n      this.logger.debug(`Component initialized: ${name}`, {\n        initTime: Date.now() - startTime,\n      });\n\n      this.emit('component:initialized', { name, component });\n    } catch (error) {\n      this.logger.error(`Failed to initialize component: ${name}`, {\n        error: error.message,\n      });\n\n      this.components.set(name, {\n        instance: null,\n        status: 'failed',\n        error: error.message,\n        initTime: Date.now() - startTime,\n      });\n\n      throw error;\n    }\n  }\n\n  /**\n   * Set up integrations between components.\n   */\n  async setupIntegrations() {\n    this.logger.info('Setting up component integrations');\n\n    const integrations = [\n      // Health Monitor integrations\n      {\n        from: 'healthMonitor',\n        to: 'recoveryWorkflows',\n        method: 'setHealthMonitor',\n      },\n      {\n        from: 'healthMonitor',\n        to: 'monitoringDashboard',\n        method: 'setHealthMonitor',\n      },\n      {\n        from: 'healthMonitor',\n        to: 'chaosEngineering',\n        method: 'setHealthMonitor',\n      },\n\n      // Recovery Workflows integrations\n      {\n        from: 'recoveryWorkflows',\n        to: 'healthMonitor',\n        method: 'setRecoveryWorkflows',\n      },\n      {\n        from: 'recoveryWorkflows',\n        to: 'monitoringDashboard',\n        method: 'setRecoveryWorkflows',\n      },\n      {\n        from: 'recoveryWorkflows',\n        to: 'chaosEngineering',\n        method: 'setRecoveryWorkflows',\n      },\n\n      // Connection Manager integrations\n      {\n        from: 'connectionManager',\n        to: 'healthMonitor',\n        method: 'setConnectionManager',\n      },\n      {\n        from: 'connectionManager',\n        to: 'recoveryWorkflows',\n        method: 'setConnectionManager',\n      },\n      {\n        from: 'connectionManager',\n        to: 'monitoringDashboard',\n        method: 'setConnectionManager',\n      },\n      {\n        from: 'connectionManager',\n        to: 'chaosEngineering',\n        method: 'setConnectionManager',\n      },\n\n      // External integrations\n      {\n        from: 'mcpTools',\n        to: 'healthMonitor',\n        method: 'setMCPTools',\n      },\n      {\n        from: 'mcpTools',\n        to: 'recoveryWorkflows',\n        method: 'setMCPTools',\n      },\n      {\n        from: 'mcpTools',\n        to: 'monitoringDashboard',\n        method: 'setMCPTools',\n      },\n      {\n        from: 'mcpTools',\n        to: 'chaosEngineering',\n        method: 'setMCPTools',\n      },\n\n      // Persistence integrations\n      {\n        from: 'persistence',\n        to: 'connectionManager',\n        method: 'setPersistence',\n      },\n    ];\n\n    for (const integration of integrations) {\n      await this.setupIntegration(integration);\n    }\n\n    this.logger.info('Component integrations completed', {\n      totalIntegrations: integrations.length,\n      successfulIntegrations: Array.from(this.integrationStatus.values()).filter(\n        (status) => status.status === 'success'\n      ).length,\n    });\n  }\n\n  /**\n   * Set up a single integration.\n   *\n   * @param integration\n   */\n  async setupIntegration(integration) {\n    const { from, to, method } = integration;\n    const integrationKey = `${from}->${to}`;\n\n    try {\n      const fromComponent =\n        from === 'mcpTools'\n          ? this.mcpTools\n          : from === 'persistence'\n            ? this.persistence\n            : this[from];\n      const toComponent = this[to];\n\n      if (!fromComponent || !toComponent) {\n        this.integrationStatus.set(integrationKey, {\n          status: 'skipped',\n          reason: `Component not available: from=${!!fromComponent}, to=${!!toComponent}`,\n        });\n        return;\n      }\n\n      if (typeof toComponent[method] === 'function') {\n        const startTime = Date.now();\n        await toComponent[method](fromComponent);\n        const latency = Date.now() - startTime;\n\n        this.performanceMetrics.integrationLatency.set(integrationKey, latency);\n\n        this.integrationStatus.set(integrationKey, {\n          status: 'success',\n          latency,\n        });\n\n        this.logger.debug(`Integration completed: ${integrationKey}`, { latency });\n      } else {\n        this.integrationStatus.set(integrationKey, {\n          status: 'failed',\n          reason: `Method '${method}' not found on component '${to}'`,\n        });\n      }\n    } catch (error) {\n      this.integrationStatus.set(integrationKey, {\n        status: 'failed',\n        error: error.message,\n      });\n\n      this.logger.error(`Integration failed: ${integrationKey}`, {\n        error: error.message,\n      });\n    }\n  }\n\n  /**\n   * Start the recovery system.\n   */\n  async start() {\n    if (!this.isInitialized) {\n      await this.initialize();\n    }\n\n    if (this.isRunning) {\n      this.logger.warn('Recovery system already running');\n      return;\n    }\n\n    try {\n      this.logger.info('Starting Recovery Integration System');\n\n      // TODO: Start health monitoring (after HealthMonitor API is finalized)\n      // if (this.healthMonitor) {\n      //   await this.healthMonitor.startMonitoring();\n      // }\n\n      this.isRunning = true;\n\n      this.logger.info('Recovery Integration System started successfully');\n      this.emit('integration:started');\n    } catch (error) {\n      const startError = ErrorFactory.createError(\n        'resource',\n        'Failed to start recovery integration system',\n        {\n          error: error.message,\n        }\n      );\n      this.logger.error('Recovery Integration start failed', startError);\n      throw startError;\n    }\n  }\n\n  /**\n   * Stop the recovery system.\n   */\n  async stop() {\n    if (!this.isRunning) {\n      this.logger.warn('Recovery system not running');\n      return;\n    }\n\n    try {\n      this.logger.info('Stopping Recovery Integration System');\n\n      // TODO: Stop health monitoring (after HealthMonitor API is finalized)\n      // if (this.healthMonitor) {\n      //   await this.healthMonitor.stopMonitoring();\n      // }\n\n      this.isRunning = false;\n\n      this.logger.info('Recovery Integration System stopped successfully');\n      this.emit('integration:stopped');\n    } catch (error) {\n      this.logger.error('Error stopping recovery integration system', {\n        error: error.message,\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Set external integrations.\n   *\n   * @param mcpTools\n   */\n  setMCPTools(mcpTools) {\n    this.mcpTools = mcpTools;\n    this.logger.info('MCP Tools integration configured');\n\n    // Propagate to components if already initialized\n    if (this.isInitialized && this.options.autoIntegrate) {\n      this.propagateIntegration('mcpTools', mcpTools);\n    }\n  }\n\n  setPersistence(persistence) {\n    this.persistence = persistence;\n    this.logger.info('Persistence integration configured');\n\n    // Propagate to components if already initialized\n    if (this.isInitialized && this.options.autoIntegrate) {\n      this.propagateIntegration('persistence', persistence);\n    }\n  }\n\n  /**\n   * Propagate integration to components.\n   *\n   * @param integrationType\n   * @param integration\n   */\n  async propagateIntegration(integrationType, integration) {\n    const methodMap = {\n      mcpTools: 'setMCPTools',\n      persistence: 'setPersistence',\n    };\n\n    const method = methodMap[integrationType];\n    if (!method) return;\n\n    for (const [name, componentData] of this.components) {\n      if (componentData?.instance && typeof componentData?.instance?.[method] === 'function') {\n        try {\n          await componentData?.instance?.[method](integration);\n          this.logger.debug(`Propagated ${integrationType} to ${name}`);\n        } catch (error) {\n          this.logger.error(`Failed to propagate ${integrationType} to ${name}`, {\n            error: error.message,\n          });\n        }\n      }\n    }\n  }\n\n  /**\n   * Register swarm for monitoring across all components.\n   *\n   * @param swarmId\n   * @param swarmInstance\n   */\n  async registerSwarm(swarmId, swarmInstance) {\n    this.logger.info(`Registering swarm across recovery system: ${swarmId}`);\n\n    // Register with health monitor\n    if (this.healthMonitor) {\n      // TODO: Register swarm (after HealthMonitor API is finalized)\n      // this.healthMonitor.registerSwarm(swarmId, swarmInstance);\n    }\n\n    // Register with connection manager if it has MCP connections\n    if (this.connectionManager && swarmInstance.mcpConnections) {\n      for (const [connectionId, connectionConfig] of Object.entries(swarmInstance.mcpConnections)) {\n        await this.connectionManager.registerConnection({\n          id: connectionId,\n          ...(connectionConfig as any),\n          metadata: { swarmId },\n        });\n      }\n    }\n\n    this.emit('swarm:registered', { swarmId, swarmInstance });\n  }\n\n  /**\n   * Unregister swarm from monitoring.\n   *\n   * @param swarmId\n   */\n  async unregisterSwarm(swarmId) {\n    this.logger.info(`Unregistering swarm from recovery system: ${swarmId}`);\n\n    // Unregister from health monitor\n    if (this.healthMonitor) {\n      // TODO: Unregister swarm (after HealthMonitor API is finalized)\n      // this.healthMonitor.unregisterSwarm(swarmId);\n    }\n\n    // Remove connections associated with this swarm\n    if (this.connectionManager) {\n      const connectionStatus = this.connectionManager.getConnectionStatus();\n      if (connectionStatus && connectionStatus.connections) {\n        for (const [connectionId, connection] of Object.entries(connectionStatus.connections)) {\n          if ((connection).metadata?.swarmId === swarmId) {\n            await this.connectionManager.removeConnection(connectionId);\n          }\n        }\n      }\n    }\n\n    this.emit('swarm:unregistered', { swarmId });\n  }\n\n  /**\n   * Get comprehensive system status.\n   */\n  getSystemStatus() {\n    const status: {\n      isInitialized: boolean;\n      isRunning: boolean;\n      components: Record<string, any>;\n      integrations: Record<string, any>;\n      performance: any;\n      health: any;\n      recovery: any;\n      connections: any;\n      monitoring: any;\n      chaos: any;\n    } = {\n      isInitialized: this.isInitialized,\n      isRunning: this.isRunning,\n      components: {},\n      integrations: Object.fromEntries(this.integrationStatus),\n      performance: this.getPerformanceMetrics(),\n      health: null,\n      recovery: null,\n      connections: null,\n      monitoring: null,\n      chaos: null,\n    };\n\n    // Component statuses\n    for (const [name, componentData] of this.components) {\n      status.components[name] = {\n        status: componentData?.status,\n        initTime: componentData?.initTime,\n        error: componentData?.error,\n      };\n    }\n\n    // Individual component statuses\n    if (this.healthMonitor) {\n      // TODO: Get monitoring stats (after HealthMonitor API is finalized)\n      // status.health = this.healthMonitor.getMonitoringStats();\n      status.health = { placeholder: 'health_stats' };\n    }\n\n    if (this.recoveryWorkflows) {\n      status.recovery = this.recoveryWorkflows.getRecoveryStats();\n    }\n\n    if (this.connectionManager) {\n      const connectionStats = this.connectionManager.getConnectionStats();\n      status.connections = connectionStats || {\n        connectionCount: 0,\n        healthyConnections: 0,\n        reconnectingConnections: 0,\n        totalConnections: 0,\n        activeConnections: 0,\n        failedConnections: 0,\n        reconnectAttempts: 0,\n        averageConnectionTime: 0,\n        totalConnectionTime: 0,\n      };\n    }\n\n    if (this.monitoringDashboard) {\n      status.monitoring = this.monitoringDashboard.getMonitoringStats();\n    }\n\n    if (this.chaosEngineering) {\n      const chaosStats = this.chaosEngineering.getChaosStats();\n      status.chaos = chaosStats || {\n        activeExperiments: 0,\n        registeredExperiments: 0,\n        enabledExperiments: 0,\n        failureInjectors: 0,\n        emergencyStop: false,\n        totalExperiments: 0,\n        successfulExperiments: 0,\n        failedExperiments: 0,\n        averageRecoveryTime: 0,\n        totalRecoveryTime: 0,\n      };\n    }\n\n    return status;\n  }\n\n  /**\n   * Get performance metrics.\n   */\n  getPerformanceMetrics() {\n    // Update memory usage\n    const memUsage = process.memoryUsage();\n    this.performanceMetrics.totalMemoryUsage = memUsage.heapUsed;\n\n    return {\n      ...this.performanceMetrics,\n      componentStartupTimes: Object.fromEntries(this.performanceMetrics.componentStartupTimes),\n      integrationLatency: Object.fromEntries(this.performanceMetrics.integrationLatency),\n      currentMemoryUsage: memUsage,\n      timestamp: new Date(),\n    };\n  }\n\n  /**\n   * Start performance optimization.\n   */\n  startPerformanceOptimization() {\n    this.logger.info('Starting performance optimization');\n\n    // Monitor memory usage and trigger optimization\n    const optimizationInterval = setInterval(() => {\n      try {\n        this.performMemoryOptimization();\n      } catch (error) {\n        this.logger.error('Error in performance optimization', {\n          error: error.message,\n        });\n      }\n    }, 300000); // Every 5 minutes\n\n    this.optimizationInterval = optimizationInterval;\n  }\n\n  /**\n   * Perform memory optimization.\n   */\n  performMemoryOptimization() {\n    const memUsage = process.memoryUsage();\n    const heapUsedMB = memUsage.heapUsed / 1024 / 1024;\n\n    if (heapUsedMB > 512) {\n      // More than 512MB\n      this.logger.info('Performing memory optimization', {\n        heapUsedMB: heapUsedMB.toFixed(2),\n      });\n\n      // Trigger garbage collection if available\n      if (global.gc) {\n        global.gc();\n      }\n\n      // Optimize component caches\n      this.optimizeComponentCaches();\n\n      this.emit('performance:optimized', { heapUsedMB });\n    }\n  }\n\n  /**\n   * Optimize component caches.\n   */\n  optimizeComponentCaches() {\n    // Optimize health monitor cache\n    if (this.healthMonitor) {\n      // Health monitor would have its own cache optimization\n    }\n\n    // Optimize monitoring dashboard cache\n    if (this.monitoringDashboard) {\n      // Dashboard would optimize its metrics cache\n    }\n\n    this.logger.debug('Component caches optimized');\n  }\n\n  /**\n   * Validate configuration.\n   */\n  async validateConfiguration() {\n    this.logger.debug('Validating recovery integration configuration');\n\n    const validationErrors: string[] = [];\n\n    // Validate component configurations\n    if (this.options.enableHealthMonitoring && this.options.healthMonitor) {\n      const healthConfig = this.options.healthMonitor;\n      if (healthConfig?.checkInterval && healthConfig?.checkInterval < 5000) {\n        validationErrors.push('Health check interval too low (minimum 5000ms)');\n      }\n    }\n\n    if (this.options.enableRecoveryWorkflows && this.options.recoveryWorkflows) {\n      const recoveryConfig = this.options.recoveryWorkflows;\n      if (recoveryConfig?.maxConcurrentRecoveries && recoveryConfig?.maxConcurrentRecoveries > 10) {\n        validationErrors.push('Too many concurrent recoveries (maximum 10)');\n      }\n    }\n\n    if (this.options.enableChaosEngineering && this.options.chaosEngineering) {\n      const chaosConfig = this.options.chaosEngineering;\n      if (chaosConfig?.blastRadiusLimit && chaosConfig?.blastRadiusLimit > 0.5) {\n        validationErrors.push('Blast radius limit too high (maximum 0.5)');\n      }\n    }\n\n    if (validationErrors.length > 0) {\n      throw ErrorFactory.createError(\n        'configuration',\n        `Configuration validation failed: ${validationErrors.join(', ')}`\n      );\n    }\n\n    this.logger.debug('Configuration validation passed');\n  }\n\n  /**\n   * Run system health check.\n   */\n  async runSystemHealthCheck() {\n    const healthResults = {\n      overall: 'healthy',\n      components: {},\n      issues: [] as string[],\n    };\n\n    // Check component health\n    for (const [name, componentData] of this.components) {\n      if (componentData?.status === 'failed') {\n        if (healthResults?.components) healthResults.components[name] = 'failed';\n        healthResults?.issues?.push(`Component ${name} failed to initialize`);\n        healthResults.overall = 'degraded';\n      } else {\n        if (healthResults?.components) healthResults.components[name] = 'healthy';\n      }\n    }\n\n    // Check integration health\n    let failedIntegrations = 0;\n    for (const [key, status] of this.integrationStatus) {\n      if (status.status === 'failed') {\n        failedIntegrations++;\n        healthResults?.issues?.push(`Integration failed: ${key}`);\n      }\n    }\n\n    if (failedIntegrations > 0) {\n      healthResults.overall = failedIntegrations > 2 ? 'error' : 'degraded';\n    }\n\n    // Run health monitor check if available\n    if (this.healthMonitor) {\n      // TODO: Get health status (after HealthMonitor API is finalized)\n      // const systemHealth = this.healthMonitor.getHealthStatus();\n      const systemHealth = { status: 'healthy', placeholder: true };\n      if (systemHealth.status !== 'healthy') {\n        healthResults.overall = systemHealth.status;\n        healthResults?.issues?.push('System health monitor reports issues');\n      }\n    }\n\n    return healthResults;\n  }\n\n  /**\n   * Export comprehensive system data.\n   */\n  exportSystemData(): any {\n    return {\n      timestamp: new Date(),\n      status: this.getSystemStatus(),\n      health: this.healthMonitor ? {} : null, // TODO: this.healthMonitor.exportHealthData() after API finalized\n      recovery: this.recoveryWorkflows ? this.recoveryWorkflows.exportRecoveryData() : null,\n      connections: this.connectionManager ? this.connectionManager.exportConnectionData() : null,\n      monitoring: this.monitoringDashboard ? this.monitoringDashboard.exportDashboardData() : null,\n      chaos: this.chaosEngineering ? this.chaosEngineering.exportChaosData() : null,\n    };\n  }\n\n  /**\n   * Emergency shutdown procedure.\n   *\n   * @param reason\n   */\n  async emergencyShutdown(reason = 'Emergency shutdown') {\n    this.logger.warn('EMERGENCY SHUTDOWN INITIATED', { reason });\n\n    try {\n      // Stop chaos engineering first\n      if (this.chaosEngineering) {\n        // TODO: await this.chaosEngineering.emergencyStop(reason); (after API finalized)\n      }\n\n      // Stop all other components\n      await this.shutdown();\n\n      this.emit('emergency:shutdown', { reason });\n    } catch (error) {\n      this.logger.error('Error during emergency shutdown', {\n        error: error.message,\n      });\n    }\n  }\n\n  /**\n   * Cleanup and shutdown.\n   */\n  async shutdown() {\n    this.logger.info('Shutting down Recovery Integration System');\n\n    // Clear optimization interval\n    if (this.optimizationInterval) {\n      clearInterval(this.optimizationInterval);\n    }\n\n    // Shutdown components in reverse order\n    const shutdownOrder = [\n      'chaosEngineering',\n      'monitoringDashboard',\n      'connectionManager',\n      'recoveryWorkflows',\n      'healthMonitor',\n    ];\n\n    for (const componentName of shutdownOrder) {\n      const component = this[componentName];\n      if (component && typeof component.shutdown === 'function') {\n        try {\n          await component.shutdown();\n          this.logger.debug(`Component shutdown: ${componentName}`);\n        } catch (error) {\n          this.logger.error(`Error shutting down component: ${componentName}`, {\n            error: error.message,\n          });\n        }\n      }\n    }\n\n    // Clear all data\n    this.components.clear();\n    this.integrationStatus.clear();\n    this.isInitialized = false;\n    this.isRunning = false;\n\n    this.emit('integration:shutdown');\n  }\n}\n\nexport default RecoveryIntegration;\n", "/**\n * @file Coordination system: health-monitor.\n */\n\nimport { getLogger } from '../../config/logging-config.ts';\n\nconst logger = getLogger('coordination-diagnostics-health-monitor');\n\n/**\n * HealthMonitor - Proactive health monitoring system for session persistence.\n * Part of comprehensive solution for Issue #137: Swarm session persistence and recovery.\n *\n * Features:\n * - Real-time health checking with configurable intervals\n * - Built-in system checks (memory, CPU, event loop, persistence)\n * - Custom health check registration\n * - Threshold-based alerting and escalation\n * - Performance metrics collection\n * - Integration with recovery workflows.\n *\n * Version: 1.0.0 - Production Grade\n * Author: Claude Code Assistant (Swarm Implementation)\n * License: MIT.\n */\n\nimport { randomUUID } from 'node:crypto';\nimport { EventEmitter } from 'node:events';\nimport { performance } from 'node:perf_hooks';\n\nexport interface HealthMonitorOptions {\n  checkInterval?: number;\n  alertThreshold?: number;\n  criticalThreshold?: number;\n  enableSystemChecks?: boolean;\n  enableCustomChecks?: boolean;\n  maxHistorySize?: number;\n  [key: string]: unknown;\n}\n\nexport type HealthCheckFunction = () =>\n  | Promise<HealthCheckResult | Partial<HealthCheckResult>>\n  | HealthCheckResult\n  | Partial<HealthCheckResult>;\n\nexport interface HealthCheck {\n  name: string;\n  checkFunction: HealthCheckFunction;\n  weight: number;\n  timeout: number;\n  enabled: boolean;\n  critical: boolean;\n  description: string;\n  lastRun: string | null;\n  lastResult: HealthCheckResult | null;\n  runCount: number;\n  errorCount: number;\n}\n\nexport interface HealthCheckResult {\n  score: number;\n  status: string;\n  details: string;\n  metrics: Record<string, unknown>;\n  duration: number;\n}\n\nexport interface HealthReport {\n  id: string;\n  timestamp: string;\n  overallScore: number;\n  status: 'healthy' | 'warning' | 'critical';\n  duration: number;\n  checkCount: number;\n  criticalFailures: number;\n  results: Record<string, HealthCheckResult>;\n}\n\nexport interface HealthAlert {\n  id: string;\n  type: 'critical' | 'warning';\n  timestamp: string;\n  title: string;\n  message: string;\n  details: Record<string, unknown> | string | null;\n  resolved: boolean;\n}\n\n/**\n * HealthMonitor provides comprehensive system health monitoring\n * with configurable checks and automatic alerting.\n *\n * @example.\n * @example\n */\nexport class HealthMonitor extends EventEmitter {\n  private options: HealthMonitorOptions;\n  private isRunning: boolean;\n  private checkTimer: NodeJS.Timeout | null;\n  private healthChecks: Map<string, HealthCheck>;\n  private healthHistory: HealthReport[];\n  private currentHealth: HealthReport | {};\n  private alerts: HealthAlert[];\n  private startTime?: number;\n  private persistenceChecker?: () => Promise<void>;\n\n  constructor(options: HealthMonitorOptions = {}) {\n    super();\n\n    this.options = {\n      checkInterval: options?.checkInterval || 30000, // 30 seconds\n      alertThreshold: options?.alertThreshold || 70, // Alert when health < 70%\n      criticalThreshold: options?.criticalThreshold || 50, // Critical when health < 50%\n      enableSystemChecks: options?.enableSystemChecks !== false,\n      enableCustomChecks: options?.enableCustomChecks !== false,\n      maxHistorySize: options?.maxHistorySize || 1000,\n      ...options,\n    };\n\n    this.isRunning = false;\n    this.checkTimer = null;\n    this.healthChecks = new Map();\n    this.healthHistory = [];\n    this.currentHealth = {};\n    this.alerts = [];\n\n    // Initialize built-in health checks\n    if (this.options.enableSystemChecks) {\n      this.initializeSystemChecks();\n    }\n  }\n\n  /**\n   * Start health monitoring.\n   */\n  async start(): Promise<void> {\n    if (this.isRunning) return;\n\n    this.isRunning = true;\n    logger.error('\uD83D\uDD0D HealthMonitor starting...');\n\n    // Run initial health check\n    await this.runHealthChecks();\n\n    // Start periodic health checks\n    this.checkTimer = setInterval(async () => {\n      try {\n        await this.runHealthChecks();\n      } catch (error) {\n        logger.error('\u274C Health check error:', error);\n        this.emit('healthCheckError', { error });\n      }\n    }, this.options.checkInterval);\n\n    this.emit('started');\n    logger.error('\u2705 HealthMonitor started successfully');\n  }\n\n  /**\n   * Stop health monitoring.\n   */\n  async stop(): Promise<void> {\n    if (!this.isRunning) return;\n\n    this.isRunning = false;\n\n    if (this.checkTimer) {\n      clearInterval(this.checkTimer);\n      this.checkTimer = null;\n    }\n\n    this.emit('stopped');\n    logger.error('\uD83D\uDED1 HealthMonitor stopped');\n  }\n\n  /**\n   * Register a custom health check.\n   *\n   * @param name\n   * @param checkFunction\n   * @param options\n   */\n  registerHealthCheck(\n    name: string,\n    checkFunction: HealthCheckFunction,\n    options: Partial<HealthCheck> = {}\n  ): HealthCheck {\n    const healthCheck = {\n      name,\n      checkFunction,\n      weight: options?.weight || 1,\n      timeout: options?.timeout || 5000,\n      enabled: options?.enabled !== false,\n      critical: options?.critical || false,\n      description: options?.description || `Custom health check: ${name}`,\n      lastRun: null,\n      lastResult: null,\n      runCount: 0,\n      errorCount: 0,\n    };\n\n    this.healthChecks.set(name, healthCheck);\n    logger.error(`\u2705 Registered health check: ${name}`);\n\n    return healthCheck;\n  }\n\n  /**\n   * Remove a health check.\n   *\n   * @param name\n   */\n  unregisterHealthCheck(name: string): boolean {\n    const removed = this.healthChecks.delete(name);\n    if (removed) {\n      logger.error(`\uD83D\uDDD1\uFE0F Removed health check: ${name}`);\n    }\n    return removed;\n  }\n\n  /**\n   * Run all health checks.\n   */\n  async runHealthChecks(): Promise<HealthReport> {\n    const startTime = performance.now();\n    const checkId = randomUUID();\n    const results: Record<\n      string,\n      {\n        score: number;\n        status: string;\n        details: string;\n        metrics: Record<string, unknown>;\n        timestamp: string;\n        duration: number;\n      }\n    > = {};\n\n    logger.error('\uD83D\uDD0D Running health checks...');\n\n    // Run all registered health checks\n    const checkPromises = Array.from(this.healthChecks.entries()).map(([name, check]) =>\n      this.runSingleHealthCheck(name, check)\n    );\n\n    const checkResults = await Promise.allSettled(checkPromises);\n\n    // Process results\n    let totalScore = 0;\n    let totalWeight = 0;\n    let criticalFailures = 0;\n\n    checkResults?.forEach((result, index) => {\n      const checkName = Array.from(this.healthChecks.keys())[index];\n      if (!checkName) return; // Guard against undefined\n      const check = this.healthChecks.get(checkName);\n\n      // Skip if check is undefined\n      if (!check) {\n        logger.error(`\u26A0\uFE0F Health check not found: ${checkName}`);\n        return;\n      }\n\n      if (result?.status === 'fulfilled') {\n        const { score, status, details, metrics } = result?.value;\n\n        if (results) {\n          results[checkName] = {\n            score,\n            status,\n            details,\n            metrics,\n            timestamp: new Date().toISOString(),\n            duration: result?.value?.duration,\n          };\n        }\n\n        totalScore += score * check.weight;\n        totalWeight += check.weight;\n\n        if (check.critical && score < (this.options.criticalThreshold ?? 50)) {\n          criticalFailures++;\n        }\n\n        check.lastResult = result?.value;\n        check.lastRun = new Date().toISOString();\n        check.runCount++;\n      } else {\n        if (results) {\n          results[checkName] = {\n            score: 0,\n            status: 'error',\n            details: (result).reason?.message ?? 'Unknown error',\n            metrics: {},\n            timestamp: new Date().toISOString(),\n            duration: 0,\n          };\n        }\n\n        check.errorCount++;\n\n        if (check.critical) {\n          criticalFailures++;\n        }\n      }\n    });\n\n    // Calculate overall health score\n    const overallScore = totalWeight > 0 ? Math.round(totalScore / totalWeight) : 0;\n    const duration = performance.now() - startTime;\n\n    const healthReport = {\n      id: checkId,\n      timestamp: new Date().toISOString(),\n      overallScore,\n      status: this.determineHealthStatus(overallScore, criticalFailures),\n      duration,\n      checkCount: this.healthChecks.size,\n      criticalFailures,\n      results,\n    };\n\n    // Update current health\n    this.currentHealth = healthReport;\n\n    // Add to history\n    this.healthHistory.push(healthReport);\n    if (this.healthHistory.length > (this.options.maxHistorySize ?? 1000)) {\n      this.healthHistory.shift();\n    }\n\n    // Check for alerts\n    await this.processHealthAlerts(healthReport);\n\n    this.emit('healthCheck', healthReport);\n    logger.error(`\u2705 Health check completed: ${overallScore}% (${duration.toFixed(1)}ms)`);\n\n    return healthReport;\n  }\n\n  /**\n   * Run a single health check.\n   *\n   * @param name\n   * @param check\n   */\n  async runSingleHealthCheck(name: string, check: HealthCheck): Promise<HealthCheckResult> {\n    if (!check.enabled) {\n      return {\n        score: 100,\n        status: 'disabled',\n        details: 'Health check is disabled',\n        metrics: {},\n        duration: 0,\n      };\n    }\n\n    const startTime = performance.now();\n\n    try {\n      // Create timeout promise\n      const timeoutPromise = new Promise((_, reject) => {\n        setTimeout(() => reject(new Error(`Health check timeout: ${name}`)), check.timeout);\n      });\n\n      // Run the health check with timeout\n      const result = await Promise.race([check.checkFunction(), timeoutPromise]);\n\n      const duration = performance.now() - startTime;\n\n      // Normalize result format\n      const normalizedResult: HealthCheckResult = {\n        score: typeof result === 'number' ? result : ((result as any)?.score ?? 100),\n        status: (result as any)?.status || 'healthy',\n        details: (result as any)?.details || (result as any)?.message || 'Health check passed',\n        metrics: (result as any)?.metrics || {},\n        duration: (result as any)?.duration ?? duration,\n      };\n\n      return normalizedResult;\n    } catch (error) {\n      const duration = performance.now() - startTime;\n\n      return {\n        score: 0,\n        status: 'error',\n        details: error instanceof Error ? error.message : String(error),\n        metrics: {},\n        duration,\n      };\n    }\n  }\n\n  /**\n   * Get current system health status.\n   */\n  getCurrentHealth(): any {\n    return {\n      ...this.currentHealth,\n      isRunning: this.isRunning,\n      checkCount: this.healthChecks.size,\n      alerts: this.alerts.length,\n      uptime: this.isRunning && this.startTime ? Date.now() - this.startTime : 0,\n    };\n  }\n\n  /**\n   * Get health history.\n   *\n   * @param limit\n   */\n  getHealthHistory(limit = 100): HealthReport[] {\n    return this.healthHistory.slice(-limit);\n  }\n\n  /**\n   * Get health trends and analysis.\n   */\n  getHealthTrends(): any {\n    if (this.healthHistory.length < 2) {\n      return {\n        trend: 'insufficient_data',\n        analysis: 'Not enough data for trend analysis',\n      };\n    }\n\n    const recent = this.healthHistory.slice(-10);\n    const scores = recent.map((h) => h.overallScore);\n\n    // Calculate trend\n    let trend = 'stable';\n    const avgRecent = scores.reduce((a, b) => a + b, 0) / scores.length;\n    const first = scores[0];\n    const last = scores[scores.length - 1];\n\n    if (first !== undefined && last !== undefined) {\n      if (last > first + 5) {\n        trend = 'improving';\n      } else if (last < first - 5) {\n        trend = 'degrading';\n      }\n    }\n\n    return {\n      trend,\n      currentScore: (this.currentHealth as HealthReport)?.overallScore || 0,\n      averageScore: avgRecent,\n      minScore: Math.min(...scores),\n      maxScore: Math.max(...scores),\n      dataPoints: scores.length,\n      analysis: `Health is ${trend} with current score of ${(this.currentHealth as HealthReport)?.overallScore || 0}%`,\n    };\n  }\n\n  // Private helper methods\n\n  private initializeSystemChecks(): void {\n    // Memory usage check\n    this.registerHealthCheck(\n      'memory',\n      () => {\n        const usage = process.memoryUsage();\n        const totalMB = usage.heapTotal / 1024 / 1024;\n        const usedMB = usage.heapUsed / 1024 / 1024;\n        const usagePercent = (usedMB / totalMB) * 100;\n\n        let score = 100;\n        if (usagePercent > 90) {\n          score = 10;\n        } else if (usagePercent > 80) {\n          score = 50;\n        } else if (usagePercent > 70) {\n          score = 75;\n        }\n\n        return {\n          score,\n          status: score > 70 ? 'healthy' : score > 50 ? 'warning' : 'critical',\n          details: `Memory usage: ${usedMB.toFixed(1)}MB / ${totalMB.toFixed(1)}MB (${usagePercent.toFixed(1)}%)`,\n          metrics: {\n            heapUsed: usedMB,\n            heapTotal: totalMB,\n            usagePercent,\n            external: usage.external / 1024 / 1024,\n          },\n        };\n      },\n      { weight: 2, critical: true, description: 'System memory usage monitoring' }\n    );\n\n    // Event loop lag check\n    this.registerHealthCheck(\n      'eventLoop',\n      () => {\n        return new Promise((resolve) => {\n          const start = performance.now();\n          setImmediate(() => {\n            const lag = performance.now() - start;\n\n            let score = 100;\n            if (lag > 100) {\n              score = 10;\n            } else if (lag > 50) {\n              score = 50;\n            } else if (lag > 20) {\n              score = 75;\n            }\n\n            resolve({\n              score,\n              status: score > 70 ? 'healthy' : score > 50 ? 'warning' : 'critical',\n              details: `Event loop lag: ${lag.toFixed(2)}ms`,\n              metrics: {\n                lag,\n                threshold: 20,\n              },\n            });\n          });\n        });\n      },\n      { weight: 1, description: 'Event loop performance monitoring' }\n    );\n\n    // CPU usage check (simplified)\n    this.registerHealthCheck(\n      'cpu',\n      () => {\n        const usage = process.cpuUsage();\n        const userTime = usage.user / 1000; // Convert to milliseconds\n        const systemTime = usage.system / 1000;\n        const totalTime = userTime + systemTime;\n\n        // Simple CPU load estimation\n        let score = 100;\n        if (totalTime > 1000) {\n          score = 30;\n        } else if (totalTime > 500) {\n          score = 60;\n        } else if (totalTime > 200) {\n          score = 80;\n        }\n\n        return {\n          score,\n          status: score > 70 ? 'healthy' : score > 50 ? 'warning' : 'critical',\n          details: `CPU usage: ${totalTime.toFixed(1)}ms (user: ${userTime.toFixed(1)}ms, system: ${systemTime.toFixed(1)}ms)`,\n          metrics: {\n            user: userTime,\n            system: systemTime,\n            total: totalTime,\n          },\n        };\n      },\n      { weight: 1, description: 'CPU usage monitoring' }\n    );\n\n    // Persistence connectivity check\n    this.registerHealthCheck(\n      'persistence',\n      async () => {\n        // This would be injected by the session manager\n        if (!this.persistenceChecker) {\n          return {\n            score: 100,\n            status: 'disabled',\n            details: 'Persistence checker not configured',\n            metrics: {},\n          };\n        }\n\n        try {\n          const startTime = performance.now();\n          await this.persistenceChecker();\n          const duration = performance.now() - startTime;\n\n          let score = 100;\n          if (duration > 1000) {\n            score = 50;\n          } else if (duration > 500) {\n            score = 75;\n          }\n\n          return {\n            score,\n            status: 'healthy',\n            details: `Persistence check passed in ${duration.toFixed(1)}ms`,\n            metrics: {\n              responseTime: duration,\n              status: 'connected',\n            },\n          };\n        } catch (error) {\n          return {\n            score: 0,\n            status: 'critical',\n            details: `Persistence check failed: ${error instanceof Error ? error.message : String(error)}`,\n            metrics: {\n              error: error instanceof Error ? error.message : String(error),\n              status: 'disconnected',\n            },\n          };\n        }\n      },\n      { weight: 3, critical: true, description: 'Database connectivity monitoring' }\n    );\n  }\n\n  private determineHealthStatus(\n    score: number,\n    criticalFailures: number\n  ): 'healthy' | 'warning' | 'critical' {\n    if (criticalFailures > 0 || score < (this.options.criticalThreshold ?? 50)) {\n      return 'critical';\n    } else if (score < (this.options.alertThreshold ?? 70)) {\n      return 'warning';\n    } else {\n      return 'healthy';\n    }\n  }\n\n  private async processHealthAlerts(healthReport: HealthReport): Promise<void> {\n    const { overallScore, status, criticalFailures, results } = healthReport;\n\n    // Create alerts for low health scores\n    if (status === 'critical') {\n      const alert: HealthAlert = {\n        id: randomUUID(),\n        type: 'critical',\n        timestamp: new Date().toISOString(),\n        title: 'Critical Health Alert',\n        message: `System health critically low: ${overallScore}% (${criticalFailures} critical failures)`,\n        details: results,\n        resolved: false,\n      };\n\n      this.alerts.push(alert);\n      this.emit('criticalAlert', alert);\n      logger.error(`\uD83D\uDEA8 CRITICAL ALERT: System health at ${overallScore}%`);\n    } else if (status === 'warning') {\n      const alert: HealthAlert = {\n        id: randomUUID(),\n        type: 'warning',\n        timestamp: new Date().toISOString(),\n        title: 'Health Warning',\n        message: `System health below threshold: ${overallScore}%`,\n        details: results,\n        resolved: false,\n      };\n\n      this.alerts.push(alert);\n      this.emit('healthWarning', alert);\n      logger.error(`\u26A0\uFE0F WARNING: System health at ${overallScore}%`);\n    }\n\n    // Clean up old alerts (keep last 100)\n    if (this.alerts.length > 100) {\n      this.alerts = this.alerts.slice(-100);\n    }\n  }\n\n  /**\n   * Set persistence checker function.\n   *\n   * @param checkerFunction\n   */\n  setPersistenceChecker(checkerFunction: () => Promise<void>): void {\n    this.persistenceChecker = checkerFunction;\n  }\n\n  /**\n   * Cleanup resources.\n   */\n  async destroy(): Promise<void> {\n    await this.stop();\n    this.healthChecks.clear();\n    this.healthHistory = [];\n    this.alerts = [];\n    this.removeAllListeners();\n  }\n}\n\nexport default HealthMonitor;\n", "/**\n * @file Coordination system: schemas.\n */\n\nimport { getLogger } from '../../../config/logging-config.ts';\n\nconst logger = getLogger('coordination-swarm-core-schemas');\n\n/**\n * Input Validation Schemas for RUV-Swarm MCP Tools.\n * Provides comprehensive validation for all 25+ MCP tools.\n */\n\nimport { ValidationError } from './errors.ts';\n\n/**\n * Base validator class.\n *\n * @example\n */\nclass BaseValidator {\n  static validate(value, schema, fieldName = 'value') {\n    try {\n      return BaseValidator.validateValue(value, schema, fieldName);\n    } catch (error) {\n      if (error instanceof ValidationError) {\n        throw error;\n      }\n      throw new ValidationError(\n        `Validation failed for ${fieldName}: ${error.message}`,\n        fieldName,\n        value\n      );\n    }\n  }\n\n  static validateValue(value, schema, fieldName) {\n    // Handle required fields\n    if (schema.required && (value === undefined || value === null)) {\n      throw new ValidationError(`${fieldName} is required`, fieldName, value, schema.type);\n    }\n\n    // Handle optional fields\n    if (!schema.required && (value === undefined || value === null)) {\n      return schema.default;\n    }\n\n    // Type validation\n    if (schema.type && !BaseValidator.validateType(value, schema.type)) {\n      throw new ValidationError(\n        `${fieldName} must be of type ${schema.type}`,\n        fieldName,\n        value,\n        schema.type\n      );\n    }\n\n    // Range validation for numbers\n    if (schema.type === 'number') {\n      if (schema.min !== undefined && value < schema.min) {\n        throw new ValidationError(\n          `${fieldName} must be at least ${schema.min}`,\n          fieldName,\n          value,\n          schema.type\n        );\n      }\n      if (schema.max !== undefined && value > schema.max) {\n        throw new ValidationError(\n          `${fieldName} must be at most ${schema.max}`,\n          fieldName,\n          value,\n          schema.type\n        );\n      }\n      if (schema.integer && !Number.isInteger(value)) {\n        throw new ValidationError(`${fieldName} must be an integer`, fieldName, value, 'integer');\n      }\n    }\n\n    // Length validation for strings and arrays\n    if (schema.type === 'string' || schema.type === 'array') {\n      const length = schema.type === 'string' ? value.length : value.length;\n      if (schema.minLength !== undefined && length < schema.minLength) {\n        throw new ValidationError(\n          `${fieldName} must be at least ${schema.minLength} characters/items long`,\n          fieldName,\n          value,\n          schema.type\n        );\n      }\n      if (schema.maxLength !== undefined && length > schema.maxLength) {\n        throw new ValidationError(\n          `${fieldName} must be at most ${schema.maxLength} characters/items long`,\n          fieldName,\n          value,\n          schema.type\n        );\n      }\n    }\n\n    // Enum validation\n    if (schema.enum && !schema.enum.includes(value)) {\n      throw new ValidationError(\n        `${fieldName} must be one of: ${schema.enum.join(', ')}`,\n        fieldName,\n        value,\n        `enum(${schema.enum.join('|')})`\n      );\n    }\n\n    // Pattern validation for strings\n    if (schema.type === 'string' && schema.pattern) {\n      const regex = new RegExp(schema.pattern);\n      if (!regex.test(value)) {\n        throw new ValidationError(\n          `${fieldName} does not match the required pattern`,\n          fieldName,\n          value,\n          'string(pattern)'\n        );\n      }\n    }\n\n    // Object property validation\n    if (schema.type === 'object' && schema.properties) {\n      for (const [propName, propSchema] of Object.entries(schema.properties)) {\n        if (value[propName] !== undefined) {\n          value[propName] = BaseValidator.validateValue(\n            value[propName],\n            propSchema,\n            `${fieldName}.${propName}`\n          );\n        } else if ((propSchema as any).required) {\n          throw new ValidationError(\n            `${fieldName}.${propName} is required`,\n            `${fieldName}.${propName}`,\n            undefined,\n            (propSchema as any).type\n          );\n        }\n      }\n    }\n\n    // Array item validation\n    if (schema.type === 'array' && schema.items) {\n      for (let i = 0; i < value.length; i++) {\n        value[i] = BaseValidator.validateValue(value[i], schema.items, `${fieldName}[${i}]`);\n      }\n    }\n\n    return value;\n  }\n\n  static validateType(value, expectedType) {\n    switch (expectedType) {\n      case 'string':\n        return typeof value === 'string';\n      case 'number':\n        return typeof value === 'number' && !Number.isNaN(value) && Number.isFinite(value);\n      case 'boolean':\n        return typeof value === 'boolean';\n      case 'array':\n        return Array.isArray(value);\n      case 'object':\n        return typeof value === 'object' && value !== null && !Array.isArray(value);\n      case 'function':\n        return typeof value === 'function';\n      default:\n        return true;\n    }\n  }\n}\n\n/**\n * Schema definitions for all MCP tools.\n */\nconst MCPSchemas = {\n  // Core Swarm Management\n  swarm_init: {\n    topology: {\n      type: 'string',\n      enum: ['mesh', 'hierarchical', 'ring', 'star'],\n      default: 'mesh',\n    },\n    maxAgents: {\n      type: 'number',\n      integer: true,\n      min: 1,\n      max: 100,\n      default: 5,\n    },\n    strategy: {\n      type: 'string',\n      enum: ['balanced', 'specialized', 'adaptive'],\n      default: 'balanced',\n    },\n    enableCognitiveDiversity: {\n      type: 'boolean',\n      default: true,\n    },\n    enableNeuralAgents: {\n      type: 'boolean',\n      default: true,\n    },\n    enableForecasting: {\n      type: 'boolean',\n      default: false,\n    },\n  },\n\n  agent_spawn: {\n    type: {\n      type: 'string',\n      enum: [\n        'researcher',\n        'coder',\n        'analyst',\n        'optimizer',\n        'coordinator',\n        'tester',\n        'reviewer',\n        'documenter',\n      ],\n      default: 'researcher',\n    },\n    name: {\n      type: 'string',\n      minLength: 1,\n      maxLength: 100,\n      required: false,\n    },\n    capabilities: {\n      type: 'array',\n      items: {\n        type: 'string',\n        minLength: 1,\n      },\n      required: false,\n    },\n    cognitivePattern: {\n      type: 'string',\n      enum: ['convergent', 'divergent', 'lateral', 'systems', 'critical', 'adaptive'],\n      required: false,\n    },\n    swarmId: {\n      type: 'string',\n      pattern: '^[a-fA-F0-9-]+$',\n      required: false,\n    },\n  },\n\n  task_orchestrate: {\n    task: {\n      type: 'string',\n      required: true,\n      minLength: 1,\n      maxLength: 1000,\n    },\n    priority: {\n      type: 'string',\n      enum: ['low', 'medium', 'high', 'critical'],\n      default: 'medium',\n    },\n    strategy: {\n      type: 'string',\n      enum: ['parallel', 'sequential', 'adaptive'],\n      default: 'adaptive',\n    },\n    maxAgents: {\n      type: 'number',\n      integer: true,\n      min: 1,\n      max: 50,\n      required: false,\n    },\n    swarmId: {\n      type: 'string',\n      pattern: '^[a-fA-F0-9-]+$',\n      required: false,\n    },\n    requiredCapabilities: {\n      type: 'array',\n      items: {\n        type: 'string',\n        minLength: 1,\n      },\n      required: false,\n    },\n    estimatedDuration: {\n      type: 'number',\n      min: 1000,\n      max: 3600000, // 1 hour max\n      required: false,\n    },\n  },\n\n  swarm_status: {\n    verbose: {\n      type: 'boolean',\n      default: false,\n    },\n    swarmId: {\n      type: 'string',\n      pattern: '^[a-fA-F0-9-]+$',\n      required: false,\n    },\n  },\n\n  task_status: {\n    taskId: {\n      type: 'string',\n      pattern: '^[a-fA-F0-9-]+$',\n      required: false,\n    },\n    detailed: {\n      type: 'boolean',\n      default: false,\n    },\n  },\n\n  task_results: {\n    taskId: {\n      type: 'string',\n      required: true,\n      pattern: '^[a-fA-F0-9-]+$',\n    },\n    format: {\n      type: 'string',\n      enum: ['summary', 'detailed', 'raw', 'performance'],\n      default: 'summary',\n    },\n    includeAgentResults: {\n      type: 'boolean',\n      default: true,\n    },\n  },\n\n  agent_list: {\n    filter: {\n      type: 'string',\n      enum: ['all', 'active', 'idle', 'busy'],\n      default: 'all',\n    },\n    swarmId: {\n      type: 'string',\n      pattern: '^[a-fA-F0-9-]+$',\n      required: false,\n    },\n  },\n\n  agent_metrics: {\n    agentId: {\n      type: 'string',\n      pattern: '^[a-fA-F0-9-]+$',\n      required: false,\n    },\n    swarmId: {\n      type: 'string',\n      pattern: '^[a-fA-F0-9-]+$',\n      required: false,\n    },\n    metric: {\n      type: 'string',\n      enum: ['all', 'cpu', 'memory', 'tasks', 'performance', 'neural'],\n      default: 'all',\n    },\n  },\n\n  benchmark_run: {\n    type: {\n      type: 'string',\n      enum: ['all', 'wasm', 'swarm', 'agent', 'task', 'neural'],\n      default: 'all',\n    },\n    iterations: {\n      type: 'number',\n      integer: true,\n      min: 1,\n      max: 100,\n      default: 10,\n    },\n    includeNeuralBenchmarks: {\n      type: 'boolean',\n      default: true,\n    },\n    includeSwarmBenchmarks: {\n      type: 'boolean',\n      default: true,\n    },\n  },\n\n  features_detect: {\n    category: {\n      type: 'string',\n      enum: ['all', 'wasm', 'simd', 'memory', 'platform', 'neural', 'forecasting'],\n      default: 'all',\n    },\n  },\n\n  memory_usage: {\n    detail: {\n      type: 'string',\n      enum: ['summary', 'detailed', 'by-agent'],\n      default: 'summary',\n    },\n  },\n\n  // Neural Network Tools\n  neural_status: {\n    agentId: {\n      type: 'string',\n      pattern: '^[a-fA-F0-9-]+$',\n      required: false,\n    },\n  },\n\n  neural_train: {\n    agentId: {\n      type: 'string',\n      required: true,\n      pattern: '^[a-fA-F0-9-]+$',\n    },\n    iterations: {\n      type: 'number',\n      integer: true,\n      min: 1,\n      max: 100,\n      default: 10,\n    },\n    learningRate: {\n      type: 'number',\n      min: 0.00001,\n      max: 1.0,\n      default: 0.001,\n    },\n    modelType: {\n      type: 'string',\n      enum: ['feedforward', 'lstm', 'transformer', 'cnn', 'attention'],\n      default: 'feedforward',\n    },\n    trainingData: {\n      type: 'object',\n      required: false,\n    },\n  },\n\n  neural_patterns: {\n    pattern: {\n      type: 'string',\n      enum: [\n        'all',\n        'convergent',\n        'divergent',\n        'lateral',\n        'systems',\n        'critical',\n        'abstract',\n        'adaptive',\n      ],\n      default: 'all',\n    },\n  },\n\n  // DAA (Decentralized Autonomous Agents) Tools\n  daa_init: {\n    enableCoordination: {\n      type: 'boolean',\n      default: true,\n    },\n    enableLearning: {\n      type: 'boolean',\n      default: true,\n    },\n    persistenceMode: {\n      type: 'string',\n      enum: ['auto', 'memory', 'disk'],\n      default: 'auto',\n    },\n  },\n\n  daa_agent_create: {\n    id: {\n      type: 'string',\n      required: true,\n      minLength: 1,\n      maxLength: 100,\n    },\n    capabilities: {\n      type: 'array',\n      items: {\n        type: 'string',\n        minLength: 1,\n      },\n      required: false,\n    },\n    cognitivePattern: {\n      type: 'string',\n      enum: ['convergent', 'divergent', 'lateral', 'systems', 'critical', 'adaptive'],\n      required: false,\n    },\n    enableMemory: {\n      type: 'boolean',\n      default: true,\n    },\n    learningRate: {\n      type: 'number',\n      min: 0.001,\n      max: 1.0,\n      default: 0.1,\n    },\n  },\n\n  daa_agent_adapt: {\n    agent_id: {\n      type: 'string',\n      required: true,\n      minLength: 1,\n    },\n    agentId: {\n      type: 'string',\n      required: false,\n      minLength: 1,\n    },\n    feedback: {\n      type: 'string',\n      minLength: 1,\n      maxLength: 1000,\n      required: false,\n    },\n    performanceScore: {\n      type: 'number',\n      min: 0,\n      max: 1,\n      required: false,\n    },\n    suggestions: {\n      type: 'array',\n      items: {\n        type: 'string',\n        minLength: 1,\n      },\n      required: false,\n    },\n  },\n\n  daa_workflow_create: {\n    id: {\n      type: 'string',\n      required: true,\n      minLength: 1,\n      maxLength: 100,\n    },\n    name: {\n      type: 'string',\n      required: true,\n      minLength: 1,\n      maxLength: 200,\n    },\n    steps: {\n      type: 'array',\n      items: {\n        type: 'object',\n      },\n      required: false,\n    },\n    dependencies: {\n      type: 'object',\n      required: false,\n    },\n    strategy: {\n      type: 'string',\n      enum: ['parallel', 'sequential', 'adaptive'],\n      default: 'adaptive',\n    },\n  },\n\n  daa_workflow_execute: {\n    workflow_id: {\n      type: 'string',\n      required: true,\n      minLength: 1,\n    },\n    workflowId: {\n      type: 'string',\n      required: false,\n      minLength: 1,\n    },\n    agentIds: {\n      type: 'array',\n      items: {\n        type: 'string',\n        minLength: 1,\n      },\n      required: false,\n    },\n    parallelExecution: {\n      type: 'boolean',\n      default: true,\n    },\n  },\n\n  daa_knowledge_share: {\n    source_agent: {\n      type: 'string',\n      required: true,\n      minLength: 1,\n    },\n    sourceAgentId: {\n      type: 'string',\n      required: false,\n      minLength: 1,\n    },\n    target_agents: {\n      type: 'array',\n      items: {\n        type: 'string',\n        minLength: 1,\n      },\n      required: true,\n      minItems: 1,\n    },\n    targetAgentIds: {\n      type: 'array',\n      items: {\n        type: 'string',\n        minLength: 1,\n      },\n      required: true,\n      minLength: 1,\n    },\n    knowledgeDomain: {\n      type: 'string',\n      minLength: 1,\n      required: false,\n    },\n    knowledgeContent: {\n      type: 'object',\n      required: false,\n    },\n  },\n\n  daa_learning_status: {\n    agentId: {\n      type: 'string',\n      required: false,\n    },\n    detailed: {\n      type: 'boolean',\n      default: false,\n    },\n  },\n\n  daa_cognitive_pattern: {\n    agentId: {\n      type: 'string',\n      required: false,\n    },\n    pattern: {\n      type: 'string',\n      enum: ['convergent', 'divergent', 'lateral', 'systems', 'critical', 'adaptive'],\n      required: false,\n    },\n    analyze: {\n      type: 'boolean',\n      default: false,\n    },\n  },\n\n  daa_meta_learning: {\n    sourceDomain: {\n      type: 'string',\n      minLength: 1,\n      required: false,\n    },\n    targetDomain: {\n      type: 'string',\n      minLength: 1,\n      required: false,\n    },\n    transferMode: {\n      type: 'string',\n      enum: ['adaptive', 'direct', 'gradual'],\n      default: 'adaptive',\n    },\n    agentIds: {\n      type: 'array',\n      items: {\n        type: 'string',\n        minLength: 1,\n      },\n      required: false,\n    },\n  },\n\n  daa_performance_metrics: {\n    category: {\n      type: 'string',\n      enum: ['all', 'system', 'performance', 'efficiency', 'neural'],\n      default: 'all',\n    },\n    timeRange: {\n      type: 'string',\n      pattern: '^\\\\d+[hmd]$', // e.g., \"1h\", \"24h\", \"7d\"\n      required: false,\n    },\n  },\n\n  // Monitoring Tools\n  swarm_monitor: {\n    swarmId: {\n      type: 'string',\n      pattern: '^[a-fA-F0-9-]+$',\n      required: false,\n    },\n    duration: {\n      type: 'number',\n      integer: true,\n      min: 1,\n      max: 3600, // 1 hour max\n      default: 10,\n    },\n    interval: {\n      type: 'number',\n      integer: true,\n      min: 1,\n      max: 60,\n      default: 1,\n    },\n    includeAgents: {\n      type: 'boolean',\n      default: true,\n    },\n    includeTasks: {\n      type: 'boolean',\n      default: true,\n    },\n    includeMetrics: {\n      type: 'boolean',\n      default: true,\n    },\n    realTime: {\n      type: 'boolean',\n      default: false,\n    },\n  },\n};\n\n/**\n * Validation utilities.\n *\n * @example\n */\nclass ValidationUtils {\n  /**\n   * Validate parameters against a schema.\n   *\n   * @param params\n   * @param toolName\n   */\n  static validateParams(params, toolName) {\n    const schema = MCPSchemas[toolName];\n    if (!schema) {\n      throw new ValidationError(\n        `No validation schema found for tool: ${toolName}`,\n        'toolName',\n        toolName,\n        'string'\n      );\n    }\n\n    // Handle empty or null params\n    if (!params || typeof params !== 'object') {\n      params = {};\n    }\n\n    const validatedParams = {};\n\n    // Validate each parameter\n    for (const [fieldName, fieldSchema] of Object.entries(schema)) {\n      try {\n        const value = params?.[fieldName];\n        validatedParams[fieldName] = BaseValidator.validate(value, fieldSchema, fieldName);\n      } catch (error) {\n        // Add tool context to error\n        if (error instanceof ValidationError) {\n          error.details.tool = toolName;\n          error.details.schema = fieldSchema;\n        }\n        throw error;\n      }\n    }\n\n    // Check for unexpected parameters\n    const allowedFields = Object.keys(schema);\n    const providedFields = Object.keys(params);\n    const unexpectedFields = providedFields.filter((field) => !allowedFields.includes(field));\n\n    if (unexpectedFields.length > 0) {\n      logger.warn(`Unexpected parameters for ${toolName}: ${unexpectedFields.join(', ')}`);\n      // Note: We don't throw here to maintain backward compatibility\n    }\n\n    return validatedParams;\n  }\n\n  /**\n   * Get schema documentation for a tool.\n   *\n   * @param toolName\n   */\n  static getSchemaDoc(toolName) {\n    const schema = MCPSchemas[toolName];\n    if (!schema) {\n      return null;\n    }\n\n    const doc = {\n      tool: toolName,\n      parameters: {},\n    };\n\n    for (const [fieldName, fieldSchema] of Object.entries(schema)) {\n      const field = fieldSchema as any;\n      doc.parameters[fieldName] = {\n        type: field.type,\n        required: field.required || false,\n        default: field.default,\n        description: ValidationUtils.generateFieldDescription(fieldName, field),\n      };\n\n      if (field.enum) {\n        doc.parameters[fieldName].allowedValues = field.enum;\n      }\n      if (field.min !== undefined || field.max !== undefined) {\n        doc.parameters[fieldName].range = {\n          min: field.min,\n          max: field.max,\n        };\n      }\n      if (field.minLength !== undefined || field.maxLength !== undefined) {\n        doc.parameters[fieldName].length = {\n          min: field.minLength,\n          max: field.maxLength,\n        };\n      }\n    }\n\n    return doc;\n  }\n\n  /**\n   * Generate human-readable description for a field.\n   *\n   * @param fieldName\n   * @param schema\n   */\n  static generateFieldDescription(fieldName, schema) {\n    let desc = `${fieldName} (${schema.type})`;\n\n    if (schema.required) {\n      desc += ' - Required';\n    } else {\n      desc += ' - Optional';\n      if (schema.default !== undefined) {\n        desc += `, default: ${schema.default}`;\n      }\n    }\n\n    if (schema.enum) {\n      desc += `. Allowed values: ${schema.enum.join(', ')}`;\n    }\n\n    if (schema.min !== undefined || schema.max !== undefined) {\n      desc += `. Range: ${schema.min || 'any'} to ${schema.max || 'any'}`;\n    }\n\n    if (schema.minLength !== undefined || schema.maxLength !== undefined) {\n      desc += `. Length: ${schema.minLength || 0} to ${schema.maxLength || 'unlimited'}`;\n    }\n\n    return desc;\n  }\n\n  /**\n   * Get all available tool schemas.\n   */\n  static getAllSchemas() {\n    return Object.keys(MCPSchemas);\n  }\n\n  /**\n   * Validate a UUID string.\n   *\n   * @param str\n   */\n  static isValidUUID(str) {\n    const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;\n    return uuidRegex.test(str);\n  }\n\n  /**\n   * Sanitize input to prevent injection attacks.\n   *\n   * @param input\n   */\n  static sanitizeInput(input) {\n    if (typeof input === 'string') {\n      // Remove potentially dangerous characters\n      return input.replace(/[<>\"'&\\x00-\\x1f\\x7f-\\x9f]/g, '');\n    }\n    return input;\n  }\n}\n\n/**\n * Export validation schemas and utilities.\n */\nexport { MCPSchemas, BaseValidator, ValidationUtils };\n\nexport default ValidationUtils;\n", "/**\n * @file Session management system.\n */\n\nimport { getLogger } from '../../../config/logging-config.ts';\n\nconst logger = getLogger('coordination-swarm-core-session-manager');\n\n/**\n * Session Management System for ZenSwarm.\n *\n * Provides comprehensive session management with persistence integration,\n * state serialization, checkpoint system, and recovery mechanisms.\n *\n * Architecture:\n * - SessionManager: Main class handling session lifecycle\n * - SessionState: Interface for session data structure\n * - Checkpoint system with integrity verification\n * - Recovery mechanisms with rollback capabilities.\n * - Integration with existing persistence layer.\n */\n\nimport crypto from 'node:crypto';\nimport { EventEmitter } from 'node:events';\nimport type { IDao, SessionCoordinationDao, SessionEntity } from '../../../database';\nimport { createDao, DatabaseTypes, EntityTypes } from '../../../database';\nimport type { SwarmOptions, SwarmState } from './types.ts';\nimport { generateId } from './utils.ts';\n\nexport interface SessionState {\n  id: string;\n  name: string;\n  createdAt: Date;\n  lastAccessedAt: Date;\n  lastCheckpointAt?: Date;\n  status: SessionStatus;\n  swarmState: SwarmState;\n  swarmOptions: SwarmOptions;\n  metadata: Record<string, any>;\n  checkpoints: SessionCheckpoint[];\n  version: string;\n}\n\nexport interface SessionCheckpoint {\n  id: string;\n  sessionId: string;\n  timestamp: Date;\n  checksum: string;\n  state: SwarmState;\n  description: string;\n  metadata: Record<string, any>;\n}\n\nexport interface SessionConfig {\n  autoCheckpoint?: boolean;\n  checkpointInterval?: number; // milliseconds\n  maxCheckpoints?: number;\n  compressionEnabled?: boolean;\n  encryptionEnabled?: boolean;\n  encryptionKey?: string;\n}\n\nexport type SessionStatus = 'active' | 'paused' | 'hibernated' | 'terminated' | 'corrupted';\n\nexport interface SessionRecoveryOptions {\n  targetCheckpoint?: string;\n  ignoreCorruption?: boolean;\n  validateState?: boolean;\n}\n\n/**\n * Core Session Manager class.\n *\n * @example\n */\nexport class SessionManager extends EventEmitter {\n  private coordinationDao: SessionCoordinationDao;\n  private activeSessions: Map<string, SessionState>;\n  private config: Required<SessionConfig>;\n  private checkpointTimers: Map<string, NodeJS.Timeout>;\n  private initialized: boolean = false;\n\n  constructor(coordinationDao: SessionCoordinationDao, config: SessionConfig = {}) {\n    super();\n\n    this.coordinationDao = coordinationDao;\n    this.activeSessions = new Map();\n    this.checkpointTimers = new Map();\n\n    this.config = {\n      autoCheckpoint: config.autoCheckpoint === undefined ? true : config?.autoCheckpoint,\n      checkpointInterval:\n        config.checkpointInterval === undefined ? 300000 : config?.checkpointInterval, // 5 minutes\n      maxCheckpoints: config.maxCheckpoints === undefined ? 10 : config?.maxCheckpoints,\n      compressionEnabled:\n        config.compressionEnabled === undefined ? true : config?.compressionEnabled,\n      encryptionEnabled: config.encryptionEnabled === undefined ? false : config?.encryptionEnabled,\n      encryptionKey:\n        config.encryptionKey === undefined ? this.generateEncryptionKey() : config?.encryptionKey,\n    };\n  }\n\n  /**\n   * Ensure DAO is initialized.\n   */\n  private async ensureInitialized(): Promise<void> {\n    if (!this.coordinationDao) {\n      // Create a coordination DAO with proper interface\n      const dao = await createDao<SessionEntity>(\n        EntityTypes.CoordinationEvent,\n        DatabaseTypes?.Coordination\n      );\n\n      // Type assertion with proper coordination methods\n      this.coordinationDao = {\n        ...dao,\n        // Add coordination-specific methods\n        execute: async (sql: string, params?: unknown[]) => {\n          const customQuery = {\n            type: 'sql' as const,\n            query: sql,\n            parameters: params ? Object.fromEntries(params.map((p, i) => [i.toString(), p])) : {},\n          };\n          const result = await dao.executeCustomQuery<{ affectedRows?: number; insertId?: number }>(\n            customQuery\n          );\n          return result || { affectedRows: 0 };\n        },\n        query: async (sql: string, params?: unknown[]) => {\n          const customQuery = {\n            type: 'sql' as const,\n            query: sql,\n            parameters: params ? Object.fromEntries(params.map((p, i) => [i.toString(), p])) : {},\n          };\n          const result = await dao.executeCustomQuery<any[]>(customQuery);\n          return Array.isArray(result) ? result : [];\n        },\n        acquireLock: async (resourceId: string, lockTimeout?: number) => {\n          throw new Error('Lock operations not yet implemented');\n        },\n        releaseLock: async (lockId: string) => {\n          throw new Error('Lock operations not yet implemented');\n        },\n        subscribe: async (pattern: string, callback: any) => {\n          throw new Error('Subscription operations not yet implemented');\n        },\n        unsubscribe: async (subscriptionId: string) => {\n          throw new Error('Subscription operations not yet implemented');\n        },\n        publish: async (channel: string, event: any) => {\n          throw new Error('Publish operations not yet implemented');\n        },\n        getCoordinationStats: async () => {\n          return {\n            activeLocks: 0,\n            activeSubscriptions: 0,\n            messagesPublished: 0,\n            messagesReceived: 0,\n            uptime: Date.now(),\n          };\n        },\n      } as SessionCoordinationDao;\n    }\n  }\n\n  /**\n   * Get initialized DAO with null safety.\n   */\n  private async getDao(): Promise<SessionCoordinationDao> {\n    await this.ensureInitialized();\n    return this.coordinationDao!;\n  }\n\n  /**\n   * Initialize the session manager.\n   */\n  async initialize(): Promise<void> {\n    if (this.initialized) return;\n\n    try {\n      // Ensure DAO is initialized\n      await this.ensureInitialized();\n\n      // Create session tables if they don't exist\n      await this.initializeSessionTables();\n\n      // Restore active sessions\n      await this.restoreActiveSessions();\n\n      this.initialized = true;\n      this.emit('manager:initialized');\n    } catch (error) {\n      throw new Error(\n        `Failed to initialize SessionManager: ${error instanceof Error ? error.message : String(error)}`\n      );\n    }\n  }\n\n  /**\n   * Create a new session.\n   *\n   * @param name\n   * @param swarmOptions\n   * @param initialState\n   */\n  async createSession(\n    name: string,\n    swarmOptions: SwarmOptions,\n    initialState?: Partial<SwarmState>\n  ): Promise<string> {\n    await this.ensureInitialized();\n\n    const sessionId = generateId('session');\n    const now = new Date();\n\n    const defaultSwarmState: SwarmState = {\n      agents: new Map(),\n      tasks: new Map(),\n      topology: swarmOptions?.topology || 'mesh',\n      connections: [],\n      metrics: {\n        totalTasks: 0,\n        completedTasks: 0,\n        failedTasks: 0,\n        averageCompletionTime: 0,\n        agentUtilization: new Map(),\n        throughput: 0,\n      },\n    };\n\n    const sessionState: SessionState = {\n      id: sessionId,\n      name,\n      createdAt: now,\n      lastAccessedAt: now,\n      status: 'active',\n      swarmState: { ...defaultSwarmState, ...initialState },\n      swarmOptions,\n      metadata: {},\n      checkpoints: [],\n      version: '1.0.0',\n    };\n\n    // Store in database\n    const dao = await this.getDao();\n    await dao.execute(\n      `\n      INSERT INTO sessions (id, name, status, swarm_options, swarm_state, metadata, created_at, last_accessed_at, version)\n      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)\n    `,\n      [\n        sessionId,\n        name,\n        'active',\n        this.serializeData(swarmOptions),\n        this.serializeData(sessionState.swarmState),\n        this.serializeData(sessionState.metadata),\n        now.toISOString(),\n        now.toISOString(),\n        sessionState.version,\n      ]\n    );\n\n    // Add to active sessions\n    this.activeSessions.set(sessionId, sessionState);\n\n    // Start auto-checkpoint if enabled\n    if (this.config.autoCheckpoint) {\n      this.startAutoCheckpoint(sessionId);\n    }\n\n    this.emit('session:created', { sessionId, name });\n    return sessionId;\n  }\n\n  /**\n   * Load an existing session.\n   *\n   * @param sessionId\n   */\n  async loadSession(sessionId: string): Promise<SessionState> {\n    await this.ensureInitialized();\n\n    // Check if already loaded\n    if (this.activeSessions.has(sessionId)) {\n      const session = this.activeSessions.get(sessionId)!;\n      session.lastAccessedAt = new Date();\n      await this.updateSessionAccess(sessionId);\n      return session;\n    }\n\n    // Load from database\n    const dao = await this.getDao();\n    const sessions = await dao.query('SELECT * FROM sessions WHERE id = ?', [sessionId]);\n\n    if (sessions.length === 0) {\n      throw new Error(`Session ${sessionId} not found`);\n    }\n\n    const sessionData = sessions[0];\n    const sessionState: SessionState = {\n      id: sessionData?.id,\n      name: sessionData?.name,\n      createdAt: new Date(sessionData?.created_at),\n      lastAccessedAt: new Date(),\n      ...(sessionData?.last_checkpoint_at && {\n        lastCheckpointAt: new Date(sessionData?.last_checkpoint_at),\n      }),\n      status: sessionData?.status as SessionStatus,\n      swarmState: this.deserializeData(sessionData?.swarm_state),\n      swarmOptions: this.deserializeData(sessionData?.swarm_options),\n      metadata: this.deserializeData(sessionData?.metadata),\n      checkpoints: await this.loadSessionCheckpoints(sessionId),\n      version: sessionData?.version,\n    } satisfies SessionState;\n\n    // Add to active sessions\n    this.activeSessions.set(sessionId, sessionState);\n\n    // Update last accessed time\n    await this.updateSessionAccess(sessionId);\n\n    // Start auto-checkpoint if enabled and session is active\n    if (this.config.autoCheckpoint && sessionState.status === 'active') {\n      this.startAutoCheckpoint(sessionId);\n    }\n\n    this.emit('session:loaded', { sessionId });\n    return sessionState;\n  }\n\n  /**\n   * Save session state.\n   *\n   * @param sessionId\n   * @param state\n   */\n  async saveSession(sessionId: string, state?: Partial<SwarmState>): Promise<void> {\n    await this.ensureInitialized();\n\n    const session = this.activeSessions.get(sessionId);\n    if (!session) {\n      throw new Error(`Session ${sessionId} not found in active sessions`);\n    }\n\n    if (state) {\n      session.swarmState = { ...session.swarmState, ...state };\n    }\n\n    session.lastAccessedAt = new Date();\n\n    // Update in database\n    const dao = await this.getDao();\n    await dao.execute(\n      `\n      UPDATE sessions \n      SET swarm_state = ?, last_accessed_at = ?\n      WHERE id = ?\n    `,\n      [this.serializeData(session.swarmState), session.lastAccessedAt.toISOString(), sessionId]\n    );\n\n    this.emit('session:saved', { sessionId });\n  }\n\n  /**\n   * Create a checkpoint of the current session state.\n   *\n   * @param sessionId\n   * @param description\n   * @param metadata\n   */\n  async createCheckpoint(\n    sessionId: string,\n    description: string = 'Auto checkpoint',\n    metadata: Record<string, any> = {}\n  ): Promise<string> {\n    await this.ensureInitialized();\n\n    const session = this.activeSessions.get(sessionId);\n    if (!session) {\n      throw new Error(`Session ${sessionId} not found`);\n    }\n\n    const checkpointId = generateId('checkpoint');\n    const now = new Date();\n    const stateData = this.serializeData(session.swarmState);\n    const checksum = this.calculateChecksum(stateData);\n\n    const checkpoint: SessionCheckpoint = {\n      id: checkpointId,\n      sessionId,\n      timestamp: now,\n      checksum,\n      state: session.swarmState,\n      description,\n      metadata,\n    };\n\n    // Store checkpoint in database\n    const dao = await this.getDao();\n    await dao.execute(\n      `\n      INSERT INTO session_checkpoints (id, session_id, timestamp, checksum, state_data, description, metadata)\n      VALUES (?, ?, ?, ?, ?, ?, ?)\n    `,\n      [\n        checkpointId,\n        sessionId,\n        now.toISOString(),\n        checksum,\n        stateData,\n        description,\n        this.serializeData(metadata),\n      ]\n    );\n\n    // Add to session checkpoints\n    session.checkpoints.push(checkpoint);\n    session.lastCheckpointAt = now;\n\n    // Maintain checkpoint limit\n    if (session.checkpoints.length > this.config.maxCheckpoints) {\n      const oldestCheckpoint = session.checkpoints.shift()!;\n      await this.deleteCheckpoint(oldestCheckpoint.id);\n    }\n\n    // Update session last checkpoint time\n    await dao.execute(\n      `\n      UPDATE sessions SET last_checkpoint_at = ? WHERE id = ?\n    `,\n      [now.toISOString(), sessionId]\n    );\n\n    this.emit('checkpoint:created', { sessionId, checkpointId, description });\n    return checkpointId;\n  }\n\n  /**\n   * Restore session from a checkpoint.\n   *\n   * @param sessionId\n   * @param checkpointId\n   * @param options\n   */\n  async restoreFromCheckpoint(\n    sessionId: string,\n    checkpointId: string,\n    options: SessionRecoveryOptions = {}\n  ): Promise<void> {\n    await this.ensureInitialized();\n\n    const session = this.activeSessions.get(sessionId);\n    if (!session) {\n      throw new Error(`Session ${sessionId} not found`);\n    }\n\n    // Load checkpoint\n    const dao = await this.getDao();\n    const checkpoints = await dao.query(\n      'SELECT * FROM session_checkpoints WHERE id = ? AND session_id = ?',\n      [checkpointId, sessionId]\n    );\n\n    if (checkpoints.length === 0) {\n      throw new Error(`Checkpoint ${checkpointId} not found`);\n    }\n\n    const checkpointData = checkpoints[0];\n    const stateData = checkpointData?.state_data;\n\n    // Verify integrity if requested\n    if (options?.validateState !== false) {\n      const expectedChecksum = checkpointData?.checksum;\n      const actualChecksum = this.calculateChecksum(stateData);\n\n      if (expectedChecksum !== actualChecksum) {\n        if (!options?.ignoreCorruption) {\n          throw new Error(`Checkpoint ${checkpointId} integrity check failed`);\n        }\n        this.emit('session:corruption_detected', { sessionId, checkpointId });\n      }\n    }\n\n    // Restore state\n    const restoredState = this.deserializeData(stateData);\n    session.swarmState = restoredState;\n    session.lastAccessedAt = new Date();\n    session.status = 'active';\n\n    // Save restored session\n    await this.saveSession(sessionId);\n\n    this.emit('session:restored', { sessionId, checkpointId });\n  }\n\n  /**\n   * Pause a session (stop processing but keep in memory).\n   *\n   * @param sessionId\n   */\n  async pauseSession(sessionId: string): Promise<void> {\n    await this.ensureInitialized();\n\n    const session = this.activeSessions.get(sessionId);\n    if (!session) {\n      throw new Error(`Session ${sessionId} not found`);\n    }\n\n    session.status = 'paused';\n    session.lastAccessedAt = new Date();\n\n    // Stop auto-checkpointing\n    this.stopAutoCheckpoint(sessionId);\n\n    // Update in database\n    const dao = await this.getDao();\n    await dao.execute('UPDATE sessions SET status = ?, last_accessed_at = ? WHERE id = ?', [\n      'paused',\n      session.lastAccessedAt.toISOString(),\n      sessionId,\n    ]);\n\n    this.emit('session:paused', { sessionId });\n  }\n\n  /**\n   * Resume a paused session.\n   *\n   * @param sessionId\n   */\n  async resumeSession(sessionId: string): Promise<void> {\n    await this.ensureInitialized();\n\n    const session = this.activeSessions.get(sessionId);\n    if (!session) {\n      throw new Error(`Session ${sessionId} not found`);\n    }\n\n    session.status = 'active';\n    session.lastAccessedAt = new Date();\n\n    // Restart auto-checkpointing\n    if (this.config.autoCheckpoint) {\n      this.startAutoCheckpoint(sessionId);\n    }\n\n    // Update in database\n    const dao = await this.getDao();\n    await dao.execute('UPDATE sessions SET status = ?, last_accessed_at = ? WHERE id = ?', [\n      'active',\n      session.lastAccessedAt.toISOString(),\n      sessionId,\n    ]);\n\n    this.emit('session:resumed', { sessionId });\n  }\n\n  /**\n   * Hibernate a session (save to disk and remove from memory).\n   *\n   * @param sessionId\n   */\n  async hibernateSession(sessionId: string): Promise<void> {\n    await this.ensureInitialized();\n\n    const session = this.activeSessions.get(sessionId);\n    if (!session) {\n      throw new Error(`Session ${sessionId} not found`);\n    }\n\n    // Create final checkpoint before hibernation\n    await this.createCheckpoint(sessionId, 'Pre-hibernation checkpoint');\n\n    session.status = 'hibernated';\n    session.lastAccessedAt = new Date();\n\n    // Stop auto-checkpointing\n    this.stopAutoCheckpoint(sessionId);\n\n    // Update in database\n    const dao = await this.getDao();\n    await dao.execute('UPDATE sessions SET status = ?, last_accessed_at = ? WHERE id = ?', [\n      'hibernated',\n      session.lastAccessedAt.toISOString(),\n      sessionId,\n    ]);\n\n    // Remove from active sessions\n    this.activeSessions.delete(sessionId);\n\n    this.emit('session:hibernated', { sessionId });\n  }\n\n  /**\n   * Terminate a session permanently.\n   *\n   * @param sessionId\n   * @param cleanup\n   */\n  async terminateSession(sessionId: string, cleanup: boolean = false): Promise<void> {\n    await this.ensureInitialized();\n\n    const session = this.activeSessions.get(sessionId);\n    if (session) {\n      session.status = 'terminated';\n      this.stopAutoCheckpoint(sessionId);\n      this.activeSessions.delete(sessionId);\n    }\n\n    // Update in database\n    const dao = await this.getDao();\n    await dao.execute('UPDATE sessions SET status = ?, last_accessed_at = ? WHERE id = ?', [\n      'terminated',\n      new Date().toISOString(),\n      sessionId,\n    ]);\n\n    if (cleanup) {\n      // Delete all checkpoints\n      await dao.execute('DELETE FROM session_checkpoints WHERE session_id = ?', [sessionId]);\n\n      // Delete session record\n      await dao.execute('DELETE FROM sessions WHERE id = ?', [sessionId]);\n    }\n\n    this.emit('session:terminated', { sessionId, cleanup });\n  }\n\n  /**\n   * List all sessions with optional filtering.\n   *\n   * @param filter\n   * @param filter.status\n   * @param filter.namePattern\n   * @param filter.createdAfter\n   * @param filter.createdBefore\n   */\n  async listSessions(filter?: {\n    status?: SessionStatus;\n    namePattern?: string;\n    createdAfter?: Date;\n    createdBefore?: Date;\n  }): Promise<SessionState[]> {\n    await this.ensureInitialized();\n\n    let sql = 'SELECT * FROM sessions';\n    const params: any[] = [];\n    const conditions: string[] = [];\n\n    if (filter) {\n      if (filter.status) {\n        conditions.push('status = ?');\n        params.push(filter.status);\n      }\n\n      if (filter.namePattern) {\n        conditions.push('name LIKE ?');\n        params.push(`%${filter.namePattern}%`);\n      }\n\n      if (filter.createdAfter) {\n        conditions.push('created_at >= ?');\n        params.push(filter.createdAfter.toISOString());\n      }\n\n      if (filter.createdBefore) {\n        conditions.push('created_at <= ?');\n        params.push(filter.createdBefore.toISOString());\n      }\n    }\n\n    if (conditions.length > 0) {\n      sql += ` WHERE ${conditions.join(' AND ')}`;\n    }\n\n    sql += ' ORDER BY last_accessed_at DESC';\n\n    const dao = await this.getDao();\n    const sessions = await dao.query(sql, params);\n\n    return sessions.map(\n      (sessionData: any): SessionState => ({\n        id: sessionData?.id,\n        name: sessionData?.name,\n        createdAt: new Date(sessionData?.created_at),\n        lastAccessedAt: new Date(sessionData?.last_accessed_at),\n        ...(sessionData?.last_checkpoint_at && {\n          lastCheckpointAt: new Date(sessionData?.last_checkpoint_at),\n        }),\n        status: sessionData?.status as SessionStatus,\n        swarmState: this.deserializeData(sessionData?.swarm_state),\n        swarmOptions: this.deserializeData(sessionData?.swarm_options),\n        metadata: this.deserializeData(sessionData?.metadata),\n        checkpoints: [], // Load on demand\n        version: sessionData?.version,\n      })\n    );\n  }\n\n  /**\n   * Get session statistics.\n   *\n   * @param sessionId\n   */\n  async getSessionStats(sessionId?: string): Promise<Record<string, any>> {\n    await this.ensureInitialized();\n\n    if (sessionId) {\n      // Stats for specific session\n      const session = await this.loadSession(sessionId);\n      return {\n        sessionId,\n        name: session.name,\n        status: session.status,\n        createdAt: session.createdAt,\n        lastAccessedAt: session.lastAccessedAt,\n        lastCheckpointAt: session.lastCheckpointAt,\n        totalAgents: session.swarmState.agents.size,\n        totalTasks: session.swarmState.tasks.size,\n        completedTasks: session.swarmState.metrics.completedTasks,\n        failedTasks: session.swarmState.metrics.failedTasks,\n        checkpointCount: session.checkpoints.length,\n        version: session.version,\n      };\n    } else {\n      // Global stats\n      const dao = await this.getDao();\n      const stats = await dao.query(`\n        SELECT \n          status,\n          COUNT(*) as count,\n          AVG(julianday('now') - julianday(last_accessed_at)) as avg_days_since_access\n        FROM sessions \n        GROUP BY status\n      `);\n\n      const totalSessions = await dao.query('SELECT COUNT(*) as total FROM sessions');\n      const totalCheckpoints = await dao.query('SELECT COUNT(*) as total FROM session_checkpoints');\n\n      return {\n        totalSessions: totalSessions[0]?.total,\n        totalCheckpoints: totalCheckpoints[0]?.total,\n        activeSessions: this.activeSessions.size,\n        statusBreakdown: stats.reduce((acc: any, stat: any) => {\n          acc[stat.status] = {\n            count: stat.count,\n            avgDaysSinceAccess: stat.avg_days_since_access,\n          };\n          return acc;\n        }, {}),\n      };\n    }\n  }\n\n  /**\n   * Private helper methods.\n   */\n\n  private async initializeSessionTables(): Promise<void> {\n    const dao = await this.getDao();\n    // Create sessions table\n    await dao.execute(`\n      CREATE TABLE IF NOT EXISTS sessions (\n        id TEXT PRIMARY KEY,\n        name TEXT NOT NULL,\n        status TEXT NOT NULL DEFAULT 'active',\n        swarm_options TEXT NOT NULL,\n        swarm_state TEXT NOT NULL,\n        metadata TEXT DEFAULT '{}',\n        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n        last_accessed_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n        last_checkpoint_at DATETIME,\n        version TEXT DEFAULT '1.0.0'\n      )\n    `);\n\n    // Create checkpoints table\n    await dao.execute(`\n      CREATE TABLE IF NOT EXISTS session_checkpoints (\n        id TEXT PRIMARY KEY,\n        session_id TEXT NOT NULL,\n        timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,\n        checksum TEXT NOT NULL,\n        state_data TEXT NOT NULL,\n        description TEXT DEFAULT '',\n        metadata TEXT DEFAULT '{}',\n        FOREIGN KEY (session_id) REFERENCES sessions(id) ON DELETE CASCADE\n      )\n    `);\n\n    // Create indexes\n    await dao.execute('CREATE INDEX IF NOT EXISTS idx_sessions_status ON sessions(status)');\n    await dao.execute(\n      'CREATE INDEX IF NOT EXISTS idx_sessions_last_accessed ON sessions(last_accessed_at)'\n    );\n    await dao.execute(\n      'CREATE INDEX IF NOT EXISTS idx_checkpoints_session ON session_checkpoints(session_id)'\n    );\n    await dao.execute(\n      'CREATE INDEX IF NOT EXISTS idx_checkpoints_timestamp ON session_checkpoints(timestamp)'\n    );\n  }\n\n  private async restoreActiveSessions(): Promise<void> {\n    const dao = await this.getDao();\n    const activeSessions = await dao.query(\n      \"SELECT * FROM sessions WHERE status IN ('active', 'paused')\"\n    );\n\n    for (const sessionData of activeSessions) {\n      const sessionState: SessionState = {\n        id: sessionData?.id,\n        name: sessionData?.name,\n        createdAt: new Date(sessionData?.created_at),\n        lastAccessedAt: new Date(sessionData?.last_accessed_at),\n        ...(sessionData?.last_checkpoint_at && {\n          lastCheckpointAt: new Date(sessionData?.last_checkpoint_at),\n        }),\n        status: sessionData?.status as SessionStatus,\n        swarmState: this.deserializeData(sessionData?.swarm_state),\n        swarmOptions: this.deserializeData(sessionData?.swarm_options),\n        metadata: this.deserializeData(sessionData?.metadata),\n        checkpoints: await this.loadSessionCheckpoints(sessionData?.id),\n        version: sessionData?.version,\n      } satisfies SessionState;\n\n      this.activeSessions.set(sessionState.id, sessionState);\n\n      // Start auto-checkpoint for active sessions\n      if (this.config.autoCheckpoint && sessionState.status === 'active') {\n        this.startAutoCheckpoint(sessionState.id);\n      }\n    }\n  }\n\n  private async loadSessionCheckpoints(sessionId: string): Promise<SessionCheckpoint[]> {\n    const dao = await this.getDao();\n    const checkpoints = await dao.query(\n      'SELECT * FROM session_checkpoints WHERE session_id = ? ORDER BY timestamp DESC LIMIT ?',\n      [sessionId, this.config.maxCheckpoints]\n    );\n\n    return checkpoints.map((cp: any) => ({\n      id: cp.id,\n      sessionId: cp.session_id,\n      timestamp: new Date(cp.timestamp),\n      checksum: cp.checksum,\n      state: this.deserializeData(cp.state_data),\n      description: cp.description,\n      metadata: this.deserializeData(cp.metadata),\n    }));\n  }\n\n  private async updateSessionAccess(sessionId: string): Promise<void> {\n    const dao = await this.getDao();\n    await dao.execute('UPDATE sessions SET last_accessed_at = ? WHERE id = ?', [\n      new Date().toISOString(),\n      sessionId,\n    ]);\n  }\n\n  private async deleteCheckpoint(checkpointId: string): Promise<void> {\n    const dao = await this.getDao();\n    await dao.execute('DELETE FROM session_checkpoints WHERE id = ?', [checkpointId]);\n  }\n\n  private startAutoCheckpoint(sessionId: string): void {\n    if (this.checkpointTimers.has(sessionId)) {\n      return; // Already running\n    }\n\n    const timer = setInterval(async () => {\n      try {\n        await this.createCheckpoint(sessionId, 'Auto checkpoint');\n      } catch (error) {\n        this.emit('checkpoint:error', {\n          sessionId,\n          error: error instanceof Error ? error.message : String(error),\n        });\n      }\n    }, this.config.checkpointInterval);\n\n    this.checkpointTimers.set(sessionId, timer);\n  }\n\n  private stopAutoCheckpoint(sessionId: string): void {\n    const timer = this.checkpointTimers.get(sessionId);\n    if (timer) {\n      clearInterval(timer);\n      this.checkpointTimers.delete(sessionId);\n    }\n  }\n\n  private serializeData(data: any): string {\n    if (this.config.compressionEnabled) {\n      // In a real implementation, you'd use a compression library\n      return JSON.stringify(data);\n    }\n    return JSON.stringify(data);\n  }\n\n  private deserializeData(serializedData: string): any {\n    return JSON.parse(serializedData);\n  }\n\n  private calculateChecksum(data: string): string {\n    return crypto.createHash('sha256').update(data).digest('hex');\n  }\n\n  private generateEncryptionKey(): string {\n    return crypto.randomBytes(32).toString('hex');\n  }\n\n  /**\n   * Cleanup and shutdown.\n   */\n  async shutdown(): Promise<void> {\n    // Stop all auto-checkpoint timers\n    for (const [_sessionId, timer] of this.checkpointTimers) {\n      clearInterval(timer);\n    }\n    this.checkpointTimers.clear();\n\n    // Create final checkpoints for active sessions\n    for (const [sessionId, session] of this.activeSessions) {\n      if (session.status === 'active') {\n        try {\n          await this.createCheckpoint(sessionId, 'Shutdown checkpoint');\n        } catch (error) {\n          logger.error(`Failed to create shutdown checkpoint for session ${sessionId}:`, error);\n        }\n      }\n    }\n\n    this.activeSessions.clear();\n    this.initialized = false;\n    this.emit('manager:shutdown');\n  }\n}\n\nexport default SessionManager;\n", "/**\n * Database Domain - Main Export Module\n *\n * @file Central export point for all database functionality including types,\n * entities, managers, and API controllers. This module serves as the single source\n * of truth for all database operations and type definitions.\n *\n * Following domain architecture standard with consolidated types.\n */\n\n// Export all database types (Single Source of Truth)\nexport * from './types.ts';\n\n/**\n * @deprecated Legacy export structure - use domain types instead\n * @example Legacy Usage\n * ```typescript\n * import { createDao, EntityTypes, DatabaseTypes } from './database';\n *\n * // Create a PostgreSQL DAO for user entities\n * const userDao = await createDao<User>(\n *   EntityTypes.User,\n *   DatabaseTypes.PostgreSQL,\n *   {\n *     host: 'localhost',\n *     port: 5432,\n *     database: 'myapp',\n *     username: 'user',\n *     password: 'pass'\n *   }\n * );\n *\n * const users = await userDao.findAll();\n * ```\n * @example Multi-Database Setup\n * ```typescript\n * import { createMultiDatabaseSetup, EntityTypes } from './database';\n *\n * // Primary database (PostgreSQL) with Redis cache fallback\n * const multiDao = await createMultiDatabaseSetup<User>(\n *   EntityTypes.User,\n *   { databaseType: 'postgresql', config: pgConfig },\n *   [{ databaseType: 'memory', config: cacheConfig }]\n * );\n *\n * // Writes go to primary, reads can fallback to cache\n * const user = await multiDao.findById('user-123');\n * ```\n */\n\n// Base implementations\nexport { BaseDao, BaseManager } from './base.dao.ts';\nexport { CoordinationDao } from './dao/coordination.dao.ts';\nexport { GraphDao } from './dao/graph.dao.ts';\nexport { MemoryDao } from './dao/memory.dao.ts';\n// DAO implementations\nexport { RelationalDao } from './dao/relational.dao.ts';\nexport { VectorDao } from './dao/vector.dao.ts';\n// Factory and configuration\nexport {\n  DALFactory,\n  // TODO: TypeScript error TS2614 - DaoConfig not exported from factory (AI unsure of safe fix - human review needed)\n  // type DaoConfig,\n  // TODO: TypeScript error TS2614 - DaoType not exported from factory (AI unsure of safe fix - human review needed)\n  // type DaoType,\n  type EntityTypeRegistry,\n  MultiDatabaseDAO,\n} from './factory.ts';\n\n// Import interfaces for use in functions below\nimport type { IDao, IManager } from './interfaces.ts';\n\n// Core interfaces\nexport type {\n  AgentMemoryCoordinationDao,\n  CheckpointCoordinationDao,\n  CheckpointEntity,\n  ClusteringOptions,\n  ClusterResult,\n  CoordinationChange,\n  CoordinationEvent,\n  // Coordination types\n  CoordinationLock,\n  CoordinationStats,\n  CustomQuery,\n  DatabaseMetadata,\n  DatabaseQuery,\n  EventCoordinationDao,\n  GenericCoordinationDao,\n  // Graph database types\n  GraphNode,\n  GraphPath,\n  GraphQueryResult,\n  GraphRelationship,\n  GraphTraversalResult,\n  HealthStatus,\n  IAgentMemoryDao,\n  ICoordinationDao,\n  IDao,\n  IGraphDao,\n  IManager,\n  IMemoryDao,\n  IVectorDao,\n  // Memory store types\n  MemoryStats,\n  PerformanceMetrics,\n  QueryOptions,\n  SessionCoordinationDao,\n  SessionEntity,\n  SortCriteria,\n  TransactionOperation,\n  // Vector database types\n  VectorDocument,\n  VectorIndexConfig,\n  VectorInsertResult,\n  VectorSearchOptions,\n  VectorSearchResult,\n  VectorStats,\n} from './interfaces.ts';\n\n// Export enums from interfaces\nexport {\n  DatabaseTypes as DatabaseTypesEnum,\n  EntityTypes as EntityTypesEnum,\n} from './interfaces.ts';\n// Manager implementations\nexport { DocumentManager } from './managers/document-manager.ts';\n\n// Re-export database provider types for convenience\nexport type {\n  DatabaseAdapter,\n  DatabaseConfig,\n  GraphDatabaseAdapter,\n  GraphResult,\n  IndexConfig,\n  VectorData,\n  VectorDatabaseAdapter,\n  VectorResult,\n} from './providers/database-providers.ts';\n\n/**\n * Convenience functions for quick DAL setup.\n */\n\n/**\n * Create a Data Access Object (DAO) for a specific entity type and database.\n *\n * This function creates a fully configured DAO instance with database connection,\n * entity mapping, and CRUD operations. It handles dependency injection setup\n * automatically and provides a clean interface for database operations.\n *\n * @template T The entity type this DAO will manage.\n * @param {string} entityType - The name of the entity type (e.g., 'User', 'Product').\n * @param {('postgresql'|'sqlite'|'kuzu'|'lancedb'|'mysql'|'memory'|'coordination')} databaseType - Database type to use.\n * @param {any} [config] - Optional database configuration object.\n * @returns {Promise<IDao<T>>} A Promise that resolves to a configured DAO instance.\n * @throws {Error} When database configuration is invalid.\n * @throws {Error} When database connection fails.\n * @throws {Error} When dependency injection setup fails.\n * @example PostgreSQL DAO with Connection Pool\n * ```typescript\n * const userDao = await createDao<User>('User', 'postgresql', {\n *   host: 'localhost',\n *   port: 5432,\n *   database: 'production',\n *   username: 'app_user',\n *   password: 'secure_password',\n *   pool: { min: 2, max: 20, timeout: 30000 }\n * });\n *\n * // Use the DAO for database operations\n * const newUser = await userDao.create({ name: 'John', email: 'john@example.com' });\n * const users = await userDao.findAll({ limit: 10 });\n * ```\n * @example LanceDB Vector DAO\n * ```typescript\n * const vectorDao = await createDao<VectorDocument>('VectorDocument', 'lancedb', {\n *   database: './vectors/embeddings.lance',\n *   options: {\n *     vectorSize: 1536, // OpenAI embedding dimension\n *     metricType: 'cosine',\n *     indexType: 'IVF_PQ'\n *   }\n * });\n *\n * // Vector similarity search\n * const similar = await vectorDao.vectorSearch([0.1, 0.2, ...], 10);\n * ```\n * @example Memory DAO for Caching\n * ```typescript\n * const cacheDao = await createDao<CacheItem>('CacheItem', 'memory', {\n *   database: ':memory:', // In-memory SQLite\n *   options: { maxSize: 1000, ttlDefault: 3600 }\n * });\n * ```\n */\n// Re-export from dao-factory to break circular dependency\nexport { createDao } from './core/dao-factory.ts';\n\n/**\n * Create a Manager instance for high-level entity operations.\n *\n * Managers provide business logic layer above DAOs, offering complex operations,\n * data validation, caching, and cross-entity relationships. They're ideal for\n * application service layers that need more than basic CRUD operations.\n *\n * @template T The entity type this manager will handle.\n * @param {string} entityType - The name of the entity type.\n * @param {('postgresql'|'sqlite'|'kuzu'|'lancedb'|'mysql'|'memory'|'coordination')} databaseType - Database type to use.\n * @param {any} [config] - Optional database configuration.\n * @returns {Promise<IManager<T>>} A Promise that resolves to a configured Manager instance.\n * @throws {Error} When manager creation fails.\n * @throws {Error} When underlying DAO creation fails.\n * @throws {Error} When business logic validation fails.\n * @example Document Manager with Validation\n * ```typescript\n * const docManager = await createManager<Document>('Document', 'postgresql', dbConfig);\n *\n * // Manager handles validation, indexing, and relationships\n * const doc = await docManager.createDocument({\n *   title: 'Important Doc',\n *   content: 'Document content...',\n *   tags: ['important', 'business']\n * });\n *\n * // Manager can handle complex queries\n * const relatedDocs = await docManager.findRelatedDocuments(doc.id, {\n *   similarity: 0.8,\n *   maxResults: 5\n * });\n * ```\n * @example User Manager with Authentication\n * ```typescript\n * const userManager = await createManager<User>('User', 'postgresql', {\n *   host: 'localhost',\n *   database: 'auth_db'\n * });\n *\n * // Manager handles password hashing, validation\n * const user = await userManager.registerUser({\n *   email: 'user@example.com',\n *   password: 'plaintext', // Will be hashed\n *   profile: { name: 'John Doe' }\n * });\n * ```\n */\nexport async function createManager<T>(\n  entityType: string,\n  databaseType: 'postgresql' | 'sqlite' | 'kuzu' | 'lancedb' | 'mysql' | 'memory' | 'coordination',\n  config?: any\n): Promise<IManager<T>> {\n  const { DALFactory } = await import('./factory.ts');\n  const { DIContainer } = await import('../di/container/di-container.ts');\n  const { CORE_TOKENS } = await import('../di/tokens/core-tokens.ts');\n\n  const container = new DIContainer();\n\n  // TODO: TypeScript error TS2345 - Logger provider type mismatch (AI unsure of safe fix - human review needed)\n  container.register(CORE_TOKENS.Logger, (() => ({\n    debug: console.debug,\n    info: console.info,\n    warn: console.warn,\n    error: console.error,\n  })) as any);\n\n  // TODO: TypeScript error TS2345 - Config provider type mismatch (AI unsure of safe fix - human review needed)\n  container.register(CORE_TOKENS.Config, (() => ({})) as any);\n\n  // TODO: TypeScript error TS2345/TS18046 - DALFactory DI token type mismatch (AI unsure of safe fix - human review needed)\n  const factory = container.resolve(DALFactory as any);\n\n  return await (factory).createManager({\n    databaseType,\n    entityType,\n    databaseConfig: config || getDefaultConfig(databaseType),\n  });\n}\n\n/**\n * Create a multi-database DAO setup with primary and secondary databases.\n *\n * This function creates a sophisticated multi-database architecture with a primary database.\n * For writes and optional secondary databases for reads, caching, or replication.\n * The primary database handles all write operations, while reads can be distributed.\n * Across secondaries for performance and reliability..\n *\n * @template T The entity type for the multi-database setup.\n * @param {string} entityType - The entity type name.\n * @param {Object} primaryConfig - Primary database configuration.\n * @param {('postgresql'|'sqlite'|'kuzu'|'lancedb'|'mysql'|'memory'|'coordination')} primaryConfig.databaseType - Primary database type.\n * @param {any} [primaryConfig.config] - Primary database connection config.\n * @param {Array} [secondaryConfigs] - Optional array of secondary database configurations.\n * @returns {Promise<MultiDatabaseDAO<T>>} A Promise that resolves to a multi-database DAO.\n * @throws {Error} When primary database configuration is invalid.\n * @throws {Error} When any secondary database setup fails.\n * @throws {Error} When DAL factory initialization fails\n * @example Primary PostgreSQL with Redis Cache\n * ```typescript\n * const multiDao = await createMultiDatabaseSetup<User>(\n *   'User',\n *   {\n *     databaseType: 'postgresql',\n *     config: {\n *       host: 'db.example.com',\n *       database: 'production',\n *       pool: { min: 5, max: 50 }\n *     }\n *   },\n *   [\n *     {\n *       databaseType: 'memory',\n *       config: {\n *         database: ':memory:',\n *         options: { maxSize: 10000, ttl: 3600 }\n *       }\n *     }\n *   ]\n * );\n *\n * // Writes go to primary PostgreSQL\n * const user = await multiDao.create({ name: 'Alice' });\n *\n * // Reads can fallback to memory cache\n * const cachedUser = await multiDao.findById(user.id);\n * ```\n * @example Vector Primary with Graph Secondary\n * ```typescript\n * const multiDao = await createMultiDatabaseSetup<Document>(\n *   'Document',\n *   {\n *     databaseType: 'lancedb', // Vector search primary\n *     config: { database: './vectors.lance', vectorSize: 1536 }\n *   },\n *   [\n *     {\n *       databaseType: 'kuzu', // Graph relationships secondary\n *       config: { database: './graph.kuzu' }\n *     }\n *   ]\n * );\n *\n * // Vector operations on primary\n * const similar = await multiDao.vectorSearch(queryVector, 10);\n *\n * // Graph traversal on secondary\n * const metadata = await multiDao.getMetadata();\n * const graphData = metadata.secondaries[0];\n * ```\n */\nexport async function createMultiDatabaseSetup<T>(\n  entityType: string,\n  primaryConfig: {\n    databaseType:\n      | 'postgresql'\n      | 'sqlite'\n      | 'kuzu'\n      | 'lancedb'\n      | 'mysql'\n      | 'memory'\n      | 'coordination';\n    config?: any;\n  },\n  secondaryConfigs?: Array<{\n    databaseType:\n      | 'postgresql'\n      | 'sqlite'\n      | 'kuzu'\n      | 'lancedb'\n      | 'mysql'\n      | 'memory'\n      | 'coordination';\n    config?: any;\n  }>\n): Promise<import('./factory.ts').MultiDatabaseDAO<T>> {\n  const { DALFactory } = await import('./factory.ts');\n  const { DIContainer } = await import('../di/container/di-container.ts');\n  const { CORE_TOKENS } = await import('../di/tokens/core-tokens.ts');\n\n  const container = new DIContainer();\n\n  // TODO: TypeScript error TS2345 - Logger provider type mismatch (AI unsure of safe fix - human review needed)\n  container.register(CORE_TOKENS.Logger, (() => ({\n    debug: console.debug,\n    info: console.info,\n    warn: console.warn,\n    error: console.error,\n  })) as any);\n\n  // TODO: TypeScript error TS2345 - Config provider type mismatch (AI unsure of safe fix - human review needed)\n  container.register(CORE_TOKENS.Config, (() => ({})) as any);\n\n  // TODO: TypeScript error TS2345/TS18046 - DALFactory DI token type mismatch (AI unsure of safe fix - human review needed)\n  const factory = container.resolve(DALFactory as any);\n\n  const primaryDaoConfig = {\n    databaseType: primaryConfig?.databaseType,\n    entityType,\n    databaseConfig: primaryConfig?.config || getDefaultConfig(primaryConfig?.databaseType),\n  };\n\n  const secondaryDaoConfigs = secondaryConfigs?.map((sc) => ({\n    databaseType: sc.databaseType,\n    entityType,\n    databaseConfig: sc.config || getDefaultConfig(sc.databaseType),\n  }));\n\n  return await (factory).createMultiDatabaseDAO(\n    entityType,\n    primaryDaoConfig,\n    secondaryDaoConfigs\n  );\n}\n\n/**\n * Get default database configuration for a given database type.\n *\n * This function provides sensible defaults for different database types,\n * including connection parameters, pool settings, and database-specific options.\n * These defaults are suitable for development and can be overridden for production.\n *\n * @param {string} databaseType - The database type to get defaults for.\n * @returns {any} Default configuration object for the specified database type.\n * @throws {Error} When an unknown database type is specified.\n * @example Getting PostgreSQL Defaults\n * ```typescript\n * const pgDefaults = getDefaultConfig('postgresql');\n * console.log(pgDefaults);\n * // Output: {\n * //   type: 'postgresql',\n * //   host: 'localhost',\n * //   port: 5432,\n * //   database: 'claudezen',\n * //   pool: { min: 2, max: 10 }\n * // }\n * ```\n * @example Vector Database Defaults\n * ```typescript\n * const lanceDefaults = getDefaultConfig('lancedb');\n * console.log(lanceDefaults.options);\n * // Output: {\n * //   vectorSize: 384,\n * //   metricType: 'cosine',\n * //   indexType: 'IVF_PQ'\n * // }\n * ```\n */\nfunction getDefaultConfig(databaseType: string): any {\n  switch (databaseType) {\n    case 'postgresql':\n      return {\n        type: 'postgresql',\n        host: 'localhost',\n        port: 5432,\n        database: 'claudezen',\n        username: 'user',\n        password: 'password',\n        pool: { min: 2, max: 10 },\n      };\n\n    case 'sqlite':\n      return {\n        type: 'sqlite',\n        database: './data/claudezen.db',\n      };\n\n    case 'kuzu':\n      return {\n        type: 'kuzu',\n        database: './data/graph.kuzu',\n        options: {\n          bufferPoolSize: '1GB',\n          maxNumThreads: 4,\n        },\n      };\n\n    case 'lancedb':\n      return {\n        type: 'lancedb',\n        database: './data/vectors.lance',\n        options: {\n          vectorSize: 384,\n          metricType: 'cosine',\n          indexType: 'IVF_PQ',\n        },\n      };\n\n    case 'mysql':\n      return {\n        type: 'mysql',\n        host: 'localhost',\n        port: 3306,\n        database: 'claudezen',\n        username: 'user',\n        password: 'password',\n        pool: { min: 2, max: 10 },\n      };\n\n    case 'memory':\n      return {\n        type: 'sqlite', // Use SQLite as backing store for memory repository\n        database: ':memory:',\n      };\n\n    case 'coordination':\n      return {\n        type: 'sqlite', // Use SQLite for coordination by default\n        database: './data/coordination.db',\n      };\n\n    default:\n      throw new Error(`Unknown database type: ${databaseType}`);\n  }\n}\n\n/**\n * Predefined Entity Type Constants.\n *\n * This object provides a centralized registry of common entity types used throughout.\n * The Claude-Zen system. Using these constants ensures consistency and prevents\n * typos when creating DAOs and managers..\n *\n * @readonly\n * @constant\n * @example Using Entity Types\n * ```typescript\n * import { createDao, EntityTypes, DatabaseTypes } from './database';\n *\n * // Type-safe entity creation\n * const agentDao = await createDao<SwarmAgent>(\n *   EntityTypes.SwarmAgent, // Instead of 'SwarmAgent' string\n *   DatabaseTypes.Coordination\n * );\n *\n * const vectorDao = await createDao<VectorDocument>(\n *   EntityTypes.VectorDocument,\n *   DatabaseTypes.LanceDB\n * );\n * ```\n * @example Entity Type Categories\n * ```typescript\n * // Swarm coordination entities\n * console.log('Swarm entities:', {\n *   agents: EntityTypes.SwarmAgent,\n *   tasks: EntityTypes.SwarmTask,\n *   executions: EntityTypes.SwarmExecution\n * });\n *\n * // Memory management entities\n * console.log('Memory entities:', {\n *   entries: EntityTypes.MemoryEntry,\n *   cache: EntityTypes.CacheItem,\n *   sessions: EntityTypes.SessionData\n * });\n * ```\n */\n// Re-export EntityTypes from dao-factory to break circular dependency\nexport { EntityTypeValues as EntityTypes } from './core/dao-factory.ts';\n\n/**\n * Supported Database Type Constants.\n *\n * This object provides constants for all supported database types in the DAL.\n * Using these constants prevents typos and provides better IDE support with.\n * Autocomplete and type checking..\n *\n * @readonly\n * @constant\n * @example Database Type Usage\n * ```typescript\n * import { createDao, EntityTypes, DatabaseTypes } from './database';\n *\n * // Relational databases\n * const userDao = await createDao(\n *   EntityTypes.User,\n *   DatabaseTypes.PostgreSQL // Instead of 'postgresql'\n * );\n *\n * // Specialized databases\n * const vectorDao = await createDao(\n *   EntityTypes.VectorDocument,\n *   DatabaseTypes.LanceDB // Vector similarity search\n * );\n *\n * const graphDao = await createDao(\n *   EntityTypes.GraphNode,\n *   DatabaseTypes.Kuzu // Graph traversal queries\n * );\n * ```\n * @example Database Capabilities\n * ```typescript\n * // Check database capabilities\n * const dbType = DatabaseTypes.LanceDB;\n * console.log('Database type:', dbType); // 'lancedb'\n *\n * // Use in switch statements\n * switch(selectedDb) {\n *   case DatabaseTypes.PostgreSQL:\n *     // Handle relational operations\n *     break;\n *   case DatabaseTypes.LanceDB:\n *     // Handle vector operations\n *     break;\n * }\n * ```\n */\nexport const DatabaseTypes = {\n  PostgreSQL: 'postgresql',\n  SQLite: 'sqlite',\n  MySQL: 'mysql',\n  Kuzu: 'kuzu',\n  LanceDB: 'lancedb',\n  Memory: 'memory',\n  Coordination: 'coordination',\n} as const;\n\n/**\n * Quick Setup Patterns for Common Use Cases.\n *\n * This object provides pre-configured factory methods for common application patterns,\n * eliminating boilerplate code and providing battle-tested configurations for typical.\n * Scenarios in AI applications, distributed systems, and data processing..\n *\n * @namespace QuickSetup\n * @readonly\n * @example Swarm Coordination Setup\n * ```typescript\n * import { QuickSetup } from './database';\n *\n * // Get complete swarm infrastructure\n * const swarmDbs = await QuickSetup.swarmCoordination();\n *\n * // Use individual components\n * const agent = await swarmDbs.agents.create({\n *   name: 'Worker-1',\n *   type: 'processor',\n *   status: 'active'\n * });\n *\n * const task = await swarmDbs.tasks.create({\n *   agentId: agent.id,\n *   payload: { action: 'process_document', docId: 'doc-123' }\n * });\n *\n * // Vector search for similar tasks\n * const similar = await swarmDbs.vectors.vectorSearch(taskEmbedding, 5);\n * ```\n * @example AI/ML Data Pipeline\n * ```typescript\n * const aiDbs = await QuickSetup.aimlData();\n *\n * // Store document in relational DB\n * const doc = await aiDbs.documents.create({\n *   title: 'Research Paper',\n *   content: 'AI research content...'\n * });\n *\n * // Store embeddings in vector DB\n * await aiDbs.embeddings.create({\n *   id: doc.id,\n *   vector: documentEmbedding,\n *   metadata: { type: 'document', source: 'research' }\n * });\n *\n * // Create knowledge graph relationships\n * await aiDbs.relationships.createNode({\n *   id: doc.id,\n *   labels: ['Document', 'Research'],\n *   properties: { title: doc.title }\n * });\n * ```\n */\nexport const QuickSetup = {\n  /**\n   * Create a typical swarm coordination setup.\n   */\n  async swarmCoordination() {\n    const { createDao: createDaoFn } = await import('./core/dao-factory.ts');\n    return {\n      agents: await createDaoFn<any>(\n        'agent',\n        'coordination' as any,\n        getDefaultConfig('coordination')\n      ),\n      tasks: await createDaoFn<any>(\n        'task',\n        'coordination' as any,\n        getDefaultConfig('coordination')\n      ),\n      executions: await createDaoFn<any>(\n        'coordination',\n        'coordination' as any,\n        getDefaultConfig('coordination')\n      ),\n      memory: await createDaoFn<any>('memory', 'memory' as any, getDefaultConfig('memory')),\n      vectors: await createDaoFn<any>('vector', 'lancedb' as any, getDefaultConfig('lancedb')),\n    };\n  },\n\n  /**\n   * Create a typical AI/ML data setup.\n   */\n  async aimlData() {\n    const { createDao: createDaoFn } = await import('./core/dao-factory.ts');\n    return {\n      documents: await createDaoFn<any>(\n        'document',\n        'postgresql' as any,\n        getDefaultConfig('postgresql')\n      ),\n      embeddings: await createDaoFn<any>('vector', 'lancedb' as any, getDefaultConfig('lancedb')),\n      relationships: await createDaoFn<any>('node', 'kuzu' as any, getDefaultConfig('kuzu')),\n      cache: await createDaoFn<any>('memory', 'memory' as any, getDefaultConfig('memory')),\n    };\n  },\n\n  /**\n   * Create a distributed application setup.\n   */\n  async distributedApp() {\n    const primaryDB = await createManager('User', 'postgresql');\n    const cacheDB = await createManager('User', 'memory');\n    const coordinationDB = await createManager('DistributedLock', 'coordination');\n\n    return {\n      primary: primaryDB,\n      cache: cacheDB,\n      coordination: coordinationDB,\n    };\n  },\n};\n\n// Default export is the factory\nexport { DALFactory as default } from './factory.ts';\n", "/**\n * @file Coordination system: session-utils.\n */\n\nimport { getLogger } from '../../../config/logging-config.ts';\n\nconst logger = getLogger('coordination-swarm-core-session-utils');\n\n/**\n * Session Management Utilities.\n *\n * Helper functions and utilities for session management,\n * including serialization, validation, migration, and recovery.\n */\n\nimport crypto from 'node:crypto';\nimport type { SessionCheckpoint, SessionState, SessionStatus } from './session-manager.ts';\nimport type { SwarmOptions, SwarmState } from './types.ts';\n\n/**\n * Session validation utilities.\n *\n * @example\n */\nexport class SessionValidator {\n  /**\n   * Validate session state integrity.\n   *\n   * @param state\n   */\n  static validateSessionState(state: SessionState): { valid: boolean; errors: string[] } {\n    const errors: string[] = [];\n\n    // Basic structure validation\n    if (!state.id || typeof state.id !== 'string') {\n      errors.push('Invalid session ID');\n    }\n\n    if (!state.name || typeof state.name !== 'string') {\n      errors.push('Invalid session name');\n    }\n\n    if (!state.createdAt || !(state.createdAt instanceof Date)) {\n      errors.push('Invalid created date');\n    }\n\n    if (!state.lastAccessedAt || !(state.lastAccessedAt instanceof Date)) {\n      errors.push('Invalid last accessed date');\n    }\n\n    // Status validation\n    const validStatuses: SessionStatus[] = [\n      'active',\n      'paused',\n      'hibernated',\n      'terminated',\n      'corrupted',\n    ];\n    if (!validStatuses.includes(state.status)) {\n      errors.push(`Invalid session status: ${state.status}`);\n    }\n\n    // Swarm state validation\n    if (!state.swarmState) {\n      errors.push('Missing swarm state');\n    } else {\n      const swarmErrors = SessionValidator.validateSwarmState(state.swarmState);\n      errors.push(...swarmErrors);\n    }\n\n    // Swarm options validation\n    if (!state.swarmOptions) {\n      errors.push('Missing swarm options');\n    } else {\n      const optionsErrors = SessionValidator.validateSwarmOptions(state.swarmOptions);\n      errors.push(...optionsErrors);\n    }\n\n    return {\n      valid: errors.length === 0,\n      errors,\n    };\n  }\n\n  /**\n   * Validate swarm state structure.\n   *\n   * @param state\n   */\n  static validateSwarmState(state: SwarmState): string[] {\n    const errors: string[] = [];\n\n    if (!state.agents || !(state.agents instanceof Map)) {\n      errors.push('Invalid agents map');\n    }\n\n    if (!state.tasks || !(state.tasks instanceof Map)) {\n      errors.push('Invalid tasks map');\n    }\n\n    if (!state.topology || typeof state.topology !== 'string') {\n      errors.push('Invalid topology');\n    }\n\n    if (!Array.isArray(state.connections)) {\n      errors.push('Invalid connections array');\n    }\n\n    if (!state.metrics || typeof state.metrics !== 'object') {\n      errors.push('Invalid metrics object');\n    }\n\n    return errors;\n  }\n\n  /**\n   * Validate swarm options.\n   *\n   * @param options\n   */\n  static validateSwarmOptions(options: SwarmOptions): string[] {\n    const errors: string[] = [];\n\n    if (\n      options?.maxAgents !== undefined &&\n      (typeof options?.maxAgents !== 'number' || options?.maxAgents <= 0)\n    ) {\n      errors.push('Invalid maxAgents value');\n    }\n\n    if (\n      options?.connectionDensity !== undefined &&\n      (typeof options?.connectionDensity !== 'number' ||\n        options?.connectionDensity < 0 ||\n        options?.connectionDensity > 1)\n    ) {\n      errors.push('Invalid connectionDensity value');\n    }\n\n    if (\n      options?.syncInterval !== undefined &&\n      (typeof options?.syncInterval !== 'number' || options?.syncInterval <= 0)\n    ) {\n      errors.push('Invalid syncInterval value');\n    }\n\n    return errors;\n  }\n\n  /**\n   * Validate checkpoint integrity.\n   *\n   * @param checkpoint\n   */\n  static validateCheckpoint(checkpoint: SessionCheckpoint): { valid: boolean; errors: string[] } {\n    const errors: string[] = [];\n\n    if (!checkpoint.id || typeof checkpoint.id !== 'string') {\n      errors.push('Invalid checkpoint ID');\n    }\n\n    if (!checkpoint.sessionId || typeof checkpoint.sessionId !== 'string') {\n      errors.push('Invalid session ID');\n    }\n\n    if (!checkpoint.timestamp || !(checkpoint.timestamp instanceof Date)) {\n      errors.push('Invalid timestamp');\n    }\n\n    if (!checkpoint.checksum || typeof checkpoint.checksum !== 'string') {\n      errors.push('Invalid checksum');\n    }\n\n    if (!checkpoint.state) {\n      errors.push('Missing checkpoint state');\n    }\n\n    return {\n      valid: errors.length === 0,\n      errors,\n    };\n  }\n}\n\n/**\n * Session serialization utilities.\n *\n * @example\n */\nexport class SessionSerializer {\n  /**\n   * Serialize a SwarmState to a portable format.\n   *\n   * @param state\n   */\n  static serializeSwarmState(state: SwarmState): string {\n    // Convert Maps to objects for JSON serialization\n    const serializable = {\n      agents: Object.fromEntries(state.agents.entries()),\n      tasks: Object.fromEntries(state.tasks.entries()),\n      topology: state.topology,\n      connections: state.connections,\n      metrics: {\n        ...state.metrics,\n        agentUtilization: Object.fromEntries(state.metrics.agentUtilization.entries()),\n      },\n    };\n\n    return JSON.stringify(serializable, null, 2);\n  }\n\n  /**\n   * Deserialize a SwarmState from portable format.\n   *\n   * @param serialized\n   */\n  static deserializeSwarmState(serialized: string): SwarmState {\n    const data = JSON.parse(serialized);\n\n    return {\n      agents: new Map(Object.entries(data?.agents)),\n      tasks: new Map(Object.entries(data?.tasks)),\n      topology: data?.topology,\n      connections: data?.connections,\n      metrics: {\n        ...data?.metrics,\n        agentUtilization: new Map(Object.entries(data?.metrics?.agentUtilization)),\n      },\n    };\n  }\n\n  /**\n   * Export session to a portable format.\n   *\n   * @param session\n   */\n  static exportSession(session: SessionState): string {\n    const exportData = {\n      id: session.id,\n      name: session.name,\n      createdAt: session.createdAt.toISOString(),\n      lastAccessedAt: session.lastAccessedAt.toISOString(),\n      lastCheckpointAt: session.lastCheckpointAt?.toISOString(),\n      status: session.status,\n      swarmState: SessionSerializer.serializeSwarmState(session.swarmState),\n      swarmOptions: session.swarmOptions,\n      metadata: session.metadata,\n      checkpoints: session.checkpoints.map((cp) => ({\n        id: cp.id,\n        sessionId: cp.sessionId,\n        timestamp: cp.timestamp.toISOString(),\n        checksum: cp.checksum,\n        state: SessionSerializer.serializeSwarmState(cp.state),\n        description: cp.description,\n        metadata: cp.metadata,\n      })),\n      version: session.version,\n      exportedAt: new Date().toISOString(),\n    };\n\n    return JSON.stringify(exportData, null, 2);\n  }\n\n  /**\n   * Import session from portable format.\n   *\n   * @param exported\n   */\n  static importSession(exported: string): SessionState {\n    const data = JSON.parse(exported);\n\n    const sessionState: SessionState = {\n      id: data?.id,\n      name: data?.name,\n      createdAt: new Date(data?.createdAt),\n      lastAccessedAt: new Date(data?.lastAccessedAt),\n      status: data?.status,\n      swarmState: SessionSerializer.deserializeSwarmState(data?.swarmState),\n      swarmOptions: data?.swarmOptions,\n      metadata: data?.metadata || {},\n      checkpoints: data?.checkpoints.map((cp: any) => ({\n        id: cp.id,\n        sessionId: cp.sessionId,\n        timestamp: new Date(cp.timestamp),\n        checksum: cp.checksum,\n        state: SessionSerializer.deserializeSwarmState(cp.state),\n        ...(cp.description && { description: cp.description }),\n        ...(cp.metadata && { metadata: cp.metadata }),\n      })),\n      version: data?.version,\n    };\n\n    // Handle optional lastCheckpointAt property\n    if (data?.lastCheckpointAt) {\n      sessionState.lastCheckpointAt = new Date(data?.lastCheckpointAt);\n    }\n\n    // Handle optional metadata property\n    if (data?.metadata !== undefined) {\n      sessionState.metadata = data?.metadata;\n    }\n\n    return sessionState;\n  }\n}\n\n/**\n * Session migration utilities.\n *\n * @example\n */\nexport class SessionMigrator {\n  /**\n   * Migrate session from older version.\n   *\n   * @param session\n   * @param fromVersion\n   * @param toVersion\n   */\n  static migrateSession(session: any, fromVersion: string, toVersion: string): SessionState {\n    const migrations = SessionMigrator.getMigrationPath(fromVersion, toVersion);\n\n    let currentSession = session;\n    for (const migration of migrations) {\n      currentSession = migration(currentSession);\n    }\n\n    return currentSession;\n  }\n\n  /**\n   * Get migration path between versions.\n   *\n   * @param fromVersion\n   * @param toVersion\n   */\n  private static getMigrationPath(\n    fromVersion: string,\n    toVersion: string\n  ): Array<(session: any) => any> {\n    const migrations: Array<(session: any) => any> = [];\n\n    // Example migrations (add as needed)\n    if (fromVersion === '0.9.0' && toVersion === '1.0.0') {\n      migrations.push(SessionMigrator.migrate_0_9_0_to_1_0_0);\n    }\n\n    return migrations;\n  }\n\n  /**\n   * Example migration from 0.9.0 to 1.0.0.\n   *\n   * @param session\n   */\n  private static migrate_0_9_0_to_1_0_0(session: any): any {\n    // Add version field if missing\n    if (!session.version) {\n      session.version = '1.0.0';\n    }\n\n    // Ensure metadata exists\n    if (!session.metadata) {\n      session.metadata = {};\n    }\n\n    // Migrate old checkpoint format\n    if (session.checkpoints) {\n      session.checkpoints = session.checkpoints.map((cp: any) => {\n        if (!cp.metadata) {\n          cp.metadata = {};\n        }\n        return cp;\n      });\n    }\n\n    return session;\n  }\n\n  /**\n   * Check if migration is needed.\n   *\n   * @param session\n   * @param targetVersion\n   */\n  static needsMigration(session: any, targetVersion: string): boolean {\n    return !session.version || session.version !== targetVersion;\n  }\n}\n\n/**\n * Session recovery utilities.\n *\n * @example\n */\nexport class SessionRecovery {\n  /**\n   * Attempt to recover a corrupted session.\n   *\n   * @param corruptedSession\n   * @param checkpoints\n   */\n  static async recoverSession(\n    corruptedSession: any,\n    checkpoints: SessionCheckpoint[]\n  ): Promise<SessionState | null> {\n    // Try to recover from the most recent valid checkpoint\n    const sortedCheckpoints = checkpoints\n      .filter((cp) => SessionRecovery.validateCheckpointIntegrity(cp))\n      .sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime());\n\n    if (sortedCheckpoints.length === 0) {\n      return null; // No valid checkpoints found\n    }\n\n    const latestCheckpoint = sortedCheckpoints[0]!;\n    // At this point, latestCheckpoint is guaranteed to exist since we checked the array length\n\n    try {\n      // Reconstruct session from checkpoint\n      const recoveredSession: SessionState = {\n        id: corruptedSession.id || latestCheckpoint.sessionId,\n        name: corruptedSession.name || 'Recovered Session',\n        createdAt: corruptedSession.createdAt || new Date(),\n        lastAccessedAt: new Date(),\n        lastCheckpointAt: latestCheckpoint.timestamp,\n        status: 'active',\n        swarmState: latestCheckpoint.state,\n        swarmOptions: corruptedSession.swarmOptions || SessionRecovery.getDefaultSwarmOptions(),\n        metadata: {\n          ...corruptedSession.metadata,\n          recovered: true,\n          recoveredAt: new Date().toISOString(),\n          recoveredFromCheckpoint: latestCheckpoint.id,\n        },\n        checkpoints: sortedCheckpoints,\n        version: corruptedSession.version || '1.0.0',\n      };\n\n      return recoveredSession;\n    } catch (error) {\n      logger.error('Failed to recover session:', error);\n      return null;\n    }\n  }\n\n  /**\n   * Validate checkpoint integrity.\n   *\n   * @param checkpoint\n   */\n  private static validateCheckpointIntegrity(checkpoint: SessionCheckpoint): boolean {\n    try {\n      // Check basic structure\n      if (!checkpoint.id || !checkpoint.sessionId || !checkpoint.state) {\n        return false;\n      }\n\n      // Validate checksum if available\n      if (checkpoint.checksum) {\n        const stateData = JSON.stringify(checkpoint.state);\n        const calculatedChecksum = crypto.createHash('sha256').update(stateData).digest('hex');\n        return calculatedChecksum === checkpoint.checksum;\n      }\n\n      return true;\n    } catch (_error) {\n      return false;\n    }\n  }\n\n  /**\n   * Get default swarm options for recovery.\n   */\n  private static getDefaultSwarmOptions(): SwarmOptions {\n    return {\n      topology: 'mesh',\n      maxAgents: 10,\n      connectionDensity: 0.5,\n      syncInterval: 1000,\n    };\n  }\n\n  /**\n   * Repair session state inconsistencies.\n   *\n   * @param session\n   */\n  static repairSessionState(session: SessionState): SessionState {\n    const repairedSession = { ...session };\n\n    // Ensure Maps are properly initialized\n    if (!(repairedSession.swarmState.agents instanceof Map)) {\n      repairedSession.swarmState.agents = new Map();\n    }\n\n    if (!(repairedSession.swarmState.tasks instanceof Map)) {\n      repairedSession.swarmState.tasks = new Map();\n    }\n\n    if (!(repairedSession.swarmState.metrics.agentUtilization instanceof Map)) {\n      repairedSession.swarmState.metrics.agentUtilization = new Map();\n    }\n\n    // Ensure arrays are properly initialized\n    if (!Array.isArray(repairedSession.swarmState.connections)) {\n      repairedSession.swarmState.connections = [];\n    }\n\n    if (!Array.isArray(repairedSession.checkpoints)) {\n      repairedSession.checkpoints = [];\n    }\n\n    // Ensure required fields have default values\n    if (!repairedSession.metadata) {\n      repairedSession.metadata = {};\n    }\n\n    if (!repairedSession.version) {\n      repairedSession.version = '1.0.0';\n    }\n\n    // Repair metrics if corrupted\n    if (!repairedSession.swarmState.metrics) {\n      repairedSession.swarmState.metrics = {\n        totalTasks: 0,\n        completedTasks: 0,\n        failedTasks: 0,\n        averageCompletionTime: 0,\n        agentUtilization: new Map(),\n        throughput: 0,\n      };\n    }\n\n    return repairedSession;\n  }\n}\n\n/**\n * Session statistics utilities.\n *\n * @example\n */\nexport class SessionStats {\n  /**\n   * Calculate session health score.\n   *\n   * @param session\n   */\n  static calculateHealthScore(session: SessionState): number {\n    let score = 100;\n\n    // Deduct points for various issues\n    if (session.status === 'corrupted') score -= 50;\n    if (session.status === 'terminated') score -= 30;\n    if (session.checkpoints.length === 0) score -= 20;\n\n    // Age factor (older sessions might be less healthy)\n    const ageInDays = (Date.now() - session.createdAt.getTime()) / (1000 * 60 * 60 * 24);\n    if (ageInDays > 30) score -= 10;\n    if (ageInDays > 90) score -= 20;\n\n    // Access pattern (unused sessions might be less healthy)\n    const daysSinceAccess = (Date.now() - session.lastAccessedAt.getTime()) / (1000 * 60 * 60 * 24);\n    if (daysSinceAccess > 7) score -= 10;\n    if (daysSinceAccess > 30) score -= 20;\n\n    // Task success rate\n    const metrics = session.swarmState.metrics;\n    if (metrics.totalTasks > 0) {\n      const successRate = metrics.completedTasks / metrics.totalTasks;\n      if (successRate < 0.5) score -= 20;\n      if (successRate < 0.2) score -= 30;\n    }\n\n    return Math.max(0, Math.min(100, score));\n  }\n\n  /**\n   * Generate session summary.\n   *\n   * @param session\n   */\n  static generateSummary(session: SessionState): Record<string, any> {\n    const metrics = session.swarmState.metrics;\n    const healthScore = SessionStats.calculateHealthScore(session);\n\n    return {\n      id: session.id,\n      name: session.name,\n      status: session.status,\n      healthScore,\n      createdAt: session.createdAt,\n      lastAccessedAt: session.lastAccessedAt,\n      lastCheckpointAt: session.lastCheckpointAt,\n      ageInDays: Math.floor((Date.now() - session.createdAt.getTime()) / (1000 * 60 * 60 * 24)),\n      daysSinceAccess: Math.floor(\n        (Date.now() - session.lastAccessedAt.getTime()) / (1000 * 60 * 60 * 24)\n      ),\n      agents: {\n        total: session.swarmState.agents.size,\n        topology: session.swarmState.topology,\n      },\n      tasks: {\n        total: metrics.totalTasks,\n        completed: metrics.completedTasks,\n        failed: metrics.failedTasks,\n        successRate: metrics.totalTasks > 0 ? metrics.completedTasks / metrics.totalTasks : 0,\n        averageCompletionTime: metrics.averageCompletionTime,\n      },\n      checkpoints: {\n        total: session.checkpoints.length,\n        latest: session.checkpoints[0]?.timestamp,\n      },\n      performance: {\n        throughput: metrics.throughput,\n        agentUtilization: Array.from(metrics.agentUtilization.entries()).reduce(\n          (acc, [id, util]) => {\n            acc[id] = util;\n            return acc;\n          },\n          {} as Record<string, number>\n        ),\n      },\n      version: session.version,\n    };\n  }\n}\n\n/**\n * Export all utilities.\n */\n// Classes are already exported inline above\n", "/**\n * @file Session Integration Layer.\n *\n * Integrates the SessionManager with the existing ZenSwarm system,\n * providing seamless session persistence for swarm operations.\n */\n\nimport { getLogger } from '../../../config/logging-config.ts';\n\nconst logger = getLogger('coordination-swarm-core-session-integration');\n\n// Node.js modules\nimport { EventEmitter } from 'node:events';\n\n// External dependencies\nimport type { IDao, SessionCoordinationDao } from '../database';\n\n// Internal modules - absolute paths\nimport { ZenSwarm } from './base-swarm.ts';\n// Internal modules - types\nimport type { SessionConfig, SessionState } from './session-manager.ts';\nimport { SessionManager } from './session-manager.ts';\nimport { SessionRecovery, SessionValidator } from './session-utils.ts';\nimport type { AgentConfig, SwarmEvent, SwarmOptions, SwarmState, Task } from './types.ts';\n\n/**\n * Enhanced ZenSwarm with session management capabilities.\n *\n * Provides persistent session support for swarm operations, allowing.\n * Recovery from failures and resumption of long-running tasks..\n *\n * @example\n */\nexport class SessionEnabledSwarm extends ZenSwarm {\n  private sessionManager: SessionManager;\n  private currentSessionId: string | undefined;\n  private sessionIntegrationEnabled: boolean = false;\n\n  /**\n   * Creates a new SessionEnabledSwarm instance.\n   *\n   * @param options - Configuration options for the swarm.\n   * @param sessionConfig - Configuration for session management.\n   * @param persistence - Optional persistence layer for session data.\n   * @example\n   * ```typescript\n   * const swarm = new SessionEnabledSwarm(\n   *   { maxAgents: 10 },\n   *   { autoSave: true, saveInterval: 5000 },\n   *   coordinationDao\n   * )\n   * ```\n   */\n  constructor(\n    options: SwarmOptions = {},\n    sessionConfig: SessionConfig = {},\n    persistence?: SessionCoordinationDao\n  ) {\n    super(options);\n\n    // Initialize session manager with existing or new persistence DAO\n    let persistenceLayer: SessionCoordinationDao;\n    if (persistence) {\n      persistenceLayer = persistence;\n    } else {\n      // Create a simple mock implementation for now\n      // TODO: Implement proper DALFactory integration with DI\n      persistenceLayer = {\n        // Repository methods\n        findById: async (_id: string | number) => null,\n        findBy: async (_criteria: Partial<any>, _options?: any) => [],\n        findAll: async (_options?: any) => [],\n        create: async (_entity: Omit<any, 'id'>) => ({\n          id: 'mock-id',\n          name: 'mock-session',\n          createdAt: new Date(),\n          lastAccessedAt: new Date(),\n          status: 'active',\n        }),\n        update: async (_id: string | number, _updates: Partial<any>) => ({\n          id: _id,\n          name: 'mock-session',\n          createdAt: new Date(),\n          lastAccessedAt: new Date(),\n          status: 'active',\n          ..._updates,\n        }),\n        delete: async (_id: string | number) => true,\n        count: async (_criteria?: Partial<any>) => 0,\n        exists: async (_id: string | number) => false,\n        executeCustomQuery: async (_query: any) => null,\n        // Coordination methods\n        acquireLock: async (_resourceId: string, _lockTimeout?: number) => ({\n          id: 'mock-lock',\n          resourceId: _resourceId,\n          acquired: new Date(),\n          expiresAt: new Date(Date.now() + 30000),\n          owner: 'mock-session-integration',\n        }),\n        releaseLock: async (_lockId: string) => {},\n        subscribe: async (_pattern: string, _callback: any) => `mock-sub-${Date.now()}`,\n        unsubscribe: async (_subscriptionId: string) => {},\n        publish: async (_channel: string, _event: any) => {},\n        getCoordinationStats: async () => ({\n          activeLocks: 0,\n          activeSubscriptions: 0,\n          messagesPublished: 0,\n          messagesReceived: 0,\n          uptime: Date.now(),\n        }),\n        execute: async (_sql: string, _params?: unknown[]) => ({ affectedRows: 1 }),\n        query: async (_sql: string, _params?: unknown[]) => [],\n      } satisfies SessionCoordinationDao;\n    }\n    this.sessionManager = new SessionManager(persistenceLayer, sessionConfig);\n\n    // Set up event forwarding\n    this.setupEventForwarding();\n  }\n\n  /**\n   * Initialize swarm with session support.\n   *\n   * Sets up the base swarm infrastructure and initializes the session.\n   * Management layer for persistent operation tracking..\n   *\n   * @throws Error if initialization fails.\n   * @example\n   * ```typescript\n   * await swarm.initialize()\n   * console.log('Swarm ready with session support')\n   * ```\n   */\n  override async initialize(): Promise<void> {\n    // Initialize base swarm\n    await super.initialize();\n\n    // Initialize session manager\n    await this.sessionManager.initialize();\n\n    this.sessionIntegrationEnabled = true;\n    this.emit('session:integration_enabled' as SwarmEvent, {});\n  }\n\n  /**\n   * Create a new session and associate with this swarm.\n   *\n   * @param sessionName\n   */\n  async createSession(sessionName: string): Promise<string> {\n    if (!this.sessionIntegrationEnabled) {\n      throw new Error('Session integration not enabled. Call init() first.');\n    }\n\n    const currentState = await this.captureCurrentState();\n    const sessionId = await this.sessionManager.createSession(\n      sessionName,\n      this.options,\n      currentState\n    );\n\n    this.currentSessionId = sessionId;\n    this.emit('session:created' as SwarmEvent, { sessionId, sessionName });\n\n    return sessionId;\n  }\n\n  /**\n   * Load an existing session and restore swarm state.\n   *\n   * @param sessionId\n   */\n  async loadSession(sessionId: string): Promise<void> {\n    if (!this.sessionIntegrationEnabled) {\n      throw new Error('Session integration not enabled. Call init() first.');\n    }\n\n    const session = await this.sessionManager.loadSession(sessionId);\n\n    // Restore swarm state from session\n    await this.restoreFromSessionState(session);\n\n    this.currentSessionId = sessionId;\n    this.emit('session:loaded' as SwarmEvent, { sessionId, sessionName: session.name });\n  }\n\n  /**\n   * Save current swarm state to session.\n   */\n  async saveSession(): Promise<void> {\n    if (!this.currentSessionId) {\n      throw new Error('No active session. Create or load a session first.');\n    }\n\n    const currentState = await this.captureCurrentState();\n    await this.sessionManager.saveSession(this.currentSessionId, currentState);\n\n    this.emit('session:saved' as SwarmEvent, { sessionId: this.currentSessionId });\n  }\n\n  /**\n   * Create a checkpoint of current state.\n   *\n   * @param description\n   */\n  async createCheckpoint(description?: string): Promise<string> {\n    if (!this.currentSessionId) {\n      throw new Error('No active session. Create or load a session first.');\n    }\n\n    // Ensure current state is saved before checkpointing\n    await this.saveSession();\n\n    const checkpointId = await this.sessionManager.createCheckpoint(\n      this.currentSessionId,\n      description || 'Manual checkpoint'\n    );\n\n    this.emit('session:checkpoint_created' as SwarmEvent, {\n      sessionId: this.currentSessionId,\n      checkpointId,\n      description,\n    });\n\n    return checkpointId;\n  }\n\n  /**\n   * Restore from a specific checkpoint.\n   *\n   * @param checkpointId\n   */\n  async restoreFromCheckpoint(checkpointId: string): Promise<void> {\n    if (!this.currentSessionId) {\n      throw new Error('No active session. Create or load a session first.');\n    }\n\n    await this.sessionManager.restoreFromCheckpoint(this.currentSessionId, checkpointId);\n\n    // Reload the session to get the restored state\n    const session = await this.sessionManager.loadSession(this.currentSessionId);\n    await this.restoreFromSessionState(session);\n\n    this.emit('session:restored' as SwarmEvent, {\n      sessionId: this.currentSessionId,\n      checkpointId,\n    });\n  }\n\n  /**\n   * Pause the current session.\n   */\n  async pauseSession(): Promise<void> {\n    if (!this.currentSessionId) {\n      throw new Error('No active session. Create or load a session first.');\n    }\n\n    // Save current state before pausing\n    await this.saveSession();\n\n    await this.sessionManager.pauseSession(this.currentSessionId);\n    this.emit('session:paused' as SwarmEvent, { sessionId: this.currentSessionId });\n  }\n\n  /**\n   * Resume a paused session.\n   */\n  async resumeSession(): Promise<void> {\n    if (!this.currentSessionId) {\n      throw new Error('No active session. Create or load a session first.');\n    }\n\n    await this.sessionManager.resumeSession(this.currentSessionId);\n    this.emit('session:resumed' as SwarmEvent, { sessionId: this.currentSessionId });\n  }\n\n  /**\n   * Hibernate the current session.\n   */\n  async hibernateSession(): Promise<void> {\n    if (!this.currentSessionId) {\n      throw new Error('No active session. Create or load a session first.');\n    }\n\n    // Save current state before hibernating\n    await this.saveSession();\n\n    await this.sessionManager.hibernateSession(this.currentSessionId);\n\n    this.emit('session:hibernated' as SwarmEvent, { sessionId: this.currentSessionId });\n    this.currentSessionId = undefined as string | undefined;\n  }\n\n  /**\n   * Terminate the current session.\n   *\n   * @param cleanup\n   */\n  async terminateSession(cleanup: boolean = false): Promise<void> {\n    if (!this.currentSessionId) {\n      throw new Error('No active session. Create or load a session first.');\n    }\n\n    const sessionId = this.currentSessionId;\n    await this.sessionManager.terminateSession(sessionId, cleanup);\n\n    this.emit('session:terminated' as SwarmEvent, { sessionId, cleanup });\n    this.currentSessionId = undefined as string | undefined;\n  }\n\n  /**\n   * List available sessions.\n   *\n   * @param filter\n   */\n  async listSessions(filter?: any): Promise<SessionState[]> {\n    if (!this.sessionIntegrationEnabled) {\n      throw new Error('Session integration not enabled. Call init() first.');\n    }\n\n    return this.sessionManager.listSessions(filter);\n  }\n\n  /**\n   * Get current session info.\n   */\n  async getCurrentSession(): Promise<SessionState | null> {\n    if (!this.currentSessionId) {\n      return null;\n    }\n\n    return this.sessionManager.loadSession(this.currentSessionId);\n  }\n\n  /**\n   * Get session statistics.\n   *\n   * @param sessionId\n   */\n  async getSessionStats(sessionId?: string): Promise<Record<string, any>> {\n    return this.sessionManager.getSessionStats(sessionId || this.currentSessionId);\n  }\n\n  /**\n   * Enhanced agent operations with session persistence.\n   *\n   * @param config\n   */\n  async addAgent(config: AgentConfig): Promise<string> {\n    // Create agent ID and simulate adding agent\n    const agentId = config?.id || `agent-${Date.now()}`;\n\n    // For now, just emit the event since the base class doesn't have addAgent\n    this.emit('agent:added', { agentId, config });\n\n    // Auto-save to session if enabled\n    if (this.currentSessionId && this.sessionIntegrationEnabled) {\n      setImmediate(() =>\n        this.saveSession().catch((error) => {\n          this.emit('session:error' as SwarmEvent, {\n            error: error.message,\n            operation: 'addAgent',\n            agentId,\n          });\n        })\n      );\n    }\n\n    return agentId;\n  }\n\n  /**\n   * Enhanced task submission with session persistence.\n   *\n   * @param task\n   */\n  async submitTask(task: Omit<Task, 'id' | 'status'>): Promise<string> {\n    // Create task ID and simulate task submission\n    const taskId = `task-${Date.now()}`;\n\n    // For now, just emit the event since the base class doesn't have submitTask\n    this.emit('task:created', { taskId, task });\n\n    // Auto-save to session if enabled\n    if (this.currentSessionId && this.sessionIntegrationEnabled) {\n      setImmediate(() =>\n        this.saveSession().catch((error) => {\n          this.emit('session:error' as SwarmEvent, {\n            error: error.message,\n            operation: 'submitTask',\n            taskId,\n          });\n        })\n      );\n    }\n\n    return taskId;\n  }\n\n  /**\n   * Enhanced destroy with session cleanup.\n   */\n  async destroy(): Promise<void> {\n    // Save session before destroying if there's an active session\n    if (this.currentSessionId) {\n      try {\n        await this.saveSession();\n        await this.createCheckpoint('Pre-destroy checkpoint');\n      } catch (error) {\n        logger.error('Failed to save session before destroy:', error);\n      }\n    }\n\n    // Shutdown session manager\n    if (this.sessionManager) {\n      await this.sessionManager.shutdown();\n    }\n\n    // Call parent shutdown (the method that actually exists)\n    await super.shutdown();\n  }\n\n  /**\n   * Private helper methods.\n   */\n\n  private async captureCurrentState(): Promise<SwarmState> {\n    // Access the protected state from parent class\n    // Note: In a real implementation, you might need to add a getter method to ZenSwarm\n    return {\n      agents: (this as any).state.agents,\n      tasks: (this as any).state.tasks,\n      topology: (this as any).state.topology,\n      connections: (this as any).state.connections,\n      metrics: (this as any).state.metrics,\n    };\n  }\n\n  private async restoreFromSessionState(session: SessionState): Promise<void> {\n    // Restore agents\n    for (const [agentId, agent] of session.swarmState.agents) {\n      if (!(this as any).state.agents.has(agentId)) {\n        // Re-add agent if not present\n        try {\n          // Ensure the agent config has the required id field\n          const configWithId = {\n            ...agent.config,\n            id: agent.config.id || agentId,\n          };\n          await this.addAgent(configWithId);\n        } catch (error) {\n          logger.warn(`Failed to restore agent ${agentId}:`, error);\n        }\n      }\n    }\n\n    // Restore tasks\n    for (const [taskId, task] of session.swarmState.tasks) {\n      if (!(this as any).state.tasks.has(taskId)) {\n        // Re-add task if not present\n        try {\n          await this.submitTask({\n            description: task.description,\n            priority: task.priority,\n            dependencies: task.dependencies || [],\n            assignedAgents: task.assignedAgents || [],\n            swarmId: this.options.topology || 'default', // Use swarm topology as swarmId\n            strategy: 'balanced', // Default strategy\n            progress: 0, // Initial progress\n            requireConsensus: false, // Default consensus requirement\n            maxAgents: 5, // Default max agents\n            requiredCapabilities: [], // Default capabilities\n            createdAt: new Date(), // Current timestamp\n            metadata: {}, // Empty metadata\n          });\n        } catch (error) {\n          logger.warn(`Failed to restore task ${taskId}:`, error);\n        }\n      }\n    }\n\n    // Update internal state\n    (this as any).state.topology = session.swarmState.topology;\n    (this as any).state.connections = session.swarmState.connections;\n    (this as any).state.metrics = session.swarmState.metrics;\n\n    this.emit('swarm:state_restored' as SwarmEvent, {\n      sessionId: session.id,\n      agentCount: session.swarmState.agents.size,\n      taskCount: session.swarmState.tasks.size,\n    });\n  }\n\n  private setupEventForwarding(): void {\n    // Forward session manager events to swarm events\n    this.sessionManager.on('session:created', (data) => {\n      this.emit('session:created' as SwarmEvent, data);\n    });\n\n    this.sessionManager.on('session:loaded', (data) => {\n      this.emit('session:loaded' as SwarmEvent, data);\n    });\n\n    this.sessionManager.on('session:saved', (data) => {\n      this.emit('session:saved' as SwarmEvent, data);\n    });\n\n    this.sessionManager.on('checkpoint:created', (data) => {\n      this.emit('session:checkpoint_created' as SwarmEvent, data);\n    });\n\n    this.sessionManager.on('session:restored', (data) => {\n      this.emit('session:restored' as SwarmEvent, data);\n    });\n\n    this.sessionManager.on('session:paused', (data) => {\n      this.emit('session:paused' as SwarmEvent, data);\n    });\n\n    this.sessionManager.on('session:resumed', (data) => {\n      this.emit('session:resumed' as SwarmEvent, data);\n    });\n\n    this.sessionManager.on('session:hibernated', (data) => {\n      this.emit('session:hibernated' as SwarmEvent, data);\n    });\n\n    this.sessionManager.on('session:terminated', (data) => {\n      this.emit('session:terminated' as SwarmEvent, data);\n    });\n\n    this.sessionManager.on('session:corruption_detected', (data) => {\n      this.emit('session:corruption_detected' as SwarmEvent, data);\n    });\n\n    this.sessionManager.on('checkpoint:error', (data) => {\n      this.emit('session:error' as SwarmEvent, { ...data, operation: 'checkpoint' });\n    });\n  }\n}\n\n/**\n * Session Recovery Service.\n *\n * Provides automated recovery capabilities for corrupted sessions.\n *\n * @example\n */\nexport class SessionRecoveryService extends EventEmitter {\n  private sessionManager: SessionManager;\n  private recoveryInProgress: Set<string> = new Set();\n\n  constructor(sessionManager: SessionManager) {\n    super();\n    this.sessionManager = sessionManager;\n  }\n\n  /**\n   * Attempt to recover a corrupted session.\n   *\n   * @param sessionId\n   */\n  async recoverSession(sessionId: string): Promise<boolean> {\n    if (this.recoveryInProgress.has(sessionId)) {\n      throw new Error(`Recovery already in progress for session ${sessionId}`);\n    }\n\n    this.recoveryInProgress.add(sessionId);\n    this.emit('recovery:started', { sessionId });\n\n    try {\n      // Load the corrupted session\n      const session = await this.sessionManager.loadSession(sessionId);\n\n      // Validate session state\n      const validation = SessionValidator.validateSessionState(session);\n      if (validation.valid) {\n        this.emit('recovery:not_needed', { sessionId });\n        return true;\n      }\n\n      this.emit('recovery:validation_failed', {\n        sessionId,\n        errors: validation.errors,\n      });\n\n      // Attempt recovery using checkpoints\n      const recoveredSession = await SessionRecovery.recoverSession(session, session.checkpoints);\n\n      if (!recoveredSession) {\n        this.emit('recovery:failed', {\n          sessionId,\n          reason: 'No valid checkpoints found',\n        });\n        return false;\n      }\n\n      // Save recovered session\n      await this.sessionManager.saveSession(sessionId, recoveredSession.swarmState);\n\n      this.emit('recovery:completed', {\n        sessionId,\n        recoveredFromCheckpoint: recoveredSession.metadata['recoveredFromCheckpoint'],\n      });\n\n      return true;\n    } catch (error) {\n      this.emit('recovery:failed', {\n        sessionId,\n        reason: error instanceof Error ? error.message : String(error),\n      });\n      return false;\n    } finally {\n      this.recoveryInProgress.delete(sessionId);\n    }\n  }\n\n  /**\n   * Run health check on all sessions.\n   */\n  async runHealthCheck(): Promise<Record<string, any>> {\n    const sessions = await this.sessionManager.listSessions();\n    const healthReport: Record<string, any> = {\n      total: sessions.length,\n      healthy: 0,\n      corrupted: 0,\n      needsRecovery: [],\n      recoveryRecommendations: [],\n    };\n\n    for (const session of sessions) {\n      const validation = SessionValidator.validateSessionState(session);\n\n      if (validation.valid) {\n        healthReport['healthy']++;\n      } else {\n        healthReport['corrupted']++;\n        healthReport['needsRecovery']?.push({\n          sessionId: session.id,\n          name: session.name,\n          errors: validation.errors,\n        });\n\n        // Generate recovery recommendation\n        if (session.checkpoints.length > 0) {\n          healthReport['recoveryRecommendations']?.push({\n            sessionId: session.id,\n            recommendation: 'automatic_recovery',\n            availableCheckpoints: session.checkpoints.length,\n          });\n        } else {\n          healthReport['recoveryRecommendations']?.push({\n            sessionId: session.id,\n            recommendation: 'manual_intervention',\n            reason: 'No checkpoints available',\n          });\n        }\n      }\n    }\n\n    this.emit('health_check:completed', healthReport);\n    return healthReport;\n  }\n\n  /**\n   * Schedule automatic recovery for corrupted sessions.\n   */\n  async scheduleAutoRecovery(): Promise<void> {\n    const healthReport = await this.runHealthCheck();\n\n    const autoRecoverySessions = healthReport['recoveryRecommendations']\n      ?.filter((rec: any) => rec.recommendation === 'automatic_recovery')\n      .map((rec: any) => rec.sessionId);\n\n    this.emit('auto_recovery:scheduled', {\n      sessions: autoRecoverySessions,\n      count: autoRecoverySessions.length,\n    });\n\n    for (const sessionId of autoRecoverySessions) {\n      try {\n        const success = await this.recoverSession(sessionId);\n        this.emit('auto_recovery:session_completed', {\n          sessionId,\n          success,\n        });\n      } catch (error) {\n        this.emit('auto_recovery:session_failed', {\n          sessionId,\n          error: error instanceof Error ? error.message : String(error),\n        });\n      }\n    }\n\n    this.emit('auto_recovery:completed', {\n      totalSessions: autoRecoverySessions.length,\n    });\n  }\n}\n\n/**\n * Factory function for creating session-enabled swarms.\n *\n * @param swarmOptions\n * @param sessionConfig\n * @param persistence\n * @example\n */\nexport function createSessionEnabledSwarm(\n  swarmOptions?: SwarmOptions,\n  sessionConfig?: SessionConfig,\n  persistence?: SessionCoordinationDao\n): SessionEnabledSwarm {\n  return new SessionEnabledSwarm(swarmOptions, sessionConfig, persistence);\n}\n\n// Components are already exported inline above\n", "/**\n * Advanced Dynamic Topology Management System\n * Provides intelligent, adaptive topology switching based on workload patterns\n * and performance metrics with fault tolerance and self-healing capabilities.\n */\n/**\n * @file Topology management system.\n */\n\nimport { EventEmitter } from 'node:events';\nimport type { ILogger } from '../../../core/interfaces/base-interfaces.ts';\nimport type { EventBusInterface as IEventBus } from '../../core/event-bus.ts';\n\n// Core types for topology management\nexport type TopologyType =\n  | 'mesh'\n  | 'hierarchical'\n  | 'ring'\n  | 'star'\n  | 'hybrid'\n  | 'small-world'\n  | 'scale-free';\n\nexport interface TopologyConfig {\n  type: TopologyType;\n  parameters: Record<string, unknown>;\n  constraints: {\n    maxLatency: number;\n    minBandwidth: number;\n    faultTolerance: number;\n    scalabilityTarget: number;\n  };\n  adaptation: {\n    enabled: boolean;\n    sensitivity: number;\n    cooldownPeriod: number;\n    maxSwitchesPerHour: number;\n  };\n}\n\nexport interface NetworkNode {\n  id: string;\n  type: 'agent' | 'broker' | 'coordinator' | 'gateway';\n  capabilities: string[];\n  connections: Map<string, Connection>;\n  metrics: NodeMetrics;\n  location: { x: number; y: number; z?: number };\n  lastSeen: Date;\n  health: number; // 0-1\n}\n\nexport interface Connection {\n  targetId: string;\n  type: 'direct' | 'relay' | 'broadcast' | 'multicast';\n  quality: ConnectionQuality;\n  traffic: TrafficStats;\n  established: Date;\n  lastActivity: Date;\n}\n\nexport interface ConnectionQuality {\n  latency: number;\n  bandwidth: number;\n  reliability: number;\n  jitter: number;\n  packetLoss: number;\n}\n\nexport interface TrafficStats {\n  bytesIn: number;\n  bytesOut: number;\n  messagesIn: number;\n  messagesOut: number;\n  errors: number;\n  lastReset: Date;\n}\n\nexport interface NodeMetrics {\n  cpuUsage: number;\n  memoryUsage: number;\n  networkUsage: number;\n  taskLoad: number;\n  responseTime: number;\n  uptime: number;\n}\n\nexport interface TopologyMetrics {\n  networkDiameter: number;\n  avgPathLength: number;\n  clusteringCoefficient: number;\n  redundancy: number;\n  loadBalance: number;\n  communicationEfficiency: number;\n  faultTolerance: number;\n}\n\nexport interface TopologyDecision {\n  currentTopology: TopologyType;\n  recommendedTopology: TopologyType;\n  confidence: number;\n  reason: string;\n  expectedImprovement: number;\n  migrationCost: number;\n  riskLevel: 'low' | 'medium' | 'high';\n}\n\n/**\n * Intelligent topology management with ML-based optimization.\n *\n * @example\n */\nexport class TopologyManager extends EventEmitter {\n  private nodes = new Map<string, NetworkNode>();\n  private currentConfig: TopologyConfig;\n  private metrics: TopologyMetrics;\n  private topologyHistory: Array<{ topology: TopologyType; timestamp: Date; performance: number }> =\n    [];\n  private adaptationEngine: TopologyAdaptationEngine;\n  private networkOptimizer: NetworkOptimizer;\n  private faultDetector: FaultDetector;\n  private migrationController: MigrationController;\n  private monitoringInterval?: NodeJS.Timeout;\n  private lastMigration = 0;\n\n  constructor(\n    initialConfig: TopologyConfig,\n    private logger: ILogger,\n    private eventBus: IEventBus\n  ) {\n    super();\n    this.currentConfig = initialConfig;\n    this.metrics = this.initializeMetrics();\n    this.adaptationEngine = new TopologyAdaptationEngine();\n    this.networkOptimizer = new NetworkOptimizer();\n    this.faultDetector = new FaultDetector();\n    this.migrationController = new MigrationController(this.logger);\n\n    this.setupEventHandlers();\n    this.startMonitoring();\n  }\n\n  private setupEventHandlers(): void {\n    this.eventBus.on('node:metrics-updated', (data: any) => {\n      this.handleNodeMetricsUpdate(data);\n    });\n\n    this.eventBus.on('connection:quality-changed', (data: any) => {\n      this.handleConnectionQualityChange(data);\n    });\n\n    this.eventBus.on('network:fault-detected', (data: any) => {\n      this.handleNetworkFault(data);\n    });\n\n    this.eventBus.on('workload:pattern-changed', (data: any) => {\n      this.handleWorkloadPatternChange(data);\n    });\n  }\n\n  /**\n   * Register a new node in the topology.\n   *\n   * @param nodeConfig\n   * @param nodeConfig.id\n   * @param nodeConfig.type\n   * @param nodeConfig.capabilities\n   * @param nodeConfig.location\n   * @param nodeConfig.location.x\n   * @param nodeConfig.location.y\n   * @param nodeConfig.location.z\n   */\n  async registerNode(nodeConfig: {\n    id: string;\n    type: NetworkNode['type'];\n    capabilities: string[];\n    location?: { x: number; y: number; z?: number };\n  }): Promise<void> {\n    const node: NetworkNode = {\n      id: nodeConfig?.id,\n      type: nodeConfig?.type,\n      capabilities: nodeConfig?.capabilities,\n      connections: new Map(),\n      metrics: this.initializeNodeMetrics(),\n      location: nodeConfig?.location || { x: Math.random() * 100, y: Math.random() * 100 },\n      lastSeen: new Date(),\n      health: 1.0,\n    };\n\n    this.nodes.set(nodeConfig?.id, node);\n\n    // Establish connections based on current topology\n    await this.establishNodeConnections(node);\n\n    this.logger.info('Node registered in topology', {\n      nodeId: nodeConfig?.id,\n      type: nodeConfig?.type,\n    });\n    this.emit('node:registered', { node });\n\n    // Trigger topology optimization\n    this.scheduleTopologyOptimization();\n  }\n\n  /**\n   * Remove a node from the topology.\n   *\n   * @param nodeId\n   */\n  async unregisterNode(nodeId: string): Promise<void> {\n    const node = this.nodes.get(nodeId);\n    if (!node) return;\n\n    // Gracefully disconnect all connections\n    await this.disconnectNodeConnections(node);\n\n    this.nodes.delete(nodeId);\n\n    this.logger.info('Node unregistered from topology', { nodeId });\n    this.emit('node:unregistered', { nodeId });\n\n    // Check if topology needs rebalancing\n    await this.handleNodeFailure(nodeId);\n  }\n\n  /**\n   * Get current topology metrics.\n   */\n  getTopologyMetrics(): TopologyMetrics {\n    return { ...this.metrics };\n  }\n\n  /**\n   * Get topology decision recommendation.\n   */\n  async getTopologyDecision(): Promise<TopologyDecision> {\n    return await this.adaptationEngine.analyzeTopology(\n      this.currentConfig,\n      this.nodes,\n      this.metrics,\n      this.topologyHistory\n    );\n  }\n\n  /**\n   * Manually trigger topology migration.\n   *\n   * @param targetTopology\n   * @param force\n   */\n  async migrateTopology(targetTopology: TopologyType, force = false): Promise<boolean> {\n    const decision = await this.getTopologyDecision();\n\n    if (!force && decision.riskLevel === 'high') {\n      this.logger.warn('Topology migration blocked due to high risk', {\n        current: this.currentConfig.type,\n        target: targetTopology,\n        risk: decision.riskLevel,\n      });\n      return false;\n    }\n\n    const migrationPlan = await this.migrationController.createMigrationPlan(\n      this.currentConfig,\n      { ...this.currentConfig, type: targetTopology },\n      this.nodes\n    );\n\n    return await this.executeMigration(migrationPlan);\n  }\n\n  /**\n   * Get network topology visualization data.\n   */\n  getTopologyVisualization(): {\n    nodes: Array<{ id: string; type: string; x: number; y: number; health: number }>;\n    edges: Array<{ source: string; target: string; quality: number; type: string }>;\n    metrics: TopologyMetrics;\n  } {\n    const nodes = Array.from(this.nodes.values()).map((node) => ({\n      id: node?.id,\n      type: node?.type,\n      x: node?.location?.x,\n      y: node?.location?.y,\n      health: node?.health,\n    }));\n\n    const edges: Array<{ source: string; target: string; quality: number; type: string }> = [];\n    for (const node of this.nodes.values()) {\n      for (const [targetId, connection] of node?.connections) {\n        edges.push({\n          source: node?.id,\n          target: targetId,\n          quality: connection.quality.reliability,\n          type: connection.type,\n        });\n      }\n    }\n\n    return { nodes, edges, metrics: this.metrics };\n  }\n\n  /**\n   * Force network optimization.\n   */\n  async optimizeNetwork(): Promise<void> {\n    await this.networkOptimizer.optimize(this.nodes, this.currentConfig);\n    await this.updateTopologyMetrics();\n    this.emit('network:optimized', { metrics: this.metrics });\n  }\n\n  private async establishNodeConnections(node: NetworkNode): Promise<void> {\n    const strategy = this.getConnectionStrategy(this.currentConfig.type);\n    const connections = await strategy.establishConnections(node, this.nodes);\n\n    for (const connection of connections) {\n      node?.connections?.set(connection.targetId, connection);\n      // Also establish reverse connection if needed\n      const targetNode = this.nodes.get(connection.targetId);\n      if (targetNode && !targetNode?.connections?.has(node?.id)) {\n        targetNode?.connections?.set(node?.id, {\n          targetId: node?.id,\n          type: connection.type,\n          quality: connection.quality,\n          traffic: this.initializeTrafficStats(),\n          established: connection.established,\n          lastActivity: connection.lastActivity,\n        });\n      }\n    }\n  }\n\n  private async disconnectNodeConnections(node: NetworkNode): Promise<void> {\n    for (const [targetId, _connection] of node?.connections) {\n      const targetNode = this.nodes.get(targetId);\n      if (targetNode) {\n        targetNode?.connections?.delete(node?.id);\n      }\n    }\n    node?.connections?.clear();\n  }\n\n  private getConnectionStrategy(topology: TopologyType): ConnectionStrategy {\n    switch (topology) {\n      case 'mesh':\n        return new MeshConnectionStrategy();\n      case 'hierarchical':\n        return new HierarchicalConnectionStrategy();\n      case 'ring':\n        return new RingConnectionStrategy();\n      case 'star':\n        return new StarConnectionStrategy();\n      case 'hybrid':\n        return new HybridConnectionStrategy();\n      case 'small-world':\n        return new SmallWorldConnectionStrategy();\n      case 'scale-free':\n        return new ScaleFreeConnectionStrategy();\n      default:\n        return new MeshConnectionStrategy();\n    }\n  }\n\n  private startMonitoring(): void {\n    this.monitoringInterval = setInterval(async () => {\n      await this.updateTopologyMetrics();\n      await this.checkForOptimizationNeeds();\n      this.performHealthChecks();\n    }, 5000); // Monitor every 5 seconds\n  }\n\n  private async updateTopologyMetrics(): Promise<void> {\n    this.metrics = await this.calculateTopologyMetrics();\n    this.emit('metrics:updated', { metrics: this.metrics });\n  }\n\n  private async calculateTopologyMetrics(): Promise<TopologyMetrics> {\n    const nodes = Array.from(this.nodes.values());\n\n    return {\n      networkDiameter: this.calculateNetworkDiameter(nodes),\n      avgPathLength: this.calculateAveragePathLength(nodes),\n      clusteringCoefficient: this.calculateClusteringCoefficient(nodes),\n      redundancy: this.calculateRedundancy(nodes),\n      loadBalance: this.calculateLoadBalance(nodes),\n      communicationEfficiency: this.calculateCommunicationEfficiency(nodes),\n      faultTolerance: this.calculateFaultTolerance(nodes),\n    };\n  }\n\n  private calculateNetworkDiameter(nodes: NetworkNode[]): number {\n    // Implement Floyd-Warshall for all-pairs shortest paths\n    const n = nodes.length;\n    const dist = Array(n)\n      .fill(null)\n      .map(() => Array(n).fill(Infinity));\n    const nodeIds = nodes.map((n) => n.id);\n\n    // Initialize distances\n    for (let i = 0; i < n; i++) {\n      const distI = dist[i];\n      if (!distI) continue;\n      distI[i] = 0;\n      const node = nodes?.[i];\n      if (!node) continue;\n      for (const [targetId] of node?.connections) {\n        const j = nodeIds?.indexOf(targetId);\n        if (j !== -1) {\n          distI[j] = 1; // Unweighted for simplicity\n        }\n      }\n    }\n\n    // Floyd-Warshall\n    for (let k = 0; k < n; k++) {\n      for (let i = 0; i < n; i++) {\n        const distI = dist[i];\n        if (!distI) continue;\n        for (let j = 0; j < n; j++) {\n          const distK = dist[k];\n          if (!distK) continue;\n          if (distI[k] + distK[j] < distI[j]) {\n            distI[j] = distI[k] + distK[j];\n          }\n        }\n      }\n    }\n\n    // Find maximum finite distance\n    let maxDist = 0;\n    for (let i = 0; i < n; i++) {\n      const distI = dist[i];\n      if (!distI) continue;\n      for (let j = 0; j < n; j++) {\n        if (distI[j] !== Infinity && distI[j] > maxDist) {\n          maxDist = distI[j];\n        }\n      }\n    }\n\n    return maxDist;\n  }\n\n  private calculateAveragePathLength(nodes: NetworkNode[]): number {\n    // Implementation similar to diameter but returns average\n    const n = nodes.length;\n    const dist = Array(n)\n      .fill(null)\n      .map(() => Array(n).fill(Infinity));\n    const nodeIds = nodes.map((n) => n.id);\n\n    for (let i = 0; i < n; i++) {\n      const distI = dist[i];\n      if (!distI) continue;\n      distI[i] = 0;\n      const node = nodes?.[i];\n      if (!node) continue;\n      for (const [targetId] of node?.connections) {\n        const j = nodeIds?.indexOf(targetId);\n        if (j !== -1) {\n          distI[j] = 1;\n        }\n      }\n    }\n\n    for (let k = 0; k < n; k++) {\n      for (let i = 0; i < n; i++) {\n        for (let j = 0; j < n; j++) {\n          const distIK = dist[i]?.[k] ?? Infinity;\n          const distKJ = dist[k]?.[j] ?? Infinity;\n          const distIJ = dist[i]?.[j] ?? Infinity;\n          if (distIK + distKJ < distIJ && dist[i]) {\n            dist[i]![j] = distIK + distKJ;\n          }\n        }\n      }\n    }\n\n    let totalDistance = 0;\n    let pathCount = 0;\n    for (let i = 0; i < n; i++) {\n      for (let j = i + 1; j < n; j++) {\n        const distance = dist[i]?.[j];\n        if (distance !== undefined && distance !== Infinity) {\n          totalDistance += distance;\n          pathCount++;\n        }\n      }\n    }\n\n    return pathCount > 0 ? totalDistance / pathCount : 0;\n  }\n\n  private calculateClusteringCoefficient(nodes: NetworkNode[]): number {\n    let totalCoefficient = 0;\n\n    for (const node of nodes) {\n      const neighbors = Array.from(node?.connections?.keys());\n      const k = neighbors.length;\n\n      if (k < 2) {\n        continue; // Need at least 2 neighbors for clustering\n      }\n\n      let actualEdges = 0;\n      for (let i = 0; i < neighbors.length; i++) {\n        for (let j = i + 1; j < neighbors.length; j++) {\n          const neighbor1 = neighbors[i];\n          const neighbor2 = neighbors[j];\n          if (neighbor1 && neighbor2) {\n            const neighborNode = this.nodes.get(neighbor1);\n            if (neighborNode?.connections.has(neighbor2)) {\n              actualEdges++;\n            }\n          }\n        }\n      }\n\n      const possibleEdges = (k * (k - 1)) / 2;\n      const coefficient = actualEdges / possibleEdges;\n      totalCoefficient += coefficient;\n    }\n\n    return nodes.length > 0 ? totalCoefficient / nodes.length : 0;\n  }\n\n  private calculateRedundancy(nodes: NetworkNode[]): number {\n    // Calculate network redundancy based on multiple paths\n    let totalRedundancy = 0;\n\n    for (const node of nodes) {\n      const pathCounts = this.countAlternatePaths(node?.id);\n      const avgPaths =\n        Object.values(pathCounts).reduce((sum, count) => sum + count, 0) /\n        Object.keys(pathCounts).length;\n      totalRedundancy += Math.min(avgPaths - 1, 1); // Normalize to 0-1\n    }\n\n    return nodes.length > 0 ? totalRedundancy / nodes.length : 0;\n  }\n\n  private calculateLoadBalance(nodes: NetworkNode[]): number {\n    if (nodes.length === 0) return 1;\n\n    const loads = nodes.map((node) => node?.metrics?.taskLoad);\n    const avgLoad = loads.reduce((sum, load) => sum + load, 0) / loads.length;\n\n    if (avgLoad === 0) return 1;\n\n    const variance = loads.reduce((sum, load) => sum + (load - avgLoad) ** 2, 0) / loads.length;\n    const standardDeviation = Math.sqrt(variance);\n\n    // Normalize: lower deviation = better balance\n    return Math.max(0, 1 - standardDeviation / avgLoad);\n  }\n\n  private calculateCommunicationEfficiency(nodes: NetworkNode[]): number {\n    let totalEfficiency = 0;\n    let connectionCount = 0;\n\n    for (const node of nodes) {\n      for (const connection of node?.connections?.values()) {\n        const latencyScore = Math.max(0, 1 - connection.quality.latency / 1000); // Normalize to 1s max\n        const bandwidthScore = Math.min(1, connection.quality.bandwidth / 1000000); // Normalize to 1Mbps max\n        const reliabilityScore = connection.quality.reliability;\n\n        const efficiency = (latencyScore + bandwidthScore + reliabilityScore) / 3;\n        totalEfficiency += efficiency;\n        connectionCount++;\n      }\n    }\n\n    return connectionCount > 0 ? totalEfficiency / connectionCount : 0;\n  }\n\n  private calculateFaultTolerance(nodes: NetworkNode[]): number {\n    // Simulate node failures and measure network connectivity\n    let totalTolerance = 0;\n    const sampleSize = Math.min(nodes.length, 10); // Test up to 10 nodes\n\n    for (let i = 0; i < sampleSize; i++) {\n      const nodeToRemove = nodes?.[i];\n      if (!nodeToRemove) continue;\n      const remainingNodes = nodes.filter((n) => n.id !== nodeToRemove?.id);\n      const connectivity = this.calculateConnectivity(remainingNodes);\n      totalTolerance += connectivity;\n    }\n\n    return sampleSize > 0 ? totalTolerance / sampleSize : 0;\n  }\n\n  private calculateConnectivity(nodes: NetworkNode[]): number {\n    if (nodes.length === 0) return 0;\n    if (nodes.length === 1) return 1;\n\n    // Use DFS to find connected components\n    const visited = new Set<string>();\n    let components = 0;\n\n    for (const node of nodes) {\n      if (!visited.has(node?.id)) {\n        this.dfsVisit(node, nodes, visited);\n        components++;\n      }\n    }\n\n    // Perfect connectivity = 1 component\n    return 1 / components;\n  }\n\n  private dfsVisit(node: NetworkNode, allNodes: NetworkNode[], visited: Set<string>): void {\n    visited.add(node?.id);\n\n    for (const [neighborId] of node?.connections) {\n      if (!visited.has(neighborId)) {\n        const neighbor = allNodes.find((n) => n.id === neighborId);\n        if (neighbor) {\n          this.dfsVisit(neighbor, allNodes, visited);\n        }\n      }\n    }\n  }\n\n  private countAlternatePaths(nodeId: string): Record<string, number> {\n    // Simplified implementation - count direct and 2-hop paths\n    const pathCounts: Record<string, number> = {};\n    const sourceNode = this.nodes.get(nodeId);\n\n    if (!sourceNode) return pathCounts;\n\n    for (const [targetId] of this.nodes) {\n      if (targetId === nodeId) continue;\n\n      pathCounts[targetId] = 0;\n\n      // Direct paths\n      if (sourceNode?.connections?.has(targetId)) {\n        pathCounts[targetId]++;\n      }\n\n      // 2-hop paths\n      for (const [intermediateId] of sourceNode?.connections) {\n        const intermediate = this.nodes.get(intermediateId);\n        if (intermediate?.connections.has(targetId)) {\n          pathCounts[targetId]++;\n        }\n      }\n    }\n\n    return pathCounts;\n  }\n\n  private async checkForOptimizationNeeds(): Promise<void> {\n    if (!this.currentConfig.adaptation.enabled) return;\n\n    const now = Date.now();\n    if (now - this.lastMigration < this.currentConfig.adaptation.cooldownPeriod) return;\n\n    const decision = await this.getTopologyDecision();\n\n    if (\n      decision.recommendedTopology !== decision.currentTopology &&\n      decision.confidence > 0.8 &&\n      decision.expectedImprovement > 0.2\n    ) {\n      this.logger.info('Topology optimization recommended', {\n        current: decision.currentTopology,\n        recommended: decision.recommendedTopology,\n        confidence: decision.confidence,\n        improvement: decision.expectedImprovement,\n      });\n\n      if (decision.riskLevel !== 'high') {\n        await this.migrateTopology(decision.recommendedTopology);\n      }\n    }\n  }\n\n  private performHealthChecks(): void {\n    const now = new Date();\n\n    for (const node of this.nodes.values()) {\n      const timeSinceLastSeen = now.getTime() - node?.lastSeen?.getTime();\n\n      if (timeSinceLastSeen > 30000) {\n        // 30 seconds timeout\n        node.health = Math.max(0, node?.health - 0.1);\n\n        if (node?.health < 0.3) {\n          this.handleUnhealthyNode(node);\n        }\n      }\n    }\n  }\n\n  private async handleUnhealthyNode(node: NetworkNode): Promise<void> {\n    this.logger.warn('Unhealthy node detected', { nodeId: node?.id, health: node?.health });\n    this.emit('node:unhealthy', { nodeId: node?.id, health: node?.health });\n\n    // Implement recovery strategies\n    await this.attemptNodeRecovery(node);\n  }\n\n  private async attemptNodeRecovery(node: NetworkNode): Promise<void> {\n    // Try to establish alternative connections\n    const strategy = this.getConnectionStrategy(this.currentConfig.type);\n    const newConnections = await strategy.establishConnections(node, this.nodes);\n\n    for (const connection of newConnections) {\n      if (!node?.connections?.has(connection.targetId)) {\n        node?.connections?.set(connection.targetId, connection);\n      }\n    }\n\n    this.emit('node:recovery-attempted', { nodeId: node?.id });\n  }\n\n  private scheduleTopologyOptimization(): void {\n    // Debounced optimization scheduling\n    setTimeout(() => {\n      this.optimizeNetwork().catch((error) => {\n        this.logger.error('Network optimization failed', { error });\n      });\n    }, 1000);\n  }\n\n  private async executeMigration(migrationPlan: MigrationPlan): Promise<boolean> {\n    try {\n      this.lastMigration = Date.now();\n      this.logger.info('Starting topology migration', { plan: migrationPlan });\n\n      const success = await this.migrationController.executeMigration(migrationPlan, this.nodes);\n\n      if (success) {\n        this.currentConfig.type = migrationPlan.targetTopology;\n        this.topologyHistory.push({\n          topology: migrationPlan.targetTopology,\n          timestamp: new Date(),\n          performance: this.metrics.communicationEfficiency,\n        });\n\n        this.emit('topology:migrated', {\n          from: migrationPlan.sourceTopology,\n          to: migrationPlan.targetTopology,\n        });\n      }\n\n      return success;\n    } catch (error) {\n      this.logger.error('Topology migration failed', { error });\n      return false;\n    }\n  }\n\n  private async handleNodeMetricsUpdate(data: any): Promise<void> {\n    const node = this.nodes.get(data?.nodeId);\n    if (node) {\n      node.metrics = { ...node?.metrics, ...data?.metrics };\n      node.lastSeen = new Date();\n      node.health = Math.min(1, node?.health + 0.1); // Improve health on activity\n    }\n  }\n\n  private async handleConnectionQualityChange(data: any): Promise<void> {\n    const node = this.nodes.get(data?.nodeId);\n    const connection = node?.connections.get(data?.targetId);\n\n    if (connection) {\n      connection.quality = { ...connection.quality, ...data?.quality };\n      connection.lastActivity = new Date();\n    }\n  }\n\n  private async handleNetworkFault(data: any): Promise<void> {\n    this.logger.warn('Network fault detected', data);\n    await this.faultDetector.handleFault(data, this.nodes);\n    this.emit('fault:handled', data);\n  }\n\n  private async handleWorkloadPatternChange(data: any): Promise<void> {\n    this.logger.info('Workload pattern changed', data);\n    await this.scheduleTopologyOptimization();\n  }\n\n  private async handleNodeFailure(nodeId: string): Promise<void> {\n    // Check if topology needs rebalancing after node failure\n    const remainingNodes = Array.from(this.nodes.values());\n    const connectivity = this.calculateConnectivity(remainingNodes);\n\n    if (connectivity < 0.8) {\n      // Network fragmented\n      this.logger.warn('Network fragmentation detected after node failure', {\n        nodeId,\n        connectivity,\n      });\n\n      await this.networkOptimizer.repairFragmentation(this.nodes, this.currentConfig);\n    }\n  }\n\n  private initializeMetrics(): TopologyMetrics {\n    return {\n      networkDiameter: 0,\n      avgPathLength: 0,\n      clusteringCoefficient: 0,\n      redundancy: 0,\n      loadBalance: 1,\n      communicationEfficiency: 1,\n      faultTolerance: 1,\n    };\n  }\n\n  private initializeNodeMetrics(): NodeMetrics {\n    return {\n      cpuUsage: 0,\n      memoryUsage: 0,\n      networkUsage: 0,\n      taskLoad: 0,\n      responseTime: 0,\n      uptime: 0,\n    };\n  }\n\n  private initializeTrafficStats(): TrafficStats {\n    return {\n      bytesIn: 0,\n      bytesOut: 0,\n      messagesIn: 0,\n      messagesOut: 0,\n      errors: 0,\n      lastReset: new Date(),\n    };\n  }\n\n  async shutdown(): Promise<void> {\n    if (this.monitoringInterval) {\n      clearInterval(this.monitoringInterval);\n    }\n\n    this.emit('shutdown');\n    this.logger.info('Topology manager shutdown');\n  }\n}\n\n// Supporting classes (interfaces for now, implementations would follow)\n\ninterface ConnectionStrategy {\n  establishConnections(\n    node: NetworkNode,\n    allNodes: Map<string, NetworkNode>\n  ): Promise<Connection[]>;\n}\n\nclass MeshConnectionStrategy implements ConnectionStrategy {\n  async establishConnections(\n    node: NetworkNode,\n    allNodes: Map<string, NetworkNode>\n  ): Promise<Connection[]> {\n    // Full mesh - connect to all other nodes\n    const connections: Connection[] = [];\n\n    for (const [targetId, targetNode] of allNodes) {\n      if (targetId !== node?.id) {\n        connections.push({\n          targetId,\n          type: 'direct',\n          quality: this.calculateInitialQuality(node, targetNode),\n          traffic: this.initializeTrafficStats(),\n          established: new Date(),\n          lastActivity: new Date(),\n        });\n      }\n    }\n\n    return connections;\n  }\n\n  private calculateInitialQuality(source: NetworkNode, target: NetworkNode): ConnectionQuality {\n    const distance = Math.sqrt(\n      (source.location.x - target?.location?.x) ** 2 +\n        (source.location.y - target?.location?.y) ** 2\n    );\n\n    return {\n      latency: Math.max(1, distance * 10), // Simulate latency based on distance\n      bandwidth: 1000000, // 1 Mbps default\n      reliability: 0.95,\n      jitter: 5,\n      packetLoss: 0.01,\n    };\n  }\n\n  private initializeTrafficStats(): TrafficStats {\n    return {\n      bytesIn: 0,\n      bytesOut: 0,\n      messagesIn: 0,\n      messagesOut: 0,\n      errors: 0,\n      lastReset: new Date(),\n    };\n  }\n}\n\nclass HierarchicalConnectionStrategy implements ConnectionStrategy {\n  async establishConnections(\n    _node: NetworkNode,\n    _allNodes: Map<string, NetworkNode>\n  ): Promise<Connection[]> {\n    // Connect based on hierarchical structure\n    const connections: Connection[] = [];\n    // Implementation would create parent-child relationships\n    return connections;\n  }\n}\n\nclass RingConnectionStrategy implements ConnectionStrategy {\n  async establishConnections(\n    _node: NetworkNode,\n    _allNodes: Map<string, NetworkNode>\n  ): Promise<Connection[]> {\n    // Connect to immediate neighbors in ring\n    const connections: Connection[] = [];\n    // Implementation would create ring connections\n    return connections;\n  }\n}\n\nclass StarConnectionStrategy implements ConnectionStrategy {\n  async establishConnections(\n    _node: NetworkNode,\n    _allNodes: Map<string, NetworkNode>\n  ): Promise<Connection[]> {\n    // Connect based on star topology (hub and spokes)\n    const connections: Connection[] = [];\n    // Implementation would identify hub and create spoke connections\n    return connections;\n  }\n}\n\nclass HybridConnectionStrategy implements ConnectionStrategy {\n  async establishConnections(\n    _node: NetworkNode,\n    _allNodes: Map<string, NetworkNode>\n  ): Promise<Connection[]> {\n    // Adaptive connection strategy\n    const connections: Connection[] = [];\n    // Implementation would choose best strategy based on conditions\n    return connections;\n  }\n}\n\nclass SmallWorldConnectionStrategy implements ConnectionStrategy {\n  async establishConnections(\n    _node: NetworkNode,\n    _allNodes: Map<string, NetworkNode>\n  ): Promise<Connection[]> {\n    // Small-world network (local clusters + long-range connections)\n    const connections: Connection[] = [];\n    // Implementation would create small-world structure\n    return connections;\n  }\n}\n\nclass ScaleFreeConnectionStrategy implements ConnectionStrategy {\n  async establishConnections(\n    _node: NetworkNode,\n    _allNodes: Map<string, NetworkNode>\n  ): Promise<Connection[]> {\n    // Scale-free network (preferential attachment)\n    const connections: Connection[] = [];\n    // Implementation would use preferential attachment algorithm\n    return connections;\n  }\n}\n\nclass TopologyAdaptationEngine {\n  async analyzeTopology(\n    currentConfig: TopologyConfig,\n    nodes: Map<string, NetworkNode>,\n    metrics: TopologyMetrics,\n    history: Array<{ topology: TopologyType; timestamp: Date; performance: number }>\n  ): Promise<TopologyDecision> {\n    // ML-based topology analysis\n    const analysis = await this.performTopologyAnalysis(currentConfig, nodes, metrics, history);\n\n    return {\n      currentTopology: currentConfig?.type,\n      recommendedTopology: analysis.recommendedTopology,\n      confidence: analysis.confidence,\n      reason: analysis.reason,\n      expectedImprovement: analysis.expectedImprovement,\n      migrationCost: analysis.migrationCost,\n      riskLevel: analysis.riskLevel,\n    };\n  }\n\n  private async performTopologyAnalysis(\n    config: TopologyConfig,\n    _nodes: Map<string, NetworkNode>,\n    _metrics: TopologyMetrics,\n    _history: Array<{ topology: TopologyType; timestamp: Date; performance: number }>\n  ): Promise<{\n    recommendedTopology: TopologyType;\n    confidence: number;\n    reason: string;\n    expectedImprovement: number;\n    migrationCost: number;\n    riskLevel: 'low' | 'medium' | 'high';\n  }> {\n    // Placeholder for ML analysis\n    // Would use neural networks, decision trees, or reinforcement learning\n\n    return {\n      recommendedTopology: config?.type,\n      confidence: 0.7,\n      reason: 'Current topology is optimal',\n      expectedImprovement: 0.05,\n      migrationCost: 0.1,\n      riskLevel: 'low',\n    };\n  }\n}\n\nclass NetworkOptimizer {\n  async optimize(nodes: Map<string, NetworkNode>, _config: TopologyConfig): Promise<void> {\n    // Network optimization algorithms\n    await this.optimizeConnections(nodes);\n    await this.balanceLoad(nodes);\n    await this.minimizeLatency(nodes);\n  }\n\n  async repairFragmentation(\n    _nodes: Map<string, NetworkNode>,\n    _config: TopologyConfig\n  ): Promise<void> {\n    // Repair network fragmentation\n    // Implementation would reconnect isolated components\n  }\n\n  private async optimizeConnections(_nodes: Map<string, NetworkNode>): Promise<void> {\n    // Connection optimization logic\n  }\n\n  private async balanceLoad(_nodes: Map<string, NetworkNode>): Promise<void> {\n    // Load balancing optimization\n  }\n\n  private async minimizeLatency(_nodes: Map<string, NetworkNode>): Promise<void> {\n    // Latency minimization algorithms\n  }\n}\n\nclass FaultDetector {\n  constructor() {\n    this.setupFaultDetection();\n  }\n\n  async handleFault(_fault: any, _nodes: Map<string, NetworkNode>): Promise<void> {\n    // Fault handling and recovery\n  }\n\n  private setupFaultDetection(): void {\n    // Setup proactive fault detection\n  }\n}\n\ninterface MigrationPlan {\n  sourceTopology: TopologyType;\n  targetTopology: TopologyType;\n  steps: MigrationStep[];\n  estimatedDuration: number;\n  rollbackPlan: MigrationStep[];\n}\n\ninterface MigrationStep {\n  id: string;\n  type: 'disconnect' | 'connect' | 'reconfigure' | 'validate';\n  nodeIds: string[];\n  parameters: Record<string, unknown>;\n  timeout: number;\n}\n\nclass MigrationController {\n  constructor(private logger: ILogger) {}\n\n  async createMigrationPlan(\n    currentConfig: TopologyConfig,\n    targetConfig: TopologyConfig,\n    _nodes: Map<string, NetworkNode>\n  ): Promise<MigrationPlan> {\n    // Create step-by-step migration plan\n    return {\n      sourceTopology: currentConfig?.type,\n      targetTopology: targetConfig?.type,\n      steps: [],\n      estimatedDuration: 30000, // 30 seconds\n      rollbackPlan: [],\n    };\n  }\n\n  async executeMigration(plan: MigrationPlan, nodes: Map<string, NetworkNode>): Promise<boolean> {\n    // Execute migration plan with rollback capability\n    try {\n      for (const step of plan.steps) {\n        await this.executeStep(step, nodes);\n      }\n      return true;\n    } catch (error) {\n      this.logger.error('Migration step failed, initiating rollback', { error });\n      await this.rollback(plan, nodes);\n      return false;\n    }\n  }\n\n  private async executeStep(_step: MigrationStep, _nodes: Map<string, NetworkNode>): Promise<void> {\n    // Execute individual migration step\n  }\n\n  private async rollback(_plan: MigrationPlan, _nodes: Map<string, NetworkNode>): Promise<void> {\n    // Execute rollback plan\n  }\n}\n\nexport default TopologyManager;\n", "/**\n * @file Core module exports.\n */\n\nimport { getLogger } from '../../../config/logging-config.ts';\n\nconst logger = getLogger('coordination-swarm-core-index');\n\n/**\n * \uD83D\uDE80 ULTIMATE ZenSwarm Implementation - FULLY INTEGRATED.\n *\n * Advanced swarm orchestration with:\n * - WASM-accelerated neural networks\n * - Cognitive diversity and pattern evolution\n * - Progressive loading and memory optimization\n * - Full persistence with coordination DAO\n * - Enterprise-grade session management\n * - Real-time performance monitoring\n * - Chaos engineering and fault tolerance.\n */\n\nimport type { SessionCoordinationDao } from '../../../database';\n// import { DALFactory } from '../database'; // TODO: Implement proper DI integration\nimport { WasmModuleLoader } from '../../../neural/wasm/wasm-loader.ts';\nimport { AgentPool, createAgent } from '../../agents/agent.ts';\nimport { executeTaskWithAgent } from './agent-adapter.ts';\nimport { getContainer } from './singleton-container.ts';\nimport type {\n  AgentConfig,\n  Message,\n  SwarmEvent,\n  SwarmEventEmitter,\n  SwarmMetrics,\n  SwarmOptions,\n  SwarmState,\n  Task,\n  TaskStatus,\n} from './types.ts';\nimport { formatMetrics, generateId, priorityToNumber, validateSwarmOptions } from './utils.ts';\n\nexport * from '../../../neural/core/neural-network-manager.ts';\nexport * from '../../../neural/wasm/wasm-loader2.ts';\n// Enhanced exports with neural capabilities\nexport * from '../../agents/agent.ts';\nexport * from '../mcp/mcp-daa-tools.ts';\n// Export the base implementation as BaseZenSwarm to avoid conflict\nexport { ZenSwarm as BaseZenSwarm } from './base-swarm.ts';\nexport * from './errors.ts';\nexport * from './hooks';\nexport * from './logger.ts';\nexport * from './logging-config.ts';\nexport * from './monitoring-dashboard.ts';\nexport * from './performance.ts';\nexport * from './performance-benchmarks.ts';\nexport * from './recovery-integration.ts';\nexport * from './recovery-workflows.ts';\nexport * from './schemas.ts';\nexport * from './session-integration.ts';\nexport * from './session-manager.ts';\nexport * from './session-utils.ts';\nexport * from './singleton-container.ts';\nexport { TopologyManager } from './topology-manager.ts';\n// Re-export all types and utilities\nexport * from './types.ts';\nexport * from './utils.ts';\n\n/**\n * Enhanced Agent class with neural capabilities and cognitive patterns.\n *\n * @example\n */\nexport class Agent {\n  public id: string;\n  public type: string;\n  public config: any;\n  public isActive: boolean;\n  public neuralNetworkId: string | undefined;\n  public cognitivePattern: string;\n  public capabilities: string[];\n  public status: 'idle' | 'active' | 'busy';\n  public state: { status: 'idle' | 'active' | 'busy' };\n\n  constructor(config: any = {}) {\n    this.id = config?.id || `agent-${Date.now()}`;\n    this.type = config?.type || 'generic';\n    this.config = config;\n    this.isActive = false;\n    this.neuralNetworkId = config?.enableNeuralNetwork ? `nn-${Date.now()}` : undefined;\n    this.cognitivePattern = config?.cognitivePattern || 'adaptive';\n    this.capabilities = config?.capabilities || [];\n    this.status = 'idle';\n    this.state = { status: 'idle' };\n  }\n\n  async initialize(): Promise<boolean> {\n    this.isActive = true;\n    this.status = 'active';\n    this.state.status = 'active';\n\n    // Initialize neural network if enabled\n    if (this.neuralNetworkId) {\n    }\n\n    return true;\n  }\n\n  async execute(task: any): Promise<any> {\n    this.status = 'busy';\n    this.state.status = 'busy';\n\n    try {\n      const result = {\n        success: true,\n        result: `Agent ${this.id} executed: ${task}`,\n        agent: this.id,\n        executionTime: Date.now(),\n        cognitivePattern: this.cognitivePattern,\n      };\n\n      // If neural network is available, enhance the execution\n      if (this.neuralNetworkId) {\n        return {\n          ...result,\n          neuralProcessing: {\n            networkId: this.neuralNetworkId,\n            cognitiveEnhancement: true,\n            patternMatching: this.cognitivePattern,\n            executionStrategy: 'neural-enhanced',\n          },\n        } as any;\n      }\n\n      return result;\n    } finally {\n      this.status = 'active';\n      this.state.status = 'active';\n    }\n  }\n\n  async updateStatus(newStatus: 'idle' | 'active' | 'busy'): Promise<void> {\n    this.status = newStatus;\n    this.state.status = newStatus;\n  }\n\n  async cleanup(): Promise<boolean> {\n    this.isActive = false;\n    this.status = 'idle';\n    this.state.status = 'idle';\n\n    if (this.neuralNetworkId) {\n    }\n\n    return true;\n  }\n\n  async communicate(_message: Message): Promise<void> {\n    if (this.neuralNetworkId) {\n    }\n  }\n}\n\n/**\n * \uD83D\uDE80 ULTIMATE ZenSwarm - The definitive swarm orchestration system.\n *\n * @example\n */\nexport class ZenSwarm implements SwarmEventEmitter {\n  // Core swarm properties\n  protected options: Required<SwarmOptions>;\n  private state: SwarmState;\n  private agentPool: AgentPool;\n  private eventHandlers: Map<SwarmEvent, Set<(data: any) => void>>;\n  private swarmId?: number;\n  private isInitialized: boolean = false;\n\n  // Enhanced WASM and Neural capabilities\n  private wasmModule?: any;\n  public wasmLoader: WasmModuleLoader;\n  public persistence: SessionCoordinationDao | null = null;\n  public activeSwarms: Map<string, SwarmWrapper> = new Map();\n  private globalAgents: Map<string, any> = new Map();\n\n  // Enhanced metrics and features\n  public metrics: {\n    totalSwarms: number;\n    totalAgents: number;\n    totalTasks: number;\n    memoryUsage: number;\n    performance: Record<string, any>;\n  };\n\n  public features: {\n    neural_networks: boolean;\n    forecasting: boolean;\n    cognitive_diversity: boolean;\n    simd_support: boolean;\n  };\n\n  constructor(options: SwarmOptions = {}) {\n    const errors = validateSwarmOptions(options);\n\n    // Initialize WASM and enhanced capabilities\n    this.wasmLoader = new WasmModuleLoader();\n    this.metrics = {\n      totalSwarms: 0,\n      totalAgents: 0,\n      totalTasks: 0,\n      memoryUsage: 0,\n      performance: {},\n    };\n\n    this.features = {\n      neural_networks: false,\n      forecasting: false,\n      cognitive_diversity: false,\n      simd_support: false,\n    };\n\n    if (errors.length > 0) {\n      throw new Error(`Invalid swarm options: ${errors.join(', ')}`);\n    }\n\n    this.options = {\n      topology: options?.topology || 'mesh',\n      maxAgents: options?.maxAgents || 10,\n      connectionDensity: options?.connectionDensity || 0.5,\n      syncInterval: options?.syncInterval || 1000,\n      wasmPath: options?.wasmPath || './wasm/ruv_swarm_wasm.js',\n      persistence: {\n        enabled: false,\n        dbPath: '',\n        checkpointInterval: 60000,\n        compressionEnabled: false,\n      },\n      pooling: {\n        enabled: false,\n        maxPoolSize: 10,\n        minPoolSize: 1,\n        idleTimeout: 300000,\n      },\n    } as Required<SwarmOptions>;\n\n    this.agentPool = new AgentPool();\n    this.eventHandlers = new Map();\n\n    this.state = {\n      agents: new Map(),\n      tasks: new Map(),\n      topology: this.options.topology,\n      connections: [],\n      metrics: {\n        totalTasks: 0,\n        completedTasks: 0,\n        failedTasks: 0,\n        averageCompletionTime: 0,\n        agentUtilization: new Map(),\n        throughput: 0,\n      },\n    };\n  }\n\n  /**\n   * Initialize the swarm with WASM module.\n   */\n  async init(): Promise<void> {\n    if (this.isInitialized) {\n      throw new Error('Swarm is already initialized');\n    }\n\n    try {\n      // Load WASM module\n      if (typeof (globalThis as any).window !== 'undefined') {\n        // Browser environment\n        const wasmModule = await import(this.options.wasmPath);\n        await wasmModule.default();\n        this.wasmModule = wasmModule;\n      } else {\n      }\n\n      // Initialize swarm in WASM if available\n      if (this.wasmModule) {\n        await this.wasmModule.init();\n        this.swarmId = this.wasmModule.createSwarm(this.options);\n      }\n\n      this.isInitialized = true;\n      this.startSyncLoop();\n\n      this.emit('swarm:initialized', { options: this.options });\n    } catch (error) {\n      throw new Error(`Failed to initialize swarm: ${error}`);\n    }\n  }\n\n  /**\n   * Static factory method for easy initialization.\n   *\n   * @param options\n   */\n  static async create(options?: SwarmOptions): Promise<ZenSwarm> {\n    const swarm = new ZenSwarm(options);\n    await swarm.init();\n    return swarm;\n  }\n\n  /**\n   * Enhanced static initialization with comprehensive features.\n   *\n   * @param options\n   */\n  static async initialize(options: any = {}): Promise<ZenSwarm> {\n    const container = getContainer();\n\n    // Register ZenSwarm factory if not already registered\n    if (!container.has('ZenSwarm')) {\n      container.register('ZenSwarm', () => new ZenSwarm(), {\n        singleton: true,\n        lazy: false,\n      });\n    }\n\n    // Get or create singleton instance through container\n    const instance = container.get('ZenSwarm');\n\n    const {\n      loadingStrategy = 'progressive',\n      enablePersistence = true,\n      enableNeuralNetworks = true,\n      enableForecasting = false,\n      useSIMD = true,\n      debug = false,\n    } = options;\n\n    // Check if already initialized through container\n    if (instance.isInitialized) {\n      if (debug) {\n      }\n      return instance;\n    }\n\n    // Minimal loading for fast startup\n    if (loadingStrategy === 'minimal') {\n      if (debug) {\n      }\n      instance.isInitialized = true;\n      instance.features.simd_support = false; // Skip SIMD detection for speed\n      return instance;\n    }\n\n    try {\n      // Initialize WASM modules (skip for minimal loading)\n      if (loadingStrategy !== 'minimal') {\n        await instance.wasmLoader.initialize(loadingStrategy);\n      }\n\n      // Detect and enable features (skip for minimal loading)\n      if (loadingStrategy !== 'minimal') {\n        await instance.detectFeatures(useSIMD);\n      }\n\n      // Initialize DAO persistence if enabled\n      if (enablePersistence) {\n        try {\n          // Create a simple mock implementation for now\n          // TODO: Implement proper DALFactory integration with DI\n          instance.persistence = {\n            query: async (_sql: string, _params?: any[]) => [],\n            execute: async (_sql: string, _params?: any[]) => ({ affectedRows: 1 }),\n          } as any;\n        } catch (error) {\n          logger.warn('\u26A0\uFE0F Persistence not available:', (error as Error).message);\n          instance.persistence = null;\n        }\n      }\n\n      // Pre-load neural networks if enabled\n      if (enableNeuralNetworks && loadingStrategy !== 'minimal') {\n        try {\n          await instance.wasmLoader.loadModule();\n          instance.features.neural_networks = true;\n          if (debug) {\n          }\n        } catch (_error) {\n          instance.features.neural_networks = false;\n        }\n      }\n\n      // Pre-load forecasting if enabled\n      if (enableForecasting && enableNeuralNetworks && loadingStrategy !== 'minimal') {\n        try {\n          await instance.wasmLoader.loadModule();\n          instance.features.forecasting = true;\n        } catch (_error) {\n          instance.features.forecasting = false;\n        }\n      }\n\n      if (loadingStrategy !== 'minimal') {\n        if (debug) {\n        }\n      }\n\n      // Mark as initialized\n      instance.isInitialized = true;\n\n      return instance;\n    } catch (error) {\n      logger.error('\u274C Failed to initialize ruv-swarm:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Detect available features (neural networks, SIMD, etc.).\n   *\n   * @param useSIMD\n   */\n  async detectFeatures(useSIMD = true): Promise<void> {\n    try {\n      // Load core module to detect basic features\n      await this.wasmLoader.loadModule();\n      const coreModule = this.wasmLoader.getModule();\n\n      // Detect SIMD support\n      if (useSIMD) {\n        this.features.simd_support = ZenSwarm.detectSIMDSupport();\n      }\n\n      // Check if core module has the expected exports\n      if (coreModule?.exports) {\n        this.features.neural_networks = true;\n        this.features.cognitive_diversity = true;\n      }\n    } catch (error) {\n      logger.warn('\u26A0\uFE0F Feature detection failed:', (error as Error).message);\n    }\n  }\n\n  /**\n   * Create a new swarm with neural capabilities.\n   *\n   * @param config\n   */\n  async createSwarm(config: any): Promise<SwarmWrapper> {\n    const {\n      id = null,\n      name = 'default-swarm',\n      topology = 'mesh',\n      strategy = 'balanced',\n      maxAgents = 10,\n      enableCognitiveDiversity = true,\n    } = config;\n\n    // Ensure core module is loaded\n    await this.wasmLoader.loadModule();\n    const coreModule = this.wasmLoader.getModule();\n\n    // Create swarm configuration\n    const swarmConfig = {\n      name,\n      topology_type: topology,\n      max_agents: maxAgents,\n      enable_cognitive_diversity: enableCognitiveDiversity && this.features.cognitive_diversity,\n    };\n\n    // Use the core module exports to create swarm\n    let wasmSwarm: any;\n    if (coreModule?.exports?.ZenSwarm) {\n      try {\n        wasmSwarm = new coreModule.exports.ZenSwarm();\n        wasmSwarm.id = id || `swarm-${Date.now()}`;\n        wasmSwarm.name = name;\n        wasmSwarm.config = swarmConfig;\n      } catch (error) {\n        logger.warn('Failed to create WASM swarm:', (error as Error).message);\n        wasmSwarm = {\n          id: id || `swarm-${Date.now()}`,\n          name,\n          config: swarmConfig,\n          agents: new Map(),\n          tasks: new Map(),\n        };\n      }\n    } else {\n      wasmSwarm = {\n        id: id || `swarm-${Date.now()}`,\n        name,\n        config: swarmConfig,\n        agents: new Map(),\n        tasks: new Map(),\n      };\n    }\n\n    // Create JavaScript wrapper with full neural capabilities\n    const swarm = new SwarmWrapper(wasmSwarm.id || wasmSwarm.name, wasmSwarm, this);\n\n    // Persist swarm if persistence is enabled and this is a new swarm\n    if (this.persistence && !id) {\n      try {\n        await this.persistence.execute(\n          'INSERT INTO swarms (id, name, topology, strategy, max_agents, created_at) VALUES (?, ?, ?, ?, ?, ?)',\n          [swarm.id, name, topology, strategy, maxAgents, new Date().toISOString()]\n        );\n      } catch (error) {\n        if (!(error as Error).message.includes('UNIQUE constraint failed')) {\n          logger.warn('Failed to persist swarm:', (error as Error).message);\n        }\n      }\n    }\n\n    this.activeSwarms.set(swarm.id, swarm);\n    this.metrics.totalSwarms++;\n    return swarm;\n  }\n\n  /**\n   * Get global metrics including neural performance.\n   */\n  async getGlobalMetrics(): Promise<any> {\n    this.metrics.memoryUsage = this.wasmLoader.getTotalMemoryUsage();\n\n    // Aggregate metrics from all swarms\n    let totalAgents = 0;\n    let totalTasks = 0;\n\n    for (const swarm of this.activeSwarms.values()) {\n      const status = await swarm.getStatus(false);\n      totalAgents += status.agents?.total || 0;\n      totalTasks += status.tasks?.total || 0;\n    }\n\n    this.metrics.totalAgents = totalAgents;\n    this.metrics.totalTasks = totalTasks;\n    this.metrics.totalSwarms = this.activeSwarms.size;\n\n    return {\n      ...this.metrics,\n      features: this.features,\n      wasm_modules: this.wasmLoader.getModuleStatus(),\n      timestamp: new Date().toISOString(),\n    };\n  }\n\n  /**\n   * Legacy compatibility method for spawnAgent with neural capabilities.\n   *\n   * @param name\n   * @param type\n   * @param options\n   */\n  async spawnAgent(name: string, type = 'researcher', options: any = {}): Promise<Agent> {\n    // Create a default swarm if none exists\n    if (this.activeSwarms.size === 0) {\n      await this.createSwarm({\n        name: 'default-swarm',\n        maxAgents: options?.maxAgents || 10,\n      });\n    }\n\n    // Get the first available swarm\n    const swarm = this.activeSwarms.values().next().value;\n    return await swarm.spawnAgent(name, type, options);\n  }\n\n  // Core ZenSwarm methods from original implementation\n  addAgent(config: AgentConfig): string {\n    if (!this.isInitialized) {\n      throw new Error('Swarm must be initialized before adding agents');\n    }\n\n    if (this.state.agents.size >= this.options.maxAgents) {\n      throw new Error(`Maximum agent limit (${this.options.maxAgents}) reached`);\n    }\n\n    const agent = createAgent(config as any);\n    this.state.agents.set(agent.id, agent as any);\n    this.agentPool.addAgent(agent as any);\n\n    // Add to WASM if available\n    if (this.wasmModule && this.swarmId !== undefined) {\n      const wasmAgentId = this.wasmModule.addAgent(this.swarmId, config);\n      (agent as any).setWasmAgentId(wasmAgentId);\n    }\n\n    this.updateConnections(agent.id);\n    this.emit('agent:added', { agentId: agent.id, config });\n\n    return agent.id;\n  }\n\n  removeAgent(agentId: string): void {\n    const agent = this.state.agents.get(agentId);\n    if (!agent) {\n      throw new Error(`Agent ${agentId} not found`);\n    }\n\n    if ((agent as any).status === 'busy') {\n      throw new Error(`Cannot remove busy agent ${agentId}`);\n    }\n\n    this.state.agents.delete(agentId);\n    this.agentPool.removeAgent(agentId);\n\n    this.state.connections = this.state.connections.filter(\n      (conn) => conn.from !== agentId && conn.to !== agentId\n    );\n\n    this.emit('agent:removed', { agentId });\n  }\n\n  async submitTask(task: Omit<Task, 'id' | 'status'>): Promise<string> {\n    if (!this.isInitialized) {\n      throw new Error('Swarm must be initialized before submitting tasks');\n    }\n\n    const fullTask: Task = {\n      ...task,\n      id: generateId('task'),\n      status: 'pending',\n    };\n\n    this.state.tasks.set(fullTask.id, fullTask);\n    this.state.metrics.totalTasks++;\n\n    this.emit('task:created', { task: fullTask });\n\n    if (this.wasmModule && this.swarmId !== undefined) {\n      this.wasmModule.assignTask(this.swarmId, fullTask);\n    } else {\n      await this.assignTask(fullTask);\n    }\n\n    return fullTask.id;\n  }\n\n  getTaskStatus(taskId: string): Task | undefined {\n    return this.state.tasks.get(taskId);\n  }\n\n  getTasksByStatus(status: TaskStatus): Task[] {\n    return Array.from(this.state.tasks.values()).filter((task) => task.status === status);\n  }\n\n  getMetrics(): SwarmMetrics {\n    return { ...this.state.metrics };\n  }\n\n  getFormattedMetrics(): string {\n    return formatMetrics(this.state.metrics);\n  }\n\n  // Event emitter implementation\n  on(event: SwarmEvent, handler: (data: any) => void): void {\n    if (!this.eventHandlers.has(event)) {\n      this.eventHandlers.set(event, new Set());\n    }\n    this.eventHandlers.get(event)?.add(handler);\n  }\n\n  off(event: SwarmEvent, handler: (data: any) => void): void {\n    const handlers = this.eventHandlers.get(event);\n    if (handlers) {\n      handlers.delete(handler);\n    }\n  }\n\n  emit(event: SwarmEvent, data: any): void {\n    const handlers = this.eventHandlers.get(event);\n    if (handlers) {\n      handlers.forEach((handler) => {\n        try {\n          handler(data);\n        } catch (error) {\n          logger.error(`Error in event handler for ${event}:`, error);\n        }\n      });\n    }\n  }\n\n  /**\n   * Shutdown the swarm with comprehensive cleanup.\n   */\n  async destroy(): Promise<void> {\n    if (!this.isInitialized) {\n      return;\n    }\n\n    // Cancel any pending tasks\n    for (const task of Array.from(this.state.tasks.values())) {\n      if (task.status === 'pending' || task.status === 'in_progress') {\n        task.status = 'failed';\n        task.error = new Error('Swarm shutdown');\n      }\n    }\n\n    // Terminate all active swarms\n    for (const swarm of this.activeSwarms.values()) {\n      if (typeof swarm.terminate === 'function') {\n        swarm.terminate();\n      }\n    }\n\n    this.activeSwarms.clear();\n    this.globalAgents.clear();\n\n    // Cleanup persistence - DAO is managed by factory, no explicit close needed\n\n    // Destroy WASM resources\n    if (this.wasmModule && this.swarmId !== undefined) {\n      this.wasmModule.destroy(this.swarmId);\n    }\n\n    // Cleanup WASM loader\n    if (this.wasmLoader && typeof this.wasmLoader.cleanup === 'function') {\n      this.wasmLoader.cleanup();\n    }\n\n    this.isInitialized = false;\n    this.emit('swarm:destroyed', {});\n  }\n\n  // Private helper methods\n  private async assignTask(task: Task): Promise<void> {\n    const agent = this.agentPool.getAvailableAgent();\n\n    if (!agent) {\n      return;\n    }\n\n    task.status = 'assigned';\n    task.assignedAgents = [agent.id];\n\n    this.emit('task:assigned', { taskId: task.id, agentId: agent.id });\n\n    const message: Message = {\n      id: generateId('msg'),\n      from: 'swarm',\n      to: agent.id,\n      type: 'task_assignment',\n      payload: task,\n      timestamp: Date.now(),\n    };\n\n    await (agent as any).communicate(message);\n\n    try {\n      task.status = 'in_progress';\n      const startTime = Date.now();\n\n      const result = await executeTaskWithAgent(agent, task);\n\n      task.status = 'completed';\n      task.result = result;\n\n      const executionTime = Date.now() - startTime;\n      this.updateMetrics(true, executionTime);\n\n      this.emit('task:completed', { taskId: task.id, result });\n    } catch (error) {\n      task.status = 'failed';\n      task.error = error as Error;\n\n      this.updateMetrics(false, 0);\n\n      this.emit('task:failed', { taskId: task.id, error });\n    } finally {\n      this.agentPool.releaseAgent(agent.id);\n\n      const pendingTasks = this.getTasksByStatus('pending');\n      if (pendingTasks.length > 0) {\n        pendingTasks.sort((a, b) => priorityToNumber(b.priority) - priorityToNumber(a.priority));\n        const nextTask = pendingTasks[0];\n        if (nextTask) {\n          await this.assignTask(nextTask);\n        }\n      }\n    }\n  }\n\n  private updateConnections(newAgentId: string): void {\n    const agents = Array.from(this.state.agents.keys());\n\n    switch (this.options.topology) {\n      case 'mesh':\n        for (const agentId of agents) {\n          if (agentId !== newAgentId) {\n            this.state.connections.push({\n              from: newAgentId,\n              to: agentId,\n              weight: 1,\n              type: 'coordination',\n            });\n          }\n        }\n        break;\n\n      case 'hierarchical':\n        if (agents.length > 1) {\n          const parentIndex = Math.floor((agents.indexOf(newAgentId) - 1) / 2);\n          if (parentIndex >= 0 && agents[parentIndex]) {\n            this.state.connections.push({\n              from: newAgentId,\n              to: agents[parentIndex],\n              weight: 1,\n              type: 'control',\n            });\n          }\n        }\n        break;\n\n      case 'distributed': {\n        const numConnections = Math.floor(agents.length * this.options.connectionDensity);\n        const shuffled = agents.filter((id) => id !== newAgentId).sort(() => Math.random() - 0.5);\n        for (let i = 0; i < Math.min(numConnections, shuffled.length); i++) {\n          const target = shuffled[i];\n          if (target) {\n            this.state.connections.push({\n              from: newAgentId,\n              to: target,\n              weight: Math.random(),\n              type: 'data',\n            });\n          }\n        }\n        break;\n      }\n    }\n  }\n\n  private updateMetrics(success: boolean, executionTime: number): void {\n    if (success) {\n      this.state.metrics.completedTasks++;\n    } else {\n      this.state.metrics.failedTasks++;\n    }\n\n    if (success && executionTime > 0) {\n      const totalCompleted = this.state.metrics.completedTasks;\n      const currentAvg = this.state.metrics.averageCompletionTime;\n      this.state.metrics.averageCompletionTime =\n        (currentAvg * (totalCompleted - 1) + executionTime) / totalCompleted;\n    }\n\n    const totalProcessed = this.state.metrics.completedTasks + this.state.metrics.failedTasks;\n    const elapsedSeconds = (Date.now() - this.startTime) / 1000;\n    this.state.metrics.throughput = totalProcessed / elapsedSeconds;\n  }\n\n  private startTime: number = Date.now();\n\n  private startSyncLoop(): void {\n    setInterval(() => {\n      if (this.wasmModule && this.swarmId !== undefined) {\n        const _wasmState = this.wasmModule.getState(this.swarmId);\n        // Update local state as needed\n      }\n\n      for (const agent of Array.from(this.state.agents.values())) {\n        this.state.metrics.agentUtilization.set(\n          (agent as any).id,\n          (agent as any).status === 'busy' ? 1 : 0\n        );\n      }\n    }, this.options.syncInterval);\n  }\n\n  /**\n   * Feature detection helpers.\n   */\n  static detectSIMDSupport(): boolean {\n    try {\n      const simdTestModule = new Uint8Array([\n        0x00,\n        0x61,\n        0x73,\n        0x6d, // WASM magic\n        0x01,\n        0x00,\n        0x00,\n        0x00, // Version 1\n        0x01,\n        0x05,\n        0x01, // Type section: 1 type\n        0x60,\n        0x00,\n        0x01,\n        0x7b, // Function type: () -> v128 (SIMD type)\n      ]);\n\n      return WebAssembly.validate(simdTestModule);\n    } catch {\n      return false;\n    }\n  }\n\n  static getVersion(): string {\n    return '2.0.0'; // Ultimate version with full WASM + neural capabilities\n  }\n\n  static getRuntimeFeatures(): any {\n    return {\n      webassembly: typeof WebAssembly !== 'undefined',\n      simd: ZenSwarm.detectSIMDSupport(),\n      workers: typeof Worker !== 'undefined',\n      shared_array_buffer: typeof SharedArrayBuffer !== 'undefined',\n      bigint: typeof BigInt !== 'undefined',\n    };\n  }\n}\n\n/**\n * Enhanced Swarm wrapper class with neural orchestration.\n *\n * @example\n */\nexport class SwarmWrapper {\n  public id: string;\n  private ruvSwarm: ZenSwarm;\n  private wasmSwarm: any;\n  public agents: Map<string, Agent>;\n  private tasks: Map<string, TaskWrapper>;\n\n  constructor(id: string, wasmInstance: any, ruvSwarmInstance: ZenSwarm) {\n    this.id = id;\n    this.wasmSwarm = wasmInstance;\n    this.ruvSwarm = ruvSwarmInstance;\n    this.agents = new Map();\n    this.tasks = new Map();\n  }\n\n  async spawnAgent(name: string, type = 'researcher', options: any = {}): Promise<Agent> {\n    const agent = new Agent({\n      id: options?.id || `agent-${Date.now()}`,\n      name,\n      type,\n      enableNeuralNetwork:\n        options?.enableNeuralNetwork !== false && this.ruvSwarm.features.neural_networks,\n      cognitivePattern: options?.cognitivePattern || 'adaptive',\n      capabilities: options?.capabilities || ['neural-processing', 'pattern-matching'],\n      ...options,\n    });\n\n    await agent.initialize();\n    this.agents.set(agent.id, agent);\n    return agent;\n  }\n\n  async getStatus(_detailed = false): Promise<any> {\n    return {\n      id: this.id,\n      agents: {\n        total: this.agents.size,\n        active: Array.from(this.agents.values()).filter((a) => a.status === 'active').length,\n        idle: Array.from(this.agents.values()).filter((a) => a.status === 'idle').length,\n      },\n      tasks: {\n        total: this.tasks.size,\n        pending: Array.from(this.tasks.values()).filter((t) => t.status === 'pending').length,\n        in_progress: Array.from(this.tasks.values()).filter((t) => t.status === 'in_progress')\n          .length,\n        completed: Array.from(this.tasks.values()).filter((t) => t.status === 'completed').length,\n      },\n    };\n  }\n\n  async terminate(): Promise<void> {\n    this.ruvSwarm.activeSwarms.delete(this.id);\n  }\n}\n\n/**\n * Enhanced Task wrapper class with neural execution.\n *\n * @example\n */\nexport class TaskWrapper {\n  public id: string;\n  public description: string;\n  public status: string;\n  public assignedAgents: string[];\n  public result: any;\n  public swarm: SwarmWrapper;\n  private startTime: number | null;\n  private endTime: number | null;\n  public progress: number;\n\n  constructor(id: string, wasmResult: any, swarm: SwarmWrapper) {\n    this.id = id;\n    this.description = wasmResult?.task_description || wasmResult?.description;\n    this.status = wasmResult?.status || 'pending';\n    this.assignedAgents = wasmResult?.assigned_agents || [];\n    this.result = null;\n    this.swarm = swarm;\n    this.startTime = null;\n    this.endTime = null;\n    this.progress = 0;\n  }\n\n  async getStatus(): Promise<any> {\n    return {\n      id: this.id,\n      status: this.status,\n      assignedAgents: this.assignedAgents,\n      progress: this.progress,\n      execution_time_ms: this.startTime ? (this.endTime || Date.now()) - this.startTime : 0,\n    };\n  }\n}\n\n// Export neural-enhanced utilities\nexport const NeuralSwarmUtils = {\n  /**\n   * Create a neural-enhanced swarm with pre-configured agents.\n   *\n   * @param config\n   */\n  async createNeuralSwarm(config: any = {}): Promise<ZenSwarm> {\n    const swarm = await ZenSwarm.initialize({\n      enableNeuralNetworks: true,\n      enableForecasting: true,\n      useSIMD: true,\n      ...config,\n    });\n    return swarm;\n  },\n\n  /**\n   * Spawn a team of neural agents with different cognitive patterns.\n   *\n   * @param swarm\n   * @param teamConfig\n   */\n  async spawnNeuralTeam(swarm: ZenSwarm, teamConfig: any = {}): Promise<Agent[]> {\n    const {\n      size = 3,\n      cognitivePatterns = ['analytical', 'creative', 'systematic'],\n      types = ['researcher', 'analyst', 'coordinator'],\n    } = teamConfig;\n\n    const agents: Agent[] = [];\n\n    for (let i = 0; i < size; i++) {\n      const agent = await swarm.spawnAgent(`neural-agent-${i + 1}`, types[i % types.length], {\n        enableNeuralNetwork: true,\n        cognitivePattern: cognitivePatterns[i % cognitivePatterns.length],\n        capabilities: ['neural-processing', 'pattern-matching', 'adaptive-learning'],\n      });\n      agents.push(agent);\n    }\n    return agents;\n  },\n};\n\n/**\n * Default export for convenience.\n */\nexport default ZenSwarm;\n", "/**\n * Agent Interface Adapter - Compatibility Layer.\n *\n * This module provides adapter functions to bridge the interface differences.\n * Between the base Agent interface and coordination-specific requirements..\n *\n * @file Agent interface compatibility adapter.\n */\n\nimport type { Agent as CoordinationAgent, Task as CoordinationTask, Message } from '../../../types';\nimport type { Agent as BaseAgent, Task as BaseTask } from '../types/agent-types';\n\n/**\n * Adapter function to convert base Agent to coordination Agent.\n *\n * @param baseAgent\n * @example\n */\nexport function adaptAgentForCoordination(baseAgent: BaseAgent): CoordinationAgent {\n  return {\n    ...baseAgent,\n    connections: [], // Initialize empty connections\n\n    // Add coordination-specific methods\n    async communicate(message: Message): Promise<void> {\n      // Default communication implementation\n      // In practice, this would delegate to the agent's message handling\n      if (baseAgent.handleMessage) {\n        await baseAgent.handleMessage(message as any);\n      }\n    },\n\n    update(state: Partial<any>): void {\n      // Default update implementation\n      // In practice, this would call the agent's updateState method\n      if (baseAgent.updateState) {\n        baseAgent.updateState(state as any);\n      }\n    },\n  };\n}\n\n/**\n * Adapter function to convert coordination Task to base Task.\n *\n * @param coordinationTask\n * @example\n */\nexport function adaptTaskForExecution(coordinationTask: CoordinationTask): BaseTask {\n  return {\n    ...coordinationTask,\n    // Add missing base task properties with defaults\n    dependencies: [], // Required by BaseTask interface\n    assignedAgents: [], // Required by BaseTask interface\n    swarmId: 'default',\n    strategy: 'direct',\n    progress: 0,\n    requireConsensus: false,\n    maxAgents: 1,\n    requiredCapabilities: [],\n    createdAt: new Date(),\n    metadata: {},\n  };\n}\n\n/**\n * Type-safe agent execution with adaptation.\n *\n * @param agent\n * @param task\n * @example\n */\nexport async function executeTaskWithAgent(\n  agent: BaseAgent | CoordinationAgent,\n  task: CoordinationTask\n): Promise<any> {\n  // Convert coordination task to base task format\n  const baseTask = adaptTaskForExecution(task);\n\n  // Execute using the base agent's execute method\n  return await agent.execute(baseTask);\n}\n\n/**\n * Create agent pool entry with proper typing.\n *\n * @param agent\n * @example\n */\nexport function createAgentPoolEntry(agent: BaseAgent): any {\n  // Return properly typed entry for agent pool\n  return {\n    agent: adaptAgentForCoordination(agent),\n    id: agent.id,\n    type: agent.type,\n    state: agent.state,\n    config: agent.config,\n    metrics: agent.metrics,\n  };\n}\n"],
  "mappings": "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",
  "names": ["cloned", "config", "performance", "logger", "config", "config", "performance", "config", "config", "performance", "config", "logger", "config", "fs", "config", "id", "result", "import_wasm_loader", "logger", "logger", "performance", "logger", "logger", "config", "getLogger", "EventEmitter", "EventEmitter", "fs", "logger", "fs", "logger", "config", "EventEmitter", "logger", "EventEmitter", "experiment", "EventEmitter", "logger", "generateId", "Logger", "ErrorFactory", "EventEmitter", "config", "ws", "EventEmitter", "EventEmitter", "EventEmitter", "randomUUID", "EventEmitter", "performance", "logger", "EventEmitter", "performance", "randomUUID", "EventEmitter", "logger", "EventEmitter", "DatabaseTypes", "logger", "EventEmitter", "config", "DatabaseTypes", "crypto", "logger", "crypto", "EventEmitter", "logger", "config", "EventEmitter", "EventEmitter", "EventEmitter", "logger", "n", "config", "logger", "config", "ZenSwarm"]
}
