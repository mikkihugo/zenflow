{
  "version": 3,
  "sources": ["../../src/database/core/dao-factory.ts"],
  "sourcesContent": ["/**\n * @file DAO Factory - Core Database Factory Functions.\n *\n * Extracted from index.ts to break circular dependencies.\n * Contains factory functions and entity type definitions.\n */\n\nimport type { DatabaseAdapter, ILogger } from '../../core/interfaces/base-interfaces.ts';\nimport type { DatabaseTypes, EntityTypes as EntityTypesEnum, IDao } from '../interfaces.ts';\n\n/**\n * Multi-database DAO interface for cross-database operations.\n *\n * @example\n */\nexport interface IMultiDatabaseDao<T> {\n  primary: IDao<T>;\n  fallbacks: IDao<T>[];\n  readPreference: 'primary' | 'fallback' | 'balanced';\n  writePolicy: 'primary-only' | 'replicated';\n  failoverTimeout: number;\n  findById(id: string): Promise<T | null>;\n  findAll(): Promise<T[]>;\n  create(entity: Omit<T, 'id'>): Promise<T>;\n  update(id: string, updates: Partial<T>): Promise<T | null>;\n  delete(id: string): Promise<boolean>;\n  findBy(filter: Partial<T>): Promise<T[]>;\n  count(filter?: Partial<T>): Promise<number>;\n}\n\nimport { BaseDao } from '../base.dao.ts';\nimport { CoordinationDao } from '../dao/coordination.dao.ts';\nimport { GraphDao } from '../dao/graph.dao.ts';\nimport { MemoryDao } from '../dao/memory.dao.ts';\n\n/**\n * Entity type constant mapping for type safety.\n */\nexport const EntityTypeValues = {\n  User: 'user' as const,\n  Agent: 'agent' as const,\n  Memory: 'memory' as const,\n  Swarm: 'swarm' as const,\n  Task: 'task' as const,\n  Workflow: 'workflow' as const,\n  Document: 'document' as const,\n  Context: 'context' as const,\n  Event: 'event' as const,\n  Node: 'node' as const,\n  Edge: 'edge' as const,\n  Vector: 'vector' as const,\n  Embedding: 'embedding' as const,\n  Coordination: 'coordination' as const,\n  Product: 'product' as const,\n  Project: 'project' as const,\n  Epic: 'epic' as const,\n  Feature: 'feature' as const,\n  PRD: 'prd' as const,\n  ADR: 'adr' as const,\n  Vision: 'vision' as const,\n  Relationship: 'relationship' as const,\n  WorkflowState: 'workflowState' as const,\n};\n\nexport type EntityTypeKey = keyof typeof EntityTypeValues;\nexport type EntityTypeValue = (typeof EntityTypeValues)[EntityTypeKey];\nexport type EntityType = EntityTypeValue;\n\n/**\n * Database configuration interface.\n *\n * @example\n */\nexport interface DatabaseConfig {\n  host?: string;\n  port?: number;\n  database?: string;\n  username?: string;\n  password?: string;\n  ssl?: boolean;\n  connectionString?: string;\n  [key: string]: any;\n}\n\n/**\n * Create a Data Access Object (DAO) for a specific entity type and database.\n *\n * This is a factory function that creates appropriate DAO instances based on\n * the entity type and database configuration provided.\n *\n * @template T - The entity type interface.\n * @param entityType - Type of entity (from EntityTypes enum).\n * @param databaseType - Type of database to connect to.\n * @param config - Database configuration object.\n * @param options.tableName\n * @param options.primaryKey\n * @param options.enableCaching\n * @param options.connectionPoolSize\n * @param options.logger\n * @param options - Optional settings for DAO creation.\n * @returns Promise resolving to configured DAO instance.\n * @example Basic DAO Creation\n * ```typescript\n * const userDao = await createDao<User>(\n *   EntityTypes.User,\n *   DatabaseTypes.PostgreSQL,\n *   {\n *     host: 'localhost',\n *     port: 5432,\n *     database: 'myapp',\n *     username: 'user',\n *     password: 'pass'\n *   }\n * );\n * ```\n */\nexport async function createDao<T>(\n  entityType: EntityType,\n  databaseType: DatabaseTypes,\n  config: DatabaseConfig,\n  options: {\n    tableName?: string;\n    primaryKey?: string;\n    enableCaching?: boolean;\n    connectionPoolSize?: number;\n    logger?: Console | { debug: Function; info: Function; warn: Function; error: Function };\n  } = {}\n): Promise<IDao<T>> {\n  // Set defaults based on entity type\n  const tableName = options?.tableName || getDefaultTableName(entityType);\n  const primaryKey = options?.primaryKey || 'id';\n  const logger = options?.logger || console;\n\n  // Create a mock adapter for now - in real implementation this would connect to actual database\n  const adapter: DatabaseAdapter = {\n    connect: async () => {},\n    disconnect: async () => {},\n    query: async () => ({ rows: [], rowCount: 0, executionTime: 0 }),\n    execute: async () => ({ affectedRows: 0, executionTime: 0 }),\n    transaction: async (fn) => fn({} as any),\n    health: async () => true,\n    getSchema: async () => ({ tables: [], views: [], version: '1.0.0' }),\n    getConnectionStats: async () => ({\n      total: 1,\n      active: 1,\n      idle: 0,\n      utilization: 100,\n      averageConnectionTime: 0,\n    }),\n  };\n\n  const iLogger: ILogger = {\n    debug: logger.debug?.bind(logger) || (() => {}),\n    info: logger.info?.bind(logger) || (() => {}),\n    warn: logger.warn?.bind(logger) || (() => {}),\n    error: logger.error?.bind(logger) || (() => {}),\n  };\n\n  // Create specialized DAOs based on entity type\n  switch (entityType) {\n    case EntityTypeValues.Memory:\n    case 'memory':\n      return createMemoryDao<T>(adapter, iLogger, tableName);\n\n    case EntityTypeValues.Product: // Use available enum value instead of Coordination\n    case 'coordination':\n      return createCoordinationDao<T>(adapter, iLogger, tableName);\n\n    case EntityTypeValues.Vector: // Use Vector instead of Graph for GraphDao\n    case 'node':\n    case 'edge':\n      return createGraphDao<T>(adapter, iLogger, tableName);\n\n    default:\n      // Cannot instantiate abstract BaseDao directly - create a concrete implementation\n      return new ConcreteDao<T>(adapter, iLogger, tableName);\n  }\n}\n\n/**\n * Concrete implementation of BaseDao for default cases.\n *\n * @example\n */\nclass ConcreteDao<T> extends BaseDao<T> {\n  constructor(adapter: DatabaseAdapter, logger: ILogger, tableName: string) {\n    super(adapter, logger, tableName);\n  }\n\n  protected mapRowToEntity(row: any): T {\n    return row as T;\n  }\n\n  protected mapEntityToRow(entity: Partial<T>): Record<string, any> {\n    return entity as Record<string, any>;\n  }\n}\n\n/**\n * Create a multi-database setup with primary database and fallbacks.\n *\n * This function creates a DAO that can work across multiple databases,\n * with a primary database for writes and optional fallback databases\n * for reads and caching.\n *\n * @template T - The entity type interface.\n * @param entityType - Type of entity (from EntityTypes enum).\n * @param primaryDatabase - Primary database configuration.\n * @param primaryDatabase.databaseType\n * @param fallbackDatabases - Array of fallback database configurations.\n * @param primaryDatabase.config\n * @param options.readPreference\n * @param options.writePolicy\n * @param options.failoverTimeout\n * @param options.logger\n * @param options - Optional settings for multi-database setup.\n * @returns Promise resolving to multi-database DAO instance.\n * @example Multi-Database Setup\n * ```typescript\n * const multiDao = await createMultiDatabaseSetup<User>(\n *   EntityTypes.User,\n *   { databaseType: 'postgresql', config: pgConfig },\n *   [{ databaseType: 'memory', config: cacheConfig }]\n * );\n * ```\n */\nexport async function createMultiDatabaseSetup<T>(\n  entityType: EntityType,\n  primaryDatabase: { databaseType: DatabaseTypes; config: DatabaseConfig },\n  fallbackDatabases: Array<{ databaseType: DatabaseTypes; config: DatabaseConfig }> = [],\n  options: {\n    readPreference?: 'primary' | 'fallback' | 'balanced';\n    writePolicy?: 'primary-only' | 'replicated';\n    failoverTimeout?: number;\n    logger?: Console | { debug: Function; info: Function; warn: Function; error: Function };\n  } = {}\n): Promise<IMultiDatabaseDao<T>> {\n  const primaryDao = await createDao<T>(\n    entityType,\n    primaryDatabase.databaseType,\n    primaryDatabase.config,\n    {\n      logger: options?.logger,\n    }\n  );\n\n  const fallbackDaos = await Promise.all(\n    fallbackDatabases.map((db) =>\n      createDao<T>(entityType, db.databaseType, db.config, {\n        logger: options?.logger,\n      })\n    )\n  );\n\n  // Return a multi-database DAO wrapper\n  return {\n    primary: primaryDao,\n    fallbacks: fallbackDaos,\n    readPreference: options?.readPreference || 'primary',\n    writePolicy: options?.writePolicy || 'primary-only',\n    failoverTimeout: options?.failoverTimeout || 5000,\n\n    async findById(id: string): Promise<T | null> {\n      try {\n        return await primaryDao.findById(id);\n      } catch (error) {\n        if (fallbackDaos.length > 0) {\n          for (const fallbackDao of fallbackDaos) {\n            try {\n              return await fallbackDao.findById(id);\n            } catch (fallbackError) {}\n          }\n        }\n        throw error;\n      }\n    },\n\n    async findAll(): Promise<T[]> {\n      const dao =\n        this.readPreference === 'fallback' && fallbackDaos.length > 0\n          ? fallbackDaos[0]\n          : primaryDao;\n\n      if (!dao) {\n        throw new Error('No DAO available');\n      }\n\n      try {\n        return await dao.findAll();\n      } catch (error) {\n        if (dao !== primaryDao) {\n          return await primaryDao.findAll();\n        }\n        throw error;\n      }\n    },\n\n    async create(entity: Omit<T, 'id'>): Promise<T> {\n      const created = await primaryDao.create(entity);\n\n      if (this.writePolicy === 'replicated') {\n        // Fire-and-forget replication to fallbacks\n        fallbackDaos.forEach((dao) => {\n          dao.create(entity).catch(() => {\n            // Log but don't fail the operation\n            options?.logger?.warn('Fallback replication failed');\n          });\n        });\n      }\n\n      return created;\n    },\n\n    async update(id: string, updates: Partial<T>): Promise<T | null> {\n      const updated = await primaryDao.update(id, updates);\n\n      if (this.writePolicy === 'replicated') {\n        fallbackDaos.forEach((dao) => {\n          dao.update(id, updates).catch(() => {\n            options?.logger?.warn('Fallback update failed');\n          });\n        });\n      }\n\n      return updated;\n    },\n\n    async delete(id: string): Promise<boolean> {\n      const deleted = await primaryDao.delete(id);\n\n      if (this.writePolicy === 'replicated') {\n        fallbackDaos.forEach((dao) => {\n          dao.delete(id).catch(() => {\n            options?.logger?.warn('Fallback deletion failed');\n          });\n        });\n      }\n\n      return deleted;\n    },\n\n    async findBy(filter: Partial<T>): Promise<T[]> {\n      const dao =\n        this.readPreference === 'fallback' && fallbackDaos.length > 0\n          ? fallbackDaos[0]\n          : primaryDao;\n\n      if (!dao) {\n        throw new Error('No DAO available');\n      }\n\n      try {\n        return await dao.findBy(filter);\n      } catch (error) {\n        if (dao !== primaryDao) {\n          return await primaryDao.findBy(filter);\n        }\n        throw error;\n      }\n    },\n\n    async count(filter?: Partial<T>): Promise<number> {\n      try {\n        return await primaryDao.count(filter);\n      } catch (error) {\n        if (fallbackDaos.length > 0) {\n          const fallbackDao = fallbackDaos[0];\n          if (fallbackDao) {\n            return await fallbackDao.count(filter);\n          }\n        }\n        throw error;\n      }\n    },\n  } as IMultiDatabaseDao<T>;\n}\n\n/**\n * Get default table name for entity type.\n *\n * @param entityType\n * @private\n * @example\n */\nfunction getDefaultTableName(entityType: EntityType): string {\n  // Convert entity type to plural table name\n  const entityMap: Record<string, string> = {\n    [EntityTypeValues.User]: 'users',\n    [EntityTypeValues.Agent]: 'agents',\n    [EntityTypeValues.Memory]: 'memories',\n    [EntityTypeValues.Swarm]: 'swarms',\n    [EntityTypeValues.Task]: 'tasks',\n    [EntityTypeValues.Workflow]: 'workflows',\n    [EntityTypeValues.Document]: 'documents',\n    [EntityTypeValues.Context]: 'contexts',\n    [EntityTypeValues.Event]: 'events',\n    [EntityTypeValues.Node]: 'nodes',\n    [EntityTypeValues.Edge]: 'edges',\n    [EntityTypeValues.Vector]: 'vectors',\n    [EntityTypeValues.Embedding]: 'embeddings',\n    [EntityTypeValues.Coordination]: 'coordination',\n    [EntityTypeValues.Product]: 'products',\n    [EntityTypeValues.Project]: 'projects',\n    [EntityTypeValues.Epic]: 'epics',\n    [EntityTypeValues.Feature]: 'features',\n    [EntityTypeValues.PRD]: 'prds',\n    [EntityTypeValues.ADR]: 'adrs',\n    [EntityTypeValues.Vision]: 'visions',\n    [EntityTypeValues.Relationship]: 'relationships',\n    [EntityTypeValues.WorkflowState]: 'workflow_states',\n  };\n\n  return entityMap[entityType] || `${entityType}s`;\n}\n\n/**\n * Factory functions to create specialized DAOs with proper constructor access.\n *\n * @param adapter\n * @param logger\n * @param tableName\n * @example\n */\nfunction createMemoryDao<T>(adapter: DatabaseAdapter, logger: ILogger, tableName: string): IDao<T> {\n  // Create a specialized memory DAO implementation\n  class MemoryDaoImpl extends MemoryDao<T> {\n    constructor(adapter: DatabaseAdapter, logger: ILogger, tableName: string) {\n      super(adapter, logger, tableName);\n    }\n  }\n  return new MemoryDaoImpl(adapter, logger, tableName) as IDao<T>;\n}\n\nfunction createCoordinationDao<T>(\n  adapter: DatabaseAdapter,\n  logger: ILogger,\n  tableName: string\n): IDao<T> {\n  // Create a specialized coordination DAO implementation\n  class CoordinationDaoImpl extends CoordinationDao<T> {\n    constructor(adapter: DatabaseAdapter, logger: ILogger, tableName: string) {\n      super(adapter, logger, tableName);\n    }\n  }\n  return new CoordinationDaoImpl(adapter, logger, tableName) as IDao<T>;\n}\n\nfunction createGraphDao<T>(adapter: DatabaseAdapter, logger: ILogger, tableName: string): IDao<T> {\n  // Create a specialized graph DAO implementation\n  class GraphDaoImpl extends GraphDao<T> {\n    constructor(adapter: DatabaseAdapter, logger: ILogger, tableName: string) {\n      super(adapter, logger, tableName);\n    }\n  }\n  return new GraphDaoImpl(adapter, logger, tableName) as IDao<T>;\n}\n"],
  "mappings": "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",
  "names": ["adapter", "logger", "tableName"]
}
