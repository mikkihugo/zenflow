{
  "version": 3,
  "sources": ["../../src/interfaces/terminal/state-hooks/use-config.ts", "../../src/interfaces/terminal/state-hooks/use-swarm-status.ts", "../../src/interfaces/terminal/utils/mock-command-handler.ts", "../../src/interfaces/terminal/index.ts", "../../src/interfaces/terminal/main.ts"],
  "sourcesContent": ["/**\n * Configuration State Hook.\n *\n * React hook for managing terminal interface configuration state.\n * Note: This is a React hook, NOT a Claude Code hook (which belongs in templates/).\n */\n/**\n * @file Interface implementation: use-config.\n */\n\nimport { useEffect, useState } from 'react';\nimport { getLogger } from '../../../config/logging-config.ts';\n\nconst logger = getLogger('ConfigHook');\n\nexport interface TerminalConfig {\n  theme: 'dark' | 'light';\n  refreshInterval: number;\n  verbose: boolean;\n  showAnimations: boolean;\n  swarmConfig: {\n    defaultTopology: 'mesh' | 'hierarchical' | 'ring' | 'star';\n    maxAgents: number;\n    autoRefresh: boolean;\n    showAdvancedMetrics: boolean;\n  };\n  ui: {\n    showBorders: boolean;\n    centerAlign: boolean;\n    compactMode: boolean;\n  };\n}\n\nconst defaultConfig: TerminalConfig = {\n  theme: 'dark',\n  refreshInterval: 3000,\n  verbose: false,\n  showAnimations: true,\n  swarmConfig: {\n    defaultTopology: 'mesh',\n    maxAgents: 10,\n    autoRefresh: true,\n    showAdvancedMetrics: false,\n  },\n  ui: {\n    showBorders: true,\n    centerAlign: false,\n    compactMode: false,\n  },\n};\n\nexport interface UseConfigReturn {\n  data: TerminalConfig;\n  isLoading: boolean;\n  error?: Error;\n  updateConfig: (updates: Partial<TerminalConfig>) => Promise<void>;\n  updateUIConfig: (updates: Partial<TerminalConfig['ui']>) => Promise<void>;\n  updateSwarmConfig: (updates: Partial<TerminalConfig['swarmConfig']>) => Promise<void>;\n  resetConfig: () => Promise<void>;\n}\n\n/**\n * Configuration React Hook.\n *\n * Provides reactive configuration management for terminal interface components.\n */\nexport const useConfig = (): UseConfigReturn => {\n  const [config, setConfig] = useState<TerminalConfig>(defaultConfig);\n  const [isLoading, setIsLoading] = useState(true);\n  const [error, setError] = useState<Error | undefined>(undefined);\n\n  // Load configuration on mount\n  useEffect(() => {\n    loadConfig();\n  }, [loadConfig]); // eslint-disable-line react-hooks/exhaustive-deps\n\n  const loadConfig = async () => {\n    try {\n      setIsLoading(true);\n      setError(undefined);\n\n      // Try to load config from file system\n      const loadedConfig = await loadConfigFromFile();\n      if (loadedConfig) {\n        setConfig({ ...defaultConfig, ...loadedConfig });\n      } else {\n        setConfig(defaultConfig);\n      }\n\n      logger.debug('Terminal configuration loaded successfully');\n    } catch (err) {\n      const error = err instanceof Error ? err : new Error('Failed to load configuration');\n      logger.error('Failed to load terminal configuration:', error);\n      setError(error);\n      setConfig(defaultConfig); // Fallback to default\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const loadConfigFromFile = async (): Promise<Partial<TerminalConfig> | null> => {\n    try {\n      // Try different config locations\n      const configPaths = [\n        './.claude/terminal-config.json',\n        './config/terminal.json',\n        `${process.env['HOME']}/.claude-zen/terminal-config.json`,\n      ];\n\n      for (const configPath of configPaths) {\n        try {\n          const fs = await import('node:fs/promises');\n          const configData = await fs.readFile(configPath, 'utf-8');\n          const parsedConfig = JSON.parse(configData);\n\n          if (parsedConfig?.terminal) {\n            return parsedConfig?.terminal;\n          } else if (parsedConfig?.theme || parsedConfig?.swarmConfig) {\n            return parsedConfig;\n          }\n        } catch (_err) {}\n      }\n\n      return null;\n    } catch (err) {\n      logger.warn('Could not load terminal config from file:', err);\n      return null;\n    }\n  };\n\n  const saveConfigToFile = async (newConfig: TerminalConfig) => {\n    try {\n      const fs = await import('node:fs/promises');\n      const path = await import('node:path');\n\n      // Ensure .claude directory exists\n      const configDir = './.claude';\n      try {\n        await fs.mkdir(configDir, { recursive: true });\n      } catch (_err) {\n        // Directory might already exist\n      }\n\n      const configPath = path.join(configDir, 'terminal-config.json');\n      const configData = JSON.stringify({ terminal: newConfig }, null, 2);\n\n      await fs.writeFile(configPath, configData, 'utf-8');\n      logger.debug('Terminal configuration saved to file');\n    } catch (err) {\n      logger.warn('Could not save terminal config to file:', err);\n      // Don't throw error - config updates should still work in memory\n    }\n  };\n\n  const updateConfig = async (updates: Partial<TerminalConfig>) => {\n    try {\n      const newConfig = { ...config, ...updates };\n      setConfig(newConfig);\n      await saveConfigToFile(newConfig);\n      logger.debug('Terminal configuration updated:', updates);\n    } catch (err) {\n      const error = err instanceof Error ? err : new Error('Failed to update configuration');\n      logger.error('Failed to update terminal configuration:', error);\n      setError(error);\n      throw error;\n    }\n  };\n\n  const updateUIConfig = async (updates: Partial<TerminalConfig['ui']>) => {\n    await updateConfig({\n      ui: { ...config?.ui, ...updates },\n    });\n  };\n\n  const updateSwarmConfig = async (updates: Partial<TerminalConfig['swarmConfig']>) => {\n    await updateConfig({\n      swarmConfig: { ...config?.swarmConfig, ...updates },\n    });\n  };\n\n  const resetConfig = async () => {\n    try {\n      setConfig(defaultConfig);\n      await saveConfigToFile(defaultConfig);\n      logger.debug('Terminal configuration reset to defaults');\n    } catch (err) {\n      const error = err instanceof Error ? err : new Error('Failed to reset configuration');\n      logger.error('Failed to reset terminal configuration:', error);\n      setError(error);\n      throw error;\n    }\n  };\n\n  return {\n    data: config,\n    isLoading,\n    error,\n    updateConfig,\n    updateUIConfig,\n    updateSwarmConfig,\n    resetConfig,\n  };\n};\n\nexport default useConfig;\n", "/**\n * Swarm Status State Hook.\n *\n * React hook for managing swarm state and providing real-time updates.\n * Note: This is a React hook, NOT a Claude Code hook (which belongs in templates/).\n */\n/**\n * @file Interface implementation: use-swarm-status.\n */\n\nimport { useEffect, useState } from 'react';\nimport { getLogger } from '../../../config/logging-config.ts';\n\nconst logger = getLogger('SwarmStatusHook');\n\n// Missing interface definitions\nexport interface SwarmMetrics {\n  totalAgents: number;\n  activeAgents: number;\n  tasksInProgress: number;\n  tasksCompleted: number;\n  totalTasks: number;\n  uptime: number;\n  performance: {\n    throughput: number;\n    errorRate: number;\n    avgLatency: number;\n  };\n}\n\nexport interface SwarmAgent {\n  id: string;\n  role: 'coordinator' | 'worker' | string;\n  status: 'active' | 'idle' | 'busy';\n  capabilities: string[];\n  lastActivity: Date;\n  metrics: {\n    tasksCompleted: number;\n    averageResponseTime: number;\n    errors: number;\n    successRate: number;\n    totalTasks: number;\n  };\n  cognitivePattern: string;\n  performanceScore: number;\n}\n\nexport interface SwarmTask {\n  id: string;\n  description: string;\n  status: 'pending' | 'in_progress' | 'completed' | 'failed';\n  progress: number;\n  assignedAgents: string[];\n  priority: 'low' | 'medium' | 'high';\n  startTime?: Date;\n  estimatedDuration?: number;\n}\n\nexport interface SwarmStatus {\n  status: 'idle' | 'active' | 'paused' | 'error' | 'unknown';\n  topology: 'mesh' | 'hierarchical' | 'ring' | 'star';\n  totalAgents: number;\n  activeAgents: number;\n  uptime: number;\n}\n\nexport interface SwarmState {\n  status: SwarmStatus;\n  metrics: SwarmMetrics;\n  agents: SwarmAgent[];\n  tasks: SwarmTask[];\n  lastUpdated: Date;\n}\n\nexport interface UseSwarmStatusOptions {\n  autoRefresh?: boolean;\n  refreshInterval?: number;\n  enableMockData?: boolean;\n}\n\nexport interface UseSwarmStatusReturn {\n  swarmState: SwarmState;\n  isLoading: boolean;\n  error?: Error;\n  refreshStatus: () => Promise<void>;\n  startAgent: (agentConfig: Partial<SwarmAgent>) => Promise<void>;\n  stopAgent: (agentId: string) => Promise<void>;\n  createTask: (taskConfig: Partial<SwarmTask>) => Promise<void>;\n  updateTask: (taskId: string, updates: Partial<SwarmTask>) => Promise<void>;\n}\n\nconst initialSwarmState: SwarmState = {\n  status: {\n    status: 'idle',\n    topology: 'mesh',\n    totalAgents: 0,\n    activeAgents: 0,\n    uptime: 0,\n  },\n  metrics: {\n    totalAgents: 0,\n    activeAgents: 0,\n    tasksInProgress: 0,\n    tasksCompleted: 0,\n    totalTasks: 0,\n    uptime: 0,\n    performance: {\n      throughput: 0,\n      errorRate: 0,\n      avgLatency: 0,\n    },\n  },\n  agents: [],\n  tasks: [],\n  lastUpdated: new Date(),\n};\n\n/**\n * Swarm Status React Hook.\n *\n * Provides reactive swarm state management with real-time updates for React components.\n *\n * @param options\n */\nexport const useSwarmStatus = (options: UseSwarmStatusOptions = {}): UseSwarmStatusReturn => {\n  const {\n    autoRefresh = true,\n    refreshInterval = 3000,\n    enableMockData = process.env['NODE_ENV'] === 'development',\n  } = options;\n\n  const [swarmState, setSwarmState] = useState<SwarmState>(initialSwarmState);\n  const [isLoading, setIsLoading] = useState(true);\n  const [error, setError] = useState<Error | undefined>(undefined);\n\n  const refreshStatus = async () => {\n    try {\n      setError(undefined);\n\n      if (enableMockData) {\n        // Use mock data for development\n        await loadMockSwarmData();\n      } else {\n        // Load real swarm data\n        await loadRealSwarmData();\n      }\n\n      logger.debug('Swarm status refreshed successfully');\n    } catch (err) {\n      const error = err instanceof Error ? err : new Error('Failed to refresh swarm status');\n      logger.error('Failed to refresh swarm status:', error);\n      setError(error);\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  // Auto-refresh effect\n  useEffect(() => {\n    // Initial load\n    refreshStatus();\n\n    if (autoRefresh) {\n      const interval = setInterval(refreshStatus, refreshInterval);\n      return () => clearInterval(interval);\n    }\n  }, [autoRefresh, refreshInterval]); // eslint-disable-line react-hooks/exhaustive-deps\n\n  const loadMockSwarmData = async () => {\n    // Simulate network delay\n    await new Promise((resolve) => setTimeout(resolve, 100));\n\n    const mockAgents: SwarmAgent[] = [\n      {\n        id: 'coordinator-main',\n        role: 'coordinator',\n        status: 'active',\n        capabilities: ['coordination', 'planning', 'monitoring', 'optimization'],\n        lastActivity: new Date(Date.now() - 1000),\n        metrics: {\n          tasksCompleted: Math.floor(Math.random() * 20) + 10,\n          averageResponseTime: 120 + Math.random() * 100,\n          errors: Math.floor(Math.random() * 2),\n          successRate: 0.95 + Math.random() * 0.05,\n          totalTasks: Math.floor(Math.random() * 25) + 10,\n        },\n        cognitivePattern: 'systems-thinking',\n        performanceScore: 0.9 + Math.random() * 0.1,\n      },\n      // Add more mock agents as needed\n    ];\n\n    const mockTasks: SwarmTask[] = [\n      {\n        id: 'task-doc-proc',\n        description: 'Process document-driven development workflow',\n        status: 'in_progress',\n        progress: 40 + Math.random() * 40,\n        assignedAgents: ['coordinator-main'],\n        priority: 'high',\n        startTime: new Date(Date.now() - 600000),\n        estimatedDuration: 1200000,\n      },\n      // Add more mock tasks as needed\n    ];\n\n    const activeAgents = mockAgents.filter((a) => a.status === 'active' || a.status === 'busy');\n    const uptime = Date.now() - (swarmState.status.uptime || Date.now() - 3600000);\n\n    const newState: SwarmState = {\n      status: {\n        status: activeAgents.length > 0 ? 'active' : 'idle',\n        topology: swarmState.status.topology,\n        totalAgents: mockAgents.length,\n        activeAgents: activeAgents.length,\n        uptime,\n      },\n      metrics: {\n        totalAgents: mockAgents.length,\n        activeAgents: activeAgents.length,\n        tasksInProgress: mockTasks.filter((t) => t.status === 'in_progress').length,\n        tasksCompleted: mockTasks.filter((t) => t.status === 'completed').length,\n        totalTasks: mockTasks.length,\n        uptime,\n        performance: {\n          throughput: 1.5 + Math.random() * 2.0,\n          errorRate: Math.random() * 0.1,\n          avgLatency: 150 + Math.random() * 100,\n        },\n      },\n      agents: mockAgents,\n      tasks: mockTasks,\n      lastUpdated: new Date(),\n    };\n\n    setSwarmState(newState);\n  };\n\n  const loadRealSwarmData = async () => {\n    // Attempt to load real swarm data with fallback to mock data\n    try {\n      // Try to import and use real swarm coordination through public API\n      const { createPublicSwarmCoordinator } = await import('../../../coordination/public-api.ts');\n      const coordinator = await createPublicSwarmCoordinator();\n\n      if (coordinator) {\n        const status = coordinator.getStatus();\n        const activeAgents = coordinator.getActiveAgents();\n\n        setSwarmState({\n          status: {\n            status: status.state === 'active' ? 'active' : 'idle',\n            topology: 'mesh', // Default topology\n            totalAgents: status.agentCount,\n            activeAgents: activeAgents.length,\n            uptime: status.uptime,\n          },\n          metrics: {\n            totalAgents: status.agentCount,\n            activeAgents: activeAgents.length,\n            tasksInProgress: status.taskCount,\n            tasksCompleted: Math.floor(Math.random() * 50), // Mock data for now\n            totalTasks: status.taskCount + Math.floor(Math.random() * 50),\n            uptime: status.uptime,\n            performance: {\n              throughput: Math.random() * 100,\n              errorRate: Math.random() * 0.05,\n              avgLatency: 120 + Math.random() * 80,\n            },\n          },\n          agents: activeAgents.map((agentId, index) => ({\n            id: agentId,\n            role: 'worker' as const,\n            status: 'active' as const,\n            capabilities: ['general'],\n            lastActivity: new Date(),\n            metrics: {\n              tasksCompleted: Math.floor(Math.random() * 20),\n              averageResponseTime: 120 + Math.random() * 80,\n              errors: Math.floor(Math.random() * 3),\n              successRate: 0.9 + Math.random() * 0.1,\n              totalTasks: Math.floor(Math.random() * 25),\n            },\n            cognitivePattern: 'adaptive',\n            performanceScore: 0.8 + Math.random() * 0.2,\n          })),\n          tasks: [], // Mock empty tasks for now\n          lastUpdated: new Date(),\n        });\n\n        logger.info('Real swarm data loaded successfully');\n        return;\n      }\n    } catch (err) {\n      logger.warn('Real swarm service not available, using mock data:', err);\n      await loadMockSwarmData();\n    }\n  };\n\n  const startAgent = async (agentConfig: Partial<SwarmAgent>) => {\n    try {\n      logger.debug('Starting agent:', agentConfig);\n\n      // Attempt to start real agent with fallback to simulation\n      try {\n        // Try to use real swarm coordinator to start agent\n        const { createPublicSwarmCoordinator } = await import(\n          '../../../coordination/public-api.ts'\n        );\n        const coordinator = await createPublicSwarmCoordinator();\n\n        if (coordinator) {\n          // For now, we'll simulate starting an agent since the public API doesn't expose agent spawning\n          logger.info('Simulating agent start through coordinator');\n          await loadRealSwarmData(); // Refresh data\n          return;\n        }\n      } catch (err) {\n        logger.warn('Real agent starting not available, simulating:', err);\n      }\n\n      // Fallback: simulate by adding to mock data\n      const newAgent: SwarmAgent = {\n        id: agentConfig?.id || `agent-${Date.now()}`,\n        role: agentConfig?.role || 'worker',\n        status: 'active',\n        capabilities: agentConfig?.capabilities || ['general'],\n        lastActivity: new Date(),\n        metrics: {\n          tasksCompleted: 0,\n          averageResponseTime: 0,\n          errors: 0,\n          successRate: 1.0,\n          totalTasks: 0,\n        },\n        cognitivePattern: agentConfig?.cognitivePattern || 'adaptive',\n        performanceScore: 1.0,\n        ...agentConfig,\n      };\n\n      setSwarmState((prev) => ({\n        ...prev,\n        agents: [...prev.agents, newAgent],\n        status: {\n          ...prev.status,\n          totalAgents: prev.status.totalAgents + 1,\n          activeAgents: prev.status.activeAgents + 1,\n        },\n        metrics: {\n          ...prev.metrics,\n          totalAgents: prev.metrics.totalAgents + 1,\n          activeAgents: prev.metrics.activeAgents + 1,\n        },\n        lastUpdated: new Date(),\n      }));\n\n      logger.debug('Agent started successfully:', newAgent.id);\n    } catch (err) {\n      const error = err instanceof Error ? err : new Error('Failed to start agent');\n      logger.error('Failed to start agent:', error);\n      throw error;\n    }\n  };\n\n  const stopAgent = async (agentId: string) => {\n    try {\n      logger.debug('Stopping agent:', agentId);\n\n      setSwarmState((prev) => ({\n        ...prev,\n        agents: prev.agents.map((agent) =>\n          agent.id === agentId ? { ...agent, status: 'idle' as const } : agent\n        ),\n        status: {\n          ...prev.status,\n          activeAgents: Math.max(0, prev.status.activeAgents - 1),\n        },\n        metrics: {\n          ...prev.metrics,\n          activeAgents: Math.max(0, prev.metrics.activeAgents - 1),\n        },\n        lastUpdated: new Date(),\n      }));\n\n      logger.debug('Agent stopped successfully:', agentId);\n    } catch (err) {\n      const error = err instanceof Error ? err : new Error('Failed to stop agent');\n      logger.error('Failed to stop agent:', error);\n      throw error;\n    }\n  };\n\n  const createTask = async (taskConfig: Partial<SwarmTask>) => {\n    try {\n      logger.debug('Creating task:', taskConfig);\n\n      const newTask: SwarmTask = {\n        id: taskConfig?.id || `task-${Date.now()}`,\n        description: taskConfig?.description || 'New task',\n        status: taskConfig?.status || 'pending',\n        progress: taskConfig?.progress || 0,\n        assignedAgents: taskConfig?.assignedAgents || [],\n        priority: taskConfig?.priority || 'medium',\n        startTime: taskConfig?.status === 'in_progress' ? new Date() : undefined,\n        ...taskConfig,\n      };\n\n      setSwarmState((prev) => ({\n        ...prev,\n        tasks: [...prev.tasks, newTask],\n        metrics: {\n          ...prev.metrics,\n          totalTasks: prev.metrics.totalTasks + 1,\n          tasksInProgress:\n            newTask.status === 'in_progress'\n              ? prev.metrics.tasksInProgress + 1\n              : prev.metrics.tasksInProgress,\n        },\n        lastUpdated: new Date(),\n      }));\n\n      logger.debug('Task created successfully:', newTask.id);\n    } catch (err) {\n      const error = err instanceof Error ? err : new Error('Failed to create task');\n      logger.error('Failed to create task:', error);\n      throw error;\n    }\n  };\n\n  const updateTask = async (taskId: string, updates: Partial<SwarmTask>) => {\n    try {\n      logger.debug('Updating task:', { taskId, updates });\n\n      setSwarmState((prev) => {\n        const oldTask = prev.tasks.find((t) => t.id === taskId);\n        const newTasks = prev.tasks.map((task) =>\n          task.id === taskId ? { ...task, ...updates } : task\n        );\n\n        // Recalculate metrics if status changed\n        let metricsUpdate = {};\n        if (oldTask && updates.status && oldTask.status !== updates.status) {\n          const inProgressChange =\n            (updates.status === 'in_progress' ? 1 : 0) - (oldTask.status === 'in_progress' ? 1 : 0);\n          const completedChange =\n            (updates.status === 'completed' ? 1 : 0) - (oldTask.status === 'completed' ? 1 : 0);\n\n          metricsUpdate = {\n            tasksInProgress: prev.metrics.tasksInProgress + inProgressChange,\n            tasksCompleted: prev.metrics.tasksCompleted + completedChange,\n          };\n        }\n\n        return {\n          ...prev,\n          tasks: newTasks,\n          metrics: {\n            ...prev.metrics,\n            ...metricsUpdate,\n          },\n          lastUpdated: new Date(),\n        };\n      });\n\n      logger.debug('Task updated successfully:', taskId);\n    } catch (err) {\n      const error = err instanceof Error ? err : new Error('Failed to update task');\n      logger.error('Failed to update task:', error);\n      throw error;\n    }\n  };\n\n  return {\n    swarmState,\n    isLoading,\n    error: error || undefined,\n    refreshStatus,\n    startAgent,\n    stopAgent,\n    createTask,\n    updateTask,\n  };\n};\n\nexport default useSwarmStatus;\n", "/**\n * Mock Command Handler - Delegates to Command Execution Engine.\n *\n * Thin wrapper around CommandExecutionEngine for backward compatibility.\n * Renamed to reflect its mock/testing nature per Google standards.\n */\n/**\n * @file Interface implementation: mock-command-handler.\n */\n\nimport { getLogger } from '../../../config/logging-config.ts';\nimport { CommandExecutionEngine } from '../command-execution-engine.ts';\nimport { getVersion } from './version-utils';\n\nconst logger = getLogger('mock-command-handler');\n\nexport interface CommandResult {\n  success: boolean;\n  message?: string;\n  data?: any;\n  error?: string;\n  timestamp?: Date;\n}\n\nexport interface CommandContext {\n  args: string[];\n  flags: Record<string, any>;\n  cwd: string;\n  config?: any;\n}\n\n/**\n * Execute terminal commands with unified result handling.\n *\n * @example\n */\nexport class MockCommandHandler {\n  /**\n   * Execute init command.\n   *\n   * @param args\n   * @param flags\n   */\n  static async executeInit(args: string[], flags: Record<string, any>): Promise<CommandResult> {\n    try {\n      const projectName = args[0] || 'claude-zen-project';\n      const template = flags.template || 'basic';\n\n      logger.debug(`Initializing project: ${projectName} with template: ${template}`);\n\n      // For now, provide a mock implementation since CLI structure has changed\n      // TODO: Integrate with actual CLI commands when available\n      logger.info(`Mock: Initializing project ${projectName} with template ${template}`);\n\n      const result = {\n        projectName,\n        template,\n        location: './project-output',\n        files: ['package.json', 'README.md', 'src/index.ts'],\n      };\n\n      return {\n        success: true,\n        message: `Project \"${projectName}\" initialized successfully`,\n        data: result,\n      };\n    } catch (error) {\n      logger.error('Init command failed:', error);\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : 'Init command failed',\n      };\n    }\n  }\n\n  /**\n   * Execute status command.\n   *\n   * @param _args\n   * @param flags\n   */\n  static async executeStatus(_args: string[], flags: Record<string, any>): Promise<CommandResult> {\n    try {\n      logger.debug('Getting system status');\n\n      // Get basic system status without complex dependencies\n      const interfaceStatus = {\n        active: false,\n        mode: 'none',\n      };\n\n      const status = {\n        version: getVersion(),\n        status: 'healthy',\n        uptime: process.uptime() * 1000,\n        components: {\n          mcp: { status: 'ready', port: 3000 },\n          swarm: { status: 'ready', agents: 0 },\n          memory: { status: 'ready', usage: process.memoryUsage() },\n          terminal: {\n            status: 'ready',\n            mode: interfaceStatus.mode || 'none',\n            active: interfaceStatus.active,\n          },\n        },\n        environment: {\n          node: process.version,\n          platform: process.platform,\n          arch: process.arch,\n          pid: process.pid,\n        },\n      };\n\n      if (flags.json) {\n        return {\n          success: true,\n          data: status,\n        };\n      }\n\n      return {\n        success: true,\n        message: 'System status retrieved successfully',\n        data: status,\n      };\n    } catch (error) {\n      logger.error('Status command failed:', error);\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : 'Status command failed',\n      };\n    }\n  }\n\n  /**\n   * Execute swarm command.\n   *\n   * @param args\n   * @param flags\n   */\n  static async executeSwarm(args: string[], flags: Record<string, any>): Promise<CommandResult> {\n    try {\n      const action = args[0];\n\n      if (!action) {\n        return {\n          success: false,\n          error: 'Swarm action required. Use: start, stop, list, status',\n        };\n      }\n\n      logger.debug(`Executing swarm action: ${action}`);\n\n      switch (action) {\n        case 'start':\n          return {\n            success: true,\n            message: `Swarm started successfully with ${flags.agents || 4} agents`,\n            data: {\n              swarmId: `swarm-${Date.now()}`,\n              agents: flags.agents || 4,\n              topology: flags.topology || 'mesh',\n            },\n          };\n\n        case 'stop':\n          return {\n            success: true,\n            message: 'Swarm stopped successfully',\n          };\n\n        case 'list':\n          return {\n            success: true,\n            data: {\n              swarms: [\n                {\n                  id: 'swarm-1',\n                  name: 'Document Processing',\n                  status: 'active',\n                  agents: 4,\n                  topology: 'mesh',\n                  uptime: 3600000,\n                },\n                {\n                  id: 'swarm-2',\n                  name: 'Feature Development',\n                  status: 'inactive',\n                  agents: 0,\n                  topology: 'hierarchical',\n                  uptime: 0,\n                },\n              ],\n            },\n          };\n\n        case 'status':\n          return {\n            success: true,\n            data: {\n              totalSwarms: 2,\n              activeSwarms: 1,\n              totalAgents: 4,\n              activeAgents: 4,\n              averageUptime: 1800000,\n              systemLoad: 0.65,\n            },\n          };\n\n        default:\n          return {\n            success: false,\n            error: `Unknown swarm action: ${action}. Use: start, stop, list, status`,\n          };\n      }\n    } catch (error) {\n      logger.error('Swarm command failed:', error);\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : 'Swarm command failed',\n      };\n    }\n  }\n\n  /**\n   * Execute MCP command.\n   *\n   * @param args\n   * @param flags\n   */\n  static async executeMCP(args: string[], flags: Record<string, any>): Promise<CommandResult> {\n    try {\n      const action = args[0];\n\n      if (!action) {\n        return {\n          success: false,\n          error: 'MCP action required. Use: start, stop, status',\n        };\n      }\n\n      logger.debug(`Executing MCP action: ${action}`);\n\n      switch (action) {\n        case 'start': {\n          const port = flags.port || 3000;\n          return {\n            success: true,\n            message: `MCP server started on port ${port}`,\n            data: {\n              port,\n              url: `http://localhost:${port}`,\n              protocol: flags.stdio ? 'stdio' : 'http',\n            },\n          };\n        }\n\n        case 'stop':\n          return {\n            success: true,\n            message: 'MCP server stopped successfully',\n          };\n\n        case 'status':\n          return {\n            success: true,\n            data: {\n              httpServer: {\n                status: 'running',\n                port: 3000,\n                uptime: process.uptime() * 1000,\n              },\n              swarmServer: {\n                status: 'running',\n                protocol: 'stdio',\n                connections: 0,\n              },\n            },\n          };\n\n        default:\n          return {\n            success: false,\n            error: `Unknown MCP action: ${action}. Use: start, stop, status`,\n          };\n      }\n    } catch (error) {\n      logger.error('MCP command failed:', error);\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : 'MCP command failed',\n      };\n    }\n  }\n\n  /**\n   * Execute workspace command.\n   *\n   * @param args\n   * @param _flags\n   */\n  static async executeWorkspace(\n    args: string[],\n    _flags: Record<string, any>\n  ): Promise<CommandResult> {\n    try {\n      const action = args[0];\n\n      if (!action) {\n        return {\n          success: false,\n          error: 'Workspace action required. Use: init, process, status',\n        };\n      }\n\n      logger.debug(`Executing workspace action: ${action}`);\n\n      switch (action) {\n        case 'init': {\n          const projectName = args[1] || 'claude-zen-workspace';\n          return {\n            success: true,\n            message: `Document-driven workspace \"${projectName}\" initialized`,\n            data: {\n              projectName,\n              structure: [\n                'docs/01-vision/',\n                'docs/02-adrs/',\n                'docs/03-prds/',\n                'docs/04-epics/',\n                'docs/05-features/',\n                'docs/06-tasks/',\n                'src/',\n                'tests/',\n              ],\n            },\n          };\n        }\n\n        case 'process': {\n          const docPath = args[1];\n          if (!docPath) {\n            return {\n              success: false,\n              error: 'Document path required for processing',\n            };\n          }\n\n          return {\n            success: true,\n            message: `Document processed: ${docPath}`,\n            data: {\n              docPath,\n              generatedFiles: [\n                'docs/02-adrs/auth-architecture.md',\n                'docs/03-prds/user-management.md',\n                'docs/04-epics/authentication-system.md',\n              ],\n            },\n          };\n        }\n\n        case 'status':\n          return {\n            success: true,\n            data: {\n              documentsProcessed: 5,\n              tasksGenerated: 23,\n              implementationProgress: 0.65,\n              lastUpdate: new Date().toISOString(),\n            },\n          };\n\n        default:\n          return {\n            success: false,\n            error: `Unknown workspace action: ${action}. Use: init, process, status`,\n          };\n      }\n    } catch (error) {\n      logger.error('Workspace command failed:', error);\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : 'Workspace command failed',\n      };\n    }\n  }\n\n  /**\n   * Execute any command - delegates to CommandExecutionEngine.\n   *\n   * @param command\n   * @param args\n   * @param flags\n   */\n  static async executeCommand(\n    command: string,\n    args: string[],\n    flags: Record<string, any>\n  ): Promise<CommandResult> {\n    logger.debug(`Delegating command execution to engine: ${command}`);\n\n    try {\n      // Delegate to the pure TypeScript engine\n      const result = await CommandExecutionEngine.executeCommand(command, args, flags, {\n        cwd: process.cwd(),\n      });\n\n      // Convert engine result to expected format\n      return {\n        success: result?.success,\n        message: result?.message,\n        data: result?.data,\n        error: result?.error,\n      };\n    } catch (error) {\n      logger.error(`Mock command handler failed for ${command}:`, error);\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : 'Command execution failed',\n      };\n    }\n  }\n}\n", "/**\n * Unified Terminal Interface - Main Export.\n *\n * Consolidates command execution and interactive terminal functionality into a single interface.\n * This replaces the separate command execution and interactive terminal interface directories.\n */\n\n// Business logic (separated from UI)\n/**\n * @file Terminal module exports.\n */\n\nexport * from './command-execution-engine.ts';\nexport { CommandExecutionEngine } from './command-execution-engine.ts';\nexport * from './command-execution-renderer';\nexport { type CommandExecutionProps, CommandExecutionRenderer } from './command-execution-renderer';\n// Additional specific component exports to resolve conflicts\nexport type { SwarmStatus } from './components/header';\n// Components - specific exports to avoid conflicts\nexport {\n  type BaseComponentProps,\n  ComponentUtils,\n  defaultUnifiedTheme,\n  ErrorMessage,\n  type ErrorMessageProps,\n  Footer,\n  type FooterProps,\n  Header,\n  type HeaderProps,\n  ProgressBar,\n  type ProgressBarProps,\n  Spinner,\n  type SpinnerProps,\n  StatusBadge,\n  type StatusBadgeProps,\n  type Theme,\n} from './components/index.ts';\n\nexport * from './interactive-terminal-application';\nexport {\n  InteractiveTerminalApplication,\n  type TUIModeProps,\n} from './interactive-terminal-application';\n\n// Process orchestrator - specific export to avoid conflicts\nexport {\n  type ProcessResult,\n  type TerminalConfig,\n  TerminalManager,\n  type TerminalSession,\n} from './process-orchestrator.ts';\n\n// Screens - specific exports to avoid conflicts\nexport {\n  defaultScreenConfigs,\n  MainMenu,\n  type MainMenuProps,\n  type ScreenConfig,\n  type ScreenType,\n  ScreenUtils,\n  SwarmDashboard,\n  type SwarmDashboardProps,\n} from './screens/index.ts';\n\n// Additional screen type exports to resolve conflicts\nexport type { SwarmAgent, SwarmMetrics, SwarmTask } from './screens/swarm-dashboard';\n// State Hooks (React hooks for component state management) - avoid conflicts\n// Note: Re-exporting from state-hooks causes conflicts, import directly when needed\n// Specific exports to avoid conflicts:\nexport { type UseConfigReturn, useConfig } from './state-hooks/use-config.ts';\nexport {\n  type SwarmState,\n  type UseSwarmStatusReturn,\n  useSwarmStatus,\n} from './state-hooks/use-swarm-status.ts';\n\n// Main components (updated for Google standards)\nexport * from './terminal-interface-router';\n// Re-export key items for convenience (updated names)\nexport { TerminalApp, type TerminalAppProps } from './terminal-interface-router';\nexport * from './utils/mock-command-handler.ts';\n\nexport {\n  type CommandContext,\n  type CommandResult,\n  MockCommandHandler,\n} from './utils/mock-command-handler.ts';\n// Utilities (updated for Google standards)\nexport * from './utils/mode-detector.ts';\nexport {\n  detectMode,\n  detectModeWithReason,\n  getEnvironmentInfo,\n  isCommandExecutionSupported,\n  isInteractiveSupported,\n  type ModeDetectionResult,\n  type TerminalMode,\n} from './utils/mode-detector.ts';\n\n// Terminal interface configuration\nexport interface TerminalInterfaceConfig {\n  mode?: 'auto' | 'command' | 'interactive';\n  theme?: 'dark' | 'light';\n  verbose?: boolean;\n  debug?: boolean;\n  autoRefresh?: boolean;\n  refreshInterval?: number;\n}\n\n// Terminal interface class for external integration\nexport class TerminalInterface {\n  private config: TerminalInterfaceConfig;\n\n  constructor(config: TerminalInterfaceConfig = {}) {\n    this.config = {\n      mode: 'auto',\n      theme: 'dark',\n      verbose: false,\n      autoRefresh: true,\n      refreshInterval: 3000,\n      ...config,\n    };\n  }\n\n  /**\n   * Initialize the terminal interface.\n   */\n  async initialize(): Promise<void> {\n    // Initialization logic if needed\n  }\n\n  /**\n   * Render the terminal interface.\n   */\n  async render(): Promise<void> {\n    const { render } = await import('ink');\n    const React = await import('react');\n    const { TerminalApp } = await import('./terminal-interface-router');\n\n    // Determine mode\n    const _mode =\n      this.config.mode === 'auto'\n        ? detectMode(process.argv.slice(2), {})\n        : (this.config.mode as TerminalMode);\n\n    const commands = process.argv.slice(2).filter((arg) => !arg.startsWith('-'));\n    const flags = this.parseFlags(process.argv.slice(2));\n    if (this.config.debug) {\n      console.log('Debug mode enabled', { mode: _mode, commands, flags });\n    }\n\n    // Render the appropriate interface\n    const { unmount } = render(\n      React.createElement(TerminalApp, {\n        commands,\n        flags: { ...flags, ...this.config },\n        onExit: (code: number) => process.exit(code),\n      })\n    );\n\n    // Setup graceful shutdown\n    const shutdown = () => {\n      unmount();\n      process.exit(0);\n    };\n\n    process.on('SIGINT', shutdown);\n    process.on('SIGTERM', shutdown);\n  }\n\n  /**\n   * Parse command line flags.\n   *\n   * @param args\n   */\n  private parseFlags(args: string[]): Record<string, any> {\n    const flags: Record<string, any> = {};\n\n    for (let i = 0; i < args.length; i++) {\n      const arg = args[i];\n\n      if (arg && arg.startsWith('--')) {\n        const key = arg.slice(2);\n        const nextArg = args[i + 1];\n\n        if (nextArg && !nextArg.startsWith('-')) {\n          flags[key] = nextArg;\n          i++; // Skip next arg\n        } else {\n          flags[key] = true;\n        }\n      } else if (arg && arg.startsWith('-')) {\n        const key = arg.slice(1);\n        flags[key] = true;\n      }\n    }\n\n    return flags;\n  }\n\n  /**\n   * Get current configuration.\n   */\n  getConfig(): TerminalInterfaceConfig {\n    return { ...this.config };\n  }\n\n  /**\n   * Update configuration.\n   *\n   * @param updates\n   */\n  updateConfig(updates: Partial<TerminalInterfaceConfig>): void {\n    this.config = { ...this.config, ...updates };\n  }\n}\n\n// Convenience functions for direct usage\nexport const createTerminalInterface = (config?: TerminalInterfaceConfig) => {\n  return new TerminalInterface(config);\n};\n\nexport const launchTerminalInterface = async (config?: TerminalInterfaceConfig) => {\n  const terminal = new TerminalInterface(config);\n  await terminal.initialize();\n  await terminal.render();\n};\n\n// Version info\nexport const TERMINAL_INTERFACE_VERSION = '1.0.0';\n\n// Export default for convenience\nexport default TerminalInterface;\n", "#!/usr/bin/env node\n/**\n * @file Main Terminal Interface Entry Point.\n *\n * This is the main entry point for the Claude-Zen terminal interface.\n * It gets called by the CLI binary and launches the appropriate terminal interface.\n */\nimport { getLogger } from '../../config/logging-config.ts';\nimport { detectModeWithReason, launchTerminalInterface } from './index.ts';\n\nconst logger = getLogger('interfaces-terminal-main');\n\n/**\n * Main entry point for terminal interface.\n *\n * @example\n */\nasync function main() {\n  try {\n    // Parse command line arguments\n    const args = process.argv.slice(2);\n    const commands = args.filter((arg) => !arg.startsWith('-'));\n    const flags = parseFlags(args);\n\n    // Detect terminal mode with debugging\n    const modeResult = detectModeWithReason(commands, flags);\n\n    if (flags.verbose || flags.debug) {\n    }\n\n    // Launch the terminal interface\n    await launchTerminalInterface({\n      mode: flags.mode || modeResult?.mode,\n      theme: flags.theme || 'dark',\n      verbose: flags.verbose || false,\n      autoRefresh: !flags['no-refresh'],\n      refreshInterval:\n        typeof flags['refresh-interval'] === 'number'\n          ? flags['refresh-interval']\n          : (typeof flags['refresh-interval'] === 'string'\n              ? parseInt(flags['refresh-interval'])\n              : 3000) || 3000,\n    });\n  } catch (error) {\n    logger.error('\u274C Failed to launch terminal interface:', error);\n    process.exit(1);\n  }\n}\n\n/**\n * Terminal interface flag values.\n *\n * @example\n */\ninterface TerminalFlags {\n  // Mode flags\n  mode?: 'auto' | 'command' | 'interactive';\n  ui?: boolean;\n  tui?: boolean;\n  interactive?: boolean;\n  i?: boolean;\n\n  // Appearance flags\n  theme?: 'dark' | 'light';\n\n  // Behavior flags\n  verbose?: boolean;\n  debug?: boolean;\n  'no-refresh'?: boolean;\n  'refresh-interval'?: string | number;\n\n  // Special flags\n  version?: boolean;\n  v?: boolean;\n  help?: boolean;\n  h?: boolean;\n  web?: boolean;\n  port?: string | number;\n\n  // Additional string or boolean flags\n  [key: string]: string | number | boolean | undefined;\n}\n\n/**\n * Parse command line flags into typed object.\n *\n * @param args\n * @example\n */\nfunction parseFlags(args: string[]): TerminalFlags {\n  const flags: TerminalFlags = {};\n\n  for (let i = 0; i < args.length; i++) {\n    const arg = args[i];\n\n    if (arg && arg.startsWith('--')) {\n      const key = arg.slice(2);\n      const nextArg = args[i + 1];\n\n      if (nextArg && !nextArg.startsWith('-')) {\n        // Handle special types\n        if (key === 'refresh-interval') {\n          const parsed = parseInt(nextArg);\n          flags[key] = Number.isNaN(parsed) ? 3000 : parsed;\n        } else if (key === 'port') {\n          const parsed = parseInt(nextArg);\n          flags[key] = Number.isNaN(parsed) ? nextArg : parsed;\n        } else {\n          flags[key] = nextArg;\n        }\n        i++; // Skip next arg\n      } else {\n        flags[key] = true;\n      }\n    } else if (arg && arg.startsWith('-') && arg.length > 1) {\n      const key = arg.slice(1);\n      flags[key] = true;\n    }\n  }\n\n  return flags;\n}\n\n// Handle graceful shutdown\nprocess.on('SIGINT', () => {\n  process.exit(0);\n});\n\nprocess.on('SIGTERM', () => {\n  process.exit(0);\n});\n\n// Launch if called directly (compatible with CommonJS and ESM)\nconst isMainModule = process.argv[1]?.endsWith('main.js') || process.argv[1]?.endsWith('main.ts');\nif (isMainModule) {\n  main().catch((error) => {\n    logger.error('\uD83D\uDCA5 Fatal error:', error);\n    process.exit(1);\n  });\n}\n\nexport { main };\nexport default main;\n"],
  "mappings": "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",
  "names": ["import_react", "logger", "logger", "TerminalApp", "logger"]
}
