import { existsSync, watch } from 'fs';
import { join } from 'path';
import { getLogger } from '../../../../config/logging-config.js';
const logger = getLogger('mcp-auto-generator-integration');
export class AutoGeneratedToolsManager {
    config;
    tools = new Map();
    watchers = [];
    constructor(config) {
        this.config = {
            enableHotReload: false,
            prefix: 'auto_',
            validation: {
                validateInputs: true,
                validateOutputs: false,
            },
            ...config,
        };
    }
    async initialize() {
        logger.info('Initializing auto-generated tools manager', {
            dir: this.config.generatedToolsDir,
            hotReload: this.config.enableHotReload,
        });
        await this.loadGeneratedTools();
        if (this.config.enableHotReload) {
            await this.setupHotReload();
        }
        logger.info('Auto-generated tools manager initialized', {
            toolsLoaded: this.tools.size,
        });
    }
    async loadGeneratedTools() {
        const indexPath = join(this.config.generatedToolsDir, 'index.js');
        if (!existsSync(indexPath)) {
            logger.warn('No generated tools found', { path: indexPath });
            return;
        }
        try {
            if (require.cache[indexPath]) {
                delete require.cache[indexPath];
            }
            const cacheBuster = Date.now();
            const module = await import(`${indexPath}?t=${cacheBuster}`);
            const { GENERATED_MCP_TOOLS, GENERATED_MCP_HANDLERS, executeGeneratedTool, } = module;
            if (!(GENERATED_MCP_TOOLS && GENERATED_MCP_HANDLERS)) {
                logger.warn('Generated tools module missing expected exports');
                return;
            }
            this.tools.clear();
            for (const toolDef of GENERATED_MCP_TOOLS) {
                const handler = GENERATED_MCP_HANDLERS[toolDef.name];
                if (!handler) {
                    logger.warn('Handler not found for tool', { tool: toolDef.name });
                    continue;
                }
                const tool = {
                    name: `${this.config.prefix}${toolDef.name}`,
                    description: toolDef.description,
                    inputSchema: toolDef.inputSchema,
                    handler: this.createToolHandler(toolDef.name, executeGeneratedTool),
                };
                this.tools.set(tool.name, tool);
            }
            logger.info('Loaded generated tools', { count: this.tools.size });
        }
        catch (error) {
            logger.error('Failed to load generated tools', {
                error: error instanceof Error ? error.message : String(error),
                path: indexPath,
            });
        }
    }
    createToolHandler(originalToolName, executeFunction) {
        return async (args) => {
            try {
                if (this.config.validation?.validateInputs) {
                    await this.validateInput(originalToolName, args);
                }
                const result = await executeFunction(originalToolName, args);
                if (this.config.validation?.validateOutputs) {
                    await this.validateOutput(originalToolName, result);
                }
                return result;
            }
            catch (error) {
                logger.error('Auto-generated tool execution failed', {
                    tool: originalToolName,
                    error: error instanceof Error ? error.message : String(error),
                });
                if (error instanceof Error) {
                    error.message = `Tool ${originalToolName}: ${error.message}`;
                }
                throw error;
            }
        };
    }
    async validateInput(toolName, args) {
        const tool = Array.from(this.tools.values()).find((t) => t.name.endsWith(toolName) ||
            t.name === `${this.config.prefix}${toolName}`);
        if (!tool) {
            return;
        }
        const schema = tool.inputSchema;
        if (schema.required) {
            for (const field of schema.required) {
                if (args[field] === undefined) {
                    throw new Error(`Required field '${field}' is missing`);
                }
            }
        }
        for (const [key, value] of Object.entries(args)) {
            const propSchema = schema.properties[key];
            if (propSchema && !this.validateType(value, propSchema)) {
                throw new Error(`Invalid type for field '${key}'`);
            }
        }
    }
    async validateOutput(toolName, result) {
        if (!result || typeof result !== 'object') {
            logger.warn('Tool returned unexpected result format', { tool: toolName });
        }
    }
    validateType(value, schema) {
        switch (schema.type) {
            case 'string':
                return typeof value === 'string';
            case 'number':
            case 'integer':
                return typeof value === 'number';
            case 'boolean':
                return typeof value === 'boolean';
            case 'array':
                return Array.isArray(value);
            case 'object':
                return typeof value === 'object' && value !== null;
            default:
                return true;
        }
    }
    async setupHotReload() {
        const watchDir = this.config.generatedToolsDir;
        if (!existsSync(watchDir)) {
            logger.warn('Watch directory does not exist', { dir: watchDir });
            return;
        }
        try {
            const watcher = watch(watchDir, { recursive: true }, (eventType, filename) => {
                if (filename === 'index.js' || filename === 'index.ts') {
                    logger.info('Generated tools changed - reloading', {
                        file: filename,
                    });
                    setTimeout(async () => {
                        try {
                            await this.loadGeneratedTools();
                            logger.info('Hot-reload completed', {
                                toolsLoaded: this.tools.size,
                            });
                        }
                        catch (error) {
                            logger.error('Hot-reload failed', {
                                error: error instanceof Error ? error.message : String(error),
                            });
                        }
                    }, 1000);
                }
            });
            this.watchers.push(watcher);
            logger.info('Hot-reload monitoring enabled', { dir: watchDir });
        }
        catch (error) {
            logger.error('Failed to setup hot-reload', {
                error: error instanceof Error ? error.message : String(error),
                dir: watchDir,
            });
        }
    }
    getTools() {
        return Array.from(this.tools.values());
    }
    getTool(name) {
        return this.tools.get(name);
    }
    async executeTool(name, args) {
        const tool = this.tools.get(name);
        if (!tool) {
            throw new Error(`Tool not found: ${name}`);
        }
        return await tool.handler(args);
    }
    getToolDefinitions() {
        return Array.from(this.tools.values()).map((tool) => ({
            name: tool.name,
            description: tool.description,
            inputSchema: tool.inputSchema,
        }));
    }
    async shutdown() {
        logger.info('Shutting down auto-generated tools manager');
        for (const watcher of this.watchers) {
            try {
                watcher.close();
            }
            catch (error) {
                logger.error('Failed to close watcher', {
                    error: error instanceof Error ? error.message : String(error),
                });
            }
        }
        this.watchers = [];
        this.tools.clear();
        logger.info('Auto-generated tools manager shutdown complete');
    }
    getStats() {
        const toolsByNamespace = {};
        for (const tool of this.tools.values()) {
            const namespace = tool.name.split('_')[0] || 'unknown';
            toolsByNamespace[namespace] = (toolsByNamespace[namespace] || 0) + 1;
        }
        return {
            totalTools: this.tools.size,
            toolsByNamespace,
            hotReloadEnabled: this.config.enableHotReload,
        };
    }
    async refresh() {
        logger.info('Manually refreshing auto-generated tools');
        await this.loadGeneratedTools();
        logger.info('Manual refresh completed', { toolsLoaded: this.tools.size });
    }
}
export function createAutoGeneratedToolsManager(config) {
    return new AutoGeneratedToolsManager(config);
}
export async function integrateAutoGeneratedTools(mcpServer, config) {
    const manager = new AutoGeneratedToolsManager(config);
    await manager.initialize();
    const tools = manager.getToolDefinitions();
    for (const tool of tools) {
        try {
            if (typeof mcpServer.registerTool === 'function') {
                mcpServer.registerTool(tool, async (args) => {
                    return await manager.executeTool(tool.name, args);
                });
            }
            logger.debug('Registered auto-generated tool with MCP server', {
                tool: tool.name,
            });
        }
        catch (error) {
            logger.error('Failed to register auto-generated tool', {
                tool: tool.name,
                error: error instanceof Error ? error.message : String(error),
            });
        }
    }
    logger.info('Auto-generated tools integrated with MCP server', {
        toolsRegistered: tools.length,
    });
    return manager;
}
export default AutoGeneratedToolsManager;
//# sourceMappingURL=mcp-integration.js.map