/**
 * Steering Document Quality Validator
 * 
 * Comprehensive quality validation system for steering documents including
 * format checking, content analysis, completeness validation, and quality scoring.
 */

import { readFile } from 'fs/promises';

// Try to import natural, fall back to basic implementation if not available
let natural;
try {
  natural = await import('natural');
} catch (error) {
  // Create basic NLP fallbacks when natural is not available
  natural = {
    PorterStemmer: { stem: (word) => word.toLowerCase() },
    SentimentAnalyzer: class { analyze() { return 1; } },
    WordTokenizer: class { tokenize(text) { return text.toLowerCase().split(/\s+/).filter(w => w.length > 0); } }
  };
}

// Quality scoring weights
const QUALITY_WEIGHTS = {
  format: 0.25,      // Document structure and formatting
  completeness: 0.30, // Required sections and content
  clarity: 0.20,     // Language clarity and readability
  specificity: 0.15, // Specific, actionable content
  consistency: 0.10  // Internal consistency and coherence
};

// Quality thresholds
const QUALITY_THRESHOLDS = {
  excellent: 0.90,
  good: 0.75,
  acceptable: 0.60,
  poor: 0.45,
  unacceptable: 0.30
};

export class SteeringQualityValidator {
  constructor(options = {}) {
    this.stemmer = natural.PorterStemmer;
    this.sentiment = new natural.SentimentAnalyzer('English', 
      natural.PorterStemmer, ['negation']);
    this.tokenizer = new natural.WordTokenizer();
    this.options = {
      strictMode: options.strictMode ?? false,
      enableNLP: options.enableNLP ?? true,
      customRules: options.customRules ?? []
    };
  }

  /**
   * Comprehensive quality validation of steering document
   */
  async validateDocument(content, domain, expectedQuality = 'standard') {
    const validation = {
      timestamp: new Date().toISOString(),
      domain,
      expectedQuality,
      scores: {},
      issues: [],
      recommendations: [],
      metadata: this.extractMetadata(content)
    };

    // Run all validation checks
    validation.scores.format = this.validateFormat(content, validation.issues);
    validation.scores.completeness = this.validateCompleteness(content, domain, validation.issues);
    validation.scores.clarity = this.validateClarity(content, validation.issues);
    validation.scores.specificity = this.validateSpecificity(content, validation.issues);
    validation.scores.consistency = this.validateConsistency(content, validation.issues);

    // Calculate overall quality score
    validation.overallScore = this.calculateOverallScore(validation.scores);
    validation.qualityLevel = this.getQualityLevel(validation.overallScore);
    validation.passed = validation.overallScore >= QUALITY_THRESHOLDS[expectedQuality];

    // Generate recommendations
    validation.recommendations = this.generateRecommendations(validation);

    return validation;
  }

  /**
   * Extract document metadata for analysis
   */
  extractMetadata(content) {
    const lines = content.split('\n');
    const words = this.tokenizer.tokenize(content.toLowerCase());
    const sentences = content.split(/[.!?]+/).filter(s => s.trim().length > 0);
    
    return {
      lineCount: lines.length,
      wordCount: words ? words.length : 0,
      sentenceCount: sentences.length,
      avgWordsPerSentence: sentences.length > 0 ? (words ? words.length : 0) / sentences.length : 0,
      headingCount: lines.filter(line => line.match(/^#+/)).length,
      listItemCount: lines.filter(line => line.match(/^[\s]*[-*+]/)).length,
      codeBlockCount: (content.match(/```/g) || []).length / 2,
      linkCount: (content.match(/\[.*?\]\(.*?\)/g) || []).length
    };
  }

  /**
   * Validate document format and structure
   */
  validateFormat(content, issues) {
    let score = 1.0;
    const formatChecks = [
      {
        name: 'Main Title',
        pattern: /^#\s+.+Steering Document/m,
        weight: 0.25,
        required: true
      },
      {
        name: 'Overview Section',
        pattern: /##\s+Overview/m,
        weight: 0.20,
        required: true
      },
      {
        name: 'Guidelines Section',
        pattern: /##\s+Guidelines/m,
        weight: 0.15,
        required: true
      },
      {
        name: 'Implementation Section',
        pattern: /##\s+Implementation/m,
        weight: 0.15,
        required: false
      },
      {
        name: 'Quality Section',
        pattern: /##\s+Quality/m,
        weight: 0.10,
        required: false
      },
      {
        name: 'Generated Footer',
        pattern: /\*Generated by Maestro/m,
        weight: 0.10,
        required: true
      },
      {
        name: 'Timestamp',
        pattern: /\*Created:\s*\d{4}-\d{2}-\d{2}/m,
        weight: 0.05,
        required: false
      }
    ];

    for (const check of formatChecks) {
      if (!check.pattern.test(content)) {
        const penalty = check.required ? check.weight : check.weight * 0.5;
        score -= penalty;
        
        issues.push({
          type: 'format',
          severity: check.required ? 'high' : 'medium',
          message: `Missing ${check.name}`,
          suggestion: `Add ${check.name.toLowerCase()} following the standard format`
        });
      }
    }

    // Check heading hierarchy
    const headings = content.match(/^#+\s+.+$/gm) || [];
    for (let i = 1; i < headings.length; i++) {
      const currentLevel = headings[i].match(/^#+/)[0].length;
      const prevLevel = headings[i-1].match(/^#+/)[0].length;
      
      if (currentLevel > prevLevel + 1) {
        score -= 0.05;
        issues.push({
          type: 'format',
          severity: 'low',
          message: 'Heading hierarchy skip detected',
          suggestion: 'Use proper heading hierarchy (h1 -> h2 -> h3, etc.)'
        });
      }
    }

    return Math.max(0, score);
  }

  /**
   * Validate content completeness for domain
   */
  validateCompleteness(content, domain, issues) {
    let score = 1.0;
    
    // Domain-specific required elements
    const domainRequirements = {
      product: {
        keywords: ['user', 'feature', 'value', 'priority', 'stakeholder'],
        sections: ['vision', 'experience', 'prioritization'],
        minWordCount: 200
      },
      technical: {
        keywords: ['architecture', 'system', 'performance', 'security', 'scalability'], 
        sections: ['principles', 'standards', 'requirements'],
        minWordCount: 300
      },
      workflow: {
        keywords: ['process', 'workflow', 'quality', 'review', 'testing'],
        sections: ['standards', 'procedures', 'gates'],
        minWordCount: 250
      },
      security: {
        keywords: ['security', 'compliance', 'risk', 'control', 'audit'],
        sections: ['framework', 'controls', 'requirements'],
        minWordCount: 350
      },
      performance: {
        keywords: ['performance', 'optimization', 'monitoring', 'metrics', 'scalability'],
        sections: ['metrics', 'strategies', 'monitoring'],
        minWordCount: 200
      }
    };

    const requirements = domainRequirements[domain] || domainRequirements.technical;
    const contentLower = content.toLowerCase();
    const wordCount = (content.match(/\b\w+\b/g) || []).length;

    // Check minimum word count
    if (wordCount < requirements.minWordCount) {
      const penalty = Math.min(0.3, (requirements.minWordCount - wordCount) / requirements.minWordCount);
      score -= penalty;
      
      issues.push({
        type: 'completeness',
        severity: 'medium',
        message: `Content too short: ${wordCount} words (minimum: ${requirements.minWordCount})`,
        suggestion: 'Add more detailed content covering all required aspects'
      });
    }

    // Check for required keywords
    let foundKeywords = 0;
    for (const keyword of requirements.keywords) {
      if (contentLower.includes(keyword)) {
        foundKeywords++;
      }
    }
    
    const keywordRatio = foundKeywords / requirements.keywords.length;
    if (keywordRatio < 0.6) {
      score -= (0.6 - keywordRatio) * 0.4;
      
      issues.push({
        type: 'completeness',
        severity: 'medium',
        message: `Missing domain keywords: ${foundKeywords}/${requirements.keywords.length} found`,
        suggestion: `Include domain-specific terms: ${requirements.keywords.join(', ')}`
      });
    }

    // Check for required sections
    let foundSections = 0;
    for (const section of requirements.sections) {
      if (contentLower.includes(section)) {
        foundSections++;
      }
    }
    
    const sectionRatio = foundSections / requirements.sections.length;
    if (sectionRatio < 0.8) {
      score -= (0.8 - sectionRatio) * 0.3;
      
      issues.push({
        type: 'completeness',
        severity: 'high',
        message: `Missing required sections: ${foundSections}/${requirements.sections.length} found`,
        suggestion: `Include sections covering: ${requirements.sections.join(', ')}`
      });
    }

    return Math.max(0, score);
  }

  /**
   * Validate content clarity and readability
   */
  validateClarity(content, issues) {
    let score = 1.0;
    
    if (!this.options.enableNLP) {
      return score; // Skip NLP-based validation if disabled
    }

    try {
      const sentences = content.split(/[.!?]+/).filter(s => s.trim().length > 0);
      const words = this.tokenizer.tokenize(content.toLowerCase()) || [];
      
      if (sentences.length === 0 || words.length === 0) {
        score -= 0.5;
        issues.push({
          type: 'clarity',
          severity: 'high',
          message: 'Content appears to be empty or malformed',
          suggestion: 'Ensure content contains proper sentences and words'
        });
        return Math.max(0, score);
      }

      // Calculate average sentence length
      const avgSentenceLength = words.length / sentences.length;
      if (avgSentenceLength > 25) {
        score -= 0.2;
        issues.push({
          type: 'clarity',
          severity: 'medium',
          message: `Sentences too long (avg: ${avgSentenceLength.toFixed(1)} words)`,
          suggestion: 'Break down complex sentences for better readability'
        });
      }

      // Check for passive voice (simplified heuristic)
      const passiveIndicators = ['is', 'are', 'was', 'were', 'been', 'being'];
      let passiveCount = 0;
      
      for (const sentence of sentences) {
        const sentenceWords = this.tokenizer.tokenize(sentence.toLowerCase()) || [];
        if (passiveIndicators.some(indicator => sentenceWords.includes(indicator))) {
          passiveCount++;
        }
      }
      
      const passiveRatio = passiveCount / sentences.length;
      if (passiveRatio > 0.4) {
        score -= passiveRatio * 0.2;
        issues.push({
          type: 'clarity',
          severity: 'low',
          message: `High passive voice usage (${(passiveRatio * 100).toFixed(1)}%)`,
          suggestion: 'Use more active voice for clearer communication'
        });
      }

      // Check for jargon and complexity
      const complexWords = words.filter(word => word.length > 12);
      const complexityRatio = complexWords.length / words.length;
      
      if (complexityRatio > 0.1) {
        score -= complexityRatio * 0.3;
        issues.push({
          type: 'clarity',
          severity: 'low',
          message: `High complexity words ratio (${(complexityRatio * 100).toFixed(1)}%)`,
          suggestion: 'Simplify language where possible for better accessibility'
        });
      }

    } catch (error) {
      // NLP processing failed, don't penalize heavily
      score -= 0.1;
      issues.push({
        type: 'clarity',
        severity: 'low',
        message: 'Unable to analyze text clarity automatically',
        suggestion: 'Manually review content for clarity and readability'
      });
    }

    return Math.max(0, score);
  }

  /**
   * Validate content specificity and actionability
   */
  validateSpecificity(content, issues) {
    let score = 1.0;
    
    // Look for specific, actionable language
    const specificIndicators = [
      'must', 'shall', 'should', 'will', 'required', 'mandatory',
      'specifically', 'exactly', 'precisely', 'defined as',
      'measured by', 'verified through', 'validated by'
    ];
    
    const vaguenessIndicators = [
      'might', 'could', 'possibly', 'perhaps', 'maybe',
      'generally', 'usually', 'typically', 'often',
      'some', 'many', 'various', 'several'
    ];
    
    const contentLower = content.toLowerCase();
    
    // Count specific language
    let specificCount = 0;
    for (const indicator of specificIndicators) {
      const regex = new RegExp(`\\b${indicator}\\b`, 'gi');
      const matches = contentLower.match(regex);
      specificCount += matches ? matches.length : 0;
    }
    
    // Count vague language
    let vagueCount = 0;
    for (const indicator of vaguenessIndicators) {
      const regex = new RegExp(`\\b${indicator}\\b`, 'gi');
      const matches = contentLower.match(regex);
      vagueCount += matches ? matches.length : 0;
    }
    
    const words = this.tokenizer.tokenize(contentLower) || [];
    const specificityRatio = words.length > 0 ? specificCount / words.length : 0;
    const vaguenessRatio = words.length > 0 ? vagueCount / words.length : 0;
    
    // Penalize for low specificity
    if (specificityRatio < 0.01) {
      score -= 0.3;
      issues.push({
        type: 'specificity',
        severity: 'medium',
        message: 'Content lacks specific, actionable language',
        suggestion: 'Add specific requirements using words like "must", "shall", "required"'
      });
    }
    
    // Penalize for high vagueness
    if (vaguenessRatio > 0.02) {
      score -= vaguenessRatio * 10;
      issues.push({
        type: 'specificity',
        severity: 'medium',
        message: `High vagueness ratio (${(vaguenessRatio * 100).toFixed(2)}%)`,
        suggestion: 'Replace vague terms with specific, measurable criteria'
      });
    }

    // Check for measurable criteria
    const measurementPatterns = [
      /\d+%/, /\d+\s*(seconds?|minutes?|hours?|days?)/, 
      /\d+\s*(MB|GB|TB)/, /\d+\s*(users?|requests?|transactions?)/,
      /<\s*\d+/, />\s*\d+/, /=\s*\d+/
    ];
    
    let measurementCount = 0;
    for (const pattern of measurementPatterns) {
      const matches = content.match(pattern);
      measurementCount += matches ? matches.length : 0;
    }
    
    if (measurementCount === 0) {
      score -= 0.2;
      issues.push({
        type: 'specificity',
        severity: 'low',
        message: 'No measurable criteria found',
        suggestion: 'Include specific metrics, thresholds, or quantifiable requirements'
      });
    }

    return Math.max(0, score);
  }

  /**
   * Validate internal consistency
   */
  validateConsistency(content, issues) {
    let score = 1.0;
    
    // Check terminology consistency
    const termVariations = [
      ['API', 'api', 'Api'],
      ['URL', 'url', 'Url'],
      ['JSON', 'json', 'Json'],
      ['HTTP', 'http', 'Http'],
      ['CLI', 'cli', 'Cli']
    ];
    
    for (const variations of termVariations) {
      const foundVariations = variations.filter(term => content.includes(term));
      if (foundVariations.length > 1) {
        score -= 0.05;
        issues.push({
          type: 'consistency',
          severity: 'low',
          message: `Inconsistent terminology: ${foundVariations.join(', ')}`,
          suggestion: `Use consistent terminology throughout (prefer: ${variations[0]})`
        });
      }
    }

    // Check section numbering consistency
    const numberedSections = content.match(/^\s*\d+\.\s+/gm) || [];
    if (numberedSections.length > 0) {
      for (let i = 0; i < numberedSections.length - 1; i++) {
        const currentNum = parseInt(numberedSections[i].match(/\d+/)[0]);
        const nextNum = parseInt(numberedSections[i + 1].match(/\d+/)[0]);
        
        if (nextNum !== currentNum + 1) {
          score -= 0.1;
          issues.push({
            type: 'consistency',
            severity: 'medium',
            message: `Section numbering inconsistency: ${currentNum} -> ${nextNum}`,
            suggestion: 'Ensure sequential section numbering'
          });
          break;
        }
      }
    }

    // Check list formatting consistency
    const bulletPoints = content.match(/^[\s]*[-*+]\s+/gm) || [];
    if (bulletPoints.length > 0) {
      const bulletChars = bulletPoints.map(bp => bp.trim().charAt(0));
      const uniqueChars = [...new Set(bulletChars)];
      
      if (uniqueChars.length > 1) {
        score -= 0.05;
        issues.push({
          type: 'consistency',
          severity: 'low',
          message: `Inconsistent bullet point formatting: ${uniqueChars.join(', ')}`,
          suggestion: 'Use consistent bullet point characters throughout'
        });
      }
    }

    return Math.max(0, score);
  }

  /**
   * Calculate overall quality score
   */
  calculateOverallScore(scores) {
    let totalScore = 0;
    let totalWeight = 0;
    
    for (const [category, weight] of Object.entries(QUALITY_WEIGHTS)) {
      if (scores[category] !== undefined) {
        totalScore += scores[category] * weight;
        totalWeight += weight;
      }
    }
    
    return totalWeight > 0 ? totalScore / totalWeight : 0;
  }

  /**
   * Get quality level from score
   */
  getQualityLevel(score) {
    for (const [level, threshold] of Object.entries(QUALITY_THRESHOLDS)) {
      if (score >= threshold) {
        return level;
      }
    }
    return 'unacceptable';
  }

  /**
   * Generate improvement recommendations
   */
  generateRecommendations(validation) {
    const recommendations = [];
    
    // Priority recommendations based on scores
    const scores = validation.scores;
    const priorityOrder = ['completeness', 'format', 'clarity', 'specificity', 'consistency'];
    
    for (const category of priorityOrder) {
      if (scores[category] < 0.7) {
        const categoryIssues = validation.issues.filter(issue => issue.type === category);
        if (categoryIssues.length > 0) {
          recommendations.push({
            category,
            priority: scores[category] < 0.5 ? 'high' : 'medium',
            score: scores[category],
            issues: categoryIssues.length,
            topSuggestion: categoryIssues[0].suggestion
          });
        }
      }
    }

    // Overall recommendations
    if (validation.overallScore < QUALITY_THRESHOLDS.acceptable) {
      recommendations.unshift({
        category: 'overall',
        priority: 'critical',
        score: validation.overallScore,
        issues: validation.issues.length,
        topSuggestion: 'Document requires significant improvement before approval'
      });
    }

    return recommendations;
  }

  /**
   * Validate multiple documents and generate comparative analysis
   */
  async validateDocuments(documents) {
    const results = [];
    
    for (const doc of documents) {
      let content;
      if (typeof doc === 'string') {
        // Assume it's a file path
        content = await readFile(doc, 'utf8');
      } else if (doc.content) {
        content = doc.content;
      } else {
        throw new Error('Invalid document format');
      }
      
      const validation = await this.validateDocument(
        content, 
        doc.domain || 'technical', 
        doc.expectedQuality || 'standard'
      );
      
      results.push({
        document: doc.name || doc.domain || 'unnamed',
        validation
      });
    }
    
    // Generate comparative analysis
    return {
      individual: results,
      comparative: this.generateComparativeAnalysis(results)
    };
  }

  /**
   * Generate comparative analysis of multiple documents
   */
  generateComparativeAnalysis(results) {
    const scores = results.map(r => r.validation.overallScore);
    const issues = results.map(r => r.validation.issues.length);
    
    return {
      averageScore: scores.reduce((a, b) => a + b, 0) / scores.length,
      scoreRange: { min: Math.min(...scores), max: Math.max(...scores) },
      averageIssues: issues.reduce((a, b) => a + b, 0) / issues.length,
      passRate: results.filter(r => r.validation.passed).length / results.length,
      qualityDistribution: this.getQualityDistribution(results),
      commonIssues: this.getCommonIssues(results)
    };
  }

  /**
   * Get quality level distribution
   */
  getQualityDistribution(results) {
    const distribution = {};
    
    for (const result of results) {
      const level = result.validation.qualityLevel;
      distribution[level] = (distribution[level] || 0) + 1;
    }
    
    return distribution;
  }

  /**
   * Get most common issues across documents
   */
  getCommonIssues(results) {
    const issueCount = {};
    
    for (const result of results) {
      for (const issue of result.validation.issues) {
        const key = `${issue.type}:${issue.message}`;
        issueCount[key] = (issueCount[key] || 0) + 1;
      }
    }
    
    return Object.entries(issueCount)
      .sort(([,a], [,b]) => b - a)
      .slice(0, 10)
      .map(([key, count]) => {
        const [type, message] = key.split(':');
        return { type, message, frequency: count };
      });
  }
}

export default SteeringQualityValidator;