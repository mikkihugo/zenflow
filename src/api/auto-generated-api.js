import express from 'express';
import { createServer } from 'http';
import { WebSocketServer } from 'ws';
import * as OpenApiValidator from 'express-openapi-validator';
import swaggerUi from 'swagger-ui-express';
import { generateApiFromMeow } from '../cli/generate-api-from-meow.js';
import { executeCommand } from '../cli/command-registry.js';
import meow from 'meow';
import Database from 'better-sqlite3';
import { readHiveRegistry } from '../cli/command-handlers/hive-mind-command.js';

const cli = meow(`
  Usage
    $ claude-zen <command> [options]

  Commands
    hive-mind    Queen-led swarms with collective intelligence
    swarm        (Internal) Multi-agent coordination
    init         Initialize project with enterprise environment
    start        Start orchestration with swarm intelligence
    status       Comprehensive system status
    help         Show help

  Options
    --version, -v  Show version
    --help, -h     Show help
`, {
  importMeta: import.meta,
  flags: {
    help: { type: 'boolean', alias: 'h' },
    version: { type: 'boolean', alias: 'v' },
  }
});

export class AutoGeneratedAPI {
  constructor(options = {}) {
    this.port = options.port || 3001;
    this.app = express();
    this.server = null;
    this.wss = null;
    this.isRunning = false;
    this.openapiSpec = generateApiFromMeow(cli);
  }

  async start() {
    if (this.isRunning) {
      console.log('API server already running');
      return;
    }

    this.app.use(express.json());
    this.app.use('/docs', swaggerUi.serve, swaggerUi.setup(this.openapiSpec));

    this.app.use(
      OpenApiValidator.middleware({
        apiSpec: this.openapiSpec,
        validateRequests: true,
        validateResponses: true,
      }),
    );

    this.app.post('/:command', async (req, res) => {
      const { command } = req.params;
      const { args, flags } = req.body;

      try {
        // This is a simplified execution. A real implementation would need a more
        // robust way to capture and return the output of the command.
        const result = await executeCommand(command, args, flags);
        res.json({ success: true, result });
      } catch (error) {
        res.status(500).json({ success: false, error: error.message });
      }
    });

    this.app.get('/hive-mind/:hiveName', async (req, res) => {
      const { hiveName } = req.params;
      const registry = await readHiveRegistry();
      const hiveInfo = registry[hiveName];

      if (!hiveInfo) {
        return res.status(404).json({ error: 'Hive not found' });
      }

      try {
        const db = new Database(hiveInfo.path);
        const stats = db.prepare(`
          SELECT
            (SELECT COUNT(*) FROM visions) as totalVisions,
            (SELECT COUNT(*) FROM epics) as totalEpics,
            (SELECT COUNT(*) FROM features) as totalFeatures,
            (SELECT COUNT(*) FROM prds) as totalPrds,
            (SELECT COUNT(*) FROM user_stories) as totalUserStories,
            (SELECT COUNT(*) FROM tasks) as totalTasks
        `).get();
        res.json({ ...hiveInfo, stats });
      } catch (error) {
        res.status(500).json({ error: error.message });
      }
    });

    this.app.use((err, req, res, next) => {
      res.status(err.status || 500).json({
        message: err.message,
        errors: err.errors,
      });
    });

    this.server = createServer(this.app);
    
    return new Promise((resolve) => {
        this.server.listen(this.port, () => {
            this.isRunning = true;
            console.log(`API server running on port ${this.port}`);
            console.log(`API docs available at http://localhost:${this.port}/docs`);
            resolve();
        });
    });
  }

  async stop() {
    if (!this.isRunning) return;
    return new Promise((resolve) => {
        this.server.close(() => {
            this.isRunning = false;
            console.log('API server stopped');
            resolve();
        });
    });
  }
}

export const autoGeneratedAPI = new AutoGeneratedAPI();