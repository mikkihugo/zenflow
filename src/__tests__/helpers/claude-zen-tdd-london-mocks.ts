/**
 * Claude-Zen TDD London Mock Classes
 *
 * Specialized mock classes for Claude-Zen architecture following TDD London pattern.
 * Generated by SWARM ORCHESTRATOR for systematic mock conversion.
 */

import { vi } from 'vitest';

// ============================================================================
// Claude-Zen Architecture Mock Classes
// ============================================================================

/**
 * MockHiveMindService - Central coordination system
 * Replaces: mockHiveMind = { initialize: vi.fn(), spawnQueen: vi.fn()... }
 */
export class MockHiveMindService {
  initialize: vi.MockedFunction<() => Promise<void>> = vi.fn();
  spawnQueen: vi.MockedFunction<(config: any) => Promise<string>> = vi.fn();
  coordinateQueens: vi.MockedFunction<(task: any) => Promise<CoordinationResult>> = vi.fn();
  processTask: vi.MockedFunction<(taskId: string) => Promise<TaskResult>> = vi.fn();
  getQueenStatus: vi.MockedFunction<(queenId: string) => Promise<QueenStatus>> = vi.fn();

  constructor() {
    this.initialize.mockResolvedValue(undefined);
    this.spawnQueen.mockResolvedValue('queen-123');
    this.coordinateQueens.mockResolvedValue({
      success: true,
      coordinationId: 'coord-123',
      activeQueens: 3,
      taskId: 'task-456',
    });
    this.processTask.mockResolvedValue({
      taskId: 'task-456',
      status: 'completed',
      result: 'Task processed successfully',
    });
    this.getQueenStatus.mockResolvedValue({
      queenId: 'queen-123',
      status: 'active',
      capabilities: ['analyze', 'design'],
    });
  }

  // TDD London interaction testing helpers
  expectInitializeCalled() {
    expect(this.initialize).toHaveBeenCalled();
    return this;
  }

  expectQueenSpawned(config?: any) {
    if (config) {
      expect(this.spawnQueen).toHaveBeenCalledWith(expect.objectContaining(config));
    } else {
      expect(this.spawnQueen).toHaveBeenCalled();
    }
    return this;
  }

  expectQueensCoordinated(task: any) {
    expect(this.coordinateQueens).toHaveBeenCalledWith(expect.objectContaining(task));
    return this;
  }

  expectTaskProcessed(taskId: string) {
    expect(this.processTask).toHaveBeenCalledWith(taskId);
    return this;
  }

  expectStatusChecked(queenId: string) {
    expect(this.getQueenStatus).toHaveBeenCalledWith(queenId);
    return this;
  }

  setupCoordinationFailure(error: string = 'Coordination failed') {
    this.coordinateQueens.mockRejectedValueOnce(new Error(error));
    return this;
  }

  clearAllMocks() {
    vi.clearAllMocks();
    return this;
  }
}

/**
 * MockQueensService - Specialized AI agents coordination
 * Replaces: mockQueens = { architectQueen: { analyze: vi.fn()... }... }
 */
export class MockQueensService {
  // Architect Queen structure
  architectQueen = {
    analyze: vi.fn(),
    design: vi.fn(),
    coordinate: vi.fn(),
  };
  
  // Code Queen structure
  codeQueen = {
    generate: vi.fn(),
    refactor: vi.fn(),
    optimize: vi.fn(),
  };
  
  // Debug Queen structure
  debugQueen = {
    diagnose: vi.fn(),
    fix: vi.fn(),
    validate: vi.fn(),
  };

  // Architect Queen methods (legacy support)
  architectAnalyze: vi.MockedFunction<(requirements: any) => Promise<ArchitectureResult>> = vi.fn();
  architectDesign: vi.MockedFunction<(spec: any) => Promise<DesignResult>> = vi.fn();
  architectCoordinate: vi.MockedFunction<(teams: string[]) => Promise<void>> = vi.fn();

  // Code Queen methods
  codeGenerate: vi.MockedFunction<(spec: any) => Promise<CodeResult>> = vi.fn();
  codeRefactor: vi.MockedFunction<(code: string) => Promise<string>> = vi.fn();
  codeOptimize: vi.MockedFunction<(code: string) => Promise<OptimizationResult>> = vi.fn();

  // Debug Queen methods
  debugDiagnose: vi.MockedFunction<(issue: any) => Promise<DiagnosisResult>> = vi.fn();
  debugFix: vi.MockedFunction<(issue: any) => Promise<FixResult>> = vi.fn();
  debugValidate: vi.MockedFunction<(fix: any) => Promise<ValidationResult>> = vi.fn();

  constructor() {
    // Initialize nested Queen structures
    this.architectQueen.analyze.mockResolvedValue({
      success: true,
      architecture: 'microservices',
      components: ['api', 'db', 'ui'],
    });
    this.architectQueen.design.mockResolvedValue({
      success: true,
      design: 'component-based',
      files: ['component.ts', 'service.ts'],
    });
    this.architectQueen.coordinate.mockResolvedValue(undefined);

    this.codeQueen.generate.mockResolvedValue({
      success: true,
      code: 'export class GeneratedCode {}',
      files: 1,
    });
    this.codeQueen.refactor.mockResolvedValue('export class RefactoredCode {}');
    this.codeQueen.optimize.mockResolvedValue({
      success: true,
      optimizations: 2,
      performanceGain: 15,
    });

    this.debugQueen.diagnose.mockResolvedValue({
      success: true,
      issues: ['memory leak', 'performance'],
      severity: 'medium',
    });
    this.debugQueen.fix.mockResolvedValue({
      success: true,
      fixed: true,
      changes: 3,
    });
    this.debugQueen.validate.mockResolvedValue({
      success: true,
      validated: true,
      confidence: 0.95,
    });

    // Legacy support - Default successful responses
    this.architectAnalyze.mockResolvedValue({
      success: true,
      architecture: 'microservices',
      components: ['api', 'db', 'ui'],
    });
    this.architectDesign.mockResolvedValue({
      success: true,
      design: 'component-based',
      files: ['component.ts', 'service.ts'],
    });
    this.architectCoordinate.mockResolvedValue(undefined);

    this.codeGenerate.mockResolvedValue({
      success: true,
      code: 'export class GeneratedCode {}',
      files: 1,
    });
    this.codeRefactor.mockResolvedValue('export class RefactoredCode {}');
    this.codeOptimize.mockResolvedValue({
      success: true,
      optimizations: 2,
      performanceGain: 15,
    });

    this.debugDiagnose.mockResolvedValue({
      success: true,
      issues: ['memory leak', 'performance'],
      severity: 'medium',
    });
    this.debugFix.mockResolvedValue({
      success: true,
      fixed: true,
      changes: 3,
    });
    this.debugValidate.mockResolvedValue({
      success: true,
      validated: true,
      confidence: 0.95,
    });
  }

  // TDD London helpers for Architect Queen
  expectArchitectAnalyzeCalled(requirements: any) {
    expect(this.architectAnalyze).toHaveBeenCalledWith(expect.objectContaining(requirements));
    return this;
  }

  expectArchitectDesignCalled(spec: any) {
    expect(this.architectDesign).toHaveBeenCalledWith(expect.objectContaining(spec));
    return this;
  }

  expectArchitectCoordinationCalled(teams: string[]) {
    expect(this.architectCoordinate).toHaveBeenCalledWith(expect.arrayContaining(teams));
    return this;
  }

  // TDD London helpers for Code Queen
  expectCodeGenerationCalled(spec: any) {
    expect(this.codeGenerate).toHaveBeenCalledWith(expect.objectContaining(spec));
    return this;
  }

  expectCodeRefactoringCalled(code: string) {
    expect(this.codeRefactor).toHaveBeenCalledWith(code);
    return this;
  }

  expectCodeOptimizationCalled(code: string) {
    expect(this.codeOptimize).toHaveBeenCalledWith(code);
    return this;
  }

  // TDD London helpers for Debug Queen
  expectDiagnosisCalled(issue: any) {
    expect(this.debugDiagnose).toHaveBeenCalledWith(expect.objectContaining(issue));
    return this;
  }

  expectFixCalled(issue: any) {
    expect(this.debugFix).toHaveBeenCalledWith(expect.objectContaining(issue));
    return this;
  }

  expectValidationCalled(fix: any) {
    expect(this.debugValidate).toHaveBeenCalledWith(expect.objectContaining(fix));
    return this;
  }

  // Workflow testing helpers
  expectFullArchitectWorkflow(requirements: any, spec: any, teams: string[]) {
    this.expectArchitectAnalyzeCalled(requirements);
    this.expectArchitectDesignCalled(spec);
    this.expectArchitectCoordinationCalled(teams);
    return this;
  }

  expectFullCodeWorkflow(spec: any, code: string) {
    this.expectCodeGenerationCalled(spec);
    this.expectCodeRefactoringCalled(code);
    this.expectCodeOptimizationCalled(code);
    return this;
  }

  expectFullDebugWorkflow(issue: any, fix: any) {
    this.expectDiagnosisCalled(issue);
    this.expectFixCalled(issue);
    this.expectValidationCalled(fix);
    return this;
  }

  clearAllMocks() {
    vi.clearAllMocks();
    return this;
  }
}

/**
 * MockNeuralFrameworkService - ruv-FANN Neural Integration
 * Replaces: mockNeuralFramework = { initializeNetwork: vi.fn()... }
 */
export class MockNeuralFrameworkService {
  initializeNetwork: vi.MockedFunction<(config: NetworkConfig) => Promise<string>> = vi.fn();
  trainModel: vi.MockedFunction<
    (networkId: string, data: TrainingData) => Promise<TrainingResult>
  > = vi.fn();
  predict: vi.MockedFunction<(networkId: string, input: number[]) => Promise<number[]>> = vi.fn();
  evaluateModel: vi.MockedFunction<
    (networkId: string, testData: TestData) => Promise<EvaluationResult>
  > = vi.fn();
  saveModel: vi.MockedFunction<(networkId: string, path: string) => Promise<void>> = vi.fn();
  loadModel: vi.MockedFunction<(path: string) => Promise<string>> = vi.fn();

  constructor() {
    this.initializeNetwork.mockResolvedValue('network-123');
    this.trainModel.mockResolvedValue({
      success: true,
      epochs: 100,
      finalError: 0.01,
      trainingTime: 5000,
    });
    this.predict.mockResolvedValue([0.95, 0.05]);
    this.evaluateModel.mockResolvedValue({
      success: true,
      accuracy: 0.95,
      precision: 0.93,
      recall: 0.94,
    });
    this.saveModel.mockResolvedValue(undefined);
    this.loadModel.mockResolvedValue('network-loaded-456');
  }

  expectNetworkInitialized(config: NetworkConfig) {
    expect(this.initializeNetwork).toHaveBeenCalledWith(expect.objectContaining(config));
    return this;
  }

  expectModelTrained(networkId: string, data?: TrainingData) {
    if (data) {
      expect(this.trainModel).toHaveBeenCalledWith(networkId, expect.objectContaining(data));
    } else {
      expect(this.trainModel).toHaveBeenCalledWith(networkId, expect.any(Object));
    }
    return this;
  }

  expectPredictionMade(networkId: string, input: number[]) {
    expect(this.predict).toHaveBeenCalledWith(networkId, expect.arrayContaining(input));
    return this;
  }

  expectModelEvaluated(networkId: string) {
    expect(this.evaluateModel).toHaveBeenCalledWith(networkId, expect.any(Object));
    return this;
  }

  expectModelSaved(networkId: string, path: string) {
    expect(this.saveModel).toHaveBeenCalledWith(networkId, path);
    return this;
  }

  expectModelLoaded(path: string) {
    expect(this.loadModel).toHaveBeenCalledWith(path);
    return this;
  }

  setupTrainingFailure(error: string = 'Training failed') {
    this.trainModel.mockRejectedValueOnce(new Error(error));
    return this;
  }

  clearAllMocks() {
    vi.clearAllMocks();
    return this;
  }
}

/**
 * MockClaudeZenApiService - REST API Layer
 * Replaces: mockClaudeZenApi = { startServer: vi.fn()... }
 */
export class MockClaudeZenApiService {
  startServer: vi.MockedFunction<(port: number) => Promise<void>> = vi.fn();
  registerQueenEndpoints: vi.MockedFunction<(queens: string[]) => Promise<void>> = vi.fn();
  handleRequest: vi.MockedFunction<(request: ApiRequest) => Promise<ApiResponse>> = vi.fn();
  handleTaskRequest: vi.MockedFunction<(request: ApiRequest) => Promise<ApiResponse>> = vi.fn();
  stopServer: vi.MockedFunction<() => Promise<void>> = vi.fn();

  constructor() {
    this.startServer.mockResolvedValue(undefined);
    this.registerQueenEndpoints.mockResolvedValue(undefined);
    this.handleRequest.mockResolvedValue({
      success: true,
      data: { result: 'API call successful' },
      status: 200,
    });
    this.handleTaskRequest.mockResolvedValue({
      success: true,
      data: { result: 'Task request successful' },
      status: 200,
    });
    this.stopServer.mockResolvedValue(undefined);
  }

  expectServerStarted(port: number) {
    expect(this.startServer).toHaveBeenCalledWith(port);
    return this;
  }

  expectQueenEndpointsRegistered(queens: string[]) {
    expect(this.registerQueenEndpoints).toHaveBeenCalledWith(expect.arrayContaining(queens));
    return this;
  }

  expectRequestHandled(request: ApiRequest) {
    expect(this.handleRequest).toHaveBeenCalledWith(expect.objectContaining(request));
    return this;
  }

  expectServerStopped() {
    expect(this.stopServer).toHaveBeenCalled();
    return this;
  }

  clearAllMocks() {
    vi.clearAllMocks();
    return this;
  }
}

// ============================================================================
// Type Definitions for Claude-Zen Architecture
// ============================================================================

export interface CoordinationResult {
  success: boolean;
  coordinationId: string;
  activeQueens: number;
  taskId: string;
}

export interface TaskResult {
  taskId: string;
  status: 'completed' | 'failed' | 'in-progress';
  result: string;
}

export interface QueenStatus {
  queenId: string;
  status: 'active' | 'inactive' | 'busy';
  capabilities: string[];
}

export interface ArchitectureResult {
  success: boolean;
  architecture: string;
  components: string[];
}

export interface DesignResult {
  success: boolean;
  design: string;
  files: string[];
}

export interface CodeResult {
  success: boolean;
  code: string;
  files: number;
}

export interface OptimizationResult {
  success: boolean;
  optimizations: number;
  performanceGain: number;
}

export interface DiagnosisResult {
  success: boolean;
  issues: string[];
  severity: 'low' | 'medium' | 'high' | 'critical';
}

export interface FixResult {
  success: boolean;
  fixed: boolean;
  changes: number;
}

export interface ValidationResult {
  success: boolean;
  validated: boolean;
  confidence: number;
}

export interface NetworkConfig {
  inputSize: number;
  hiddenLayers: number[];
  outputSize: number;
}

export interface TrainingData {
  inputs: number[][];
  outputs: number[][];
}

export interface TestData {
  inputs: number[][];
  expectedOutputs: number[][];
}

export interface TrainingResult {
  success: boolean;
  epochs: number;
  finalError: number;
  trainingTime: number;
}

export interface EvaluationResult {
  success: boolean;
  accuracy: number;
  precision: number;
  recall: number;
}

export interface ApiRequest {
  method: string;
  path: string;
  body?: any;
  params?: any;
}

export interface ApiResponse {
  success: boolean;
  data: any;
  status: number;
}

// ============================================================================
// Factory Function for Claude-Zen Mock Creation
// ============================================================================

/**
 * Factory function to create complete Claude-Zen mock suite
 */
export function createClaudeZenMocks() {
  return {
    hiveMind: new MockHiveMindService(),
    queens: new MockQueensService(),
    neuralFramework: new MockNeuralFrameworkService(),
    api: new MockClaudeZenApiService(),
  };
}

/**
 * Helper to clear all Claude-Zen mocks
 */
export function clearAllClaudeZenMocks(mocks: ReturnType<typeof createClaudeZenMocks>) {
  Object.values(mocks).forEach((mock) => mock.clearAllMocks());
}
