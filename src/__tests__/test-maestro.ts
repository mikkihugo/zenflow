#!/usr/bin/env node

/**
 * Manual Test for Maestro Specs-Driven Flow with Agent Reuse
 * Tests the enhanced maestro orchestrator functionality
 */

import { mkdir, writeFile } from 'node:fs/promises';
import { join } from 'node:path';

// Mock interfaces
interface AgentProfile {
  type: string;
  capabilities: string[];
  metadata?: Record<string, any>;
}

interface Task {
  id: string;
  type: string;
  description: string;
  assignedAgent?: string;
  metadata?: Record<string, any>;
}

interface WorkflowState {
  featureName: string;
  currentPhase: string;
  currentTaskIndex: number;
  status: string;
  lastActivity: Date;
  history: Array<{
    phase: string;
    status: string;
    timestamp: Date;
  }>;
}

// Mock implementations for testing
class MockEventBus {
  emit(_event: string, _data: any): void {}
  on(): void {}
}

class MockLogger {
  info(_msg: string): void {}
  warn(_msg: string): void {}
  error(_msg: string): void {}
  debug(_msg: string): void {}
}

class MockMemoryManager {
  async store(): Promise<void> {}
  async retrieve(): Promise<any> {}
}

class MockAgentManager {
  private agents = new Map<string, { type: string; profile: AgentProfile; status: string }>();

  async createAgent(type: string, profile: AgentProfile): Promise<string> {
    const agentId = `${type}-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`;
    this.agents.set(agentId, { type, profile, status: 'created' });
    return agentId;
  }

  async startAgent(agentId: string): Promise<void> {
    const agent = this.agents.get(agentId);
    if (agent) {
      agent.status = 'running';
    }
  }

  async stopAgent(agentId: string): Promise<void> {
    const agent = this.agents.get(agentId);
    if (agent) {
      agent.status = 'stopped';
      this.agents.delete(agentId);
    }
  }
}

class MockOrchestrator {
  async assignTask(_task: Task): Promise<{ success: boolean; duration: number }> {
    // Simulate task execution
    await new Promise((resolve) => setTimeout(resolve, 100));
    return { success: true, duration: 100 };
  }
}

// Test the maestro orchestrator
async function testMaestroWithAgentReuse(): Promise<void> {
  // Mock config
  const _config = { enableHiveMind: false };

  // Create mock dependencies
  const eventBus = new MockEventBus();
  const logger = new MockLogger();
  const memoryManager = new MockMemoryManager();
  const agentManager = new MockAgentManager();
  const mainOrchestrator = new MockOrchestrator();

  // Simple implementation of the core MaestroOrchestrator functionality
  class TestMaestroOrchestrator {
    private maestroState = new Map<string, WorkflowState>();
    private agentPool = new Map<string, string>();
    private capabilityIndex = new Map<string, string[]>();
    private agentManager: MockAgentManager;
    private mainOrchestrator: MockOrchestrator;

    constructor() {
      this.logger = logger;
      this.agentManager = agentManager;
      this.mainOrchestrator = mainOrchestrator;
    }

    async createSpec(featureName: string, initialRequest: string): Promise<void> {
      const workflowState: WorkflowState = {
        featureName,
        currentPhase: 'Requirements Clarification',
        currentTaskIndex: 0,
        status: 'active',
        lastActivity: new Date(),
        history: [],
      };

      this.maestroState.set(featureName, workflowState);

      // Create specs directory structure
      const specsDir = join(process.cwd(), 'docs', 'maestro', 'specs', featureName);
      await mkdir(specsDir, { recursive: true });

      const requirementsContent = `# Requirements for ${featureName}

## High-Level Request
${initialRequest}

## User Stories
- As a developer, I want ${initialRequest.toLowerCase()}, so that I can verify functionality

## Acceptance Criteria
- [ ] Feature functions as described
- [ ] Agent reuse is working properly
- [ ] Performance is optimized

*Generated by Test Maestro Orchestrator*
`;

      await writeFile(join(specsDir, 'requirements.md'), requirementsContent);
    }

    async generateDesign(featureName: string): Promise<void> {
      // Test the enhanced agent selection
      const designTask: Task = {
        id: `design-${featureName}`,
        type: 'design-generation',
        description: `Generate design for ${featureName}`,
        metadata: { featureName },
      };

      // Simulate the new agent selection logic
      const optimalAgentTypes = await this.getOptimalAgentTypes(
        ['design', 'architecture', 'analysis'],
        'design-generation',
        2
      );

      // Create agents with reuse logic
      const selectedAgents: string[] = [];
      for (const agentType of optimalAgentTypes) {
        const agentId = await this.getOrCreateAgent(agentType, {
          type: agentType,
          capabilities: ['design', 'architecture'],
          metadata: { task: 'design-generation' },
        });
        selectedAgents?.push(agentId);
      }

      // Execute design generation
      designTask.assignedAgent = selectedAgents?.[0];
      await this.mainOrchestrator.assignTask(designTask);

      // Generate design document
      const specsDir = join(process.cwd(), 'docs', 'maestro', 'specs', featureName);
      const designContent = `# Design for ${featureName}

## Architecture Overview
System designed using enhanced agent reuse functionality.

## Agent Reuse Statistics
- Reused agents: ${this.getAgentReuseCount()}
- Total agents: ${this.agentPool.size}
- Reuse rate: ${this.calculateReuseRate()}%

*Generated by Enhanced Maestro Orchestrator with Agent Reuse*
`;

      await writeFile(join(specsDir, 'design.md'), designContent);
    }

    private async getOptimalAgentTypes(
      _requiredCapabilities: string[],
      _taskType: string,
      maxAgents: number
    ): Promise<string[]> {
      // Enhanced agent selection logic
      const availableTypes = ['design-architect', 'system-architect', 'requirements-analyst'];
      const selected = availableTypes.slice(0, maxAgents);

      return selected;
    }

    private async getOrCreateAgent(agentType: string, profile: AgentProfile): Promise<string> {
      // Check if we can reuse an existing agent
      const existingAgentId = this.findReusableAgent(agentType, profile);
      if (existingAgentId) {
        return existingAgentId;
      }

      // Create new agent
      const agentId = await this.agentManager.createAgent(agentType, profile);
      this.agentPool.set(agentId, agentType);

      // Index by capabilities
      if (!this.capabilityIndex.has(agentType)) {
        this.capabilityIndex.set(agentType, []);
      }
      this.capabilityIndex.get(agentType)?.push(agentId);
      return agentId;
    }

    private findReusableAgent(agentType: string, _profile: AgentProfile): string | null {
      const agentsOfType = this.capabilityIndex.get(agentType);
      if (agentsOfType && agentsOfType.length > 0) {
        // Return the first available agent of this type
        return agentsOfType[0];
      }
      return null;
    }

    private getAgentReuseCount(): number {
      // Simulate reuse counting
      return Math.max(0, this.agentPool.size - 2);
    }

    private calculateReuseRate(): number {
      if (this.agentPool.size === 0) return 0;
      const reuseCount = this.getAgentReuseCount();
      return Math.round((reuseCount / this.agentPool.size) * 100 * 10) / 10;
    }

    async generateTasks(featureName: string): Promise<void> {
      const tasksContent = `# Implementation Tasks for ${featureName}

## Task List
- [ ] 1. Set up project structure
- [ ] 2. Implement core functionality
- [ ] 3. Add comprehensive testing
- [ ] 4. Create documentation

*Generated by Test Maestro with Agent Reuse*
`;

      const specsDir = join(process.cwd(), 'docs', 'maestro', 'specs', featureName);
      await writeFile(join(specsDir, 'tasks.md'), tasksContent);
    }

    getStats(): { totalAgents: number; reuseRate: number; capabilityTypes: number } {
      return {
        totalAgents: this.agentPool.size,
        reuseRate: this.calculateReuseRate(),
        capabilityTypes: this.capabilityIndex.size,
      };
    }
  }

  try {
    const maestro = new TestMaestroOrchestrator();

    // Test workflow simulation
    const testFeatures = [
      'agent-reuse-validation-1',
      'agent-reuse-validation-2',
      'agent-reuse-validation-3',
    ];

    for (const feature of testFeatures) {
      await maestro.createSpec(feature, `Enhanced agent reuse testing for ${feature}`);
      await maestro.generateDesign(feature);
      await maestro.generateTasks(feature);

      // Brief pause between features
      await new Promise((resolve) => setTimeout(resolve, 200));
    }

    // Print final statistics
    const stats = maestro.getStats();

    if (stats.reuseRate >= 50) {
    } else {
    }
  } catch (error) {
    console.error(
      `
      ❌ Test failed:`,
      error
    );
    process.exit(1);
  }
}

// Run the test
if (import.meta.url === `file://${process.argv[1]}`) {
  testMaestroWithAgentReuse().catch((error) => {
    console.error('Test execution failed:', error);
    process.exit(1);
  });
}
