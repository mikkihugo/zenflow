/**
 * @fileoverview MCP Server Integration for Auto-Generated Tools
 *
 * This module integrates auto-generated OpenAPI tools with the existing MCP server.
 * It provides a bridge between the generated tools and the MCP protocol, enabling
 * seamless use of API endpoints through the MCP interface.
 *
 * Features:
 * - Automatic tool registration with MCP server
 * - Dynamic tool loading from generated files
 * - Error handling and logging integration
 * - Hot-reloading support for development
 * - Tool validation and schema checking
 */

import { existsSync, watch } from 'fs';
import { readFile } from 'fs/promises';
import { join } from 'path';

import { getLogger } from '../../../../config/logging-config.js';

const logger = getLogger('mcp-auto-generator-integration');

export interface AutoGeneratedTool {
  name: string;
  description: string;
  inputSchema: {
    type: 'object';
    properties: Record<string, any>;
    required?: string[];
    additionalProperties?: boolean;
  };
  handler: (args: any) => Promise<any>;
}

export interface AutoGeneratorConfig {
  /** Directory containing generated tools */
  generatedToolsDir: string;
  /** Whether to enable hot-reloading of tools */
  enableHotReload?: boolean;
  /** Tool name prefix */
  prefix?: string;
  /** Validation options */
  validation?: {
    validateInputs?: boolean;
    validateOutputs?: boolean;
  };
}

/**
 * Auto-Generated Tools Manager
 *
 * Manages the lifecycle of auto-generated MCP tools, including loading,
 * registration, and hot-reloading when tools are regenerated.
 */
export class AutoGeneratedToolsManager {
  private config: AutoGeneratorConfig;
  private tools: Map<string, AutoGeneratedTool> = new Map();
  private watchers: any[] = [];

  constructor(config: AutoGeneratorConfig) {
    this.config = {
      enableHotReload: false,
      prefix: 'auto_',
      validation: {
        validateInputs: true,
        validateOutputs: false,
      },
      ...config,
    };
  }

  /**
   * Initialize the auto-generated tools manager
   */
  async initialize(): Promise<void> {
    logger.info('Initializing auto-generated tools manager', {
      dir: this.config.generatedToolsDir,
      hotReload: this.config.enableHotReload,
    });

    // Load existing tools
    await this.loadGeneratedTools();

    // Setup hot-reloading if enabled
    if (this.config.enableHotReload) {
      await this.setupHotReload();
    }

    logger.info('Auto-generated tools manager initialized', {
      toolsLoaded: this.tools.size,
    });
  }

  /**
   * Load generated tools from the output directory
   */
  private async loadGeneratedTools(): Promise<void> {
    const indexPath = join(this.config.generatedToolsDir, 'index.js');

    if (!existsSync(indexPath)) {
      logger.warn('No generated tools found', { path: indexPath });
      return;
    }

    try {
      // Clear module cache for hot-reloading
      if (require.cache[indexPath]) {
        delete require.cache[indexPath];
      }

      // Dynamic import with cache busting
      const cacheBuster = Date.now();
      const module = await import(`${indexPath}?t=${cacheBuster}`);

      const {
        GENERATED_MCP_TOOLS,
        GENERATED_MCP_HANDLERS,
        executeGeneratedTool,
      } = module;

      if (!(GENERATED_MCP_TOOLS && GENERATED_MCP_HANDLERS)) {
        logger.warn('Generated tools module missing expected exports');
        return;
      }

      // Clear existing tools
      this.tools.clear();

      // Load tools
      for (const toolDef of GENERATED_MCP_TOOLS) {
        const handler = GENERATED_MCP_HANDLERS[toolDef.name];

        if (!handler) {
          logger.warn('Handler not found for tool', { tool: toolDef.name });
          continue;
        }

        const tool: AutoGeneratedTool = {
          name: `${this.config.prefix}${toolDef.name}`,
          description: toolDef.description,
          inputSchema: toolDef.inputSchema,
          handler: this.createToolHandler(toolDef.name, executeGeneratedTool),
        };

        this.tools.set(tool.name, tool);
      }

      logger.info('Loaded generated tools', { count: this.tools.size });
    } catch (error) {
      logger.error('Failed to load generated tools', {
        error: error instanceof Error ? error.message : String(error),
        path: indexPath,
      });
    }
  }

  /**
   * Create a tool handler with validation and error handling
   */
  private createToolHandler(
    originalToolName: string,
    executeFunction: (name: string, args: any) => Promise<any>,
  ): (args: any) => Promise<any> {
    return async (args: any) => {
      try {
        // Input validation
        if (this.config.validation?.validateInputs) {
          await this.validateInput(originalToolName, args);
        }

        // Execute the tool
        const result = await executeFunction(originalToolName, args);

        // Output validation
        if (this.config.validation?.validateOutputs) {
          await this.validateOutput(originalToolName, result);
        }

        return result;
      } catch (error) {
        logger.error('Auto-generated tool execution failed', {
          tool: originalToolName,
          error: error instanceof Error ? error.message : String(error),
        });

        // Re-throw with context
        if (error instanceof Error) {
          error.message = `Tool ${originalToolName}: ${error.message}`;
        }
        throw error;
      }
    };
  }

  /**
   * Validate tool input against schema
   */
  private async validateInput(toolName: string, args: any): Promise<void> {
    // Basic validation - could use JSON Schema validator
    const tool = Array.from(this.tools.values()).find(
      (t) =>
        t.name.endsWith(toolName) ||
        t.name === `${this.config.prefix}${toolName}`,
    );

    if (!tool) {
      return;
    }

    const schema = tool.inputSchema;

    // Check required fields
    if (schema.required) {
      for (const field of schema.required) {
        if (args[field] === undefined) {
          throw new Error(`Required field '${field}' is missing`);
        }
      }
    }

    // Basic type checking
    for (const [key, value] of Object.entries(args)) {
      const propSchema = schema.properties[key];
      if (propSchema && !this.validateType(value, propSchema)) {
        throw new Error(`Invalid type for field '${key}'`);
      }
    }
  }

  /**
   * Validate output (placeholder)
   */
  private async validateOutput(toolName: string, result: any): Promise<void> {
    // Placeholder for output validation
    if (!result || typeof result !== 'object') {
      logger.warn('Tool returned unexpected result format', { tool: toolName });
    }
  }

  /**
   * Basic type validation helper
   */
  private validateType(value: any, schema: any): boolean {
    switch (schema.type) {
      case 'string':
        return typeof value === 'string';
      case 'number':
      case 'integer':
        return typeof value === 'number';
      case 'boolean':
        return typeof value === 'boolean';
      case 'array':
        return Array.isArray(value);
      case 'object':
        return typeof value === 'object' && value !== null;
      default:
        return true; // Unknown type, allow
    }
  }

  /**
   * Setup hot-reloading of generated tools
   */
  private async setupHotReload(): Promise<void> {
    const watchDir = this.config.generatedToolsDir;

    if (!existsSync(watchDir)) {
      logger.warn('Watch directory does not exist', { dir: watchDir });
      return;
    }

    try {
      const watcher = watch(
        watchDir,
        { recursive: true },
        (eventType, filename) => {
          if (filename === 'index.js' || filename === 'index.ts') {
            logger.info('Generated tools changed - reloading', {
              file: filename,
            });

            // Debounce rapid changes
            setTimeout(async () => {
              try {
                await this.loadGeneratedTools();
                logger.info('Hot-reload completed', {
                  toolsLoaded: this.tools.size,
                });
              } catch (error) {
                logger.error('Hot-reload failed', {
                  error: error instanceof Error ? error.message : String(error),
                });
              }
            }, 1000);
          }
        },
      );

      this.watchers.push(watcher);
      logger.info('Hot-reload monitoring enabled', { dir: watchDir });
    } catch (error) {
      logger.error('Failed to setup hot-reload', {
        error: error instanceof Error ? error.message : String(error),
        dir: watchDir,
      });
    }
  }

  /**
   * Get all loaded tools
   */
  public getTools(): AutoGeneratedTool[] {
    return Array.from(this.tools.values());
  }

  /**
   * Get a specific tool by name
   */
  public getTool(name: string): AutoGeneratedTool | undefined {
    return this.tools.get(name);
  }

  /**
   * Execute a tool by name
   */
  public async executeTool(name: string, args: any): Promise<any> {
    const tool = this.tools.get(name);

    if (!tool) {
      throw new Error(`Tool not found: ${name}`);
    }

    return await tool.handler(args);
  }

  /**
   * Get tool definitions for MCP registration
   */
  public getToolDefinitions(): Array<{
    name: string;
    description: string;
    inputSchema: any;
  }> {
    return Array.from(this.tools.values()).map((tool) => ({
      name: tool.name,
      description: tool.description,
      inputSchema: tool.inputSchema,
    }));
  }

  /**
   * Shutdown the manager
   */
  public async shutdown(): Promise<void> {
    logger.info('Shutting down auto-generated tools manager');

    // Close watchers
    for (const watcher of this.watchers) {
      try {
        watcher.close();
      } catch (error) {
        logger.error('Failed to close watcher', {
          error: error instanceof Error ? error.message : String(error),
        });
      }
    }
    this.watchers = [];

    // Clear tools
    this.tools.clear();

    logger.info('Auto-generated tools manager shutdown complete');
  }

  /**
   * Get statistics about loaded tools
   */
  public getStats(): {
    totalTools: number;
    toolsByNamespace: Record<string, number>;
    hotReloadEnabled: boolean;
  } {
    const toolsByNamespace: Record<string, number> = {};

    for (const tool of this.tools.values()) {
      const namespace = tool.name.split('_')[0] || 'unknown';
      toolsByNamespace[namespace] = (toolsByNamespace[namespace] || 0) + 1;
    }

    return {
      totalTools: this.tools.size,
      toolsByNamespace,
      hotReloadEnabled: this.config.enableHotReload,
    };
  }

  /**
   * Refresh tools (manually trigger reload)
   */
  public async refresh(): Promise<void> {
    logger.info('Manually refreshing auto-generated tools');
    await this.loadGeneratedTools();
    logger.info('Manual refresh completed', { toolsLoaded: this.tools.size });
  }
}

/**
 * Create and configure auto-generated tools manager
 */
export function createAutoGeneratedToolsManager(
  config: AutoGeneratorConfig,
): AutoGeneratedToolsManager {
  return new AutoGeneratedToolsManager(config);
}

/**
 * Helper function to integrate with existing MCP server
 */
export async function integrateAutoGeneratedTools(
  mcpServer: any,
  config: AutoGeneratorConfig,
): Promise<AutoGeneratedToolsManager> {
  const manager = new AutoGeneratedToolsManager(config);

  await manager.initialize();

  // Register tools with MCP server
  const tools = manager.getToolDefinitions();

  for (const tool of tools) {
    try {
      // Register tool with MCP server (assuming it has a registerTool method)
      if (typeof mcpServer.registerTool === 'function') {
        mcpServer.registerTool(tool, async (args: any) => {
          return await manager.executeTool(tool.name, args);
        });
      }

      logger.debug('Registered auto-generated tool with MCP server', {
        tool: tool.name,
      });
    } catch (error) {
      logger.error('Failed to register auto-generated tool', {
        tool: tool.name,
        error: error instanceof Error ? error.message : String(error),
      });
    }
  }

  logger.info('Auto-generated tools integrated with MCP server', {
    toolsRegistered: tools.length,
  });

  return manager;
}

export default AutoGeneratedToolsManager;
