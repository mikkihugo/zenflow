/**\n * Hierarchical Task Management Plugin\n * Manages the complete hierarchy: Vision → Epic → Feature → PRD → ADR → User Story → Task\n * With intelligent suggestion system for missing components\n */\n\nimport { EventEmitter } from 'events';\nimport { nanoid } from 'nanoid';\nimport fs from 'fs-extra';\nimport path from 'path';\n\nexport class HierarchicalTaskManagerPlugin extends EventEmitter {\n  static metadata = {\n    name: 'hierarchical-task-manager',\n    version: '1.0.0',\n    description: 'Complete hierarchical task management from vision to implementation',\n    dependencies: ['memory-rag', 'architect-advisor'],\n    capabilities: ['vision-management', 'epic-breakdown', 'feature-planning', 'prd-generation', 'user-story-creation', 'task-delegation', 'completeness-analysis']\n  };\n\n  constructor() {\n    super();\n    this.registry = null;\n    this.memoryRag = null;\n    this.architectAdvisor = null;\n    \n    // Hierarchical storage\n    this.visions = new Map();\n    this.epics = new Map();\n    this.features = new Map();\n    this.prds = new Map();\n    this.adrs = new Map();\n    this.userStories = new Map();\n    this.tasks = new Map();\n    this.assignments = new Map();\n    \n    // Intelligence engines\n    this.suggestionEngine = null;\n    this.completenessAnalyzer = null;\n    this.breakdownEngine = null;\n  }\n\n  async initialize(registry, options = {}) {\n    this.registry = registry;\n    this.options = {\n      hierarchyPath: options.hierarchyPath || './.swarm/hierarchy',\n      autoBreakdown: options.autoBreakdown !== false,\n      completenessThreshold: options.completenessThreshold || 0.85,\n      suggestionInterval: options.suggestionInterval || 300000, // 5 minutes\n      enableQueenCoordination: options.enableQueenCoordination !== false,\n      minConfidenceForSuggestion: options.minConfidenceForSuggestion || 0.7,\n      ...options\n    };\n\n    // Get dependent plugins\n    this.memoryRag = registry.pluginSystem.getPlugin('memory-rag');\n    this.architectAdvisor = registry.pluginSystem.getPlugin('architect-advisor');\n\n    // Initialize storage\n    await this.initializeStorage();\n\n    // Initialize intelligence engines\n    this.initializeIntelligenceEngines();\n\n    // Load existing hierarchy\n    await this.loadHierarchy();\n\n    // Register plugin services\n    await this.registerPluginServices();\n\n    // Start intelligent monitoring\n    if (this.options.autoBreakdown) {\n      this.startIntelligentMonitoring();\n    }\n  }\n\n  async initializeStorage() {\n    await fs.ensureDir(this.options.hierarchyPath);\n    \n    this.storageFiles = {\n      visions: path.join(this.options.hierarchyPath, 'visions.json'),\n      epics: path.join(this.options.hierarchyPath, 'epics.json'),\n      features: path.join(this.options.hierarchyPath, 'features.json'),\n      prds: path.join(this.options.hierarchyPath, 'prds.json'),\n      userStories: path.join(this.options.hierarchyPath, 'user-stories.json'),\n      tasks: path.join(this.options.hierarchyPath, 'tasks.json'),\n      assignments: path.join(this.options.hierarchyPath, 'assignments.json'),\n      suggestions: path.join(this.options.hierarchyPath, 'suggestions.json')\n    };\n  }\n\n  initializeIntelligenceEngines() {\n    this.suggestionEngine = new SuggestionEngine(this);\n    this.completenessAnalyzer = new CompletenessAnalyzer(this);\n    this.breakdownEngine = new BreakdownEngine(this);\n  }\n\n  async registerPluginServices() {\n    await this.registry.register('service:hierarchical-task-manager', {\n      plugin: 'hierarchical-task-manager',\n      version: HierarchicalTaskManagerPlugin.metadata.version,\n      capabilities: HierarchicalTaskManagerPlugin.metadata.capabilities,\n      hierarchy: {\n        visions: this.visions.size,\n        epics: this.epics.size,\n        features: this.features.size,\n        prds: this.prds.size,\n        userStories: this.userStories.size,\n        tasks: this.tasks.size,\n        assignments: this.assignments.size\n      }\n    }, {\n      tags: ['service', 'plugin', 'task-management', 'hierarchy', 'intelligence'],\n      ttl: 3600\n    });\n  }\n\n  // Vision Management\n  async createVision(visionData) {\n    const visionId = nanoid();\n    const vision = {\n      id: visionId,\n      title: visionData.title,\n      description: visionData.description,\n      objectives: visionData.objectives || [],\n      stakeholders: visionData.stakeholders || [],\n      timeline: visionData.timeline,\n      priority: visionData.priority || 'medium',\n      status: 'draft',\n      created: new Date(),\n      metadata: {\n        source: visionData.source || 'manual',\n        confidence: visionData.confidence || 1.0,\n        complexity: this.calculateComplexity(visionData)\n      },\n      children: {\n        epics: [],\n        prds: [],\n        adrs: []\n      }\n    };\n\n    this.visions.set(visionId, vision);\n\n    // Register in meta registry\n    await this.registry.register(`vision:${visionId}`, vision, {\n      tags: ['vision', 'hierarchy', 'planning'],\n      ttl: 86400\n    });\n\n    // Auto-generate breakdown if enabled\n    if (this.options.autoBreakdown) {\n      await this.initiateBreakdown(visionId, 'vision');\n    }\n\n    await this.persistHierarchy();\n    this.emit('visionCreated', { visionId, vision });\n\n    return visionId;\n  }\n\n  // Epic Management\n  async createEpic(epicData, parentVisionId) {\n    const epicId = nanoid();\n    const epic = {\n      id: epicId,\n      parentVisionId,\n      title: epicData.title,\n      description: epicData.description,\n      acceptanceCriteria: epicData.acceptanceCriteria || [],\n      businessValue: epicData.businessValue,\n      effort: epicData.effort || 'medium',\n      priority: epicData.priority || 'medium',\n      status: 'planned',\n      created: new Date(),\n      metadata: {\n        source: epicData.source || 'breakdown',\n        confidence: epicData.confidence || 0.8,\n        complexity: this.calculateComplexity(epicData)\n      },\n      children: {\n        features: [],\n        userStories: [],\n        tasks: []\n      }\n    };\n\n    this.epics.set(epicId, epic);\n\n    // Link to parent vision\n    if (parentVisionId && this.visions.has(parentVisionId)) {\n      this.visions.get(parentVisionId).children.epics.push(epicId);\n    }\n\n    // Register in meta registry\n    await this.registry.register(`epic:${epicId}`, epic, {\n      tags: ['epic', 'hierarchy', 'planning', `vision:${parentVisionId}`],\n      ttl: 86400\n    });\n\n    // Auto-generate feature breakdown\n    if (this.options.autoBreakdown) {\n      await this.initiateBreakdown(epicId, 'epic');\n    }\n\n    await this.persistHierarchy();\n    this.emit('epicCreated', { epicId, epic, parentVisionId });\n\n    return epicId;\n  }\n\n  // Feature Management\n  async createFeature(featureData, parentEpicId) {\n    const featureId = nanoid();\n    const feature = {\n      id: featureId,\n      parentEpicId,\n      title: featureData.title,\n      description: featureData.description,\n      functionalRequirements: featureData.functionalRequirements || [],\n      nonFunctionalRequirements: featureData.nonFunctionalRequirements || [],\n      dependencies: featureData.dependencies || [],\n      risks: featureData.risks || [],\n      effort: featureData.effort || 'medium',\n      priority: featureData.priority || 'medium',\n      status: 'defined',\n      created: new Date(),\n      metadata: {\n        source: featureData.source || 'breakdown',\n        confidence: featureData.confidence || 0.7,\n        complexity: this.calculateComplexity(featureData)\n      },\n      children: {\n        userStories: [],\n        tasks: [],\n        prds: []\n      }\n    };\n\n    this.features.set(featureId, feature);\n\n    // Link to parent epic\n    if (parentEpicId && this.epics.has(parentEpicId)) {\n      this.epics.get(parentEpicId).children.features.push(featureId);\n    }\n\n    // Register in meta registry\n    await this.registry.register(`feature:${featureId}`, feature, {\n      tags: ['feature', 'hierarchy', 'planning', `epic:${parentEpicId}`],\n      ttl: 86400\n    });\n\n    // Auto-generate PRD and User Stories\n    if (this.options.autoBreakdown) {\n      await this.generatePRD(featureId);\n      await this.initiateBreakdown(featureId, 'feature');\n    }\n\n    await this.persistHierarchy();\n    this.emit('featureCreated', { featureId, feature, parentEpicId });\n\n    return featureId;\n  }\n\n  // PRD Generation\n  async generatePRD(featureId) {\n    const feature = this.features.get(featureId);\n    if (!feature) {\n      throw new Error(`Feature ${featureId} not found`);\n    }\n\n    const prdId = nanoid();\n    const prd = {\n      id: prdId,\n      featureId,\n      title: `PRD: ${feature.title}`,\n      sections: {\n        overview: {\n          description: feature.description,\n          objectives: this.extractObjectives(feature),\n          success_metrics: this.generateSuccessMetrics(feature)\n        },\n        requirements: {\n          functional: feature.functionalRequirements,\n          non_functional: feature.nonFunctionalRequirements,\n          constraints: this.identifyConstraints(feature)\n        },\n        user_stories: [], // Will be populated\n        technical_specifications: {\n          architecture: await this.generateArchitecturalGuidance(feature),\n          dependencies: feature.dependencies,\n          risks: feature.risks\n        },\n        implementation: {\n          phases: this.generateImplementationPhases(feature),\n          timeline: this.estimateTimeline(feature),\n          resources: this.estimateResources(feature)\n        }\n      },\n      status: 'draft',\n      created: new Date(),\n      metadata: {\n        generatedBy: 'hierarchical-task-manager',\n        confidence: 0.8,\n        completeness: 0.6 // Will be updated as sections are filled\n      }\n    };\n\n    this.prds.set(prdId, prd);\n\n    // Link to feature\n    feature.children.prds.push(prdId);\n\n    // Register in meta registry\n    await this.registry.register(`prd:${prdId}`, prd, {\n      tags: ['prd', 'hierarchy', 'documentation', `feature:${featureId}`],\n      ttl: 86400\n    });\n\n    // Generate PRD document\n    await this.generatePRDDocument(prdId);\n\n    await this.persistHierarchy();\n    this.emit('prdGenerated', { prdId, prd, featureId });\n\n    return prdId;\n  }\n\n  // User Story Creation\n  async createUserStory(storyData, parentId, parentType) {\n    const storyId = nanoid();\n    const userStory = {\n      id: storyId,\n      parentId,\n      parentType, // 'epic' or 'feature'\n      title: storyData.title,\n      narrative: {\n        as: storyData.as || 'a user',\n        i_want: storyData.i_want,\n        so_that: storyData.so_that\n      },\n      acceptanceCriteria: storyData.acceptanceCriteria || [],\n      priority: storyData.priority || 'medium',\n      effort: storyData.effort || 'medium',\n      status: 'backlog',\n      created: new Date(),\n      metadata: {\n        source: storyData.source || 'breakdown',\n        confidence: storyData.confidence || 0.7,\n        testability: this.assessTestability(storyData)\n      },\n      children: {\n        tasks: []\n      }\n    };\n\n    this.userStories.set(storyId, userStory);\n\n    // Link to parent\n    if (parentType === 'epic' && this.epics.has(parentId)) {\n      this.epics.get(parentId).children.userStories.push(storyId);\n    } else if (parentType === 'feature' && this.features.has(parentId)) {\n      this.features.get(parentId).children.userStories.push(storyId);\n    }\n\n    // Register in meta registry\n    await this.registry.register(`user-story:${storyId}`, userStory, {\n      tags: ['user-story', 'hierarchy', 'development', `${parentType}:${parentId}`],\n      ttl: 86400\n    });\n\n    // Auto-generate tasks\n    if (this.options.autoBreakdown) {\n      await this.generateTasksForUserStory(storyId);\n    }\n\n    await this.persistHierarchy();\n    this.emit('userStoryCreated', { storyId, userStory, parentId, parentType });\n\n    return storyId;\n  }\n\n  // Task Creation and Management\n  async createTask(taskData, parentId, parentType) {\n    const taskId = nanoid();\n    const task = {\n      id: taskId,\n      parentId,\n      parentType, // 'user-story', 'feature', 'epic'\n      title: taskData.title,\n      description: taskData.description,\n      type: taskData.type || 'development', // development, design, research, testing, deployment\n      priority: taskData.priority || 'medium',\n      effort: taskData.effort || 'medium',\n      skills: taskData.skills || [],\n      dependencies: taskData.dependencies || [],\n      status: 'todo',\n      assignee: null,\n      created: new Date(),\n      metadata: {\n        source: taskData.source || 'breakdown',\n        confidence: taskData.confidence || 0.8,\n        automation_potential: this.assessAutomationPotential(taskData)\n      }\n    };\n\n    this.tasks.set(taskId, task);\n\n    // Link to parent\n    if (parentType === 'user-story' && this.userStories.has(parentId)) {\n      this.userStories.get(parentId).children.tasks.push(taskId);\n    } else if (parentType === 'feature' && this.features.has(parentId)) {\n      this.features.get(parentId).children.tasks.push(taskId);\n    } else if (parentType === 'epic' && this.epics.has(parentId)) {\n      this.epics.get(parentId).children.tasks.push(taskId);\n    }\n\n    // Register in meta registry\n    await this.registry.register(`task:${taskId}`, task, {\n      tags: ['task', 'hierarchy', 'development', `${parentType}:${parentId}`, task.type],\n      ttl: 86400\n    });\n\n    await this.persistHierarchy();\n    this.emit('taskCreated', { taskId, task, parentId, parentType });\n\n    return taskId;\n  }\n\n  // Queen Task Assignment System\n  async assignTaskToQueen(taskId, queenId, context = {}) {\n    const task = this.tasks.get(taskId);\n    if (!task) {\n      throw new Error(`Task ${taskId} not found`);\n    }\n\n    const assignmentId = nanoid();\n    const assignment = {\n      id: assignmentId,\n      taskId,\n      queenId,\n      assigned: new Date(),\n      context: {\n        priority: task.priority,\n        skills_required: task.skills,\n        effort_estimate: task.effort,\n        dependencies: task.dependencies,\n        ...context\n      },\n      status: 'assigned',\n      progress: {\n        started: null,\n        completed: null,\n        progress_percentage: 0,\n        milestones: []\n      },\n      communication: {\n        updates: [],\n        blockers: [],\n        questions: []\n      }\n    };\n\n    this.assignments.set(assignmentId, assignment);\n    task.assignee = queenId;\n    task.status = 'assigned';\n\n    // Register assignment in meta registry\n    await this.registry.register(`assignment:${assignmentId}`, assignment, {\n      tags: ['assignment', 'task-delegation', 'queen', `queen:${queenId}`, `task:${taskId}`],\n      ttl: 86400\n    });\n\n    // Notify Queen system\n    await this.notifyQueenSystem(assignmentId, assignment);\n\n    await this.persistHierarchy();\n    this.emit('taskAssigned', { assignmentId, assignment, taskId, queenId });\n\n    return assignmentId;\n  }\n\n  // Intelligent Breakdown System\n  async initiateBreakdown(parentId, parentType) {\n    const breakdown = await this.breakdownEngine.generateBreakdown(parentId, parentType);\n    \n    if (breakdown.confidence > this.options.minConfidenceForSuggestion) {\n      for (const item of breakdown.items) {\n        await this.createChildItem(item, parentId, parentType);\n      }\n    }\n\n    this.emit('breakdownCompleted', { parentId, parentType, breakdown });\n    return breakdown;\n  }\n\n  async createChildItem(itemData, parentId, parentType) {\n    switch (parentType) {\n      case 'vision':\n        return await this.createEpic(itemData, parentId);\n      case 'epic':\n        return await this.createFeature(itemData, parentId);\n      case 'feature':\n        return await this.createUserStory(itemData, parentId, 'feature');\n      case 'user-story':\n        return await this.createTask(itemData, parentId, 'user-story');\n      default:\n        throw new Error(`Unknown parent type: ${parentType}`);\n    }\n  }\n\n  // Completeness Analysis and Suggestions\n  async analyzeCompleteness(hierarchyId, hierarchyType) {\n    const analysis = await this.completenessAnalyzer.analyze(hierarchyId, hierarchyType);\n    \n    if (analysis.completeness < this.options.completenessThreshold) {\n      const suggestions = await this.suggestionEngine.generateCompletionSuggestions(analysis);\n      \n      this.emit('completenessIssue', {\n        hierarchyId,\n        hierarchyType,\n        analysis,\n        suggestions\n      });\n      \n      return { analysis, suggestions };\n    }\n    \n    return { analysis, suggestions: [] };\n  }\n\n  async suggestMissingComponents() {\n    const allSuggestions = [];\n    \n    // Analyze all visions for completeness\n    for (const [visionId] of this.visions) {\n      const result = await this.analyzeCompleteness(visionId, 'vision');\n      if (result.suggestions.length > 0) {\n        allSuggestions.push(...result.suggestions);\n      }\n    }\n    \n    // Analyze orphaned items\n    const orphanAnalysis = await this.identifyOrphanedItems();\n    if (orphanAnalysis.length > 0) {\n      allSuggestions.push(...orphanAnalysis);\n    }\n    \n    return allSuggestions;\n  }\n\n  // Intelligence monitoring\n  startIntelligentMonitoring() {\n    this.monitoringInterval = setInterval(async () => {\n      await this.performIntelligentAnalysis();\n    }, this.options.suggestionInterval);\n  }\n\n  async performIntelligentAnalysis() {\n    try {\n      // Check completeness of all hierarchies\n      const suggestions = await this.suggestMissingComponents();\n      \n      if (suggestions.length > 0) {\n        this.emit('intelligentSuggestions', { suggestions, timestamp: new Date() });\n      }\n      \n      // Check for bottlenecks and optimization opportunities\n      const bottlenecks = await this.identifyBottlenecks();\n      if (bottlenecks.length > 0) {\n        this.emit('bottlenecksIdentified', { bottlenecks, timestamp: new Date() });\n      }\n      \n    } catch (error) {\n      this.emit('analysisError', error);\n    }\n  }\n\n  // Utility methods\n  calculateComplexity(data) {\n    let complexity = 1;\n    \n    if (data.description) {\n      complexity += Math.min(data.description.length / 100, 3);\n    }\n    \n    if (data.objectives?.length) {\n      complexity += data.objectives.length * 0.5;\n    }\n    \n    if (data.functionalRequirements?.length) {\n      complexity += data.functionalRequirements.length * 0.3;\n    }\n    \n    return Math.min(complexity, 10);\n  }\n\n  assessTestability(storyData) {\n    let score = 0.5;\n    \n    if (storyData.acceptanceCriteria?.length > 0) {\n      score += 0.3;\n    }\n    \n    if (storyData.i_want && storyData.so_that) {\n      score += 0.2;\n    }\n    \n    return Math.min(score, 1);\n  }\n\n  assessAutomationPotential(taskData) {\n    let score = 0.1;\n    \n    const automationKeywords = ['test', 'deploy', 'build', 'format', 'lint', 'check'];\n    if (automationKeywords.some(keyword => \n      taskData.title?.toLowerCase().includes(keyword) ||\n      taskData.description?.toLowerCase().includes(keyword)\n    )) {\n      score += 0.6;\n    }\n    \n    if (taskData.type === 'testing' || taskData.type === 'deployment') {\n      score += 0.3;\n    }\n    \n    return Math.min(score, 1);\n  }\n\n  // Hierarchy navigation and querying\n  async getHierarchy(rootId, rootType) {\n    const hierarchy = {\n      root: null,\n      children: []\n    };\n    \n    switch (rootType) {\n      case 'vision':\n        hierarchy.root = this.visions.get(rootId);\n        if (hierarchy.root) {\n          hierarchy.children = await this.getVisionChildren(rootId);\n        }\n        break;\n      case 'epic':\n        hierarchy.root = this.epics.get(rootId);\n        if (hierarchy.root) {\n          hierarchy.children = await this.getEpicChildren(rootId);\n        }\n        break;\n      case 'feature':\n        hierarchy.root = this.features.get(rootId);\n        if (hierarchy.root) {\n          hierarchy.children = await this.getFeatureChildren(rootId);\n        }\n        break;\n    }\n    \n    return hierarchy;\n  }\n\n  async getVisionChildren(visionId) {\n    const vision = this.visions.get(visionId);\n    if (!vision) return [];\n    \n    const children = [];\n    \n    // Add epics\n    for (const epicId of vision.children.epics || []) {\n      const epic = this.epics.get(epicId);\n      if (epic) {\n        children.push({\n          type: 'epic',\n          data: epic,\n          children: await this.getEpicChildren(epicId)\n        });\n      }\n    }\n    \n    return children;\n  }\n\n  async getEpicChildren(epicId) {\n    const epic = this.epics.get(epicId);\n    if (!epic) return [];\n    \n    const children = [];\n    \n    // Add features\n    for (const featureId of epic.children.features || []) {\n      const feature = this.features.get(featureId);\n      if (feature) {\n        children.push({\n          type: 'feature',\n          data: feature,\n          children: await this.getFeatureChildren(featureId)\n        });\n      }\n    }\n    \n    // Add user stories\n    for (const storyId of epic.children.userStories || []) {\n      const story = this.userStories.get(storyId);\n      if (story) {\n        children.push({\n          type: 'user-story',\n          data: story,\n          children: await this.getUserStoryChildren(storyId)\n        });\n      }\n    }\n    \n    return children;\n  }\n\n  async getFeatureChildren(featureId) {\n    const feature = this.features.get(featureId);\n    if (!feature) return [];\n    \n    const children = [];\n    \n    // Add user stories\n    for (const storyId of feature.children.userStories || []) {\n      const story = this.userStories.get(storyId);\n      if (story) {\n        children.push({\n          type: 'user-story',\n          data: story,\n          children: await this.getUserStoryChildren(storyId)\n        });\n      }\n    }\n    \n    // Add tasks\n    for (const taskId of feature.children.tasks || []) {\n      const task = this.tasks.get(taskId);\n      if (task) {\n        children.push({\n          type: 'task',\n          data: task,\n          children: []\n        });\n      }\n    }\n    \n    return children;\n  }\n\n  async getUserStoryChildren(storyId) {\n    const story = this.userStories.get(storyId);\n    if (!story) return [];\n    \n    const children = [];\n    \n    // Add tasks\n    for (const taskId of story.children.tasks || []) {\n      const task = this.tasks.get(taskId);\n      if (task) {\n        children.push({\n          type: 'task',\n          data: task,\n          children: []\n        });\n      }\n    }\n    \n    return children;\n  }\n\n  // Persistence methods\n  async persistHierarchy() {\n    const promises = [];\n    \n    promises.push(this.saveToFile(this.storageFiles.visions, Array.from(this.visions.entries())));\n    promises.push(this.saveToFile(this.storageFiles.epics, Array.from(this.epics.entries())));\n    promises.push(this.saveToFile(this.storageFiles.features, Array.from(this.features.entries())));\n    promises.push(this.saveToFile(this.storageFiles.prds, Array.from(this.prds.entries())));\n    promises.push(this.saveToFile(this.storageFiles.userStories, Array.from(this.userStories.entries())));\n    promises.push(this.saveToFile(this.storageFiles.tasks, Array.from(this.tasks.entries())));\n    promises.push(this.saveToFile(this.storageFiles.assignments, Array.from(this.assignments.entries())));\n    \n    await Promise.all(promises);\n  }\n\n  async loadHierarchy() {\n    try {\n      await Promise.all([\n        this.loadFromFile(this.storageFiles.visions, this.visions),\n        this.loadFromFile(this.storageFiles.epics, this.epics),\n        this.loadFromFile(this.storageFiles.features, this.features),\n        this.loadFromFile(this.storageFiles.prds, this.prds),\n        this.loadFromFile(this.storageFiles.userStories, this.userStories),\n        this.loadFromFile(this.storageFiles.tasks, this.tasks),\n        this.loadFromFile(this.storageFiles.assignments, this.assignments)\n      ]);\n    } catch (error) {\n      this.emit('loadError', error);\n    }\n  }\n\n  async saveToFile(filePath, data) {\n    await fs.writeJson(filePath, data, { spaces: 2 });\n  }\n\n  async loadFromFile(filePath, targetMap) {\n    if (await fs.pathExists(filePath)) {\n      const data = await fs.readJson(filePath);\n      targetMap.clear();\n      for (const [key, value] of data) {\n        targetMap.set(key, value);\n      }\n    }\n  }\n\n  // API methods\n  getStats() {\n    return {\n      hierarchy: {\n        visions: this.visions.size,\n        epics: this.epics.size,\n        features: this.features.size,\n        prds: this.prds.size,\n        userStories: this.userStories.size,\n        tasks: this.tasks.size,\n        assignments: this.assignments.size\n      },\n      status: {\n        totalItems: this.visions.size + this.epics.size + this.features.size + this.userStories.size + this.tasks.size,\n        completedTasks: Array.from(this.tasks.values()).filter(t => t.status === 'completed').length,\n        activeTasks: Array.from(this.tasks.values()).filter(t => ['assigned', 'in-progress'].includes(t.status)).length\n      }\n    };\n  }\n\n  async cleanup() {\n    if (this.monitoringInterval) {\n      clearInterval(this.monitoringInterval);\n    }\n    \n    await this.persistHierarchy();\n    \n    // Clear memory\n    this.visions.clear();\n    this.epics.clear();\n    this.features.clear();\n    this.prds.clear();\n    this.userStories.clear();\n    this.tasks.clear();\n    this.assignments.clear();\n  }\n\n  // Helper methods - will be implemented by the engines\n  async generateTasksForUserStory(storyId) {\n    return this.breakdownEngine.generateTasksForUserStory(storyId);\n  }\n\n  async generateArchitecturalGuidance(feature) {\n    if (this.architectAdvisor) {\n      // Leverage the architect advisor for technical guidance\n      return { guidance: 'Use architect advisor for detailed guidance' };\n    }\n    return { guidance: 'Standard architecture patterns' };\n  }\n\n  async notifyQueenSystem(assignmentId, assignment) {\n    // Register the assignment so Queen systems can discover it\n    await this.registry.register(`queen-task:${assignmentId}`, {\n      type: 'task-assignment',\n      assignmentId,\n      taskId: assignment.taskId,\n      queenId: assignment.queenId,\n      context: assignment.context,\n      status: assignment.status,\n      created: assignment.assigned\n    }, {\n      tags: ['queen-task', 'assignment', `queen:${assignment.queenId}`],\n      ttl: 86400\n    });\n  }\n\n  // Placeholder methods that will be implemented by intelligence engines\n  extractObjectives(feature) {\n    return feature.functionalRequirements?.slice(0, 3) || [];\n  }\n\n  generateSuccessMetrics(feature) {\n    return [\n      'Feature implementation completed',\n      'All acceptance criteria met',\n      'User feedback positive'\n    ];\n  }\n\n  identifyConstraints(feature) {\n    return feature.dependencies || [];\n  }\n\n  generateImplementationPhases(feature) {\n    return [\n      { phase: 'Design', duration: '1 week' },\n      { phase: 'Implementation', duration: '2-4 weeks' },\n      { phase: 'Testing', duration: '1 week' },\n      { phase: 'Deployment', duration: '3 days' }\n    ];\n  }\n\n  estimateTimeline(feature) {\n    const complexity = feature.metadata?.complexity || 3;\n    return `${complexity * 2} weeks`;\n  }\n\n  estimateResources(feature) {\n    return {\n      developers: 1,\n      designers: 0,\n      qa: 1,\n      devops: 0\n    };\n  }\n\n  async generatePRDDocument(prdId) {\n    const prd = this.prds.get(prdId);\n    if (!prd) return;\n\n    const markdown = this.generatePRDMarkdown(prd);\n    const filePath = path.join(this.options.hierarchyPath, `prd-${prdId}.md`);\n    \n    await fs.writeFile(filePath, markdown, 'utf8');\n  }\n\n  generatePRDMarkdown(prd) {\n    return `# ${prd.title}\n\n## Overview\n${prd.sections.overview.description}\n\n### Objectives\n${prd.sections.overview.objectives.map(obj => `- ${obj}`).join('\\n')}\n\n### Success Metrics\n${prd.sections.overview.success_metrics.map(metric => `- ${metric}`).join('\\n')}\n\n## Requirements\n\n### Functional Requirements\n${prd.sections.requirements.functional.map(req => `- ${req}`).join('\\n')}\n\n### Non-Functional Requirements\n${prd.sections.requirements.non_functional.map(req => `- ${req}`).join('\\n')}\n\n## Technical Specifications\n\n### Architecture\n\\`\\`\\`json\n${JSON.stringify(prd.sections.technical_specifications.architecture, null, 2)}\n\\`\\`\\`\n\n### Dependencies\n${prd.sections.technical_specifications.dependencies.map(dep => `- ${dep}`).join('\\n')}\n\n### Risks\n${prd.sections.technical_specifications.risks.map(risk => `- ${risk}`).join('\\n')}\n\n## Implementation Plan\n\n### Phases\n${prd.sections.implementation.phases.map(phase => `- **${phase.phase}**: ${phase.duration}`).join('\\n')}\n\n### Timeline\n${prd.sections.implementation.timeline}\n\n### Resources\n\\`\\`\\`json\n${JSON.stringify(prd.sections.implementation.resources, null, 2)}\n\\`\\`\\`\n\n---\n*Generated by Hierarchical Task Manager Plugin*\n*Date: ${prd.created}*`;\n  }\n\n  async identifyOrphanedItems() {\n    const orphans = [];\n    \n    // Find features without epics\n    for (const [featureId, feature] of this.features) {\n      if (!feature.parentEpicId || !this.epics.has(feature.parentEpicId)) {\n        orphans.push({\n          type: 'orphaned-feature',\n          id: featureId,\n          suggestion: 'Create epic for this feature or link to existing epic',\n          confidence: 0.9\n        });\n      }\n    }\n    \n    // Find user stories without features or epics\n    for (const [storyId, story] of this.userStories) {\n      if (!story.parentId || (!this.epics.has(story.parentId) && !this.features.has(story.parentId))) {\n        orphans.push({\n          type: 'orphaned-user-story',\n          id: storyId,\n          suggestion: 'Link this user story to a feature or epic',\n          confidence: 0.9\n        });\n      }\n    }\n    \n    return orphans;\n  }\n\n  async identifyBottlenecks() {\n    const bottlenecks = [];\n    \n    // Find tasks with many dependencies\n    for (const [taskId, task] of this.tasks) {\n      if (task.dependencies.length > 3) {\n        bottlenecks.push({\n          type: 'dependency-bottleneck',\n          taskId,\n          dependencyCount: task.dependencies.length,\n          suggestion: 'Consider breaking down this task or parallelizing dependencies'\n        });\n      }\n    }\n    \n    // Find overloaded assignees\n    const assigneeLoads = new Map();\n    for (const [, assignment] of this.assignments) {\n      if (assignment.status === 'assigned') {\n        assigneeLoads.set(assignment.queenId, (assigneeLoads.get(assignment.queenId) || 0) + 1);\n      }\n    }\n    \n    for (const [queenId, load] of assigneeLoads) {\n      if (load > 5) {\n        bottlenecks.push({\n          type: 'assignee-overload',\n          queenId,\n          taskCount: load,\n          suggestion: 'Consider redistributing tasks or adding more resources'\n        });\n      }\n    }\n    \n    return bottlenecks;\n  }\n}\n\n// Intelligence Engines\nclass SuggestionEngine {\n  constructor(manager) {\n    this.manager = manager;\n  }\n\n  async generateCompletionSuggestions(analysis) {\n    const suggestions = [];\n    \n    if (analysis.missingEpics > 0) {\n      suggestions.push({\n        type: 'missing-epic',\n        priority: 'high',\n        suggestion: `Vision needs ${analysis.missingEpics} more epic(s) for completeness`,\n        confidence: 0.8\n      });\n    }\n    \n    if (analysis.missingFeatures > 0) {\n      suggestions.push({\n        type: 'missing-features',\n        priority: 'medium',\n        suggestion: `Epic needs ${analysis.missingFeatures} more feature(s)`,\n        confidence: 0.7\n      });\n    }\n    \n    return suggestions;\n  }\n}\n\nclass CompletenessAnalyzer {\n  constructor(manager) {\n    this.manager = manager;\n  }\n\n  async analyze(hierarchyId, hierarchyType) {\n    let completeness = 0;\n    let analysis = {};\n    \n    switch (hierarchyType) {\n      case 'vision':\n        analysis = await this.analyzeVision(hierarchyId);\n        break;\n      case 'epic':\n        analysis = await this.analyzeEpic(hierarchyId);\n        break;\n      case 'feature':\n        analysis = await this.analyzeFeature(hierarchyId);\n        break;\n    }\n    \n    // Calculate overall completeness score\n    completeness = this.calculateCompletenessScore(analysis);\n    \n    return { ...analysis, completeness };\n  }\n\n  async analyzeVision(visionId) {\n    const vision = this.manager.visions.get(visionId);\n    if (!vision) return { completeness: 0 };\n    \n    const epicCount = vision.children.epics?.length || 0;\n    const expectedEpics = Math.max(vision.objectives?.length || 3, 3);\n    \n    return {\n      hasDescription: !!vision.description,\n      hasObjectives: vision.objectives?.length > 0,\n      epicCount,\n      expectedEpics,\n      missingEpics: Math.max(expectedEpics - epicCount, 0),\n      hasStakeholders: vision.stakeholders?.length > 0,\n      hasTimeline: !!vision.timeline\n    };\n  }\n\n  async analyzeEpic(epicId) {\n    const epic = this.manager.epics.get(epicId);\n    if (!epic) return { completeness: 0 };\n    \n    const featureCount = epic.children.features?.length || 0;\n    const userStoryCount = epic.children.userStories?.length || 0;\n    \n    return {\n      hasDescription: !!epic.description,\n      hasAcceptanceCriteria: epic.acceptanceCriteria?.length > 0,\n      featureCount,\n      userStoryCount,\n      missingFeatures: Math.max(3 - featureCount, 0),\n      hasBusinessValue: !!epic.businessValue\n    };\n  }\n\n  async analyzeFeature(featureId) {\n    const feature = this.manager.features.get(featureId);\n    if (!feature) return { completeness: 0 };\n    \n    const userStoryCount = feature.children.userStories?.length || 0;\n    const taskCount = feature.children.tasks?.length || 0;\n    const prdCount = feature.children.prds?.length || 0;\n    \n    return {\n      hasDescription: !!feature.description,\n      hasFunctionalRequirements: feature.functionalRequirements?.length > 0,\n      hasNonFunctionalRequirements: feature.nonFunctionalRequirements?.length > 0,\n      userStoryCount,\n      taskCount,\n      prdCount,\n      hasPrd: prdCount > 0,\n      missingUserStories: Math.max(2 - userStoryCount, 0)\n    };\n  }\n\n  calculateCompletenessScore(analysis) {\n    let score = 0;\n    let total = 0;\n    \n    // Score basic requirements\n    if (analysis.hasDescription !== undefined) {\n      score += analysis.hasDescription ? 1 : 0;\n      total += 1;\n    }\n    \n    if (analysis.hasAcceptanceCriteria !== undefined) {\n      score += analysis.hasAcceptanceCriteria ? 1 : 0;\n      total += 1;\n    }\n    \n    if (analysis.hasFunctionalRequirements !== undefined) {\n      score += analysis.hasFunctionalRequirements ? 1 : 0;\n      total += 1;\n    }\n    \n    // Score children completeness\n    if (analysis.epicCount !== undefined && analysis.expectedEpics > 0) {\n      score += Math.min(analysis.epicCount / analysis.expectedEpics, 1);\n      total += 1;\n    }\n    \n    if (analysis.featureCount !== undefined) {\n      score += Math.min(analysis.featureCount / 3, 1); // Expect at least 3 features\n      total += 1;\n    }\n    \n    if (analysis.userStoryCount !== undefined) {\n      score += Math.min(analysis.userStoryCount / 2, 1); // Expect at least 2 user stories\n      total += 1;\n    }\n    \n    return total > 0 ? score / total : 0;\n  }\n}\n\nclass BreakdownEngine {\n  constructor(manager) {\n    this.manager = manager;\n  }\n\n  async generateBreakdown(parentId, parentType) {\n    const breakdown = {\n      parentId,\n      parentType,\n      items: [],\n      confidence: 0.7,\n      reasoning: 'AI-generated breakdown based on patterns'\n    };\n    \n    switch (parentType) {\n      case 'vision':\n        breakdown.items = await this.breakdownVision(parentId);\n        break;\n      case 'epic':\n        breakdown.items = await this.breakdownEpic(parentId);\n        break;\n      case 'feature':\n        breakdown.items = await this.breakdownFeature(parentId);\n        break;\n      case 'user-story':\n        breakdown.items = await this.breakdownUserStory(parentId);\n        break;\n    }\n    \n    return breakdown;\n  }\n\n  async breakdownVision(visionId) {\n    const vision = this.manager.visions.get(visionId);\n    if (!vision) return [];\n    \n    const epics = [];\n    \n    // Generate epics based on objectives\n    for (let i = 0; i < Math.min(vision.objectives?.length || 3, 5); i++) {\n      const objective = vision.objectives?.[i] || `Objective ${i + 1}`;\n      epics.push({\n        title: `Epic: ${objective}`,\n        description: `Implementation of ${objective} as part of ${vision.title}`,\n        businessValue: `Contributes to ${vision.title} vision`,\n        priority: i === 0 ? 'high' : 'medium',\n        source: 'ai-breakdown'\n      });\n    }\n    \n    return epics;\n  }\n\n  async breakdownEpic(epicId) {\n    const epic = this.manager.epics.get(epicId);\n    if (!epic) return [];\n    \n    const features = [];\n    \n    // Generate features based on acceptance criteria\n    const criteriaCount = epic.acceptanceCriteria?.length || 3;\n    for (let i = 0; i < Math.min(criteriaCount, 5); i++) {\n      const criteria = epic.acceptanceCriteria?.[i] || `Feature ${i + 1}`;\n      features.push({\n        title: `Feature: ${criteria.substring(0, 50)}...`,\n        description: `Implementation of: ${criteria}`,\n        functionalRequirements: [criteria],\n        priority: i < 2 ? 'high' : 'medium',\n        source: 'ai-breakdown'\n      });\n    }\n    \n    return features;\n  }\n\n  async breakdownFeature(featureId) {\n    const feature = this.manager.features.get(featureId);\n    if (!feature) return [];\n    \n    const userStories = [];\n    \n    // Generate user stories based on functional requirements\n    for (let i = 0; i < Math.min(feature.functionalRequirements?.length || 2, 4); i++) {\n      const requirement = feature.functionalRequirements?.[i] || `Requirement ${i + 1}`;\n      userStories.push({\n        title: `User Story: ${requirement.substring(0, 50)}...`,\n        as: 'a user',\n        i_want: requirement,\n        so_that: 'I can accomplish my goals efficiently',\n        acceptanceCriteria: [\n          'Given the user interface is available',\n          'When the user performs the action',\n          'Then the expected result occurs'\n        ],\n        priority: i < 2 ? 'high' : 'medium',\n        source: 'ai-breakdown'\n      });\n    }\n    \n    return userStories;\n  }\n\n  async breakdownUserStory(storyId) {\n    const story = this.manager.userStories.get(storyId);\n    if (!story) return [];\n    \n    const tasks = [];\n    \n    // Generate standard development tasks\n    const taskTypes = [\n      { title: 'Design UI/UX', type: 'design', effort: 'medium' },\n      { title: 'Implement Backend Logic', type: 'development', effort: 'high' },\n      { title: 'Implement Frontend', type: 'development', effort: 'high' },\n      { title: 'Write Unit Tests', type: 'testing', effort: 'medium' },\n      { title: 'Integration Testing', type: 'testing', effort: 'low' },\n      { title: 'Documentation', type: 'documentation', effort: 'low' }\n    ];\n    \n    for (const taskType of taskTypes) {\n      tasks.push({\n        title: `${taskType.title} for ${story.title}`,\n        description: `${taskType.title} to implement: ${story.narrative.i_want}`,\n        type: taskType.type,\n        effort: taskType.effort,\n        skills: this.getRequiredSkills(taskType.type),\n        priority: taskType.type === 'development' ? 'high' : 'medium',\n        source: 'ai-breakdown'\n      });\n    }\n    \n    return tasks;\n  }\n\n  async generateTasksForUserStory(storyId) {\n    const breakdown = await this.generateBreakdown(storyId, 'user-story');\n    const taskIds = [];\n    \n    for (const taskData of breakdown.items) {\n      const taskId = await this.manager.createTask(taskData, storyId, 'user-story');\n      taskIds.push(taskId);\n    }\n    \n    return taskIds;\n  }\n\n  getRequiredSkills(taskType) {\n    const skillMap = {\n      'development': ['programming', 'backend', 'frontend'],\n      'design': ['ui-design', 'ux-design'],\n      'testing': ['testing', 'qa'],\n      'documentation': ['writing', 'documentation'],\n      'deployment': ['devops', 'deployment']\n    };\n    \n    return skillMap[taskType] || ['general'];\n  }\n}\n\nexport default HierarchicalTaskManagerPlugin;"