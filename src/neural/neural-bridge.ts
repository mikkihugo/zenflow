/**
 * @file Neural Network Bridge
 * Integrates neural network components with Claude-Zen system.
 */

import { getLogger } from '../config/logging-config';

// TODO: Use dependency injection for logger
// Should inject Logger from DI container instead of creating directly
// Example: constructor(@inject(CORE_TOKENS.Logger) private logger: Logger) {}
const logger = getLogger('Neural');

export interface NeuralConfig {
  wasmPath?: string;
  gpuAcceleration?: boolean;
  modelPath?: string;
  enableTraining?: boolean;
}

export interface NeuralNetwork {
  id: string;
  type: 'feedforward' | 'lstm' | 'transformer' | 'autoencoder';
  layers: number[];
  weights?: Float32Array; // Changed to Float32Array for WASM compatibility
  status: 'idle' | 'training' | 'predicting' | 'error';
  handle?: number; // WASM network handle
}

export interface TrainingData {
  inputs: number[][];
  outputs: number[][];
}

export interface PredictionResult {
  outputs: number[];
  confidence: number;
  processingTime: number;
}

/**
 * Neural Network Bridge for Claude-Zen integration.
 *
 * @example
 */
// Import type for WASM module (will be generated by wasm-pack)
type WasmNetwork = any; // Will be replaced with actual type after wasm-pack build

export class NeuralBridge {
  private static instance: NeuralBridge;
  private networks: Map<string, WasmNetwork> = new Map(); // Now stores WASM networks
  private networkMetadata: Map<string, NeuralNetwork> = new Map(); // Stores metadata
  private config: NeuralConfig;
  private initialized = false;
  private wasmModule: any = null; // Will hold the WASM module

  constructor(config: NeuralConfig = {}) {
    this.config = {
      wasmPath: './wasm/claude_zen_neural', // Points to neural/wasm/ directory
      gpuAcceleration: false,
      enableTraining: true,
      ...config,
    };
  }

  static getInstance(config?: NeuralConfig): NeuralBridge {
    if (!NeuralBridge.instance) {
      NeuralBridge.instance = new NeuralBridge(config);
    }
    return NeuralBridge.instance;
  }

  /**
   * Initialize neural network bridge.
   */
  async initialize(): Promise<void> {
    if (this.initialized) return;

    logger.info('Initializing Neural Bridge...');

    try {
      // Load WASM module if available
      if (this.config.wasmPath) {
        await this.loadWasmModule();
      }

      // Initialize GPU acceleration if enabled
      if (this.config.gpuAcceleration) {
        await this.initializeGPU();
      }

      this.initialized = true;
      logger.info('Neural Bridge initialized successfully');
    } catch (error) {
      logger.error('Failed to initialize Neural Bridge:', error);
      throw error;
    }
  }

  /**
   * Create a new neural network.
   *
   * @param id
   * @param type
   * @param layers
   */
  async createNetwork(
    id: string,
    type: NeuralNetwork['type'],
    layers: number[]
  ): Promise<string> {
    if (!this.initialized) {
      await this.initialize();
    }

    if (!this.wasmModule) {
      throw new Error('WASM module not loaded');
    }

    try {
      // Create the actual WASM network using our Rust implementation
      const layersArray = new Uint32Array(layers);
      const wasmNetwork = new this.wasmModule.WasmNetwork(layersArray);

      // Store the WASM network instance
      this.networks.set(id, wasmNetwork);

      // Store metadata separately for status tracking
      const metadata: NeuralNetwork = {
        id,
        type,
        layers,
        status: 'idle',
      };
      this.networkMetadata.set(id, metadata);

      logger.info(`Created WASM neural network: ${id} (${type}) with layers: [${layers.join(', ')}]`);
      return id;
    } catch (error) {
      logger.error(`Failed to create network ${id}:`, error);
      throw new Error(`Network creation failed: ${error.message}`);
    }
  }

  /**
   * Train a neural network.
   *
   * @param networkId
   * @param trainingData
   * @param epochs
   */
  async trainNetwork(
    networkId: string,
    trainingData: TrainingData,
    epochs: number = 1000
  ): Promise<boolean> {
    const wasmNetwork = this.networks.get(networkId);
    const metadata = this.networkMetadata.get(networkId);
    
    if (!wasmNetwork || !metadata) {
      throw new Error(`Network not found: ${networkId}`);
    }

    if (!this.config.enableTraining) {
      throw new Error('Training is disabled in configuration');
    }

    metadata.status = 'training';
    logger.info(`Training WASM network ${networkId} for ${epochs} epochs`);

    try {
      const startTime = Date.now();

      // Flatten the training data into Float32Arrays for WASM
      const flatInputs = new Float32Array(trainingData.inputs.flat());
      const flatOutputs = new Float32Array(trainingData.outputs.flat());

      // Call the actual WASM training function
      const finalError = wasmNetwork.train(flatInputs, flatOutputs, epochs);

      const trainingTime = Date.now() - startTime;
      metadata.status = 'idle';

      logger.info(`WASM training completed for ${networkId} in ${trainingTime}ms with final error: ${finalError}`);
      return true;
    } catch (error) {
      metadata.status = 'error';
      logger.error(`WASM training failed for ${networkId}:`, error);
      return false;
    }
  }

  /**
   * Make predictions with a neural network.
   *
   * @param networkId
   * @param inputs
   */
  async predict(
    networkId: string,
    inputs: number[]
  ): Promise<PredictionResult> {
    const wasmNetwork = this.networks.get(networkId);
    const metadata = this.networkMetadata.get(networkId);
    
    if (!wasmNetwork || !metadata) {
      throw new Error(`Network not found: ${networkId}`);
    }

    metadata.status = 'predicting';
    const startTime = Date.now();

    try {
      // Convert inputs to Float32Array for WASM
      const inputsArray = new Float32Array(inputs);
      
      // Call the actual WASM predict function
      const outputsArray = wasmNetwork.predict(inputsArray);
      
      // Convert the result back to a standard number array
      const outputs = Array.from(outputsArray);
      const processingTime = Date.now() - startTime;

      metadata.status = 'idle';

      return {
        outputs,
        confidence: this.calculateConfidence(outputs),
        processingTime,
      };
    } catch (error) {
      metadata.status = 'error';
      logger.error(`WASM prediction failed for ${networkId}:`, error);
      throw error;
    }
  }

  /**
   * Calculate confidence from network outputs.
   * For softmax outputs, this would be the max probability.
   * For regression, this could be based on output variance.
   *
   * @param outputs
   */
  private calculateConfidence(outputs: number[]): number {
    if (outputs.length === 0) return 0;
    
    // For classification (softmax-like outputs), use max value
    if (outputs.every(x => x >= 0 && x <= 1)) {
      return Math.max(...outputs);
    }
    
    // For regression or other outputs, use a different heuristic
    // This is a simple approach - could be more sophisticated
    const mean = outputs.reduce((a, b) => a + b, 0) / outputs.length;
    const variance = outputs.reduce((a, b) => a + (b - mean) ** 2, 0) / outputs.length;
    return Math.max(0, Math.min(1, 1 - variance)); // Lower variance = higher confidence
  }

  /**
   * Get network status.
   *
   * @param networkId
   */
  getNetworkStatus(networkId: string): NeuralNetwork | undefined {
    return this.networkMetadata.get(networkId);
  }

  /**
   * List all networks.
   */
  listNetworks(): NeuralNetwork[] {
    return Array.from(this.networkMetadata.values());
  }

  /**
   * Remove a network.
   *
   * @param networkId
   */
  removeNetwork(networkId: string): boolean {
    const wasmNetwork = this.networks.get(networkId);
    if (wasmNetwork) {
      // WASM networks are automatically cleaned up when they go out of scope
      // due to the Drop implementation in Rust
      this.networks.delete(networkId);
    }
    return this.networkMetadata.delete(networkId);
  }

  /**
   * Get neural system stats.
   */
  getStats(): {
    totalNetworks: number;
    activeNetworks: number;
    trainingNetworks: number;
    gpuEnabled: boolean;
    wasmEnabled: boolean;
  } {
    const networks = Array.from(this.networkMetadata.values());

    return {
      totalNetworks: networks.length,
      activeNetworks: networks.filter((n) => n.status !== 'idle').length,
      trainingNetworks: networks.filter((n) => n.status === 'training').length,
      gpuEnabled: !!this.config.gpuAcceleration,
      wasmEnabled: !!this.wasmModule,
    };
  }

  private async loadWasmModule(): Promise<void> {
    logger.info('Loading WASM module...');

    try {
      // Dynamically import the WASM module generated by wasm-pack
      const wasmModule = await import(/* @vite-ignore */ `${this.config.wasmPath}/claude_zen_neural.js`);
      
      // Initialize the WASM module
      await wasmModule.default();
      
      // Store the module for later use
      this.wasmModule = wasmModule;
      
      logger.info('WASM module loaded and initialized successfully');
    } catch (error) {
      logger.error('Failed to load WASM module:', error);
      throw new Error(`WASM module loading failed: ${error.message}`);
    }
  }

  private async initializeGPU(): Promise<void> {
    // In a real implementation, this would initialize GPU acceleration
    // using the WebGPU components from the integrated system
    logger.info('Initializing GPU acceleration...');

    // Simulate GPU initialization
    await new Promise((resolve) => setTimeout(resolve, 200));

    logger.info('GPU acceleration initialized');
  }


  /**
   * Shutdown neural bridge.
   */
  async shutdown(): Promise<void> {
    logger.info('Shutting down Neural Bridge...');

    // Stop all training processes by updating metadata
    for (const metadata of this.networkMetadata.values()) {
      if (metadata.status === 'training') {
        metadata.status = 'idle';
      }
    }

    // Clear WASM networks (will trigger Drop implementation in Rust)
    this.networks.clear();
    this.networkMetadata.clear();
    this.wasmModule = null;
    this.initialized = false;

    logger.info('Neural Bridge shutdown complete');
  }
}

// Export convenience functions
export async function createNeuralNetwork(
  id: string,
  type: NeuralNetwork['type'],
  layers: number[],
  config?: NeuralConfig
): Promise<string> {
  const bridge = NeuralBridge.getInstance(config);
  return await bridge.createNetwork(id, type, layers);
}

export async function trainNeuralNetwork(
  networkId: string,
  trainingData: TrainingData,
  epochs?: number
): Promise<boolean> {
  const bridge = NeuralBridge.getInstance();
  return await bridge.trainNetwork(networkId, trainingData, epochs);
}

export async function predictWithNetwork(
  networkId: string,
  inputs: number[]
): Promise<PredictionResult> {
  const bridge = NeuralBridge.getInstance();
  return await bridge.predict(networkId, inputs);
}
