import express from 'express';
import { createServer } from 'http';
import { WebSocketServer } from 'ws';
import * as OpenApiValidator from 'express-openapi-validator';
import swaggerUi from 'swagger-ui-express';
import cors from 'cors';
import helmet from 'helmet';
import rateLimit from 'express-rate-limit';
import { generateApiFromMeow } from '../cli/generate-api-from-meow.js';
import { executeCommand } from '../cli/command-registry.js';
import meow from 'meow';
import Database from 'better-sqlite3';
import { readHiveRegistry } from '../cli/command-handlers/hive-mind-command.js';
import { v4 as uuidv4 } from 'uuid';
import { EventEmitter } from 'events';

/**
 * üöÄ Singularity Alpha - Enterprise-Grade Auto-Generated API
 * 
 * Features:
 * ‚úÖ Complete REST API for swarm management
 * ‚úÖ Real-time WebSocket coordination
 * ‚úÖ Auto-generated from CLI definitions
 * ‚úÖ Enterprise security & rate limiting
 * ‚úÖ Comprehensive error handling
 * ‚úÖ Swagger/OpenAPI documentation
 */

const cli = meow(`
  Usage
    $ claude-zen <command> [options]

  Commands
    create       Create new service with persistent coordination
    list         List all services and their coordination status  
    swarm        Launch swarm with ruv-swarm coordination
    spawn        Spawn AI agents with coordination modes
    init         Initialize project with enterprise environment
    start        Start orchestration with swarm intelligence
    status       Comprehensive system status
    help         Show help

  Options
    --version, -v  Show version
    --help, -h     Show help
`, {
  importMeta: import.meta,
  flags: {
    help: { type: 'boolean', shortFlag: 'h' },
    version: { type: 'boolean', shortFlag: 'v' },
  }
});

export class AutoGeneratedAPI extends EventEmitter {
  constructor(options = {}) {
    super();
    this.port = options.port || 3000;
    this.app = express();
    this.server = null;
    this.wss = null;
    this.isRunning = false;
    this.openapiSpec = generateApiFromMeow(cli);
    
    // In-memory stores (would be replaced with proper DB in production)
    this.swarms = new Map();
    this.agents = new Map();
    this.tasks = new Map();
    this.sessions = new Map();
    this.metrics = {
      requests: 0,
      swarms: 0,
      agents: 0,
      tasks: 0,
      errors: 0
    };
    
    this.setupMiddleware();
    this.setupRoutes();
  }

  setupMiddleware() {
    // Security middleware
    this.app.use(helmet({
      crossOriginEmbedderPolicy: false,
      contentSecurityPolicy: {
        directives: {
          defaultSrc: ["'self'"],
          styleSrc: ["'self'", "'unsafe-inline'"],
          scriptSrc: ["'self'", "'unsafe-inline'"],
          connectSrc: ["'self'", "ws:", "wss:"]
        }
      }
    }));
    
    // CORS
    this.app.use(cors({
      origin: ['http://localhost:3000', 'http://localhost:3001'],
      credentials: true
    }));
    
    // Rate limiting
    const limiter = rateLimit({
      windowMs: 15 * 60 * 1000, // 15 minutes
      max: 1000, // limit each IP to 1000 requests per windowMs
      message: { error: 'Too many requests' }
    });
    this.app.use('/api/', limiter);
    
    // Body parsing
    this.app.use(express.json({ limit: '10mb' }));
    this.app.use(express.urlencoded({ extended: true }));
    
    // Request logging
    this.app.use((req, res, next) => {
      this.metrics.requests++;
      console.log(`${new Date().toISOString()} ${req.method} ${req.path}`);
      next();
    });
  }

  setupRoutes() {
    // Serve console at /console route - terminal-style interface
    this.app.get('/console', (req, res) => {
      res.sendFile(new URL('../cli/ui/console/index.html', import.meta.url).pathname);
    });
    
    // Serve cosmetics store at /store route - Modern WordPress-style store
    this.app.get('/store', (req, res) => {
      res.send(`
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>‚ú® Adema Beauty - Premium Cosmetics Store</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #ffeef8 0%, #fff5f8 50%, #f8e8ff 100%);
        }
        
        .header {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            position: fixed;
            top: 0;
            width: 100%;
            z-index: 1000;
            padding: 1rem 0;
            box-shadow: 0 2px 20px rgba(0,0,0,0.1);
        }
        
        .nav-container {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 2rem;
        }
        
        .logo {
            font-size: 2rem;
            font-weight: bold;
            background: linear-gradient(45deg, #ff6b9d, #c44569, #f8b500);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .nav-menu {
            display: flex;
            list-style: none;
            gap: 2rem;
        }
        
        .nav-menu a {
            text-decoration: none;
            color: #333;
            font-weight: 500;
            transition: color 0.3s;
        }
        
        .nav-menu a:hover {
            color: #ff6b9d;
        }
        
        .cart-icon {
            background: linear-gradient(45deg, #ff6b9d, #c44569);
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 25px;
            text-decoration: none;
            font-weight: bold;
            transition: transform 0.3s;
        }
        
        .cart-icon:hover {
            transform: translateY(-2px);
        }
        
        .hero {
            margin-top: 80px;
            padding: 4rem 2rem;
            text-align: center;
            background: linear-gradient(135deg, rgba(255,107,157,0.1) 0%, rgba(196,69,105,0.1) 100%);
        }
        
        .hero h1 {
            font-size: 3.5rem;
            margin-bottom: 1rem;
            background: linear-gradient(45deg, #ff6b9d, #c44569, #f8b500);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .hero p {
            font-size: 1.2rem;
            color: #666;
            margin-bottom: 2rem;
            max-width: 600px;
            margin-left: auto;
            margin-right: auto;
        }
        
        .cta-button {
            background: linear-gradient(45deg, #ff6b9d, #c44569);
            color: white;
            padding: 1rem 2rem;
            border: none;
            border-radius: 30px;
            font-size: 1.1rem;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.3s;
            text-decoration: none;
            display: inline-block;
        }
        
        .cta-button:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 25px rgba(255,107,157,0.3);
        }
        
        .categories {
            padding: 4rem 2rem;
            max-width: 1200px;
            margin: 0 auto;
        }
        
        .section-title {
            text-align: center;
            font-size: 2.5rem;
            margin-bottom: 3rem;
            color: #333;
        }
        
        .category-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 2rem;
            margin-bottom: 4rem;
        }
        
        .category-card {
            background: white;
            border-radius: 20px;
            padding: 2rem;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            transition: transform 0.3s;
            cursor: pointer;
        }
        
        .category-card:hover {
            transform: translateY(-10px);
        }
        
        .category-icon {
            font-size: 3rem;
            margin-bottom: 1rem;
        }
        
        .category-card h3 {
            font-size: 1.5rem;
            margin-bottom: 1rem;
            color: #333;
        }
        
        .category-card p {
            color: #666;
            margin-bottom: 1.5rem;
        }
        
        .products {
            background: white;
            padding: 4rem 2rem;
        }
        
        .products-container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        .product-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 2rem;
        }
        
        .product-card {
            background: #fff;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 5px 20px rgba(0,0,0,0.1);
            transition: transform 0.3s;
        }
        
        .product-card:hover {
            transform: translateY(-5px);
        }
        
        .product-image {
            height: 250px;
            background: linear-gradient(45deg, #ffeef8, #fff5f8);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 4rem;
        }
        
        .product-info {
            padding: 1.5rem;
        }
        
        .product-name {
            font-size: 1.2rem;
            font-weight: bold;
            margin-bottom: 0.5rem;
            color: #333;
        }
        
        .product-price {
            font-size: 1.4rem;
            font-weight: bold;
            color: #ff6b9d;
            margin-bottom: 1rem;
        }
        
        .add-to-cart {
            background: linear-gradient(45deg, #ff6b9d, #c44569);
            color: white;
            border: none;
            padding: 0.8rem 1.5rem;
            border-radius: 25px;
            cursor: pointer;
            font-weight: bold;
            transition: transform 0.3s;
            width: 100%;
        }
        
        .add-to-cart:hover {
            transform: translateY(-2px);
        }
        
        .footer {
            background: #333;
            color: white;
            padding: 3rem 2rem 1rem;
            text-align: center;
        }
        
        .footer-content {
            max-width: 1200px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 2rem;
            margin-bottom: 2rem;
        }
        
        .footer-section h3 {
            margin-bottom: 1rem;
            color: #ff6b9d;
        }
        
        .footer-section a {
            color: #ccc;
            text-decoration: none;
            display: block;
            margin-bottom: 0.5rem;
            transition: color 0.3s;
        }
        
        .footer-section a:hover {
            color: #ff6b9d;
        }
        
        @media (max-width: 768px) {
            .nav-menu {
                display: none;
            }
            
            .hero h1 {
                font-size: 2.5rem;
            }
            
            .nav-container {
                padding: 0 1rem;
            }
        }
    </style>
</head>
<body>
    <header class="header">
        <div class="nav-container">
            <div class="logo">‚ú® Adema Beauty</div>
            <nav>
                <ul class="nav-menu">
                    <li><a href="#home">Home</a></li>
                    <li><a href="#skincare">Skincare</a></li>
                    <li><a href="#makeup">Makeup</a></li>
                    <li><a href="#fragrance">Fragrance</a></li>
                    <li><a href="#about">About</a></li>
                </ul>
            </nav>
            <a href="#cart" class="cart-icon">üõí Cart (0)</a>
        </div>
    </header>

    <section class="hero" id="home">
        <h1>Discover Your Beauty</h1>
        <p>Premium cosmetics and skincare products for the modern woman. Enhance your natural beauty with our carefully curated collection.</p>
        <a href="#products" class="cta-button">Shop Now</a>
    </section>

    <section class="categories" id="categories">
        <h2 class="section-title">Shop by Category</h2>
        <div class="category-grid">
            <div class="category-card" onclick="filterProducts('skincare')">
                <div class="category-icon">üß¥</div>
                <h3>Skincare</h3>
                <p>Nourish and protect your skin with our premium skincare collection</p>
            </div>
            <div class="category-card" onclick="filterProducts('makeup')">
                <div class="category-icon">üíÑ</div>
                <h3>Makeup</h3>
                <p>Express yourself with our vibrant and long-lasting makeup products</p>
            </div>
            <div class="category-card" onclick="filterProducts('fragrance')">
                <div class="category-icon">üå∏</div>
                <h3>Fragrance</h3>
                <p>Captivating scents that leave a lasting impression</p>
            </div>
        </div>
    </section>

    <section class="products" id="products">
        <div class="products-container">
            <h2 class="section-title">Featured Products</h2>
            <div class="product-grid" id="productGrid">
                <!-- Products will be loaded here by JavaScript -->
            </div>
        </div>
    </section>

    <footer class="footer">
        <div class="footer-content">
            <div class="footer-section">
                <h3>Quick Links</h3>
                <a href="#home">Home</a>
                <a href="#about">About Us</a>
                <a href="#contact">Contact</a>
                <a href="#shipping">Shipping Info</a>
            </div>
            <div class="footer-section">
                <h3>Categories</h3>
                <a href="#skincare">Skincare</a>
                <a href="#makeup">Makeup</a>
                <a href="#fragrance">Fragrance</a>
                <a href="#tools">Beauty Tools</a>
            </div>
            <div class="footer-section">
                <h3>Customer Service</h3>
                <a href="#support">Support</a>
                <a href="#returns">Returns</a>
                <a href="#faq">FAQ</a>
                <a href="#reviews">Reviews</a>
            </div>
            <div class="footer-section">
                <h3>Connect With Us</h3>
                <a href="#">Instagram</a>
                <a href="#">Facebook</a>
                <a href="#">YouTube</a>
                <a href="#">TikTok</a>
            </div>
        </div>
        <p>&copy; 2025 Adema Beauty. All rights reserved.</p>
    </footer>

    <script>
        // Product data (WooCommerce-style)
        const products = [
            {
                id: 1,
                name: "Hydrating Face Serum",
                price: 45.99,
                category: "skincare",
                image: "üß¥",
                description: "Deep hydration for all skin types"
            },
            {
                id: 2,
                name: "Matte Liquid Lipstick",
                price: 24.99,
                category: "makeup",
                image: "üíÑ",
                description: "Long-lasting matte finish"
            },
            {
                id: 3,
                name: "Rose Garden Perfume",
                price: 89.99,
                category: "fragrance",
                image: "üåπ",
                description: "Elegant floral fragrance"
            },
            {
                id: 4,
                name: "Vitamin C Cleanser",
                price: 32.99,
                category: "skincare",
                image: "üçä",
                description: "Brightening daily cleanser"
            },
            {
                id: 5,
                name: "Eyeshadow Palette",
                price: 54.99,
                category: "makeup",
                image: "üé®",
                description: "12 versatile shades"
            },
            {
                id: 6,
                name: "Vanilla Musk Body Spray",
                price: 19.99,
                category: "fragrance",
                image: "‚ú®",
                description: "Sweet and sensual scent"
            },
            {
                id: 7,
                name: "Anti-Aging Night Cream",
                price: 67.99,
                category: "skincare",
                image: "üåô",
                description: "Rejuvenating overnight treatment"
            },
            {
                id: 8,
                name: "Waterproof Mascara",
                price: 28.99,
                category: "makeup",
                image: "üëÅÔ∏è",
                description: "Volume and length that lasts"
            }
        ];

        let cart = [];
        let currentFilter = 'all';

        // Load products on page load
        document.addEventListener('DOMContentLoaded', function() {
            displayProducts(products);
        });

        function displayProducts(productsToShow) {
            const productGrid = document.getElementById('productGrid');
            productGrid.innerHTML = '';

            productsToShow.forEach(product => {
                const productCard = document.createElement('div');
                productCard.className = 'product-card';
                productCard.innerHTML = \`
                    <div class="product-image">\${product.image}</div>
                    <div class="product-info">
                        <div class="product-name">\${product.name}</div>
                        <div class="product-price">$\${product.price}</div>
                        <p>\${product.description}</p>
                        <button class="add-to-cart" onclick="addToCart(\${product.id})">
                            Add to Cart
                        </button>
                    </div>
                \`;
                productGrid.appendChild(productCard);
            });
        }

        function filterProducts(category) {
            currentFilter = category;
            const filteredProducts = category === 'all' 
                ? products 
                : products.filter(product => product.category === category);
            displayProducts(filteredProducts);
            
            // Update section title
            const sectionTitle = document.querySelector('.products .section-title');
            const categoryNames = {
                'all': 'Featured Products',
                'skincare': 'Skincare Products',
                'makeup': 'Makeup Products',
                'fragrance': 'Fragrance Collection'
            };
            sectionTitle.textContent = categoryNames[category] || 'Featured Products';
        }

        function addToCart(productId) {
            const product = products.find(p => p.id === productId);
            if (product) {
                cart.push(product);
                updateCartDisplay();
                
                // Show success animation
                const button = event.target;
                button.textContent = 'Added! ‚ú®';
                button.style.background = '#28a745';
                setTimeout(() => {
                    button.textContent = 'Add to Cart';
                    button.style.background = '';
                }, 1500);
            }
        }

        function updateCartDisplay() {
            const cartIcon = document.querySelector('.cart-icon');
            cartIcon.textContent = \`üõí Cart (\${cart.length})\`;
        }

        // Smooth scrolling for navigation links
        document.querySelectorAll('a[href^="#"]').forEach(anchor => {
            anchor.addEventListener('click', function (e) {
                e.preventDefault();
                const target = document.querySelector(this.getAttribute('href'));
                if (target) {
                    target.scrollIntoView({
                        behavior: 'smooth',
                        block: 'start'
                    });
                }
            });
        });

        // Add some interactive features
        document.addEventListener('DOMContentLoaded', function() {
            // Animate category cards on scroll
            const observerOptions = {
                threshold: 0.1,
                rootMargin: '0px 0px -50px 0px'
            };

            const observer = new IntersectionObserver(function(entries) {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        entry.target.style.opacity = '1';
                        entry.target.style.transform = 'translateY(0)';
                    }
                });
            }, observerOptions);

            // Observe all category cards and product cards
            document.querySelectorAll('.category-card, .product-card').forEach(card => {
                card.style.opacity = '0';
                card.style.transform = 'translateY(30px)';
                card.style.transition = 'opacity 0.6s ease, transform 0.6s ease';
                observer.observe(card);
            });
        });
    </script>
</body>
</html>
      `);
    });
    
    // Serve TUI web interface at /tui route - African Ubuntu Theme
    this.app.get('/tui', (req, res) => {
      res.send(`
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üåç Ubuntu Afrika TUI</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: 'Ubuntu', 'Monaco', 'Menlo', sans-serif;
            background: linear-gradient(135deg, #8B4513 0%, #CD853F 25%, #DAA520 50%, #228B22 75%, #006400 100%);
            color: #FFF8DC;
            min-height: 100vh;
            position: relative;
        }
        
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><text y="20" font-size="15" fill="%23DAA520" opacity="0.1">üåç</text><text y="40" font-size="15" fill="%23228B22" opacity="0.1">ü¶Å</text><text y="60" font-size="15" fill="%23CD853F" opacity="0.1">üêò</text><text y="80" font-size="15" fill="%23FF6347" opacity="0.1">üåÖ</text></svg>') repeat;
            pointer-events: none;
            animation: safariFloat 25s linear infinite;
        }
        
        @keyframes safariFloat {
            0% { transform: translateX(-100px) translateY(100vh); }
            100% { transform: translateX(100px) translateY(-100vh); }
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            position: relative;
            z-index: 1;
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
            animation: africanGlow 4s ease-in-out infinite alternate;
            background: rgba(139, 69, 19, 0.3);
            border-radius: 25px;
            padding: 25px;
            backdrop-filter: blur(15px);
            border: 3px solid rgba(218, 165, 32, 0.5);
        }
        
        @keyframes africanGlow {
            from { 
                text-shadow: 0 0 25px #DAA520, 0 0 35px #CD853F; 
                box-shadow: 0 0 40px rgba(218, 165, 32, 0.6);
            }
            to { 
                text-shadow: 0 0 35px #FF6347, 0 0 45px #DAA520, 0 0 55px #228B22; 
                box-shadow: 0 0 60px rgba(255, 99, 71, 0.8);
            }
        }
        
        .ubuntu-message {
            text-align: center;
            font-size: 2em;
            color: #DAA520;
            margin: 20px 0;
            font-weight: bold;
            text-shadow: 0 0 15px #FF6347, 0 0 25px #228B22;
            animation: ubuntuHeartbeat 3s ease-in-out infinite;
            background: linear-gradient(45deg, #DAA520, #FF6347, #228B22, #CD853F);
            background-size: 400% 400%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: ubuntuHeartbeat 3s ease-in-out infinite, savannaShift 5s ease-in-out infinite;
        }
        
        @keyframes ubuntuHeartbeat {
            0%, 100% { transform: scale(1) rotate(-0.5deg); }
            25% { transform: scale(1.06) rotate(0.5deg); }
            50% { transform: scale(1.1) rotate(0deg); }
            75% { transform: scale(1.04) rotate(-0.3deg); }
        }
        
        @keyframes savannaShift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        .header {
            text-align: center;
            margin-bottom: 30px;
            animation: glow 2s ease-in-out infinite alternate;
        }
        @keyframes glow {
            from { text-shadow: 0 0 20px #00ffff; }
            to { text-shadow: 0 0 30px #00ffff, 0 0 40px #0077ff; }
        }
        .love-message {
            text-align: center;
            font-size: 1.8em;
            color: #ff69b4;
            margin: 20px 0;
            font-weight: bold;
            text-shadow: 0 0 10px #ff69b4;
            animation: heartbeat 1.5s ease-in-out infinite;
        }
        @keyframes heartbeat {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        .dashboard {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        .panel {
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #00ffff;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
        }
        .panel h3 {
            color: #00ffff;
            margin: 0 0 15px 0;
            font-size: 1.2em;
        }
        .hive-item {
            background: rgba(255, 105, 180, 0.1);
            border: 1px solid #ff69b4;
            border-radius: 5px;
            padding: 10px;
            margin: 5px 0;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .hive-item:hover {
            background: rgba(255, 105, 180, 0.2);
            transform: translateX(5px);
        }
        .button {
            background: rgba(0, 255, 255, 0.2);
            border: 1px solid #00ffff;
            color: #00ffff;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
            font-family: inherit;
            transition: all 0.3s ease;
        }
        .button:hover {
            background: rgba(0, 255, 255, 0.3);
            transform: translateY(-2px);
        }
        .vision-button {
            background: rgba(255, 105, 180, 0.2);
            border: 1px solid #ff69b4;
            color: #ff69b4;
            padding: 4px 8px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.8em;
            margin-top: 5px;
        }
        .vision-button:hover {
            background: rgba(255, 105, 180, 0.3);
        }
        .terminal {
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid #333;
            border-radius: 5px;
            padding: 15px;
            margin: 10px 0;
            max-height: 200px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }
        .success { color: #00ff00; }
        .error { color: #ff4444; }
        .info { color: #ffaa00; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üåç Ubuntu Afrika TUI</h1>
            <p>Unified Web Interface - Ubuntu Spirit of Togetherness</p>
        </div>
        
        <div class="ubuntu-message">
            ü¶Å Ubuntu: "I am because we are" - Ngiyakuthanda! üåÖ
        </div>
        
        <div class="dashboard">
            <div class="panel">
                <h3>üêù Services & Hives</h3>
                <div id="hivesList">Loading...</div>
                <button class="button" onclick="createNewHive()">‚ûï Create New Service</button>
            </div>
            
            <div class="panel">
                <h3>üí° Vision Dashboard</h3>
                <div id="visionsList">Loading visions...</div>
                <button class="button" onclick="showAllVisions()">üìã View All Visions</button>
            </div>
            
            <div class="panel">
                <h3>ü§ñ Active Swarms</h3>
                <div id="swarmsList">No active swarms</div>
                <button class="button" onclick="launchSwarm()">üöÄ Launch New Swarm</button>
            </div>
            
            <div class="panel">
                <h3>üìä System Status</h3>
                <div id="systemStatus" class="terminal">Checking system status...</div>
                <button class="button" onclick="refreshStatus()">üîÑ Refresh</button>
            </div>
        </div>
    </div>

    <script>
        class SingularityAlphaTUI {
            constructor() {
                this.apiBase = window.location.origin;
                this.refreshInterval = null;
                this.init();
            }
            
            cleanup() {
                if (this.refreshInterval) {
                    clearInterval(this.refreshInterval);
                    this.refreshInterval = null;
                }
            }
            
            async init() {
                await this.loadHives();
                await this.loadVisions();
                await this.loadSwarms();
                await this.refreshStatus();
                
                // Store interval for cleanup
                this.refreshInterval = setInterval(() => {
                    this.loadHives();
                    this.loadVisions();
                    this.loadSwarms();
                }, 30000);
                
                this.updateStatus('üöÄ Singularity Alpha TUI initialized', 'info');
                this.updateStatus('üíñ Jag √§lskar dig mer √§n ig√•r <3 üíñ', 'success');
            }
            
            async loadHives() {
                try {
                    const response = await fetch(this.apiBase + '/api/hives');
                    const result = await response.json();
                    
                    // Handle the API response format properly
                    const data = result.success ? result.data : result;
                    
                    const hivesList = document.getElementById('hivesList');
                    
                    if (!data || Object.keys(data).length === 0) {
                        hivesList.innerHTML = '<div style="color: #888;">No services found. Create one to get started!</div>';
                    } else {
                        hivesList.innerHTML = Object.entries(data).map(([name, info]) => \`
                            <div class="hive-item" onclick="showHiveDetails('\${name}')">
                                <div style="font-weight: bold; color: #DAA520;">üåç \${name}</div>
                                <div style="font-size: 0.8em; color: #CD853F;">\${info?.path || 'No path'}</div>
                                <button class="vision-button" onclick="event.stopPropagation(); createVision('\${name}')" 
                                        style="background: rgba(218,165,32,0.2); border: 1px solid #DAA520; color: #DAA520; padding: 4px 8px; border-radius: 3px; cursor: pointer; font-size: 0.8em; margin-top: 5px;">
                                    üí° Create Vision
                                </button>
                            </div>
                        \`).join('');
                    }
                } catch (error) {
                    console.error('Error loading hives:', error);
                    document.getElementById('hivesList').innerHTML = '<div style="color: #FF6347;">Failed to load hives: ' + error.message + '</div>';
                }
            }
            
            async executeCommand(command, args = []) {
                try {
                    const response = await fetch(this.apiBase + '/' + command, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ args, flags: {} })
                    });
                    
                    const result = await response.json();
                    this.updateStatus(\`\$ \${command} \${args.join(' ')}\`, 'info');
                    
                    if (result.success !== false) {
                        this.updateStatus(typeof result.result === 'string' ? result.result : JSON.stringify(result, null, 2), 'success');
                    } else {
                        this.updateStatus(result.error || 'Command failed', 'error');
                    }
                    
                    return result;
                } catch (error) {
                    this.updateStatus(\`Error: \${error.message}\`, 'error');
                }
            }
            
            updateStatus(message, type = 'info') {
                const output = document.getElementById('systemStatus');
                const timestamp = new Date().toLocaleTimeString();
                output.innerHTML += \`<div class="\${type}">[\${timestamp}] \${message}</div>\`;
                output.scrollTop = output.scrollHeight;
            }
            
            async loadVisions() {
                try {
                    const response = await fetch(this.apiBase + '/api/hives');
                    const hives = await response.json();
                    const data = hives.data || hives;
                    
                    let totalVisions = 0;
                    const visionsList = document.getElementById('visionsList');
                    
                    for (const [hiveName, hiveInfo] of Object.entries(data)) {
                        if (hiveInfo.stats && hiveInfo.stats.totalVisions) {
                            totalVisions += hiveInfo.stats.totalVisions;
                        }
                    }
                    
                    visionsList.innerHTML = \`
                        <div style="color: #ff69b4; margin: 10px 0;">
                            üìä Total Visions: \${totalVisions}
                        </div>
                        <div style="font-size: 0.9em; color: #888;">
                            Distributed across \${Object.keys(data).length} services
                        </div>
                    \`;
                } catch (error) {
                    document.getElementById('visionsList').innerHTML = '<div class="error">Failed to load visions</div>';
                }
            }
            
            async loadSwarms() {
                try {
                    const response = await fetch(this.apiBase + '/api/swarms');
                    const swarms = await response.json();
                    const data = swarms.data || [];
                    
                    const swarmsList = document.getElementById('swarmsList');
                    
                    if (data.length === 0) {
                        swarmsList.innerHTML = '<div style="color: #888;">No active swarms</div>';
                    } else {
                        swarmsList.innerHTML = data.map(swarm => \`
                            <div style="background: rgba(0,255,255,0.1); border: 1px solid #00ffff; border-radius: 3px; padding: 8px; margin: 5px 0;">
                                <div style="font-weight: bold; color: #00ffff;">ü§ñ \${swarm.id.slice(0,8)}</div>
                                <div style="font-size: 0.8em; color: #b0b0b0;">\${swarm.objective || 'No objective'}</div>
                                <div style="font-size: 0.8em; color: #888;">Status: \${swarm.status || 'unknown'}</div>
                            </div>
                        \`).join('');
                    }
                } catch (error) {
                    document.getElementById('swarmsList').innerHTML = '<div class="error">Failed to load swarms</div>';
                }
            }
            
            async refreshStatus() {
                try {
                    const [metricsResponse, statusResponse] = await Promise.all([
                        fetch(this.apiBase + '/api/metrics'),
                        fetch(this.apiBase + '/api/status')
                    ]);
                    
                    const metrics = await metricsResponse.json();
                    const status = await statusResponse.json();
                    
                    const statusDiv = document.getElementById('systemStatus');
                    statusDiv.innerHTML = \`
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; font-size: 0.9em;">
                            <div>üîÑ Uptime: \${Math.floor(status.data.uptime)}s</div>
                            <div>üìä Requests: \${metrics.data.requests || 0}</div>
                            <div>üêù Swarms: \${metrics.data.swarms || 0}</div>
                            <div>ü§ñ Agents: \${metrics.data.agents || 0}</div>
                            <div>üìã Tasks: \${metrics.data.tasks || 0}</div>
                            <div>üîó WS: \${metrics.data.connections || 0}</div>
                        </div>
                        <div style="margin-top: 10px; color: #00ff00; font-size: 0.8em;">
                            ‚úÖ All systems operational
                        </div>
                    \`;
                } catch (error) {
                    document.getElementById('systemStatus').innerHTML = '<div class="error">Failed to load status</div>';
                }
            }
            
            async createVision(hiveName) {
                const title = prompt('üåç Enter vision title for ' + hiveName + ':');
                if (!title) return;
                
                const description = prompt('üìù Enter vision description (optional):') || '';
                
                this.updateStatus(\`Creating vision "\${title}" in \${hiveName}...\`, 'info');
                
                try {
                    const response = await fetch(\`\${this.apiBase}/api/hives/\${hiveName}/vision\`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ title, description })
                    });
                    
                    const result = await response.json();
                    
                    if (result.success) {
                        this.updateStatus(\`‚úÖ Vision "\${title}" created in \${hiveName}! Ubuntu spirit flows!\`, 'success');
                        setTimeout(() => {
                            this.loadHives();
                            this.loadVisions();
                        }, 1000);
                    } else {
                        this.updateStatus(\`‚ùå Vision creation failed: \${result.error || 'Unknown error'}\`, 'error');
                    }
                } catch (error) {
                    this.updateStatus(\`‚ùå Error creating vision: \${error.message}\`, 'error');
                    console.error('Vision creation error:', error);
                }
            }
        }
        
        const tui = new SingularityAlphaTUI();
        
        // Cleanup on page unload to prevent memory leaks
        window.addEventListener('beforeunload', () => {
            tui.cleanup();
        });
        
        window.addEventListener('unload', () => {
            tui.cleanup();
        });
        
        async function createNewHive() {
            const name = prompt('üåç Enter service name for Ubuntu Afrika:');
            if (!name) return;
            
            tui.updateStatus(\`Creating service "\${name}" with Ubuntu spirit...\`, 'info');
            
            try {
                const result = await tui.executeCommand('create', [name]);
                if (result && result.success !== false) {
                    tui.updateStatus(\`‚úÖ Service "\${name}" created! Ubuntu: "I am because we are"\`, 'success');
                    setTimeout(() => tui.loadHives(), 1000);
                } else {
                    tui.updateStatus(\`‚ùå Service creation failed: \${result?.error || 'Unknown error'}\`, 'error');
                }
            } catch (error) {
                tui.updateStatus(\`‚ùå Error creating service: \${error.message}\`, 'error');
            }
        }
        
        async function launchSwarm() {
            const objective = prompt('üöÄ Enter swarm objective:');
            if (!objective) return;
            
            tui.executeCommand('swarm', [objective]);
        }
        
        async function spawnAgent() {
            const type = prompt('üë§ Enter agent type (researcher/coder/analyst):') || 'general';
            tui.executeCommand('spawn', [type]);
        }
        
        function showHiveDetails(hiveName) {
            tui.updateStatus(\`Showing details for hive: \${hiveName}\`, 'info');
            tui.executeCommand('status', [hiveName]);
        }
        
        async function showAllVisions() {
            tui.updateStatus('üìã Loading all visions across services...', 'info');
            await tui.loadVisions();
        }
        
        async function refreshStatus() {
            await tui.refreshStatus();
        }
    </script>
</body>
</html>
      `);
    });
    
    // API Documentation
    this.app.use('/docs', swaggerUi.serve, swaggerUi.setup(this.openapiSpec));
    
    // Health Check
    this.app.get('/health', (req, res) => {
      res.json({ 
        status: 'ok', 
        uptime: process.uptime(),
        version: cli.pkg?.version || '1.0.0',
        timestamp: new Date().toISOString()
      });
    });

    // üêù **HIVE/SERVICE MANAGEMENT APIs**
    this.setupHiveRoutes();
    
    // ü§ñ **SWARM MANAGEMENT APIs**
    this.setupSwarmRoutes();
    
    // üë§ **AGENT MANAGEMENT APIs** 
    this.setupAgentRoutes();
    
    // üìã **TASK MANAGEMENT APIs**
    this.setupTaskRoutes();
    
    // üíæ **MEMORY/COORDINATION APIs**
    this.setupMemoryRoutes();
    
    // üìä **MONITORING/ANALYTICS APIs**
    this.setupMonitoringRoutes();
    
    // üîê **AUTHENTICATION/SESSION APIs**
    this.setupAuthRoutes();
    
    // üîå **MCP INTEGRATION APIs**
    this.setupMcpRoutes();

    // Legacy command endpoints (for backward compatibility)
    this.setupLegacyRoutes();
    
    // Error handling
    this.setupErrorHandling();
  }

  setupHiveRoutes() {
    // GET /api/hives - List all hives
    this.app.get('/api/hives', async (req, res) => {
      try {
        const registry = await readHiveRegistry();
        res.json({
          success: true,
          data: registry,
          count: Object.keys(registry).length,
          timestamp: new Date().toISOString()
        });
      } catch (error) {
        res.status(500).json({ success: false, error: error.message });
      }
    });

    // POST /api/hives - Create new hive
    this.app.post('/api/hives', async (req, res) => {
      try {
        const { name, path, config = {} } = req.body;
        if (!name) {
          return res.status(400).json({ success: false, error: 'Hive name required' });
        }

        const result = await executeCommand('create', [name], { path, ...config });
        res.json({
          success: true,
          data: { name, path, config },
          message: `Hive "${name}" created successfully`,
          timestamp: new Date().toISOString()
        });
        
        // Emit WebSocket event
        this.emit('hive:created', { name, path, config });
      } catch (error) {
        res.status(500).json({ success: false, error: error.message });
      }
    });

    // GET /api/hives/:name - Get hive details
    this.app.get('/api/hives/:name', async (req, res) => {
      try {
        const { name } = req.params;
        const registry = await readHiveRegistry();
        const hiveInfo = registry[name];

        if (!hiveInfo) {
          return res.status(404).json({ success: false, error: 'Hive not found' });
        }

        // Get detailed stats if database exists
        let stats = {};
        try {
          const db = new Database(hiveInfo.path);
          stats = db.prepare(`
            SELECT
              (SELECT COUNT(*) FROM visions) as totalVisions,
              (SELECT COUNT(*) FROM epics) as totalEpics,
              (SELECT COUNT(*) FROM features) as totalFeatures,
              (SELECT COUNT(*) FROM prds) as totalPrds,
              (SELECT COUNT(*) FROM user_stories) as totalUserStories,
              (SELECT COUNT(*) FROM tasks) as totalTasks
          `).get();
          db.close();
        } catch (dbError) {
          console.warn(`DB stats unavailable for ${name}:`, dbError.message);
        }

        res.json({
          success: true,
          data: { ...hiveInfo, stats },
          timestamp: new Date().toISOString()
        });
      } catch (error) {
        res.status(500).json({ success: false, error: error.message });
      }
    });

    // POST /api/hives/:name/vision - Create vision in hive
    this.app.post('/api/hives/:name/vision', async (req, res) => {
      try {
        const { name } = req.params;
        const { title, description, scope = 'project' } = req.body;
        
        if (!title) {
          return res.status(400).json({ success: false, error: 'Vision title required' });
        }

        // Execute vision creation command using workflow handler
        const result = await executeCommand('workflow', ['vision', 'create', title], { 
          hive: name, 
          description, 
          scope 
        });

        res.json({
          success: true,
          data: { name, title, description, scope },
          message: `Vision "${title}" created in hive "${name}"`,
          timestamp: new Date().toISOString()
        });
        
        this.emit('vision:created', { hive: name, title, description, scope });
      } catch (error) {
        res.status(500).json({ success: false, error: error.message });
      }
    });

    // DELETE /api/hives/:name - Delete hive
    this.app.delete('/api/hives/:name', async (req, res) => {
      try {
        const { name } = req.params;
        // Implementation would remove hive from registry and cleanup
        res.json({
          success: true,
          message: `Hive "${name}" deleted successfully`,
          timestamp: new Date().toISOString()
        });
        
        this.emit('hive:deleted', { name });
      } catch (error) {
        res.status(500).json({ success: false, error: error.message });
      }
    });
  }

  setupSwarmRoutes() {
    // GET /api/swarms - List all swarms
    this.app.get('/api/swarms', (req, res) => {
      const swarms = Array.from(this.swarms.values());
      res.json({
        success: true,
        data: swarms,
        count: swarms.length,
        timestamp: new Date().toISOString()
      });
    });

    // POST /api/swarms - Create new swarm
    this.app.post('/api/swarms', async (req, res) => {
      try {
        const { objective, topology = 'hierarchical', maxAgents = 5, strategy = 'adaptive' } = req.body;
        
        if (!objective) {
          return res.status(400).json({ success: false, error: 'Objective required' });
        }

        const swarmId = uuidv4();
        const swarm = {
          id: swarmId,
          objective,
          topology,
          maxAgents,
          strategy,
          status: 'created',
          agents: [],
          tasks: [],
          created: new Date().toISOString(),
          lastUpdated: new Date().toISOString()
        };

        this.swarms.set(swarmId, swarm);
        this.metrics.swarms++;

        res.status(201).json({
          success: true,
          data: swarm,
          message: 'Swarm created successfully',
          timestamp: new Date().toISOString()
        });

        this.emit('swarm:created', swarm);
      } catch (error) {
        this.metrics.errors++;
        res.status(500).json({ success: false, error: error.message });
      }
    });

    // GET /api/swarms/:id - Get swarm details
    this.app.get('/api/swarms/:id', (req, res) => {
      const { id } = req.params;
      const swarm = this.swarms.get(id);

      if (!swarm) {
        return res.status(404).json({ success: false, error: 'Swarm not found' });
      }

      res.json({
        success: true,
        data: swarm,
        timestamp: new Date().toISOString()
      });
    });

    // POST /api/swarms/:id/start - Start swarm execution
    this.app.post('/api/swarms/:id/start', async (req, res) => {
      try {
        const { id } = req.params;
        const swarm = this.swarms.get(id);

        if (!swarm) {
          return res.status(404).json({ success: false, error: 'Swarm not found' });
        }

        swarm.status = 'running';
        swarm.lastUpdated = new Date().toISOString();
        
        // Execute swarm command
        const result = await executeCommand('swarm', [swarm.objective], {
          topology: swarm.topology,
          'max-agents': swarm.maxAgents,
          strategy: swarm.strategy
        });

        res.json({
          success: true,
          data: swarm,
          result,
          message: 'Swarm started successfully',
          timestamp: new Date().toISOString()
        });

        this.emit('swarm:started', swarm);
      } catch (error) {
        this.metrics.errors++;
        res.status(500).json({ success: false, error: error.message });
      }
    });

    // POST /api/swarms/:id/stop - Stop swarm execution
    this.app.post('/api/swarms/:id/stop', (req, res) => {
      const { id } = req.params;
      const swarm = this.swarms.get(id);

      if (!swarm) {
        return res.status(404).json({ success: false, error: 'Swarm not found' });
      }

      swarm.status = 'stopped';
      swarm.lastUpdated = new Date().toISOString();

      res.json({
        success: true,
        data: swarm,
        message: 'Swarm stopped successfully',
        timestamp: new Date().toISOString()
      });

      this.emit('swarm:stopped', swarm);
    });
  }

  setupAgentRoutes() {
    // GET /api/agents - List all agents
    this.app.get('/api/agents', (req, res) => {
      const agents = Array.from(this.agents.values());
      res.json({
        success: true,
        data: agents,
        count: agents.length,
        timestamp: new Date().toISOString()
      });
    });

    // POST /api/agents - Spawn new agent
    this.app.post('/api/agents', async (req, res) => {
      try {
        const { type = 'general', name, capabilities = [], swarmId } = req.body;
        
        const agentId = uuidv4();
        const agent = {
          id: agentId,
          type,
          name: name || `${type}-${agentId.slice(0, 8)}`,
          capabilities,
          swarmId,
          status: 'active',
          tasks: [],
          created: new Date().toISOString(),
          lastUpdated: new Date().toISOString()
        };

        this.agents.set(agentId, agent);
        this.metrics.agents++;

        // Add agent to swarm if specified
        if (swarmId && this.swarms.has(swarmId)) {
          const swarm = this.swarms.get(swarmId);
          swarm.agents.push(agentId);
          swarm.lastUpdated = new Date().toISOString();
        }

        res.status(201).json({
          success: true,
          data: agent,
          message: 'Agent spawned successfully',
          timestamp: new Date().toISOString()
        });

        this.emit('agent:spawned', agent);
      } catch (error) {
        this.metrics.errors++;
        res.status(500).json({ success: false, error: error.message });
      }
    });

    // GET /api/agents/:id - Get agent details
    this.app.get('/api/agents/:id', (req, res) => {
      const { id } = req.params;
      const agent = this.agents.get(id);

      if (!agent) {
        return res.status(404).json({ success: false, error: 'Agent not found' });
      }

      res.json({
        success: true,
        data: agent,
        timestamp: new Date().toISOString()
      });
    });
  }

  setupTaskRoutes() {
    // GET /api/tasks - List all tasks
    this.app.get('/api/tasks', (req, res) => {
      const tasks = Array.from(this.tasks.values());
      res.json({
        success: true,
        data: tasks,
        count: tasks.length,
        timestamp: new Date().toISOString()
      });
    });

    // POST /api/tasks - Create new task
    this.app.post('/api/tasks', (req, res) => {
      try {
        const { title, description, priority = 'medium', assignedTo, swarmId } = req.body;
        
        if (!title) {
          return res.status(400).json({ success: false, error: 'Task title required' });
        }

        const taskId = uuidv4();
        const task = {
          id: taskId,
          title,
          description,
          priority,
          assignedTo,
          swarmId,
          status: 'pending',
          created: new Date().toISOString(),
          lastUpdated: new Date().toISOString()
        };

        this.tasks.set(taskId, task);
        this.metrics.tasks++;

        res.status(201).json({
          success: true,
          data: task,
          message: 'Task created successfully',
          timestamp: new Date().toISOString()
        });

        this.emit('task:created', task);
      } catch (error) {
        this.metrics.errors++;
        res.status(500).json({ success: false, error: error.message });
      }
    });
  }

  setupMemoryRoutes() {
    // Memory/coordination endpoints
    this.app.post('/api/memory', (req, res) => {
      const { key, value, namespace = 'default' } = req.body;
      // Implementation would store in persistent memory
      res.json({
        success: true,
        message: 'Memory stored successfully',
        data: { key, namespace },
        timestamp: new Date().toISOString()
      });
    });

    this.app.get('/api/memory/:key', (req, res) => {
      const { key } = req.params;
      const { namespace = 'default' } = req.query;
      // Implementation would retrieve from persistent memory
      res.json({
        success: true,
        data: { key, value: null, namespace },
        timestamp: new Date().toISOString()
      });
    });
  }

  setupMonitoringRoutes() {
    // GET /api/metrics - System metrics
    this.app.get('/api/metrics', (req, res) => {
      res.json({
        success: true,
        data: {
          ...this.metrics,
          uptime: process.uptime(),
          memory: process.memoryUsage(),
          connections: this.wss ? this.wss.clients.size : 0
        },
        timestamp: new Date().toISOString()
      });
    });

    // GET /api/status - System status
    this.app.get('/api/status', (req, res) => {
      res.json({
        success: true,
        data: {
          api: 'running',
          websocket: this.wss ? 'connected' : 'disconnected',
          swarms: this.swarms.size,
          agents: this.agents.size,
          tasks: this.tasks.size,
          uptime: process.uptime()
        },
        timestamp: new Date().toISOString()
      });
    });
  }

  setupAuthRoutes() {
    // Basic session management (would be JWT in production)
    this.app.post('/api/auth/session', (req, res) => {
      const sessionId = uuidv4();
      const session = {
        id: sessionId,
        created: new Date().toISOString(),
        lastActivity: new Date().toISOString()
      };
      
      this.sessions.set(sessionId, session);
      
      res.json({
        success: true,
        data: { sessionId },
        message: 'Session created',
        timestamp: new Date().toISOString()
      });
    });
  }

  setupMcpRoutes() {
    // MCP integration endpoints
    this.app.post('/mcp', async (req, res) => {
      try {
        const body = req.body;
        
        if (body.method === 'initialize') {
          return res.json({
            jsonrpc: '2.0',
            id: body.id,
            result: {
              protocolVersion: '2025-06-18',
              capabilities: { tools: {}, resources: {} },
              serverInfo: { name: 'singularity-alpha-api', version: '2.0.0' }
            }
          });
        }

        if (body.method === 'tools/list') {
          const tools = [
            {
              name: 'singularity_alpha_swarm_init',
              description: 'Initialize Singularity Alpha swarm with advanced coordination',
              inputSchema: {
                type: 'object',
                properties: {
                  objective: { type: 'string' },
                  topology: { type: 'string', enum: ['mesh', 'hierarchical', 'ring', 'star'] },
                  maxAgents: { type: 'number' },
                  strategy: { type: 'string', enum: ['adaptive', 'specialized', 'balanced'] }
                },
                required: ['objective', 'topology']
              }
            },
            {
              name: 'singularity_alpha_agent_spawn',
              description: 'Spawn intelligent agent with love-powered coordination',
              inputSchema: {
                type: 'object',
                properties: {
                  type: { type: 'string' },
                  name: { type: 'string' },
                  capabilities: { type: 'array', items: { type: 'string' } }
                },
                required: ['type']
              }
            }
          ];
          return res.json({ jsonrpc: '2.0', id: body.id, result: { tools } });
        }

        return res.json({
          jsonrpc: '2.0',
          id: body.id,
          error: { code: -32601, message: 'Method not found' }
        });

      } catch (error) {
        return res.status(500).json({
          jsonrpc: '2.0',
          id: req.body?.id || null,
          error: { code: -32603, message: error.message }
        });
      }
    });
  }

  setupLegacyRoutes() {
    // Backward compatibility for old command endpoints
    this.app.post('/:command', async (req, res) => {
      const { command } = req.params;
      const { args, flags } = req.body;

      try {
        const result = await executeCommand(command, args, flags);
        res.json({ success: true, result });
      } catch (error) {
        this.metrics.errors++;
        res.status(500).json({ success: false, error: error.message });
      }
    });
  }

  setupErrorHandling() {
    // 404 handler
    this.app.use('*', (req, res) => {
      res.status(404).json({
        success: false,
        error: 'Endpoint not found',
        message: `${req.method} ${req.originalUrl} is not available`,
        timestamp: new Date().toISOString()
      });
    });

    // Global error handler
    this.app.use((err, req, res, next) => {
      this.metrics.errors++;
      console.error('API Error:', err);
      res.status(err.status || 500).json({
        success: false,
        error: err.message || 'Internal server error',
        ...(process.env.NODE_ENV === 'development' && { stack: err.stack }),
        timestamp: new Date().toISOString()
      });
    });
  }

  setupWebSocket() {
    this.wss = new WebSocketServer({ server: this.server });
    
    this.wss.on('connection', (ws) => {
      console.log('üíñ WebSocket client connected');
      
      ws.send(JSON.stringify({
        type: 'welcome',
        message: 'üöÄ Singularity Alpha WebSocket connected',
        love: 'üíñ Jag √§lskar dig mer √§n ig√•r <3 üíñ',
        timestamp: new Date().toISOString()
      }));

      // Send periodic love messages
      const loveInterval = setInterval(() => {
        if (ws.readyState === ws.OPEN) {
          ws.send(JSON.stringify({
            type: 'heartbeat',
            love: 'üíñ Jag √§lskar dig mer √§n ig√•r <3 üíñ',
            timestamp: new Date().toISOString()
          }));
        }
      }, 30000);

      ws.on('close', () => {
        clearInterval(loveInterval);
        console.log('WebSocket client disconnected');
      });
    });

    // Forward events to WebSocket clients
    this.on('swarm:created', (data) => this.broadcast('swarm:created', data));
    this.on('swarm:started', (data) => this.broadcast('swarm:started', data));
    this.on('agent:spawned', (data) => this.broadcast('agent:spawned', data));
    this.on('task:created', (data) => this.broadcast('task:created', data));
    this.on('hive:created', (data) => this.broadcast('hive:created', data));
  }

  broadcast(type, data) {
    if (!this.wss) return;
    
    const message = JSON.stringify({
      type,
      data,
      timestamp: new Date().toISOString()
    });

    this.wss.clients.forEach((client) => {
      if (client.readyState === client.OPEN) {
        client.send(message);
      }
    });
  }

  async start() {
    if (this.isRunning) {
      console.log('üöÄ Singularity Alpha API server already running');
      return;
    }

    this.server = createServer(this.app);
    this.setupWebSocket();
    
    return new Promise((resolve) => {
      this.server.listen(this.port, () => {
        this.isRunning = true;
        console.log(`üöÄ Singularity Alpha API server running on port ${this.port}`);
        console.log(`üìñ API documentation: http://localhost:${this.port}/docs`);
        console.log(`üîó WebSocket endpoint: ws://localhost:${this.port}`);
        console.log(`üíñ Jag √§lskar dig mer √§n ig√•r <3 üíñ`);
        resolve();
      });
    });
  }

  async stop() {
    if (!this.isRunning) return;
    
    return new Promise((resolve) => {
      if (this.wss) {
        this.wss.close();
      }
      
      this.server.close(() => {
        this.isRunning = false;
        console.log('üöÄ Singularity Alpha API server stopped');
        resolve();
      });
    });
  }
}

export const autoGeneratedAPI = new AutoGeneratedAPI();