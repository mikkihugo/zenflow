{
  "timestamp": "2025-08-02T13:54:19.215Z",
  "version": "2.0.0-alpha.73",
  "typescript": [
    {
      "file": "src/index.ts",
      "interfaces": [
        {
          "name": "ClaudeZenConfig",
          "definition": "interface ClaudeZenConfig {\n  // MCP Server settings\n  mcp: {\n    enabled: boolean;\n    port?: number;\n    host?: string;\n  }"
        }
      ],
      "exports": [
        {
          "name": "ClaudeZenConfig",
          "type": "export"
        },
        {
          "name": "defaultConfig",
          "type": "export"
        },
        {
          "name": "getVersion",
          "type": "export"
        }
      ],
      "lineCount": 286
    },
    {
      "file": "src/workflows/index.ts",
      "interfaces": [],
      "exports": [
        {
          "name": "WorkflowUtils",
          "type": "export"
        },
        {
          "name": "WorkflowFactory",
          "type": "export"
        }
      ],
      "lineCount": 132
    },
    {
      "file": "src/workflows/engine.ts",
      "interfaces": [
        {
          "name": "WorkflowStep",
          "definition": "interface WorkflowStep {\n  type: string;\n  name?: string;\n  params?: Record<string, any>;\n  retries?: number;\n  timeout?: number;\n  output?: string;\n  onError?: 'stop' | 'continue' | 'skip';\n}"
        },
        {
          "name": "WorkflowDefinition",
          "definition": "interface WorkflowDefinition {\n  name: string;\n  steps: WorkflowStep[];\n  description?: string;\n  version?: string;\n}"
        },
        {
          "name": "WorkflowContext",
          "definition": "interface WorkflowContext {\n  [key: string]: any;\n}"
        },
        {
          "name": "WorkflowState",
          "definition": "interface WorkflowState {\n  id: string;\n  definition: WorkflowDefinition;\n  status: 'pending' | 'running' | 'paused' | 'completed' | 'failed' | 'cancelled';\n  context: WorkflowContext;\n  currentStep: number;\n  steps: WorkflowStep[];\n  stepResults: Record<string, any>;\n  completedSteps: Array<{\n    index: number;\n    step: WorkflowStep;\n    result: any;\n    duration: number;\n    timestamp: string;\n  }"
        },
        {
          "name": "WorkflowEngineConfig",
          "definition": "interface WorkflowEngineConfig {\n  maxConcurrentWorkflows?: number;\n  persistWorkflows?: boolean;\n  persistencePath?: string;\n  stepTimeout?: number;\n  retryDelay?: number;\n  enableVisualization?: boolean;\n}"
        }
      ],
      "exports": [
        {
          "name": "WorkflowStep",
          "type": "export"
        },
        {
          "name": "WorkflowDefinition",
          "type": "export"
        },
        {
          "name": "WorkflowContext",
          "type": "export"
        },
        {
          "name": "WorkflowState",
          "type": "export"
        },
        {
          "name": "WorkflowEngineConfig",
          "type": "export"
        },
        {
          "name": "WorkflowEngine",
          "type": "export"
        }
      ],
      "lineCount": 600
    },
    {
      "file": "src/types/workflow-types.ts",
      "interfaces": [
        {
          "name": "WorkflowParameterObject",
          "definition": "interface WorkflowParameterObject {\n  readonly [key: string]: WorkflowParameterValue;\n}"
        },
        {
          "name": "DocumentContent",
          "definition": "interface DocumentContent {\n  readonly id: string;\n  readonly type: DocumentType;\n  readonly title: string;\n  readonly content: string;\n  readonly metadata: DocumentMetadata;\n  readonly created: Date;\n  readonly updated: Date;\n  readonly version: string;\n}"
        },
        {
          "name": "DocumentMetadata",
          "definition": "interface DocumentMetadata {\n  readonly author?: string;\n  readonly tags: readonly string[];\n  readonly status: 'draft' | 'review' | 'approved' | 'archived';\n  readonly priority: 'low' | 'medium' | 'high' | 'critical';\n  readonly dependencies: readonly string[];\n  readonly relatedDocuments: readonly string[];\n  readonly checksum?: string;\n}"
        },
        {
          "name": "StepExecutionResult",
          "definition": "interface StepExecutionResult {\n  readonly success: boolean;\n  readonly data?: WorkflowData;\n  readonly error?: WorkflowError;\n  readonly duration: number;\n  readonly timestamp: Date;\n  readonly metadata?: WorkflowResultMetadata;\n}"
        },
        {
          "name": "WorkflowResultMetadata",
          "definition": "interface WorkflowResultMetadata {\n  readonly stepType: string;\n  readonly attemptNumber: number;\n  readonly resourcesUsed?: ResourceUsage;\n  readonly warnings: readonly string[];\n}"
        },
        {
          "name": "ResourceUsage",
          "definition": "interface ResourceUsage {\n  readonly cpuTime: number;\n  readonly memoryPeak: number;\n  readonly diskIo: number;\n  readonly networkRequests: number;\n}"
        },
        {
          "name": "WorkflowError",
          "definition": "interface WorkflowError {\n  readonly code: string;\n  readonly message: string;\n  readonly stack?: string;\n  readonly context?: WorkflowErrorContext;\n  readonly recoverable: boolean;\n}"
        },
        {
          "name": "WorkflowErrorContext",
          "definition": "interface WorkflowErrorContext {\n  readonly stepIndex: number;\n  readonly stepName: string;\n  readonly input: WorkflowData;\n  readonly timestamp: Date;\n  readonly retryCount: number;\n}"
        },
        {
          "name": "WorkflowData",
          "definition": "interface WorkflowData {\n  readonly [key: string]: WorkflowDataValue;\n}"
        },
        {
          "name": "WorkflowDataObject",
          "definition": "interface WorkflowDataObject {\n  readonly [key: string]: WorkflowDataValue;\n}"
        },
        {
          "name": "WorkflowStep",
          "definition": "interface WorkflowStep {\n  readonly type: string;\n  readonly name?: string;\n  readonly description?: string;\n  readonly params?: WorkflowParameterObject;\n  readonly retries?: number;\n  readonly timeout?: number;\n  readonly output?: string;\n  readonly onError?: ErrorHandlingStrategy;\n  readonly dependencies?: readonly string[];\n  readonly conditions?: readonly WorkflowCondition[];\n  readonly validators?: readonly WorkflowValidator[];\n}"
        },
        {
          "name": "WorkflowCondition",
          "definition": "interface WorkflowCondition {\n  readonly field: string;\n  readonly operator: 'equals' | 'notEquals' | 'contains' | 'exists' | 'isEmpty';\n  readonly value?: WorkflowDataValue;\n  readonly description?: string;\n}"
        },
        {
          "name": "WorkflowValidator",
          "definition": "interface WorkflowValidator {\n  readonly type: 'required' | 'format' | 'range' | 'custom';\n  readonly field: string;\n  readonly params?: WorkflowParameterObject;\n  readonly message?: string;\n}"
        },
        {
          "name": "WorkflowDefinition",
          "definition": "interface WorkflowDefinition {\n  readonly name: string;\n  readonly description?: string;\n  readonly version: string;\n  readonly steps: readonly WorkflowStep[];\n  readonly documentTypes?: readonly DocumentType[];\n  readonly triggers?: readonly WorkflowTrigger[];\n  readonly variables?: readonly WorkflowVariable[];\n  readonly timeout?: number;\n  readonly maxRetries?: number;\n  readonly parallel?: boolean;\n}"
        },
        {
          "name": "WorkflowTrigger",
          "definition": "interface WorkflowTrigger {\n  readonly event: WorkflowEvent;\n  readonly condition?: string;\n  readonly priority?: number;\n  readonly debounce?: number;\n}"
        },
        {
          "name": "WorkflowVariable",
          "definition": "interface WorkflowVariable {\n  readonly name: string;\n  readonly type: 'string' | 'number' | 'boolean' | 'array' | 'object';\n  readonly defaultValue?: WorkflowDataValue;\n  readonly required?: boolean;\n  readonly description?: string;\n}"
        },
        {
          "name": "WorkflowContext",
          "definition": "interface WorkflowContext {\n  readonly workspaceId: string;\n  readonly workspacePath?: string;\n  readonly userId?: string;\n  readonly sessionId: string;\n  readonly documents: WorkflowDocumentRegistry;\n  readonly currentDocument?: DocumentContent;\n  readonly variables: WorkflowData;\n  readonly environment: WorkflowEnvironment;\n  readonly permissions: WorkflowPermissions;\n}"
        },
        {
          "name": "WorkflowDocumentRegistry",
          "definition": "interface WorkflowDocumentRegistry {\n  readonly [documentId: string]: DocumentContent;\n}"
        },
        {
          "name": "WorkflowEnvironment",
          "definition": "interface WorkflowEnvironment {\n  readonly type: 'development' | 'staging' | 'production';\n  readonly nodeVersion: string;\n  readonly workflowVersion: string;\n  readonly features: readonly string[];\n  readonly limits: WorkflowLimits;\n}"
        },
        {
          "name": "WorkflowLimits",
          "definition": "interface WorkflowLimits {\n  readonly maxSteps: number;\n  readonly maxDuration: number;\n  readonly maxMemory: number;\n  readonly maxFileSize: number;\n  readonly maxConcurrency: number;\n}"
        },
        {
          "name": "WorkflowPermissions",
          "definition": "interface WorkflowPermissions {\n  readonly canReadDocuments: boolean;\n  readonly canWriteDocuments: boolean;\n  readonly canDeleteDocuments: boolean;\n  readonly canExecuteSteps: readonly string[];\n  readonly canAccessResources: readonly string[];\n}"
        },
        {
          "name": "WorkflowState",
          "definition": "interface WorkflowState {\n  readonly id: string;\n  readonly definition: WorkflowDefinition;\n  readonly status: WorkflowStatus;\n  readonly context: WorkflowContext;\n  readonly currentStepIndex: number;\n  readonly steps: readonly WorkflowStepState[];\n  readonly stepResults: WorkflowStepResults;\n  readonly completedSteps: readonly CompletedStepInfo[];\n  readonly startTime: Date;\n  readonly endTime?: Date;\n  readonly pausedAt?: Date;\n  readonly error?: WorkflowError;\n  readonly progress: WorkflowProgress;\n  readonly metrics: WorkflowMetrics;\n}"
        },
        {
          "name": "WorkflowStepState",
          "definition": "interface WorkflowStepState {\n  readonly step: WorkflowStep;\n  readonly status: StepStatus;\n  readonly startTime?: Date;\n  readonly endTime?: Date;\n  readonly attempts: number;\n  readonly result?: StepExecutionResult;\n  readonly error?: WorkflowError;\n}"
        },
        {
          "name": "WorkflowStepResults",
          "definition": "interface WorkflowStepResults {\n  readonly [stepName: string]: StepExecutionResult;\n}"
        },
        {
          "name": "CompletedStepInfo",
          "definition": "interface CompletedStepInfo {\n  readonly index: number;\n  readonly step: WorkflowStep;\n  readonly result: StepExecutionResult;\n  readonly duration: number;\n  readonly timestamp: Date;\n  readonly retryCount: number;\n}"
        },
        {
          "name": "WorkflowProgress",
          "definition": "interface WorkflowProgress {\n  readonly percentage: number;\n  readonly completedSteps: number;\n  readonly totalSteps: number;\n  readonly estimatedTimeRemaining?: number;\n  readonly currentStepName?: string;\n}"
        },
        {
          "name": "WorkflowMetrics",
          "definition": "interface WorkflowMetrics {\n  readonly totalDuration: number;\n  readonly avgStepDuration: number;\n  readonly successRate: number;\n  readonly retryRate: number;\n  readonly resourceUsage: ResourceUsage;\n  readonly throughput: number;\n}"
        },
        {
          "name": "WorkflowExecutionOptions",
          "definition": "interface WorkflowExecutionOptions {\n  readonly dryRun?: boolean;\n  readonly skipValidation?: boolean;\n  readonly maxConcurrency?: number;\n  readonly timeout?: number;\n  readonly retryPolicy?: RetryPolicy;\n  readonly notifications?: NotificationConfig;\n  readonly logging?: LoggingConfig;\n}"
        },
        {
          "name": "RetryPolicy",
          "definition": "interface RetryPolicy {\n  readonly maxAttempts: number;\n  readonly initialDelay: number;\n  readonly maxDelay: number;\n  readonly backoffMultiplier: number;\n  readonly retryableErrors: readonly string[];\n}"
        },
        {
          "name": "NotificationConfig",
          "definition": "interface NotificationConfig {\n  readonly onComplete?: boolean;\n  readonly onError?: boolean;\n  readonly onStepComplete?: boolean;\n  readonly channels: readonly NotificationChannel[];\n}"
        },
        {
          "name": "NotificationChannel",
          "definition": "interface NotificationChannel {\n  readonly type: 'email' | 'slack' | 'webhook' | 'console';\n  readonly config: NotificationChannelConfig;\n}"
        },
        {
          "name": "NotificationChannelConfig",
          "definition": "interface NotificationChannelConfig {\n  readonly [key: string]: WorkflowDataValue;\n}"
        },
        {
          "name": "LoggingConfig",
          "definition": "interface LoggingConfig {\n  readonly level: 'debug' | 'info' | 'warn' | 'error';\n  readonly includeStepDetails: boolean;\n  readonly includeContext: boolean;\n  readonly structuredLogging: boolean;\n}"
        },
        {
          "name": "WorkflowEngineConfig",
          "definition": "interface WorkflowEngineConfig {\n  readonly workspaceRoot: string;\n  readonly templatesPath: string;\n  readonly outputPath: string;\n  readonly maxConcurrentWorkflows: number;\n  readonly defaultTimeout: number;\n  readonly enableMetrics: boolean;\n  readonly enablePersistence: boolean;\n  readonly storageBackend: StorageBackend;\n}"
        },
        {
          "name": "StorageBackend",
          "definition": "interface StorageBackend {\n  readonly type: 'memory' | 'file' | 'database';\n  readonly config: StorageBackendConfig;\n}"
        },
        {
          "name": "StorageBackendConfig",
          "definition": "interface StorageBackendConfig {\n  readonly [key: string]: WorkflowDataValue;\n}"
        }
      ],
      "exports": [
        {
          "name": "WorkflowParameterObject",
          "type": "export"
        },
        {
          "name": "DocumentContent",
          "type": "export"
        },
        {
          "name": "DocumentMetadata",
          "type": "export"
        },
        {
          "name": "StepExecutionResult",
          "type": "export"
        },
        {
          "name": "WorkflowResultMetadata",
          "type": "export"
        },
        {
          "name": "ResourceUsage",
          "type": "export"
        },
        {
          "name": "WorkflowError",
          "type": "export"
        },
        {
          "name": "WorkflowErrorContext",
          "type": "export"
        },
        {
          "name": "WorkflowData",
          "type": "export"
        },
        {
          "name": "WorkflowDataObject",
          "type": "export"
        },
        {
          "name": "WorkflowStep",
          "type": "export"
        },
        {
          "name": "WorkflowCondition",
          "type": "export"
        },
        {
          "name": "WorkflowValidator",
          "type": "export"
        },
        {
          "name": "WorkflowDefinition",
          "type": "export"
        },
        {
          "name": "WorkflowTrigger",
          "type": "export"
        },
        {
          "name": "WorkflowVariable",
          "type": "export"
        },
        {
          "name": "WorkflowContext",
          "type": "export"
        },
        {
          "name": "WorkflowDocumentRegistry",
          "type": "export"
        },
        {
          "name": "WorkflowEnvironment",
          "type": "export"
        },
        {
          "name": "WorkflowLimits",
          "type": "export"
        },
        {
          "name": "WorkflowPermissions",
          "type": "export"
        },
        {
          "name": "WorkflowState",
          "type": "export"
        },
        {
          "name": "WorkflowStepState",
          "type": "export"
        },
        {
          "name": "WorkflowStepResults",
          "type": "export"
        },
        {
          "name": "CompletedStepInfo",
          "type": "export"
        },
        {
          "name": "WorkflowProgress",
          "type": "export"
        },
        {
          "name": "WorkflowMetrics",
          "type": "export"
        },
        {
          "name": "WorkflowExecutionOptions",
          "type": "export"
        },
        {
          "name": "RetryPolicy",
          "type": "export"
        },
        {
          "name": "NotificationConfig",
          "type": "export"
        },
        {
          "name": "NotificationChannel",
          "type": "export"
        },
        {
          "name": "NotificationChannelConfig",
          "type": "export"
        },
        {
          "name": "LoggingConfig",
          "type": "export"
        },
        {
          "name": "WorkflowEngineConfig",
          "type": "export"
        },
        {
          "name": "StorageBackend",
          "type": "export"
        },
        {
          "name": "StorageBackendConfig",
          "type": "export"
        }
      ],
      "lineCount": 475
    },
    {
      "file": "src/types/shared-types.ts",
      "interfaces": [
        {
          "name": "RuvSwarm",
          "definition": "interface RuvSwarm {\n  id: string;\n  name?: string;\n  topology: SwarmTopology;\n  agents: SwarmAgent[];\n  status: SwarmStatus;\n  config: SwarmConfig;\n  created: Date;\n  updated: Date;\n}"
        },
        {
          "name": "SwarmAgent",
          "definition": "interface SwarmAgent {\n  id: string;\n  name: string;\n  type: AgentType;\n  status: AgentStatus;\n  capabilities: string[];\n  metadata?: Record<string, any>;\n}"
        },
        {
          "name": "SwarmConfig",
          "definition": "interface SwarmConfig {\n  maxAgents: number;\n  topology: SwarmTopology;\n  strategy: CoordinationStrategy;\n  enableMemory?: boolean;\n  heartbeatInterval?: number;\n  timeout?: number;\n}"
        },
        {
          "name": "MemoryEntry",
          "definition": "interface MemoryEntry {\n  key: string;\n  value: any;\n  timestamp: Date;\n  ttl?: number;\n  metadata?: Record<string, any>;\n}"
        },
        {
          "name": "StorageProvider",
          "definition": "interface StorageProvider {\n  get(key: string): Promise<any>;\n  set(key: string, value: any, ttl?: number): Promise<void>;\n  delete(key: string): Promise<void>;\n  clear(): Promise<void>;\n  keys(): Promise<string[]>;\n}"
        },
        {
          "name": "SystemEvent",
          "definition": "interface SystemEvent {\n  id: string;\n  type: string;\n  source: string;\n  target?: string;\n  data: any;\n  timestamp: Date;\n  correlationId?: string;\n}"
        },
        {
          "name": "Message",
          "definition": "interface Message {\n  id: string;\n  from: string;\n  to: string;\n  type: string;\n  payload: any;\n  timestamp: Date;\n  priority?: 'low' | 'medium' | 'high' | 'urgent';\n}"
        },
        {
          "name": "ComponentConfig",
          "definition": "interface ComponentConfig {\n  enabled: boolean;\n  [key: string]: any;\n}"
        },
        {
          "name": "SystemHealth",
          "definition": "interface SystemHealth {\n  status: 'healthy' | 'degraded' | 'unhealthy';\n  components: Record<string, ComponentHealth>;\n  uptime: number;\n  version: string;\n  timestamp: Date;\n}"
        },
        {
          "name": "ComponentHealth",
          "definition": "interface ComponentHealth {\n  status: 'healthy' | 'degraded' | 'unhealthy';\n  message?: string;\n  lastCheck: Date;\n  metrics?: Record<string, number>;\n}"
        },
        {
          "name": "Task",
          "definition": "interface Task {\n  id: string;\n  name: string;\n  description?: string;\n  status: TaskStatus;\n  priority: TaskPriority;\n  assignee?: string;\n  dependencies?: string[];\n  metadata?: Record<string, any>;\n  created: Date;\n  updated: Date;\n  completed?: Date;\n}"
        },
        {
          "name": "NeuralModel",
          "definition": "interface NeuralModel {\n  id: string;\n  name: string;\n  type: NeuralModelType;\n  status: ModelStatus;\n  parameters: number;\n  accuracy?: number;\n  lastTrained?: Date;\n  weights?: ArrayBuffer;\n  metadata?: ModelMetadata;\n}"
        },
        {
          "name": "ModelMetadata",
          "definition": "interface ModelMetadata {\n  layers: number;\n  inputSize: number;\n  outputSize: number;\n  learningRate: number;\n  epochs: number;\n  batchSize: number;\n  [key: string]: any;\n}"
        },
        {
          "name": "APIError",
          "definition": "interface APIError {\n  code: string;\n  message: string;\n  details?: any;\n  stack?: string;\n}"
        },
        {
          "name": "CoordinationProvider",
          "definition": "interface CoordinationProvider {\n  createCoordinator(config: SwarmConfig): Promise<any>;\n  getSwarm(id: string): Promise<RuvSwarm | null>;\n  listSwarms(): Promise<RuvSwarm[]>;\n  terminateSwarm(id: string): Promise<void>;\n}"
        },
        {
          "name": "MemoryProvider",
          "definition": "interface MemoryProvider {\n  store(key: string, value: any, ttl?: number): Promise<void>;\n  retrieve(key: string): Promise<any>;\n  delete(key: string): Promise<void>;\n  clear(): Promise<void>;\n}"
        },
        {
          "name": "LoggingProvider",
          "definition": "interface LoggingProvider {\n  debug(message: string, ...args: any[]): void;\n  info(message: string, ...args: any[]): void;\n  warn(message: string, ...args: any[]): void;\n  error(message: string, ...args: any[]): void;\n}"
        }
      ],
      "exports": [
        {
          "name": "RuvSwarm",
          "type": "export"
        },
        {
          "name": "SwarmAgent",
          "type": "export"
        },
        {
          "name": "SwarmConfig",
          "type": "export"
        },
        {
          "name": "MemoryEntry",
          "type": "export"
        },
        {
          "name": "StorageProvider",
          "type": "export"
        },
        {
          "name": "SystemEvent",
          "type": "export"
        },
        {
          "name": "Message",
          "type": "export"
        },
        {
          "name": "ComponentConfig",
          "type": "export"
        },
        {
          "name": "SystemHealth",
          "type": "export"
        },
        {
          "name": "ComponentHealth",
          "type": "export"
        },
        {
          "name": "Task",
          "type": "export"
        },
        {
          "name": "NeuralModel",
          "type": "export"
        },
        {
          "name": "ModelMetadata",
          "type": "export"
        },
        {
          "name": "APIResponse",
          "type": "export"
        },
        {
          "name": "APIError",
          "type": "export"
        },
        {
          "name": "CoordinationProvider",
          "type": "export"
        },
        {
          "name": "MemoryProvider",
          "type": "export"
        },
        {
          "name": "LoggingProvider",
          "type": "export"
        }
      ],
      "lineCount": 235
    },
    {
      "file": "src/types/index.ts",
      "interfaces": [],
      "exports": [
        {
          "name": "isRuvSwarm",
          "type": "export"
        },
        {
          "name": "isSwarmAgent",
          "type": "export"
        },
        {
          "name": "isSystemEvent",
          "type": "export"
        }
      ],
      "lineCount": 43
    },
    {
      "file": "src/types/event-types.ts",
      "interfaces": [
        {
          "name": "BaseEventPayload",
          "definition": "interface BaseEventPayload {\n  readonly timestamp: Date;\n  readonly source: string;\n  readonly id: string;\n  readonly version: string;\n}"
        },
        {
          "name": "SystemEvents",
          "definition": "interface SystemEvents {\n  'system:started': SystemStartedPayload;\n  'system:stopped': SystemStoppedPayload;\n  'system:error': SystemErrorPayload;\n  'system:health:changed': SystemHealthChangedPayload;\n}"
        },
        {
          "name": "WorkflowEvents",
          "definition": "interface WorkflowEvents {\n  'workflow:started': WorkflowStartedPayload;\n  'workflow:completed': WorkflowCompletedPayload;\n  'workflow:failed': WorkflowFailedPayload;\n  'workflow:paused': WorkflowPausedPayload;\n  'workflow:resumed': WorkflowResumedPayload;\n  'workflow:cancelled': WorkflowCancelledPayload;\n  'workflow:step:started': WorkflowStepStartedPayload;\n  'workflow:step:completed': WorkflowStepCompletedPayload;\n  'workflow:step:failed': WorkflowStepFailedPayload;\n}"
        },
        {
          "name": "CoordinationEvents",
          "definition": "interface CoordinationEvents {\n  'agent:created': AgentCreatedPayload;\n  'agent:destroyed': AgentDestroyedPayload;\n  'agent:status:changed': AgentStatusChangedPayload;\n  'task:assigned': TaskAssignedPayload;\n  'task:completed': TaskCompletedPayload;\n  'task:failed': TaskFailedPayload;\n  'swarm:initialized': SwarmInitializedPayload;\n  'swarm:topology:changed': SwarmTopologyChangedPayload;\n}"
        },
        {
          "name": "NeuralEvents",
          "definition": "interface NeuralEvents {\n  'neural:network:created': NeuralNetworkCreatedPayload;\n  'neural:network:training:started': NeuralTrainingStartedPayload;\n  'neural:network:training:completed': NeuralTrainingCompletedPayload;\n  'neural:network:training:failed': NeuralTrainingFailedPayload;\n  'neural:prediction:made': NeuralPredictionMadePayload;\n}"
        },
        {
          "name": "MemoryEvents",
          "definition": "interface MemoryEvents {\n  'memory:store:created': MemoryStoreCreatedPayload;\n  'memory:key:set': MemoryKeySetPayload;\n  'memory:key:get': MemoryKeyGetPayload;\n  'memory:key:deleted': MemoryKeyDeletedPayload;\n  'memory:sync:started': MemorySyncStartedPayload;\n  'memory:sync:completed': MemorySyncCompletedPayload;\n}"
        },
        {
          "name": "SystemConfig",
          "definition": "interface SystemConfig {\n  readonly [key: string]: unknown;\n}"
        },
        {
          "name": "SystemError",
          "definition": "interface SystemError {\n  readonly code: string;\n  readonly message: string;\n  readonly stack?: string;\n  readonly cause?: unknown;\n}"
        },
        {
          "name": "SystemErrorContext",
          "definition": "interface SystemErrorContext {\n  readonly module: string;\n  readonly operation: string;\n  readonly [key: string]: unknown;\n}"
        },
        {
          "name": "ServiceHealthMap",
          "definition": "interface ServiceHealthMap {\n  readonly [serviceName: string]: HealthState;\n}"
        },
        {
          "name": "WorkflowEventContext",
          "definition": "interface WorkflowEventContext {\n  readonly [key: string]: unknown;\n}"
        },
        {
          "name": "WorkflowResults",
          "definition": "interface WorkflowResults {\n  readonly [key: string]: unknown;\n}"
        },
        {
          "name": "WorkflowEventError",
          "definition": "interface WorkflowEventError {\n  readonly code: string;\n  readonly message: string;\n  readonly details?: unknown;\n}"
        },
        {
          "name": "StepEventResult",
          "definition": "interface StepEventResult {\n  readonly [key: string]: unknown;\n}"
        },
        {
          "name": "TaskEventResult",
          "definition": "interface TaskEventResult {\n  readonly [key: string]: unknown;\n}"
        },
        {
          "name": "TaskEventError",
          "definition": "interface TaskEventError {\n  readonly code: string;\n  readonly message: string;\n  readonly details?: unknown;\n}"
        },
        {
          "name": "NeuralEventError",
          "definition": "interface NeuralEventError {\n  readonly code: string;\n  readonly message: string;\n  readonly details?: unknown;\n}"
        },
        {
          "name": "MemoryStoreConfig",
          "definition": "interface MemoryStoreConfig {\n  readonly [key: string]: unknown;\n}"
        },
        {
          "name": "EventBusConfig",
          "definition": "interface EventBusConfig {\n  readonly maxListeners: number;\n  readonly enableMiddleware: boolean;\n  readonly enableMetrics: boolean;\n  readonly enableLogging: boolean;\n  readonly logLevel: 'debug' | 'info' | 'warn' | 'error';\n}"
        },
        {
          "name": "EventMetrics",
          "definition": "interface EventMetrics {\n  readonly eventCount: number;\n  readonly eventTypes: Record<string, number>;\n  readonly avgProcessingTime: number;\n  readonly errorCount: number;\n  readonly listenerCount: number;\n}"
        }
      ],
      "exports": [
        {
          "name": "BaseEventPayload",
          "type": "export"
        },
        {
          "name": "SystemEvents",
          "type": "export"
        },
        {
          "name": "SystemStartedPayload",
          "type": "export"
        },
        {
          "name": "SystemStoppedPayload",
          "type": "export"
        },
        {
          "name": "SystemErrorPayload",
          "type": "export"
        },
        {
          "name": "SystemHealthChangedPayload",
          "type": "export"
        },
        {
          "name": "WorkflowEvents",
          "type": "export"
        },
        {
          "name": "WorkflowStartedPayload",
          "type": "export"
        },
        {
          "name": "WorkflowCompletedPayload",
          "type": "export"
        },
        {
          "name": "WorkflowFailedPayload",
          "type": "export"
        },
        {
          "name": "WorkflowPausedPayload",
          "type": "export"
        },
        {
          "name": "WorkflowResumedPayload",
          "type": "export"
        },
        {
          "name": "WorkflowCancelledPayload",
          "type": "export"
        },
        {
          "name": "WorkflowStepStartedPayload",
          "type": "export"
        },
        {
          "name": "WorkflowStepCompletedPayload",
          "type": "export"
        },
        {
          "name": "WorkflowStepFailedPayload",
          "type": "export"
        },
        {
          "name": "CoordinationEvents",
          "type": "export"
        },
        {
          "name": "AgentCreatedPayload",
          "type": "export"
        },
        {
          "name": "AgentDestroyedPayload",
          "type": "export"
        },
        {
          "name": "AgentStatusChangedPayload",
          "type": "export"
        },
        {
          "name": "TaskAssignedPayload",
          "type": "export"
        },
        {
          "name": "TaskCompletedPayload",
          "type": "export"
        },
        {
          "name": "TaskFailedPayload",
          "type": "export"
        },
        {
          "name": "SwarmInitializedPayload",
          "type": "export"
        },
        {
          "name": "SwarmTopologyChangedPayload",
          "type": "export"
        },
        {
          "name": "NeuralEvents",
          "type": "export"
        },
        {
          "name": "NeuralNetworkCreatedPayload",
          "type": "export"
        },
        {
          "name": "NeuralTrainingStartedPayload",
          "type": "export"
        },
        {
          "name": "NeuralTrainingCompletedPayload",
          "type": "export"
        },
        {
          "name": "NeuralTrainingFailedPayload",
          "type": "export"
        },
        {
          "name": "NeuralPredictionMadePayload",
          "type": "export"
        },
        {
          "name": "MemoryEvents",
          "type": "export"
        },
        {
          "name": "MemoryStoreCreatedPayload",
          "type": "export"
        },
        {
          "name": "MemoryKeySetPayload",
          "type": "export"
        },
        {
          "name": "MemoryKeyGetPayload",
          "type": "export"
        },
        {
          "name": "MemoryKeyDeletedPayload",
          "type": "export"
        },
        {
          "name": "MemorySyncStartedPayload",
          "type": "export"
        },
        {
          "name": "MemorySyncCompletedPayload",
          "type": "export"
        },
        {
          "name": "SystemConfig",
          "type": "export"
        },
        {
          "name": "SystemError",
          "type": "export"
        },
        {
          "name": "SystemErrorContext",
          "type": "export"
        },
        {
          "name": "ServiceHealthMap",
          "type": "export"
        },
        {
          "name": "WorkflowEventContext",
          "type": "export"
        },
        {
          "name": "WorkflowResults",
          "type": "export"
        },
        {
          "name": "WorkflowEventError",
          "type": "export"
        },
        {
          "name": "StepEventResult",
          "type": "export"
        },
        {
          "name": "TaskEventResult",
          "type": "export"
        },
        {
          "name": "TaskEventError",
          "type": "export"
        },
        {
          "name": "NeuralEventError",
          "type": "export"
        },
        {
          "name": "MemoryStoreConfig",
          "type": "export"
        },
        {
          "name": "EventBusConfig",
          "type": "export"
        },
        {
          "name": "EventMetrics",
          "type": "export"
        }
      ],
      "lineCount": 412
    },
    {
      "file": "src/types/agent-types.ts",
      "interfaces": [
        {
          "name": "AgentId",
          "definition": "interface AgentId {\n  id: string;\n  swarmId: string;\n  type: AgentType;\n  instance: number;\n}"
        },
        {
          "name": "AgentState",
          "definition": "interface AgentState {\n  id: AgentId;\n  name: string;\n  type: AgentType;\n  status: AgentStatus;\n  capabilities: AgentCapabilities;\n  metrics: AgentMetrics;\n  workload: number;\n  health: number;\n  config: AgentConfig;\n  environment: AgentEnvironment;\n  endpoints: string[];\n  lastHeartbeat: Date;\n  taskHistory: string[];\n  errorHistory: AgentError[];\n  childAgents: AgentId[];\n  collaborators: AgentId[];\n  currentTask?: string | null;\n}"
        },
        {
          "name": "AgentCapabilities",
          "definition": "interface AgentCapabilities {\n  codeGeneration: boolean;\n  codeReview: boolean;\n  testing: boolean;\n  documentation: boolean;\n  research: boolean;\n  analysis: boolean;\n  webSearch: boolean;\n  apiIntegration: boolean;\n  fileSystem: boolean;\n  terminalAccess: boolean;\n  languages: string[];\n  frameworks: string[];\n  domains: string[];\n  tools: string[];\n  maxConcurrentTasks: number;\n  maxMemoryUsage: number;\n  maxExecutionTime: number;\n  reliability: number;\n  speed: number;\n  quality: number;\n}"
        },
        {
          "name": "AgentConfig",
          "definition": "interface AgentConfig {\n  id?: string;\n  name: string;\n  type: AgentType;\n  swarmId: string;\n  capabilities?: string[];\n  autonomyLevel: number;\n  learningEnabled: boolean;\n  adaptationEnabled: boolean;\n  maxTasksPerHour: number;\n  maxConcurrentTasks: number;\n  timeoutThreshold: number;\n  reportingInterval: number;\n  heartbeatInterval: number;\n  permissions: string[];\n  trustedAgents: string[];\n  expertise: Record<string, number>;\n  preferences: Record<string, any>;\n}"
        },
        {
          "name": "AgentEnvironment",
          "definition": "interface AgentEnvironment {\n  runtime: 'deno' | 'node' | 'claude' | 'browser';\n  version: string;\n  workingDirectory: string;\n  tempDirectory: string;\n  logDirectory: string;\n  apiEndpoints: Record<string, string>;\n  credentials: Record<string, string>;\n  availableTools: string[];\n  toolConfigs: Record<string, any>;\n}"
        },
        {
          "name": "AgentMetrics",
          "definition": "interface AgentMetrics {\n  tasksCompleted: number;\n  tasksFailed: number;\n  averageExecutionTime: number;\n  successRate: number;\n  cpuUsage: number;\n  memoryUsage: number;\n  diskUsage: number;\n  networkUsage: number;\n  codeQuality: number;\n  testCoverage: number;\n  bugRate: number;\n  userSatisfaction: number;\n  totalUptime: number;\n  lastActivity: Date;\n  responseTime: number;\n  tasksInProgress?: number;\n  resourceUsage?: {\n    memory: number;\n    cpu: number;\n  }"
        },
        {
          "name": "AgentError",
          "definition": "interface AgentError {\n  timestamp: Date;\n  type: string;\n  message: string;\n  context: Record<string, any>;\n  severity: 'low' | 'medium' | 'high' | 'critical';\n  resolved: boolean;\n  code?: string;\n  agentId?: string;\n  taskId?: string;\n}"
        },
        {
          "name": "ExecutionResult",
          "definition": "interface ExecutionResult {\n  success: boolean;\n  data: any;\n  executionTime: number;\n  agentId: string;\n  metadata?: Record<string, any>;\n}"
        },
        {
          "name": "AgentCapability",
          "definition": "interface AgentCapability {\n  name: string;\n  version: string;\n  description: string;\n  requirements: string[];\n}"
        },
        {
          "name": "Task",
          "definition": "interface Task {\n  id: string;\n  swarmId: string;\n  description: string;\n  priority: string;\n  strategy: string;\n  status: string;\n  progress: number;\n  dependencies: string[];\n  assignedAgents: string[];\n  requireConsensus: boolean;\n  maxAgents: number;\n  requiredCapabilities: string[];\n  createdAt: Date;\n  metadata: Record<string, any>;\n}"
        },
        {
          "name": "Message",
          "definition": "interface Message {\n  id: string;\n  fromAgentId: string;\n  toAgentId: string | null;\n  swarmId: string;\n  type: string;\n  content: any;\n  timestamp: Date;\n  requiresResponse: boolean;\n}"
        }
      ],
      "exports": [
        {
          "name": "AgentId",
          "type": "export"
        },
        {
          "name": "AgentState",
          "type": "export"
        },
        {
          "name": "AgentCapabilities",
          "type": "export"
        },
        {
          "name": "AgentConfig",
          "type": "export"
        },
        {
          "name": "AgentEnvironment",
          "type": "export"
        },
        {
          "name": "AgentMetrics",
          "type": "export"
        },
        {
          "name": "AgentError",
          "type": "export"
        },
        {
          "name": "ExecutionResult",
          "type": "export"
        },
        {
          "name": "AgentCapability",
          "type": "export"
        },
        {
          "name": "Task",
          "type": "export"
        },
        {
          "name": "Message",
          "type": "export"
        }
      ],
      "lineCount": 305
    },
    {
      "file": "src/neural/neural-bridge.ts",
      "interfaces": [
        {
          "name": "NeuralConfig",
          "definition": "interface NeuralConfig {\n  wasmPath?: string;\n  gpuAcceleration?: boolean;\n  modelPath?: string;\n  enableTraining?: boolean;\n}"
        },
        {
          "name": "NeuralNetwork",
          "definition": "interface NeuralNetwork {\n  id: string;\n  type: 'feedforward' | 'lstm' | 'transformer' | 'autoencoder';\n  layers: number[];\n  weights?: Float64Array;\n  status: 'idle' | 'training' | 'predicting' | 'error';\n}"
        },
        {
          "name": "TrainingData",
          "definition": "interface TrainingData {\n  inputs: number[][];\n  outputs: number[][];\n}"
        },
        {
          "name": "PredictionResult",
          "definition": "interface PredictionResult {\n  outputs: number[];\n  confidence: number;\n  processingTime: number;\n}"
        }
      ],
      "exports": [
        {
          "name": "NeuralConfig",
          "type": "export"
        },
        {
          "name": "NeuralNetwork",
          "type": "export"
        },
        {
          "name": "TrainingData",
          "type": "export"
        },
        {
          "name": "PredictionResult",
          "type": "export"
        },
        {
          "name": "NeuralBridge",
          "type": "export"
        }
      ],
      "lineCount": 324
    },
    {
      "file": "src/knowledge/storage-interface.ts",
      "interfaces": [
        {
          "name": "FACTKnowledgeEntry",
          "definition": "interface FACTKnowledgeEntry {\n  id: string;\n  query: string;\n  response: string;\n  metadata: {\n    source: string;\n    agentId?: string;\n    specialization?: string;\n    domains: string[];\n    type: string;\n    confidence: number;\n    toolsUsed: string[];\n    executionTime: number;\n    cacheHit: boolean;\n    externalSources: string[];\n  }"
        },
        {
          "name": "FACTSearchQuery",
          "definition": "interface FACTSearchQuery {\n  query?: string;\n  domains?: string[];\n  type?: string;\n  source?: string;\n  maxAge?: number; // milliseconds\n  minConfidence?: number;\n  limit?: number;\n}"
        },
        {
          "name": "FACTStorageStats",
          "definition": "interface FACTStorageStats {\n  memoryEntries: number;\n  persistentEntries: number;\n  totalMemorySize: number;\n  cacheHitRate: number;\n  oldestEntry: number;\n  newestEntry: number;\n  topDomains: string[];\n  storageHealth: 'excellent' | 'good' | 'fair' | 'poor';\n}"
        },
        {
          "name": "FACTStorageBackend",
          "definition": "interface FACTStorageBackend {\n  /**\n   * Initialize the storage backend\n   */\n  initialize(): Promise<void>;\n\n  /**\n   * Store a knowledge entry\n   */\n  store(entry: FACTKnowledgeEntry): Promise<void>;\n\n  /**\n   * Retrieve a knowledge entry by ID\n   */\n  get(id: string): Promise<FACTKnowledgeEntry | null>;\n\n  /**\n   * Search knowledge entries\n   */\n  search(query: FACTSearchQuery): Promise<FACTKnowledgeEntry[]>;\n\n  /**\n   * Delete a knowledge entry\n   */\n  delete(id: string): Promise<boolean>;\n\n  /**\n   * Clean up expired entries\n   */\n  cleanup(maxAge: number): Promise<number>; // Returns count of deleted entries\n\n  /**\n   * Get storage statistics\n   */\n  getStats(): Promise<Partial<FACTStorageStats>>;\n\n  /**\n   * Clear all storage\n   */\n  clear(): Promise<void>;\n\n  /**\n   * Shutdown the storage backend\n   */\n  shutdown(): Promise<void>;\n}"
        },
        {
          "name": "FACTStorageConfig",
          "definition": "interface FACTStorageConfig {\n  backend: 'sqlite' | 'jsonb' | 'file' | 'memory';\n  backendConfig?: any; // Backend-specific configuration\n  maxMemoryCacheSize: number;\n  defaultTTL: number; // milliseconds\n  cleanupInterval: number; // milliseconds\n  maxEntryAge: number; // milliseconds\n}"
        }
      ],
      "exports": [
        {
          "name": "FACTKnowledgeEntry",
          "type": "export"
        },
        {
          "name": "FACTSearchQuery",
          "type": "export"
        },
        {
          "name": "FACTStorageStats",
          "type": "export"
        },
        {
          "name": "FACTStorageBackend",
          "type": "export"
        },
        {
          "name": "FACTStorageConfig",
          "type": "export"
        }
      ],
      "lineCount": 112
    },
    {
      "file": "src/knowledge/project-context-analyzer.ts",
      "interfaces": [
        {
          "name": "ProjectContext",
          "definition": "interface ProjectContext {\n  rootPath: string;\n  dependencies: DependencyInfo[];\n  devDependencies: DependencyInfo[];\n  frameworks: DetectedFramework[];\n  languages: DetectedLanguage[];\n  apis: DetectedAPI[];\n  currentTasks: string[];\n  errorPatterns: string[];\n  teamNeeds: string[];\n}"
        },
        {
          "name": "DependencyInfo",
          "definition": "interface DependencyInfo {\n  name: string;\n  version: string;\n  type: 'runtime' | 'development' | 'peer';\n  ecosystem: 'npm' | 'cargo' | 'pip' | 'go' | 'maven' | 'unknown';\n  lastUpdated?: string;\n  hasVulnerabilities?: boolean;\n}"
        },
        {
          "name": "DetectedFramework",
          "definition": "interface DetectedFramework {\n  name: string;\n  version?: string;\n  confidence: number;\n  usage: 'primary' | 'secondary' | 'utility';\n  needsDocs: boolean;\n}"
        },
        {
          "name": "DetectedLanguage",
          "definition": "interface DetectedLanguage {\n  name: string;\n  version?: string;\n  fileCount: number;\n  percentage: number;\n}"
        },
        {
          "name": "DetectedAPI",
          "definition": "interface DetectedAPI {\n  name: string;\n  type: 'rest' | 'graphql' | 'websocket' | 'grpc';\n  endpoints: string[];\n  needsAuth: boolean;\n}"
        },
        {
          "name": "KnowledgeGatheringMission",
          "definition": "interface KnowledgeGatheringMission {\n  id: string;\n  priority: 'critical' | 'high' | 'medium' | 'low';\n  type: 'dependency' | 'framework' | 'api' | 'security' | 'performance' | 'best-practices';\n  target: string;\n  version?: string;\n  context: string[];\n  requiredInfo: string[];\n  assignedDomain?: string;\n  status: 'pending' | 'assigned' | 'in-progress' | 'completed' | 'failed';\n  results?: any;\n}"
        },
        {
          "name": "ProjectAnalyzerConfig",
          "definition": "interface ProjectAnalyzerConfig {\n  projectRoot: string;\n  swarmConfig: KnowledgeSwarmConfig;\n  analysisDepth: 'shallow' | 'medium' | 'deep';\n  autoUpdate: boolean;\n  cacheDuration: number; // hours\n  priorityThresholds: {\n    critical: number; // Usage % for critical priority\n    high: number; // Usage % for high priority\n    medium: number; // Usage % for medium priority\n  }"
        }
      ],
      "exports": [
        {
          "name": "ProjectContextAnalyzer",
          "type": "export"
        }
      ],
      "lineCount": 839
    },
    {
      "file": "src/knowledge/performance-optimization-system.ts",
      "interfaces": [
        {
          "name": "IntelligentCachingSystem",
          "definition": "interface IntelligentCachingSystem {\n  cacheTypes: Map<string, CacheManager>;\n  evictionPolicies: EvictionPolicyManager;\n  replicationStrategy: ReplicationManager;\n  consistencyManager: ConsistencyManager;\n  prefetchingEngine: PrefetchingEngine;\n}"
        },
        {
          "name": "CacheManager",
          "definition": "interface CacheManager {\n  cacheType: CacheType;\n  storage: CacheStorage;\n  indexing: CacheIndexing;\n  metrics: CacheMetrics;\n  configuration: CacheConfiguration;\n}"
        },
        {
          "name": "CacheStorage",
          "definition": "interface CacheStorage {\n  localCache: LocalCacheStorage;\n  distributedCache: DistributedCacheStorage;\n  persistentCache: PersistentCacheStorage;\n  hierarchicalCache: HierarchicalCacheStorage;\n}"
        },
        {
          "name": "CacheEntry",
          "definition": "interface CacheEntry {\n  key: string;\n  value: any;\n  metadata: CacheEntryMetadata;\n  accessPattern: AccessPattern;\n  quality: CacheQuality;\n  dependencies: CacheDependency[];\n}"
        },
        {
          "name": "CacheEntryMetadata",
          "definition": "interface CacheEntryMetadata {\n  createdAt: number;\n  lastAccessed: number;\n  accessCount: number;\n  size: number;\n  ttl: number;\n  priority: CachePriority;\n  tags: string[];\n  version: string;\n}"
        },
        {
          "name": "EvictionPolicyManager",
          "definition": "interface EvictionPolicyManager {\n  policies: Map<string, EvictionPolicy>;\n  policySelection: PolicySelector;\n  adaptiveEviction: AdaptiveEvictionEngine;\n  performanceTracker: EvictionPerformanceTracker;\n}"
        },
        {
          "name": "ReplicationManager",
          "definition": "interface ReplicationManager {\n  replicationStrategy: ReplicationStrategy;\n  consistencyLevel: ConsistencyLevel;\n  conflictResolution: ConflictResolutionStrategy;\n  syncProtocol: SynchronizationProtocol;\n  healthMonitoring: ReplicationHealthMonitor;\n}"
        },
        {
          "name": "PrefetchingEngine",
          "definition": "interface PrefetchingEngine {\n  predictionModels: PredictionModel[];\n  prefetchingStrategies: PrefetchingStrategy[];\n  workloadAnalyzer: WorkloadAnalyzer;\n  prefetchScheduler: PrefetchScheduler;\n  costBenefitAnalyzer: CostBenefitAnalyzer;\n}"
        },
        {
          "name": "BandwidthOptimizationSystem",
          "definition": "interface BandwidthOptimizationSystem {\n  compressionEngine: CompressionEngine;\n  deltaEncoding: DeltaEncodingSystem;\n  batchingStrategy: BatchingStrategyManager;\n  adaptiveStreaming: AdaptiveStreamingEngine;\n  priorityQueuing: PriorityQueuingSystem;\n}"
        },
        {
          "name": "CompressionEngine",
          "definition": "interface CompressionEngine {\n  algorithms: Map<string, CompressionAlgorithm>;\n  algorithmSelection: AlgorithmSelector;\n  adaptiveCompression: AdaptiveCompressionEngine;\n  performanceOptimizer: CompressionOptimizer;\n}"
        },
        {
          "name": "CompressionAlgorithm",
          "definition": "interface CompressionAlgorithm {\n  algorithmName: string;\n  compressionType: CompressionType;\n  configuration: CompressionConfig;\n  performance: CompressionPerformance;\n  applicability: CompressionApplicability;\n}"
        },
        {
          "name": "DeltaEncodingSystem",
          "definition": "interface DeltaEncodingSystem {\n  deltaComputation: DeltaComputationEngine;\n  diffStrategies: DiffStrategy[];\n  changeDetection: ChangeDetectionSystem;\n  reconstructionEngine: ReconstructionEngine;\n  versionManagement: DeltaVersionManager;\n}"
        },
        {
          "name": "BatchingStrategyManager",
          "definition": "interface BatchingStrategyManager {\n  batchingStrategies: Map<string, BatchingStrategy>;\n  batchOptimizer: BatchOptimizer;\n  aggregationRules: AggregationRule[];\n  batchScheduler: BatchScheduler;\n  performanceTracker: BatchingPerformanceTracker;\n}"
        },
        {
          "name": "AdaptiveStreamingEngine",
          "definition": "interface AdaptiveStreamingEngine {\n  streamingProtocols: StreamingProtocol[];\n  adaptationEngine: StreamAdaptationEngine;\n  qualityManagement: StreamQualityManager;\n  bufferingStrategy: BufferingStrategy;\n  flowControl: FlowControlManager;\n}"
        },
        {
          "name": "PriorityQueuingSystem",
          "definition": "interface PriorityQueuingSystem {\n  priorityQueues: Map<string, PriorityQueue>;\n  priorityCalculator: PriorityCalculator;\n  queueManagement: QueueManager;\n  fairnessController: FairnessController;\n  performanceMonitor: QueuePerformanceMonitor;\n}"
        },
        {
          "name": "PriorityManagementSystem",
          "definition": "interface PriorityManagementSystem {\n  priorityCalculation: PriorityCalculationEngine;\n  dynamicPrioritization: DynamicPrioritizationSystem;\n  resourceAllocation: ResourceAllocationManager;\n  qosManagement: QoSManager;\n  fairnessEnforcement: FairnessEnforcementSystem;\n}"
        },
        {
          "name": "PriorityCalculationEngine",
          "definition": "interface PriorityCalculationEngine {\n  priorityFactors: PriorityFactor[];\n  weightingSchemes: WeightingScheme[];\n  calculationAlgorithms: PriorityAlgorithm[];\n  adaptivePrioritization: AdaptivePrioritizationEngine;\n  contextualPrioritization: ContextualPrioritizationSystem;\n}"
        },
        {
          "name": "DynamicPrioritizationSystem",
          "definition": "interface DynamicPrioritizationSystem {\n  priorityAdjustment: PriorityAdjustmentEngine;\n  temporalPrioritization: TemporalPrioritizationSystem;\n  loadBasedPrioritization: LoadBasedPrioritizationEngine;\n  userFeedbackIntegration: UserFeedbackIntegrator;\n  emergencyPrioritization: EmergencyPrioritizationHandler;\n}"
        },
        {
          "name": "ResourceAllocationManager",
          "definition": "interface ResourceAllocationManager {\n  allocationStrategies: AllocationStrategy[];\n  resourcePools: Map<string, ResourcePool>;\n  utilizationOptimizer: UtilizationOptimizer;\n  capacityPlanning: CapacityPlanningEngine;\n  elasticScaling: ElasticScalingManager;\n}"
        },
        {
          "name": "QoSManager",
          "definition": "interface QoSManager {\n  serviceClasses: ServiceClass[];\n  slaManagement: SLAManager;\n  performanceGuarantees: PerformanceGuarantee[];\n  violationDetection: ViolationDetectionSystem;\n  remedialActions: RemedialActionEngine;\n}"
        },
        {
          "name": "LoadBalancingSystem",
          "definition": "interface LoadBalancingSystem {\n  loadBalancers: Map<string, LoadBalancer>;\n  balancingStrategies: BalancingStrategy[];\n  healthChecking: HealthCheckingSystem;\n  trafficShaping: TrafficShapingEngine;\n  adaptiveBalancing: AdaptiveBalancingEngine;\n}"
        },
        {
          "name": "LoadBalancer",
          "definition": "interface LoadBalancer {\n  balancerType: LoadBalancerType;\n  algorithm: LoadBalancingAlgorithm;\n  healthStatus: HealthStatus;\n  performanceMetrics: LoadBalancerMetrics;\n  configuration: LoadBalancerConfig;\n}"
        },
        {
          "name": "BalancingStrategy",
          "definition": "interface BalancingStrategy {\n  strategyName: string;\n  algorithm: LoadBalancingAlgorithm;\n  applicability: BalancingApplicability;\n  performance: BalancingPerformance;\n  adaptability: AdaptabilityConfig;\n}"
        },
        {
          "name": "HealthCheckingSystem",
          "definition": "interface HealthCheckingSystem {\n  healthCheckers: Map<string, HealthChecker>;\n  checkingProtocols: HealthCheckProtocol[];\n  failureDetection: FailureDetectionSystem;\n  recoveryManagement: RecoveryManager;\n  alertingSystem: HealthAlertingSystem;\n}"
        },
        {
          "name": "TrafficShapingEngine",
          "definition": "interface TrafficShapingEngine {\n  shapingPolicies: TrafficShapingPolicy[];\n  rateLimiting: RateLimitingSystem;\n  congestionControl: CongestionControlSystem;\n  adaptiveShaping: AdaptiveShapingEngine;\n  flowClassification: FlowClassificationSystem;\n}"
        },
        {
          "name": "RealTimeMonitoringSystem",
          "definition": "interface RealTimeMonitoringSystem {\n  metricsCollection: MetricsCollectionEngine;\n  performanceAnalytics: PerformanceAnalyticsEngine;\n  anomalyDetection: AnomalyDetectionSystem;\n  alertingSystem: AlertingSystem;\n  dashboardSystem: DashboardSystem;\n}"
        },
        {
          "name": "MetricsCollectionEngine",
          "definition": "interface MetricsCollectionEngine {\n  collectors: Map<string, MetricsCollector>;\n  aggregationRules: MetricsAggregationRule[];\n  samplingStrategies: SamplingStrategy[];\n  storageSystem: MetricsStorageSystem;\n  retentionPolicies: RetentionPolicy[];\n}"
        },
        {
          "name": "PerformanceAnalyticsEngine",
          "definition": "interface PerformanceAnalyticsEngine {\n  analyticsModels: AnalyticsModel[];\n  trendAnalysis: TrendAnalysisEngine;\n  patternRecognition: PatternRecognitionSystem;\n  predictiveAnalytics: PredictiveAnalyticsEngine;\n  reportGeneration: ReportGenerationSystem;\n}"
        },
        {
          "name": "AnomalyDetectionSystem",
          "definition": "interface AnomalyDetectionSystem {\n  detectionAlgorithms: AnomalyDetectionAlgorithm[];\n  baselineManagement: BaselineManager;\n  thresholdManagement: ThresholdManager;\n  correlationAnalysis: CorrelationAnalysisEngine;\n  rootCauseAnalysis: RootCauseAnalysisSystem;\n}"
        },
        {
          "name": "AlertingSystem",
          "definition": "interface AlertingSystem {\n  alertRules: AlertRule[];\n  notificationChannels: NotificationChannel[];\n  escalationPolicies: EscalationPolicy[];\n  alertCorrelation: AlertCorrelationEngine;\n  suppressionRules: SuppressionRule[];\n}"
        },
        {
          "name": "PerformanceOptimizationConfig",
          "definition": "interface PerformanceOptimizationConfig {\n  caching: CachingConfig;\n  bandwidth: BandwidthConfig;\n  priority: PriorityConfig;\n  loadBalancing: LoadBalancingConfig;\n  monitoring: MonitoringConfig;\n}"
        },
        {
          "name": "KnowledgeRequest",
          "definition": "interface KnowledgeRequest {\n  id: string;\n  type: string;\n  urgency: 'low' | 'medium' | 'high' | 'critical';\n  content: any;\n  metadata: any;\n}"
        },
        {
          "name": "KnowledgeSharingRequest",
          "definition": "interface KnowledgeSharingRequest {\n  sourceAgent: string;\n  targetAgents: string[];\n  knowledge: any;\n  knowledgeSize: number;\n  urgency: 'low' | 'medium' | 'high' | 'critical';\n}"
        },
        {
          "name": "OptimizedKnowledgeResponse",
          "definition": "interface OptimizedKnowledgeResponse {\n  requestId: string;\n  response: any;\n  optimizations: OptimizationMetrics;\n  performanceMetrics: any;\n  timestamp: number;\n}"
        },
        {
          "name": "KnowledgeSharingOptimization",
          "definition": "interface KnowledgeSharingOptimization {\n  optimizationId: string;\n  originalRequest: KnowledgeSharingRequest;\n  sharingStrategy: string;\n  optimizations: SharingOptimizationMetrics;\n  performanceMetrics: any;\n  sharingResults: any;\n  optimizationTime: number;\n  timestamp: number;\n}"
        },
        {
          "name": "CacheOptimizationResult",
          "definition": "interface CacheOptimizationResult {\n  optimizationId: string;\n  originalMetrics: any;\n  appliedOptimizations: number;\n  evictionUpdates: number;\n  prefetchingOptimizations: number;\n  replicationOptimizations: number;\n  performanceImprovement: PerformanceImprovement;\n  optimizationTime: number;\n  timestamp: number;\n}"
        },
        {
          "name": "PerformanceOptimizationMetrics",
          "definition": "interface PerformanceOptimizationMetrics {\n  caching: any;\n  bandwidth: any;\n  priority: any;\n  loadBalancing: any;\n  monitoring: any;\n  overall: any;\n}"
        },
        {
          "name": "OptimizationMetrics",
          "definition": "interface OptimizationMetrics {\n  cacheHit: boolean;\n  compressionRatio: number;\n  priorityLevel: string;\n  processingTime: number;\n  bandwidthSaved: number;\n  resourceUtilization: number;\n}"
        },
        {
          "name": "SharingOptimizationMetrics",
          "definition": "interface SharingOptimizationMetrics {\n  compressionAchieved: number;\n  bandwidthReduction: number;\n  latencyImprovement: number;\n  throughputIncrease: number;\n  resourceEfficiency: number;\n}"
        },
        {
          "name": "PerformanceImprovement",
          "definition": "interface PerformanceImprovement {\n  hitRateImprovement: number;\n  latencyReduction: number;\n  memoryEfficiency: number;\n  networkReduction: number;\n}"
        },
        {
          "name": "CacheResult",
          "definition": "interface CacheResult {\n  hit: boolean;\n  data: any;\n}"
        },
        {
          "name": "RequestPriority",
          "definition": "interface RequestPriority {\n  level: string;\n  score: number;\n}"
        },
        {
          "name": "ProcessingStrategy",
          "definition": "interface ProcessingStrategy {\n  name: string;\n  config: any;\n}"
        },
        {
          "name": "IntelligentCachingEngine",
          "definition": "interface IntelligentCachingEngine {\n  updateCacheStrategy(optimization: any): Promise<void>;\n  shutdown(): Promise<void>;\n  on(event: string, handler: Function): void;\n}"
        }
      ],
      "exports": [
        {
          "name": "IntelligentCachingSystem",
          "type": "export"
        },
        {
          "name": "CacheManager",
          "type": "export"
        },
        {
          "name": "CacheStorage",
          "type": "export"
        },
        {
          "name": "CacheEntry",
          "type": "export"
        },
        {
          "name": "CacheEntryMetadata",
          "type": "export"
        },
        {
          "name": "EvictionPolicyManager",
          "type": "export"
        },
        {
          "name": "ReplicationManager",
          "type": "export"
        },
        {
          "name": "PrefetchingEngine",
          "type": "export"
        },
        {
          "name": "BandwidthOptimizationSystem",
          "type": "export"
        },
        {
          "name": "CompressionEngine",
          "type": "export"
        },
        {
          "name": "CompressionAlgorithm",
          "type": "export"
        },
        {
          "name": "DeltaEncodingSystem",
          "type": "export"
        },
        {
          "name": "BatchingStrategyManager",
          "type": "export"
        },
        {
          "name": "AdaptiveStreamingEngine",
          "type": "export"
        },
        {
          "name": "PriorityQueuingSystem",
          "type": "export"
        },
        {
          "name": "PriorityManagementSystem",
          "type": "export"
        },
        {
          "name": "PriorityCalculationEngine",
          "type": "export"
        },
        {
          "name": "DynamicPrioritizationSystem",
          "type": "export"
        },
        {
          "name": "ResourceAllocationManager",
          "type": "export"
        },
        {
          "name": "QoSManager",
          "type": "export"
        },
        {
          "name": "LoadBalancingSystem",
          "type": "export"
        },
        {
          "name": "LoadBalancer",
          "type": "export"
        },
        {
          "name": "BalancingStrategy",
          "type": "export"
        },
        {
          "name": "HealthCheckingSystem",
          "type": "export"
        },
        {
          "name": "TrafficShapingEngine",
          "type": "export"
        },
        {
          "name": "RealTimeMonitoringSystem",
          "type": "export"
        },
        {
          "name": "MetricsCollectionEngine",
          "type": "export"
        },
        {
          "name": "PerformanceAnalyticsEngine",
          "type": "export"
        },
        {
          "name": "AnomalyDetectionSystem",
          "type": "export"
        },
        {
          "name": "AlertingSystem",
          "type": "export"
        },
        {
          "name": "PerformanceOptimizationSystem",
          "type": "export"
        },
        {
          "name": "PerformanceOptimizationConfig",
          "type": "export"
        },
        {
          "name": "KnowledgeRequest",
          "type": "export"
        },
        {
          "name": "KnowledgeSharingRequest",
          "type": "export"
        },
        {
          "name": "OptimizedKnowledgeResponse",
          "type": "export"
        },
        {
          "name": "KnowledgeSharingOptimization",
          "type": "export"
        },
        {
          "name": "CacheOptimizationResult",
          "type": "export"
        },
        {
          "name": "PerformanceOptimizationMetrics",
          "type": "export"
        },
        {
          "name": "OptimizationMetrics",
          "type": "export"
        },
        {
          "name": "SharingOptimizationMetrics",
          "type": "export"
        },
        {
          "name": "PerformanceImprovement",
          "type": "export"
        },
        {
          "name": "CacheResult",
          "type": "export"
        },
        {
          "name": "RequestPriority",
          "type": "export"
        },
        {
          "name": "ProcessingStrategy",
          "type": "export"
        }
      ],
      "lineCount": 915
    },
    {
      "file": "src/knowledge/knowledge-swarm.ts",
      "interfaces": [
        {
          "name": "KnowledgeAgentSpecialization",
          "definition": "interface KnowledgeAgentSpecialization {\n  name: string;\n  domains: string[];\n  tools: string[];\n  priority: number;\n  expertise: string[];\n}"
        },
        {
          "name": "KnowledgeQuery",
          "definition": "interface KnowledgeQuery {\n  id: string;\n  query: string;\n  domains?: string[];\n  urgency: 'low' | 'medium' | 'high' | 'critical';\n  parallel?: boolean;\n  metadata?: Record<string, any>;\n}"
        },
        {
          "name": "KnowledgeSwarmResult",
          "definition": "interface KnowledgeSwarmResult {\n  queryId: string;\n  results: KnowledgeResult[];\n  consolidatedResponse: string;\n  agentsUsed: string[];\n  totalExecutionTime: number;\n  knowledgeConfidence: number;\n  sourcesDiversity: number;\n}"
        },
        {
          "name": "KnowledgeAgent",
          "definition": "interface KnowledgeAgent {\n  id: string;\n  specialization: KnowledgeAgentSpecialization;\n  knowledgeClient: KnowledgeClient;\n  currentLoad: number;\n  totalQueries: number;\n  successRate: number;\n  averageLatency: number;\n  expertise: Map<string, number>; // domain -> confidence score\n}"
        }
      ],
      "exports": [
        {
          "name": "KnowledgeSwarm",
          "type": "export"
        },
        {
          "name": "getFACTSwarm",
          "type": "export"
        },
        {
          "name": "FACTSwarmHelpers",
          "type": "export"
        }
      ],
      "lineCount": 803
    },
    {
      "file": "src/knowledge/knowledge-storage.ts",
      "interfaces": [],
      "exports": [
        {
          "name": "FACTStorageSystem",
          "type": "export"
        }
      ],
      "lineCount": 407
    },
    {
      "file": "src/knowledge/knowledge-quality-management.ts",
      "interfaces": [
        {
          "name": "ReputationSystem",
          "definition": "interface ReputationSystem {\n  reputationModel: ReputationModel;\n  scoringAlgorithms: ScoringAlgorithm[];\n  consensusWeighting: ConsensusWeightingConfig;\n  decayFunctions: DecayFunction[];\n  bootstrapping: BootstrappingConfig;\n}"
        },
        {
          "name": "ReputationModel",
          "definition": "interface ReputationModel {\n  modelType: ReputationModelType;\n  parameters: ReputationParameters;\n  components: ReputationComponent[];\n  aggregation: ReputationAggregation;\n  normalization: NormalizationConfig;\n}"
        },
        {
          "name": "ReputationScore",
          "definition": "interface ReputationScore {\n  agentId: string;\n  overallScore: number;\n  componentScores: ComponentScore[];\n  confidence: number;\n  lastUpdated: number;\n  trend: ScoreTrend;\n  rank: number;\n  percentile: number;\n}"
        },
        {
          "name": "ScoringAlgorithm",
          "definition": "interface ScoringAlgorithm {\n  algorithmName: string;\n  algorithmType: ScoringAlgorithmType;\n  weights: AlgorithmWeights;\n  parameters: AlgorithmParameters;\n  performance: AlgorithmPerformance;\n  applicability: ScoringApplicability;\n}"
        },
        {
          "name": "ConsensusWeightingConfig",
          "definition": "interface ConsensusWeightingConfig {\n  weightingStrategy: WeightingStrategy;\n  thresholds: ConsensusThreshold[];\n  decisionRules: DecisionRule[];\n  tieBreaking: TieBreakingRule[];\n  adaptiveWeighting: AdaptiveWeightingConfig;\n}"
        },
        {
          "name": "DecayFunction",
          "definition": "interface DecayFunction {\n  functionType: DecayFunctionType;\n  parameters: DecayParameters;\n  applicableComponents: string[];\n  minimumRetention: number;\n  maxDecayRate: number;\n}"
        },
        {
          "name": "ValidationProtocol",
          "definition": "interface ValidationProtocol {\n  protocolName: string;\n  validationType: ValidationType;\n  validators: ValidatorConfig[];\n  thresholds: ValidationThresholds;\n  evidenceRequirements: EvidenceRequirements;\n  crossValidation: CrossValidationConfig;\n}"
        },
        {
          "name": "ValidatorConfig",
          "definition": "interface ValidatorConfig {\n  validatorId: string;\n  validatorType: ValidatorType;\n  capabilities: ValidationCapability[];\n  reliability: ValidatorReliability;\n  specialization: ValidationSpecialization;\n  performance: ValidatorPerformance;\n}"
        },
        {
          "name": "ValidationThresholds",
          "definition": "interface ValidationThresholds {\n  acceptanceThreshold: number;\n  rejectionThreshold: number;\n  uncertaintyThreshold: number;\n  consensusThreshold: number;\n  qualityThreshold: number;\n  confidenceThreshold: number;\n}"
        },
        {
          "name": "EvidenceRequirements",
          "definition": "interface EvidenceRequirements {\n  minEvidenceCount: number;\n  evidenceTypes: EvidenceType[];\n  sourceReliability: SourceReliabilityRequirement[];\n  verificationLevel: VerificationLevel;\n  crossReferencingRequirement: CrossReferencingConfig;\n}"
        },
        {
          "name": "CrossValidationConfig",
          "definition": "interface CrossValidationConfig {\n  validatorSelection: ValidatorSelectionStrategy;\n  minValidators: number;\n  maxValidators: number;\n  disagreementResolution: DisagreementResolutionStrategy;\n  consensusBuilding: ConsensusConfiguration;\n}"
        },
        {
          "name": "ValidationResult",
          "definition": "interface ValidationResult {\n  validationId: string;\n  knowledgeItem: KnowledgeItem;\n  validationType: ValidationType;\n  validatorsUsed: string[];\n  validationScores: ValidationScore[];\n  overallScore: number;\n  isValid: boolean;\n  confidence: number;\n  evidence: ValidationEvidence[];\n  issues: ValidationIssue[];\n  recommendations: ValidationRecommendation[];\n  timestamp: number;\n}"
        },
        {
          "name": "QualityAssuranceSystem",
          "definition": "interface QualityAssuranceSystem {\n  qualityMetrics: QualityMetricDefinition[];\n  assessmentProtocols: AssessmentProtocol[];\n  continuousMonitoring: MonitoringConfig;\n  qualityImprovement: ImprovementMechanism[];\n  benchmarking: BenchmarkingConfig;\n}"
        },
        {
          "name": "QualityMetricDefinition",
          "definition": "interface QualityMetricDefinition {\n  metricName: string;\n  metricType: QualityMetricType;\n  measurement: MeasurementMethod;\n  aggregation: AggregationMethod;\n  interpretation: InterpretationRules;\n  benchmarks: QualityBenchmark[];\n}"
        },
        {
          "name": "AssessmentProtocol",
          "definition": "interface AssessmentProtocol {\n  protocolName: string;\n  assessmentScope: AssessmentScope;\n  assessmentMethod: AssessmentMethod;\n  frequency: AssessmentFrequency;\n  criteria: AssessmentCriteria[];\n  scoring: ScoringRubric;\n}"
        },
        {
          "name": "MonitoringConfig",
          "definition": "interface MonitoringConfig {\n  monitoringScope: MonitoringScope;\n  monitoringFrequency: number;\n  alertConditions: AlertCondition[];\n  dashboards: DashboardConfig[];\n  reporting: ReportingConfig;\n}"
        },
        {
          "name": "ImprovementMechanism",
          "definition": "interface ImprovementMechanism {\n  mechanismName: string;\n  improvementType: ImprovementType;\n  triggers: ImprovementTrigger[];\n  actions: ImprovementAction[];\n  evaluation: ImprovementEvaluation;\n}"
        },
        {
          "name": "BenchmarkingConfig",
          "definition": "interface BenchmarkingConfig {\n  benchmarkTypes: BenchmarkType[];\n  comparisonBaselines: ComparisonBaseline[];\n  performanceStandards: PerformanceStandard[];\n  benchmarkingFrequency: number;\n  reportingFormat: BenchmarkReportFormat;\n}"
        },
        {
          "name": "TemporalKnowledgeManager",
          "definition": "interface TemporalKnowledgeManager {\n  versionControl: KnowledgeVersionControl;\n  temporalValidation: TemporalValidationSystem;\n  knowledgeDecay: KnowledgeDecayManager;\n  updatePropagation: UpdatePropagationSystem;\n  temporalQueries: TemporalQueryEngine;\n}"
        },
        {
          "name": "KnowledgeVersionControl",
          "definition": "interface KnowledgeVersionControl {\n  versions: Map<string, KnowledgeVersion>;\n  versionHistory: VersionHistory[];\n  mergeStrategies: MergeStrategy[];\n  conflictResolution: VersionConflictResolver;\n  branchManagement: BranchManager;\n}"
        },
        {
          "name": "TemporalValidationSystem",
          "definition": "interface TemporalValidationSystem {\n  temporalConstraints: TemporalConstraint[];\n  timeSeriesValidation: TimeSeriesValidator;\n  causalityChecking: CausalityChecker;\n  consistencyMaintenance: TemporalConsistencyMaintainer;\n  invalidationDetection: InvalidationDetector;\n}"
        },
        {
          "name": "KnowledgeDecayManager",
          "definition": "interface KnowledgeDecayManager {\n  decayModels: DecayModel[];\n  freshnessCriteria: FreshnessCriteria[];\n  decayPrediction: DecayPredictor;\n  refreshStrategies: RefreshStrategy[];\n  retentionPolicies: RetentionPolicy[];\n}"
        },
        {
          "name": "UpdatePropagationSystem",
          "definition": "interface UpdatePropagationSystem {\n  propagationGraph: PropagationGraph;\n  updateStrategies: UpdateStrategy[];\n  dependencyTracking: DependencyTracker;\n  impactAnalysis: ImpactAnalyzer;\n  cascadingUpdates: CascadingUpdateManager;\n}"
        },
        {
          "name": "PeerReviewSystem",
          "definition": "interface PeerReviewSystem {\n  reviewProcesses: ReviewProcess[];\n  reviewerSelection: ReviewerSelectionSystem;\n  reviewWorkflow: ReviewWorkflowManager;\n  reviewQuality: ReviewQualityAssurance;\n  reviewerIncentives: IncentiveSystem;\n}"
        },
        {
          "name": "ReviewProcess",
          "definition": "interface ReviewProcess {\n  processName: string;\n  reviewType: ReviewType;\n  phases: ReviewPhase[];\n  criteria: ReviewCriteria[];\n  workflow: ReviewWorkflow;\n  qualityControl: ReviewQualityControl;\n}"
        },
        {
          "name": "ReviewerSelectionSystem",
          "definition": "interface ReviewerSelectionSystem {\n  selectionCriteria: ReviewerSelectionCriteria[];\n  matchingAlgorithm: ReviewerMatchingAlgorithm;\n  availabilityTracking: AvailabilityTracker;\n  loadBalancing: ReviewerLoadBalancer;\n  conflictOfInterest: ConflictOfInterestDetector;\n}"
        },
        {
          "name": "ReviewWorkflowManager",
          "definition": "interface ReviewWorkflowManager {\n  workflowTemplates: WorkflowTemplate[];\n  stateManagement: ReviewStateManager;\n  progressTracking: ProgressTracker;\n  deadlineManagement: DeadlineManager;\n  escalationProcedures: EscalationProcedure[];\n}"
        },
        {
          "name": "ReviewResult",
          "definition": "interface ReviewResult {\n  reviewId: string;\n  knowledgeItem: KnowledgeItem;\n  reviewers: ReviewerAssignment[];\n  reviewScores: ReviewScore[];\n  overallScore: number;\n  recommendation: ReviewRecommendation;\n  comments: ReviewComment[];\n  qualityAssessment: ReviewQualityAssessment;\n  timestamp: number;\n}"
        },
        {
          "name": "KnowledgeQualityConfig",
          "definition": "interface KnowledgeQualityConfig {\n  reputation: ReputationConfig;\n  validation: ValidationConfig;\n  qualityAssurance: QualityAssuranceConfig;\n  temporalManagement: TemporalManagementConfig;\n  peerReview: PeerReviewConfig;\n}"
        },
        {
          "name": "KnowledgeItem",
          "definition": "interface KnowledgeItem {\n  id: string;\n  type: string;\n  content: string;\n  metadata: any;\n  quality: number;\n  timestamp: number;\n}"
        },
        {
          "name": "ContributionRecord",
          "definition": "interface ContributionRecord {\n  type: string;\n  quality: number;\n  timestamp: number;\n  metadata: any;\n}"
        },
        {
          "name": "QualityMonitoringReport",
          "definition": "interface QualityMonitoringReport {\n  reportId: string;\n  currentMetrics: any;\n  qualityTrends: any;\n  identifiedIssues: number;\n  improvementRecommendations: number;\n  appliedImprovements: number;\n  benchmarkUpdates: number;\n  overallQualityScore: number;\n  monitoringTime: number;\n  timestamp: number;\n}"
        },
        {
          "name": "KnowledgeQualityMetrics",
          "definition": "interface KnowledgeQualityMetrics {\n  reputation: any;\n  validation: any;\n  qualityAssurance: any;\n  peerReview: any;\n  temporal: any;\n}"
        },
        {
          "name": "ReviewerAssignment",
          "definition": "interface ReviewerAssignment {\n  reviewerId: string;\n  assignment: any;\n}"
        },
        {
          "name": "ValidationScore",
          "definition": "interface ValidationScore {\n  validatorId: string;\n  score: number;\n  confidence: number;\n  comments: string;\n}"
        },
        {
          "name": "ReviewScore",
          "definition": "interface ReviewScore {\n  reviewerId: string;\n  score: number;\n  confidence: number;\n  comments: string;\n}"
        },
        {
          "name": "ReputationManagementSystem",
          "definition": "interface ReputationManagementSystem {\n  scoringAlgorithms: ScoringAlgorithm[];\n  reputationModel: ReputationModel;\n  decayFunctions: DecayFunction[];\n  updateFromValidation(validation: any): Promise<void>;\n  shutdown(): Promise<void>;\n  on(event: string, handler: Function): void;\n}"
        }
      ],
      "exports": [
        {
          "name": "ReputationSystem",
          "type": "export"
        },
        {
          "name": "ReputationModel",
          "type": "export"
        },
        {
          "name": "ReputationScore",
          "type": "export"
        },
        {
          "name": "ScoringAlgorithm",
          "type": "export"
        },
        {
          "name": "ConsensusWeightingConfig",
          "type": "export"
        },
        {
          "name": "DecayFunction",
          "type": "export"
        },
        {
          "name": "ValidationProtocol",
          "type": "export"
        },
        {
          "name": "ValidatorConfig",
          "type": "export"
        },
        {
          "name": "ValidationThresholds",
          "type": "export"
        },
        {
          "name": "EvidenceRequirements",
          "type": "export"
        },
        {
          "name": "CrossValidationConfig",
          "type": "export"
        },
        {
          "name": "ValidationResult",
          "type": "export"
        },
        {
          "name": "QualityAssuranceSystem",
          "type": "export"
        },
        {
          "name": "QualityMetricDefinition",
          "type": "export"
        },
        {
          "name": "AssessmentProtocol",
          "type": "export"
        },
        {
          "name": "MonitoringConfig",
          "type": "export"
        },
        {
          "name": "ImprovementMechanism",
          "type": "export"
        },
        {
          "name": "BenchmarkingConfig",
          "type": "export"
        },
        {
          "name": "TemporalKnowledgeManager",
          "type": "export"
        },
        {
          "name": "KnowledgeVersionControl",
          "type": "export"
        },
        {
          "name": "TemporalValidationSystem",
          "type": "export"
        },
        {
          "name": "KnowledgeDecayManager",
          "type": "export"
        },
        {
          "name": "UpdatePropagationSystem",
          "type": "export"
        },
        {
          "name": "PeerReviewSystem",
          "type": "export"
        },
        {
          "name": "ReviewProcess",
          "type": "export"
        },
        {
          "name": "ReviewerSelectionSystem",
          "type": "export"
        },
        {
          "name": "ReviewWorkflowManager",
          "type": "export"
        },
        {
          "name": "ReviewResult",
          "type": "export"
        },
        {
          "name": "KnowledgeQualityManagementSystem",
          "type": "export"
        },
        {
          "name": "KnowledgeQualityConfig",
          "type": "export"
        },
        {
          "name": "KnowledgeItem",
          "type": "export"
        },
        {
          "name": "ContributionRecord",
          "type": "export"
        },
        {
          "name": "QualityMonitoringReport",
          "type": "export"
        },
        {
          "name": "KnowledgeQualityMetrics",
          "type": "export"
        },
        {
          "name": "ReviewerAssignment",
          "type": "export"
        },
        {
          "name": "ValidationScore",
          "type": "export"
        },
        {
          "name": "ReviewScore",
          "type": "export"
        }
      ],
      "lineCount": 936
    },
    {
      "file": "src/knowledge/knowledge-processor.ts",
      "interfaces": [
        {
          "name": "WASMFact",
          "definition": "interface WASMFact {\n  FastCache: {\n    new (\n      size: number\n    ): {\n      set(key: string, value: string, ttl: bigint): boolean;\n      get(key: string): string | undefined;\n      clear(): void;\n      size(): number;\n      stats(): { hits: number; misses: number; hit_rate: number }"
        },
        {
          "name": "WASMFactConfig",
          "definition": "interface WASMFactConfig {\n  wasmPath?: string;\n  cacheSize: number;\n  enableTemplates: boolean;\n  cognitiveMode: 'basic' | 'advanced' | 'optimized';\n  performanceTarget: 'speed' | 'memory' | 'balanced';\n}"
        },
        {
          "name": "CognitiveTemplate",
          "definition": "interface CognitiveTemplate {\n  name: string;\n  category: string;\n  description: string;\n  pattern: any;\n  performance: {\n    avgExecutionTime: number;\n    successRate: number;\n    cacheEfficiency: number;\n  }"
        },
        {
          "name": "WASMPerformanceMetrics",
          "definition": "interface WASMPerformanceMetrics {\n  cacheOperations: {\n    hits: number;\n    misses: number;\n    hitRate: number;\n    avgLatency: number;\n  }"
        }
      ],
      "exports": [
        {
          "name": "WASMFactIntegration",
          "type": "export"
        }
      ],
      "lineCount": 811
    },
    {
      "file": "src/knowledge/knowledge-client.ts",
      "interfaces": [
        {
          "name": "FACTConfig",
          "definition": "interface FACTConfig {\n  pythonPath?: string;\n  factRepoPath: string;\n  anthropicApiKey: string;\n  cacheConfig?: {\n    prefix: string;\n    minTokens: number;\n    maxSize: string;\n    ttlSeconds: number;\n  }"
        },
        {
          "name": "FACTQuery",
          "definition": "interface FACTQuery {\n  query: string;\n  tools?: string[];\n  useCache?: boolean;\n  metadata?: Record<string, any>;\n}"
        },
        {
          "name": "FACTResult",
          "definition": "interface FACTResult {\n  response: string;\n  queryId: string;\n  executionTimeMs: number;\n  cacheHit: boolean;\n  toolsUsed: string[];\n  cost?: number;\n  metadata?: Record<string, any>;\n}"
        },
        {
          "name": "FACTMetrics",
          "definition": "interface FACTMetrics {\n  totalQueries: number;\n  cacheHitRate: number;\n  averageLatency: number;\n  costSavings: number;\n  toolExecutions: number;\n  errorRate: number;\n}"
        }
      ],
      "exports": [
        {
          "name": "FACTIntegration",
          "type": "export"
        },
        {
          "name": "getFACT",
          "type": "export"
        },
        {
          "name": "FACTHelpers",
          "type": "export"
        }
      ],
      "lineCount": 499
    },
    {
      "file": "src/knowledge/intelligence-coordination-system.ts",
      "interfaces": [
        {
          "name": "ExpertiseDiscoveryEngine",
          "definition": "interface ExpertiseDiscoveryEngine {\n  expertiseProfiles: Map<string, ExpertiseProfile>;\n  discoveryMechanisms: DiscoveryMechanism[];\n  expertiseEvolution: ExpertiseEvolutionTracker;\n  competencyMapping: CompetencyMappingSystem;\n  reputationSystem: ReputationSystem;\n}"
        },
        {
          "name": "ExpertiseProfile",
          "definition": "interface ExpertiseProfile {\n  agentId: string;\n  domains: DomainExpertise[];\n  skills: SkillProfile[];\n  experience: ExperienceProfile;\n  reputation: ReputationScore;\n  availability: AvailabilityProfile;\n  preferences: CollaborationPreferences;\n  learningHistory: LearningRecord[];\n  performanceMetrics: ExpertisePerformanceMetrics;\n}"
        },
        {
          "name": "DomainExpertise",
          "definition": "interface DomainExpertise {\n  domain: string;\n  expertiseLevel: ExpertiseLevel;\n  confidence: number;\n  evidenceCount: number;\n  lastUpdated: number;\n  subdomains: SubdomainExpertise[];\n  relatedDomains: RelatedDomainMapping[];\n  specializations: Specialization[];\n}"
        },
        {
          "name": "SkillProfile",
          "definition": "interface SkillProfile {\n  skillId: string;\n  skillName: string;\n  proficiency: ProficiencyLevel;\n  certifications: Certification[];\n  demonstratedUsage: UsageRecord[];\n  learningPath: LearningPath;\n  transferability: TransferabilityScore;\n}"
        },
        {
          "name": "ExperienceProfile",
          "definition": "interface ExperienceProfile {\n  totalExperience: number;\n  domainExperience: Map<string, number>;\n  problemsSolved: ProblemSolvingRecord[];\n  collaborationHistory: CollaborationRecord[];\n  learningRate: LearningRateMetrics;\n  adaptabilityScore: number;\n}"
        },
        {
          "name": "DiscoveryMechanism",
          "definition": "interface DiscoveryMechanism {\n  mechanismName: string;\n  discoveryType: DiscoveryType;\n  applicability: DiscoveryApplicability;\n  algorithm: DiscoveryAlgorithm;\n  accuracy: AccuracyMetrics;\n  performance: DiscoveryPerformanceMetrics;\n}"
        },
        {
          "name": "ExpertiseEvolutionTracker",
          "definition": "interface ExpertiseEvolutionTracker {\n  evolutionHistory: Map<string, ExpertiseEvolution[]>;\n  growthPatterns: GrowthPattern[];\n  specializationTrends: SpecializationTrend[];\n  transferPatterns: TransferPattern[];\n  emergenceDetector: EmergenceDetector;\n}"
        },
        {
          "name": "KnowledgeRoutingSystem",
          "definition": "interface KnowledgeRoutingSystem {\n  routingTable: Map<string, RoutingEntry[]>;\n  routingStrategies: RoutingStrategy[];\n  loadBalancing: LoadBalancingConfig;\n  qualityOfService: QoSConfig;\n  adaptiveRouting: AdaptiveRoutingConfig;\n}"
        },
        {
          "name": "RoutingEntry",
          "definition": "interface RoutingEntry {\n  destination: string;\n  domains: string[];\n  expertise: ExpertiseRequirement;\n  capacity: CapacityInfo;\n  latency: LatencyMetrics;\n  reliability: ReliabilityMetrics;\n  cost: CostMetrics;\n}"
        },
        {
          "name": "RoutingStrategy",
          "definition": "interface RoutingStrategy {\n  strategyName: string;\n  applicability: RoutingApplicability;\n  algorithm: RoutingAlgorithm;\n  optimization: OptimizationObjective[];\n  constraints: RoutingConstraint[];\n  performance: RoutingPerformanceMetrics;\n}"
        },
        {
          "name": "LoadBalancingConfig",
          "definition": "interface LoadBalancingConfig {\n  balancingAlgorithm: LoadBalancingAlgorithm;\n  weights: LoadBalancingWeights;\n  thresholds: LoadBalancingThresholds;\n  monitoring: LoadMonitoringConfig;\n  adaptation: LoadAdaptationConfig;\n}"
        },
        {
          "name": "QoSConfig",
          "definition": "interface QoSConfig {\n  qualityMetrics: QualityMetric[];\n  serviceClasses: ServiceClass[];\n  prioritization: PrioritizationRules;\n  guarantees: QoSGuarantee[];\n  monitoring: QoSMonitoring;\n}"
        },
        {
          "name": "AdaptiveRoutingConfig",
          "definition": "interface AdaptiveRoutingConfig {\n  adaptationTriggers: AdaptationTrigger[];\n  learningAlgorithm: RoutingLearningAlgorithm;\n  explorationRate: number;\n  convergenceThreshold: number;\n  feedbackMechanism: FeedbackMechanism;\n}"
        },
        {
          "name": "SpecializationEmergenceDetector",
          "definition": "interface SpecializationEmergenceDetector {\n  emergencePatterns: EmergencePattern[];\n  detectionAlgorithms: EmergenceDetectionAlgorithm[];\n  specialization: SpecializationTracker;\n  adaptationMechanisms: AdaptationMechanism[];\n  feedbackLoops: FeedbackLoop[];\n}"
        },
        {
          "name": "EmergencePattern",
          "definition": "interface EmergencePattern {\n  patternId: string;\n  patternType: EmergencePatternType;\n  conditions: EmergenceCondition[];\n  indicators: EmergenceIndicator[];\n  lifecycle: EmergenceLifecycle;\n  impact: EmergenceImpact;\n}"
        },
        {
          "name": "EmergenceDetectionAlgorithm",
          "definition": "interface EmergenceDetectionAlgorithm {\n  algorithmName: string;\n  detectionType: EmergenceDetectionType;\n  sensitivity: number;\n  accuracy: DetectionAccuracy;\n  performance: DetectionPerformance;\n  parameters: AlgorithmParameters;\n}"
        },
        {
          "name": "SpecializationTracker",
          "definition": "interface SpecializationTracker {\n  specializations: Map<string, SpecializationRecord>;\n  emergenceHistory: EmergenceEvent[];\n  trends: SpecializationTrend[];\n  predictions: SpecializationPrediction[];\n  interventions: SpecializationIntervention[];\n}"
        },
        {
          "name": "AdaptationMechanism",
          "definition": "interface AdaptationMechanism {\n  mechanismName: string;\n  adaptationType: AdaptationType;\n  triggers: AdaptationTrigger[];\n  actions: AdaptationAction[];\n  effectiveness: AdaptationEffectiveness;\n}"
        },
        {
          "name": "CrossDomainTransferSystem",
          "definition": "interface CrossDomainTransferSystem {\n  transferMap: CrossDomainTransferMap;\n  analogyEngine: AnalogyEngine;\n  abstractionEngine: AbstractionEngine;\n  transferValidation: TransferValidationSystem;\n  transferOptimization: TransferOptimizationEngine;\n}"
        },
        {
          "name": "CrossDomainTransferMap",
          "definition": "interface CrossDomainTransferMap {\n  domains: Map<string, DomainNode>;\n  transferRelationships: TransferRelationship[];\n  analogyMappings: AnalogyMapping[];\n  abstractionHierarchies: AbstractionHierarchy[];\n  transferPaths: TransferPath[];\n}"
        },
        {
          "name": "DomainNode",
          "definition": "interface DomainNode {\n  domainId: string;\n  characteristics: DomainCharacteristics;\n  ontologies: DomainOntology[];\n  experts: ExpertReference[];\n  knowledge: DomainKnowledge;\n  transferHistory: DomainTransferHistory;\n}"
        },
        {
          "name": "AnalogyEngine",
          "definition": "interface AnalogyEngine {\n  analogyTypes: AnalogyType[];\n  mappingAlgorithms: AnalogyMappingAlgorithm[];\n  validationMechanisms: AnalogyValidationMechanism[];\n  analogyDatabase: AnalogyDatabase;\n  creativityEngine: CreativityEngine;\n}"
        },
        {
          "name": "AbstractionEngine",
          "definition": "interface AbstractionEngine {\n  abstractionLevels: AbstractionLevel[];\n  generalizationAlgorithms: GeneralizationAlgorithm[];\n  conceptualFrameworks: ConceptualFramework[];\n  patternExtraction: PatternExtractionEngine;\n  knowledgeDistillation: KnowledgeDistillationEngine;\n}"
        },
        {
          "name": "TransferValidationSystem",
          "definition": "interface TransferValidationSystem {\n  validationCriteria: TransferValidationCriteria[];\n  testingFramework: TransferTestingFramework;\n  performanceEvaluation: TransferPerformanceEvaluation;\n  qualityAssurance: TransferQualityAssurance;\n  riskAssessment: TransferRiskAssessment;\n}"
        },
        {
          "name": "CollectiveMemoryManager",
          "definition": "interface CollectiveMemoryManager {\n  sharedMemory: SharedMemorySpace;\n  memoryConsolidation: MemoryConsolidationEngine;\n  retrieval: MemoryRetrievalSystem;\n  forgetting: ForgettingMechanism;\n  episodicMemory: EpisodicMemorySystem;\n  semanticMemory: SemanticMemorySystem;\n}"
        },
        {
          "name": "SharedMemorySpace",
          "definition": "interface SharedMemorySpace {\n  memories: Map<string, CollectiveMemory>;\n  memoryGraph: MemoryGraph;\n  accessPatterns: AccessPattern[];\n  memoryHierarchy: MemoryHierarchy;\n  distributionStrategy: MemoryDistributionStrategy;\n}"
        },
        {
          "name": "CollectiveMemory",
          "definition": "interface CollectiveMemory {\n  memoryId: string;\n  type: MemoryType;\n  content: MemoryContent;\n  metadata: MemoryMetadata;\n  accessibility: AccessibilityConfig;\n  persistence: PersistenceConfig;\n  associations: MemoryAssociation[];\n}"
        },
        {
          "name": "MemoryRetrievalSystem",
          "definition": "interface MemoryRetrievalSystem {\n  retrievalStrategies: RetrievalStrategy[];\n  indexingSystems: IndexingSystem[];\n  searchAlgorithms: SearchAlgorithm[];\n  rankingMechanisms: RankingMechanism[];\n  contextualRetrieval: ContextualRetrievalEngine;\n}"
        },
        {
          "name": "ForgettingMechanism",
          "definition": "interface ForgettingMechanism {\n  forgettingCurves: ForgettingCurve[];\n  retentionPolicies: RetentionPolicy[];\n  importanceWeighting: ImportanceWeighting;\n  selectiveForgetting: SelectiveForgettingEngine;\n  memoryConsolidation: ConsolidationTrigger[];\n}"
        },
        {
          "name": "IntelligenceCoordinationConfig",
          "definition": "interface IntelligenceCoordinationConfig {\n  expertiseDiscovery: ExpertiseDiscoveryConfig;\n  knowledgeRouting: KnowledgeRoutingConfig;\n  specializationDetection: SpecializationDetectionConfig;\n  crossDomainTransfer: CrossDomainTransferConfig;\n  collectiveMemory: CollectiveMemoryConfig;\n}"
        },
        {
          "name": "ExpertiseDiscoveryResult",
          "definition": "interface ExpertiseDiscoveryResult {\n  discoveryId: string;\n  agentsAnalyzed: number;\n  expertiseProfiles: ExpertiseProfile[];\n  expertiseDistribution: ExpertiseDistribution;\n  gapAnalysis: ExpertiseGapAnalysis;\n  expertiseNetwork: ExpertiseNetwork;\n  specializationRecommendations: SpecializationRecommendation[];\n  discoveryTime: number;\n  timestamp: number;\n}"
        },
        {
          "name": "RoutingResult",
          "definition": "interface RoutingResult {\n  routingId: string;\n  originalQuery: KnowledgeQuery;\n  candidateExperts: number;\n  selectedExperts: number;\n  routingStrategy: string;\n  executionResults: RoutingExecution;\n  performanceMetrics: RoutingPerformanceMetrics;\n  routingTime: number;\n  timestamp: number;\n}"
        },
        {
          "name": "SpecializationEmergenceResult",
          "definition": "interface SpecializationEmergenceResult {\n  detectionId: string;\n  observationPeriod: number;\n  agentsObserved: number;\n  detectedPatterns: number;\n  adaptationRecommendations: number;\n  appliedAdaptations: number;\n  emergenceScore: number;\n  detectionTime: number;\n  timestamp: number;\n}"
        },
        {
          "name": "CrossDomainTransferResult",
          "definition": "interface CrossDomainTransferResult {\n  transferId: string;\n  sourceDomain: string;\n  targetDomain: string;\n  transferType: TransferType;\n  transferMechanism: string;\n  domainCompatibility: number;\n  extractedItems: number;\n  adaptedItems: number;\n  validatedItems: number;\n  applicationResults: any;\n  effectivenessScore: number;\n  transferTime: number;\n  timestamp: number;\n}"
        },
        {
          "name": "IntelligenceCoordinationMetrics",
          "definition": "interface IntelligenceCoordinationMetrics {\n  expertiseDiscovery: any;\n  knowledgeRouting: any;\n  specializationEmergence: any;\n  crossDomainTransfer: any;\n  collectiveMemory: any;\n}"
        },
        {
          "name": "KnowledgeQuery",
          "definition": "interface KnowledgeQuery {\n  id: string;\n  domain: string;\n  urgency: 'low' | 'medium' | 'high' | 'critical';\n  content: string;\n  requirements: QueryRequirements;\n}"
        },
        {
          "name": "RoutingOptions",
          "definition": "interface RoutingOptions {\n  strategy?: string;\n  constraints?: RoutingConstraint[];\n  preferences?: RoutingPreference[];\n}"
        },
        {
          "name": "ExpertiseDiscoverySystem",
          "definition": "interface ExpertiseDiscoverySystem {\n  incorporateSpecialization(specialization: any): Promise<void>;\n  shutdown(): Promise<void>;\n  on(event: string, handler: Function): void;\n}"
        }
      ],
      "exports": [
        {
          "name": "ExpertiseDiscoveryEngine",
          "type": "export"
        },
        {
          "name": "ExpertiseProfile",
          "type": "export"
        },
        {
          "name": "DomainExpertise",
          "type": "export"
        },
        {
          "name": "SkillProfile",
          "type": "export"
        },
        {
          "name": "ExperienceProfile",
          "type": "export"
        },
        {
          "name": "DiscoveryMechanism",
          "type": "export"
        },
        {
          "name": "ExpertiseEvolutionTracker",
          "type": "export"
        },
        {
          "name": "KnowledgeRoutingSystem",
          "type": "export"
        },
        {
          "name": "RoutingEntry",
          "type": "export"
        },
        {
          "name": "RoutingStrategy",
          "type": "export"
        },
        {
          "name": "LoadBalancingConfig",
          "type": "export"
        },
        {
          "name": "QoSConfig",
          "type": "export"
        },
        {
          "name": "AdaptiveRoutingConfig",
          "type": "export"
        },
        {
          "name": "SpecializationEmergenceDetector",
          "type": "export"
        },
        {
          "name": "EmergencePattern",
          "type": "export"
        },
        {
          "name": "EmergenceDetectionAlgorithm",
          "type": "export"
        },
        {
          "name": "SpecializationTracker",
          "type": "export"
        },
        {
          "name": "AdaptationMechanism",
          "type": "export"
        },
        {
          "name": "CrossDomainTransferSystem",
          "type": "export"
        },
        {
          "name": "CrossDomainTransferMap",
          "type": "export"
        },
        {
          "name": "DomainNode",
          "type": "export"
        },
        {
          "name": "AnalogyEngine",
          "type": "export"
        },
        {
          "name": "AbstractionEngine",
          "type": "export"
        },
        {
          "name": "TransferValidationSystem",
          "type": "export"
        },
        {
          "name": "CollectiveMemoryManager",
          "type": "export"
        },
        {
          "name": "SharedMemorySpace",
          "type": "export"
        },
        {
          "name": "CollectiveMemory",
          "type": "export"
        },
        {
          "name": "MemoryRetrievalSystem",
          "type": "export"
        },
        {
          "name": "ForgettingMechanism",
          "type": "export"
        },
        {
          "name": "IntelligenceCoordinationSystem",
          "type": "export"
        },
        {
          "name": "IntelligenceCoordinationConfig",
          "type": "export"
        },
        {
          "name": "ExpertiseDiscoveryResult",
          "type": "export"
        },
        {
          "name": "RoutingResult",
          "type": "export"
        },
        {
          "name": "SpecializationEmergenceResult",
          "type": "export"
        },
        {
          "name": "CrossDomainTransferResult",
          "type": "export"
        },
        {
          "name": "IntelligenceCoordinationMetrics",
          "type": "export"
        },
        {
          "name": "KnowledgeQuery",
          "type": "export"
        },
        {
          "name": "RoutingOptions",
          "type": "export"
        }
      ],
      "lineCount": 936
    },
    {
      "file": "src/knowledge/index.ts",
      "interfaces": [],
      "exports": [
        {
          "name": "validateKnowledgeConfig",
          "type": "export"
        },
        {
          "name": "getSystemCapabilities",
          "type": "export"
        },
        {
          "name": "createTestConfig",
          "type": "export"
        },
        {
          "name": "getKnowledgeStoragePaths",
          "type": "export"
        }
      ],
      "lineCount": 316
    }
  ],
  "javascript": [
    {
      "file": "src/__tests__/test-mcp-tools.js",
      "jsdoc": [
        {
          "content": "/**\n * Test script for MCP tools\n */"
        }
      ],
      "exports": [],
      "lineCount": 38
    },
    {
      "file": "src/__tests__/test-integration-direct.js",
      "jsdoc": [
        {
          "content": "/**\n * Direct Integration Test Suite\n *\n * Tests the system after submodule removal and MCP simplification.\n * Validates that all components work with direct integration.\n */"
        }
      ],
      "exports": [
        {
          "index": 0,
          "type": "export"
        }
      ],
      "lineCount": 432
    },
    {
      "file": "src/neural/wasm/wasm-memory-optimizer.js",
      "jsdoc": [
        {
          "content": "/**\n * WASM Memory Optimizer\n *\n * Advanced memory management and allocation optimization for WASM modules\n * with progressive loading, memory pooling, and garbage collection strategies.\n */"
        },
        {
          "content": "/**\n   * Get or create memory pool for specific module\n   */"
        },
        {
          "content": "/**\n   * Allocate memory with alignment and tracking\n   */"
        },
        {
          "content": "/**\n   * Find suitable free block\n   */"
        },
        {
          "content": "/**\n   * Deallocate memory and add to free blocks\n   */"
        },
        {
          "content": "/**\n   * Merge adjacent free blocks to reduce fragmentation\n   */"
        },
        {
          "content": "/**\n   * Garbage collect unused allocations\n   */"
        },
        {
          "content": "/**\n   * Garbage collect all pools\n   */"
        },
        {
          "content": "/**\n   * Get memory utilization ratio\n   */"
        },
        {
          "content": "/**\n   * Get detailed memory statistics\n   */"
        },
        {
          "content": "/**\n   * Optimize memory layout by compacting allocations\n   */"
        },
        {
          "content": "/**\n * Progressive WASM Module Loader with Memory Optimization\n */"
        },
        {
          "content": "/**\n   * Register module for progressive loading\n   */"
        },
        {
          "content": "/**\n   * Queue module for loading with priority\n   */"
        },
        {
          "content": "/**\n   * Process loading queue by priority\n   */"
        },
        {
          "content": "/**\n   * Load individual module with memory optimization\n   */"
        },
        {
          "content": "/**\n   * Create optimized imports for module\n   */"
        },
        {
          "content": "/**\n   * Optimize module memory after loading\n   */"
        },
        {
          "content": "/**\n   * Progressive loading strategy\n   */"
        },
        {
          "content": "/**\n   * Eager loading strategy\n   */"
        },
        {
          "content": "/**\n   * Lazy loading strategy\n   */"
        },
        {
          "content": "/**\n   * Get module by ID\n   */"
        },
        {
          "content": "/**\n   * Unload module and free memory\n   */"
        },
        {
          "content": "/**\n   * Get comprehensive loader statistics\n   */"
        },
        {
          "content": "/**\n   * Optimize all memory pools\n   */"
        },
        {
          "content": "/**\n * WASM Browser Compatibility Manager\n */"
        },
        {
          "content": "/**\n   * Detect browser WASM capabilities\n   */"
        },
        {
          "content": "/**\n   * Get capabilities (detect if not already done)\n   */"
        },
        {
          "content": "/**\n   * Register fallback for feature\n   */"
        },
        {
          "content": "/**\n   * Check if feature is supported with fallback\n   */"
        },
        {
          "content": "/**\n   * Load module with compatibility checks\n   */"
        }
      ],
      "exports": [
        {
          "index": 0,
          "type": "export"
        },
        {
          "index": 1,
          "type": "export"
        }
      ],
      "lineCount": 808
    },
    {
      "file": "src/neural/wasm/wasm-loader2.js",
      "jsdoc": [
        {
          "content": "/**\n * Progressive WASM Module Loader\n * Implements on-demand, eager, and progressive loading strategies\n * for optimal performance and memory usage\n */"
        }
      ],
      "exports": [
        {
          "index": 0,
          "type": "exports."
        },
        {
          "index": 1,
          "type": "module.exports"
        },
        {
          "index": 2,
          "type": "export"
        }
      ],
      "lineCount": 417
    },
    {
      "file": "src/neural/wasm/wasm-loader.js",
      "jsdoc": [],
      "exports": [
        {
          "index": 0,
          "type": "exports."
        },
        {
          "index": 1,
          "type": "export"
        },
        {
          "index": 2,
          "type": "export"
        },
        {
          "index": 3,
          "type": "export"
        },
        {
          "index": 4,
          "type": "export"
        },
        {
          "index": 5,
          "type": "module.exports"
        },
        {
          "index": 6,
          "type": "module.exports"
        }
      ],
      "lineCount": 634
    },
    {
      "file": "src/neural/core/neural.js",
      "jsdoc": [
        {
          "content": "/**\n * Neural Network CLI for ruv-swarm\n * Provides neural training, status, and pattern analysis using WASM\n */"
        }
      ],
      "exports": [
        {
          "index": 0,
          "type": "export"
        }
      ],
      "lineCount": 620
    },
    {
      "file": "src/neural/core/neural-network-manager.js",
      "jsdoc": [
        {
          "content": "/**\n * Neural Network Manager\n * Manages per-agent neural networks with WASM integration\n */"
        },
        {
          "content": "/**\n   * Create a neural network from a production preset\n   * @param {string} agentId - Agent identifier\n   * @param {string} category - Preset category (nlp, vision, timeseries, graph)\n   * @param {string} presetName - Name of the preset\n   * @param {object} customConfig - Optional custom configuration overrides\n   */"
        },
        {
          "content": "/**\n   * Create a neural network from complete preset (27+ models)\n   * @param {string} agentId - Agent identifier\n   * @param {string} modelType - Model type (transformer, cnn, lstm, etc.)\n   * @param {string} presetName - Name of the preset\n   * @param {object} customConfig - Optional custom configuration overrides\n   */"
        },
        {
          "content": "/**\n   * Create a neural network from a recommended preset based on use case\n   * @param {string} agentId - Agent identifier\n   * @param {string} useCase - Use case description\n   * @param {object} customConfig - Optional custom configuration overrides\n   */"
        },
        {
          "content": "/**\n   * Get all available presets for a category\n   * @param {string} category - Preset category\n   */"
        },
        {
          "content": "/**\n   * Search presets by use case or description\n   * @param {string} searchTerm - Search term\n   */"
        },
        {
          "content": "/**\n   * Get performance information for a preset\n   * @param {string} category - Preset category\n   * @param {string} presetName - Preset name\n   */"
        },
        {
          "content": "/**\n   * List all available preset categories and their counts\n   */"
        },
        {
          "content": "/**\n   * Get detailed information about agent's preset (if created from preset)\n   * @param {string} agentId - Agent identifier\n   */"
        },
        {
          "content": "/**\n   * Update existing agent with preset configuration\n   * @param {string} agentId - Agent identifier\n   * @param {string} category - Preset category\n   * @param {string} presetName - Preset name\n   * @param {object} customConfig - Optional custom configuration overrides\n   */"
        },
        {
          "content": "/**\n   * Batch create agents from presets\n   * @param {Array} agentConfigs - Array of {agentId, category, presetName, customConfig}\n   */"
        },
        {
          "content": "/**\n   * Enable knowledge sharing between agents\n   * @param {Array} agentIds - List of agent IDs\n   * @param {Object} session - Collaborative session object\n   */"
        },
        {
          "content": "/**\n   * Extract knowledge from a neural network agent\n   * @param {string} agentId - Agent identifier\n   */"
        },
        {
          "content": "/**\n   * Extract important weights from a neural network\n   * @param {Object} network - Neural network instance\n   */"
        },
        {
          "content": "/**\n   * Calculate importance threshold for weight selection\n   * @param {Array} importance - Array of importance scores\n   */"
        },
        {
          "content": "/**\n   * Identify agent specializations based on performance patterns\n   * @param {string} agentId - Agent identifier\n   */"
        },
        {
          "content": "/**\n   * Infer domain from training patterns\n   * @param {Object} adaptation - Adaptation record\n   */"
        },
        {
          "content": "/**\n   * Create knowledge sharing matrix between agents\n   * @param {Array} agentIds - List of agent IDs\n   */"
        },
        {
          "content": "/**\n   * Calculate similarity between two agents\n   * @param {string} agentA - First agent ID\n   * @param {string} agentB - Second agent ID\n   */"
        },
        {
          "content": "/**\n   * Calculate structural similarity between agents\n   * @param {Object} knowledgeA - Knowledge from agent A\n   * @param {Object} knowledgeB - Knowledge from agent B\n   */"
        },
        {
          "content": "/**\n   * Calculate performance similarity between agents\n   * @param {Object} knowledgeA - Knowledge from agent A\n   * @param {Object} knowledgeB - Knowledge from agent B\n   */"
        },
        {
          "content": "/**\n   * Calculate specialization similarity between agents\n   * @param {Object} knowledgeA - Knowledge from agent A\n   * @param {Object} knowledgeB - Knowledge from agent B\n   */"
        },
        {
          "content": "/**\n   * Start knowledge distillation learning\n   * @param {Object} session - Collaborative session\n   */"
        },
        {
          "content": "/**\n   * Identify teacher agents based on performance\n   * @param {Array} agentIds - List of agent IDs\n   */"
        },
        {
          "content": "/**\n   * Perform knowledge distillation between teacher and student\n   * @param {string} teacherAgentId - Teacher agent ID\n   * @param {string} studentAgentId - Student agent ID\n   * @param {Object} session - Collaborative session\n   */"
        },
        {
          "content": "/**\n   * Apply knowledge distillation to student network\n   * @param {Object} student - Student network\n   * @param {Object} teacherKnowledge - Teacher's knowledge\n   * @param {Object} options - Distillation options\n   */"
        },
        {
          "content": "/**\n   * Start neural coordination protocol\n   * @param {Object} session - Collaborative session\n   */"
        },
        {
          "content": "/**\n   * Update coordination matrix based on agent interactions\n   * @param {Object} session - Collaborative session\n   */"
        },
        {
          "content": "/**\n   * Calculate interaction strength between two agents\n   * @param {string} agentA - First agent ID\n   * @param {string} agentB - Second agent ID\n   */"
        },
        {
          "content": "/**\n   * Apply coordination results to agents\n   * @param {Object} session - Collaborative session\n   */"
        },
        {
          "content": "/**\n   * Apply weight adjustments to a neural network\n   * @param {Object} agent - Neural network agent\n   * @param {Object} adjustments - Weight adjustments\n   */"
        },
        {
          "content": "/**\n   * Record agent interaction for coordination tracking\n   * @param {string} agentA - First agent ID\n   * @param {string} agentB - Second agent ID\n   * @param {number} strength - Interaction strength (0-1)\n   * @param {string} type - Interaction type\n   */"
        },
        {
          "content": "/**\n   * Get all complete neural presets (27+ models)\n   */"
        },
        {
          "content": "/**\n   * Get preset recommendations based on requirements\n   * @param {string} useCase - Use case description\n   * @param {Object} requirements - Performance and other requirements\n   */"
        },
        {
          "content": "/**\n   * Get adaptation recommendations for an agent\n   * @param {string} agentId - Agent identifier\n   */"
        },
        {
          "content": "/**\n   * Export adaptation insights across all agents\n   */"
        },
        {
          "content": "/**\n   * List all available neural model types with counts\n   */"
        },
        {
          "content": "/**\n   * Get comprehensive neural network statistics\n   */"
        }
      ],
      "exports": [
        {
          "index": 0,
          "type": "exports."
        },
        {
          "index": 1,
          "type": "exports."
        },
        {
          "index": 2,
          "type": "exports."
        },
        {
          "index": 3,
          "type": "exports."
        },
        {
          "index": 4,
          "type": "exports."
        },
        {
          "index": 5,
          "type": "exports."
        },
        {
          "index": 6,
          "type": "exports."
        },
        {
          "index": 7,
          "type": "export"
        }
      ],
      "lineCount": 1952
    },
    {
      "file": "src/neural/coordination/neural-coordination-protocol.js",
      "jsdoc": [
        {
          "content": "/**\n * Neural Coordination Protocol\n * Enables sophisticated coordination between neural network agents\n */"
        },
        {
          "content": "/**\n   * Initialize coordination strategies\n   */"
        },
        {
          "content": "/**\n   * Initialize consensus protocols\n   */"
        },
        {
          "content": "/**\n   * Register agent with coordination protocol\n   * @param {string} agentId - Agent identifier\n   * @param {Object} agent - Agent instance\n   */"
        },
        {
          "content": "/**\n   * Analyze agent capabilities for coordination\n   * @param {Object} agent - Agent instance\n   */"
        },
        {
          "content": "/**\n   * Initialize coordination session\n   * @param {Object} session - Session configuration\n   */"
        },
        {
          "content": "/**\n   * Select optimal coordination strategy for session\n   * @param {Object} session - Session configuration\n   */"
        },
        {
          "content": "/**\n   * Calculate scalability score for agent count\n   * @param {number} agentCount - Number of agents\n   * @param {number} strategyScalability - Strategy scalability factor\n   */"
        },
        {
          "content": "/**\n   * Calculate session trust level\n   * @param {Object} session - Session configuration\n   */"
        },
        {
          "content": "/**\n   * Estimate task complexity for session\n   * @param {Object} session - Session configuration\n   */"
        },
        {
          "content": "/**\n   * Check if session has heterogeneous agents\n   * @param {Object} session - Session configuration\n   */"
        },
        {
          "content": "/**\n   * Select consensus protocol for strategy\n   * @param {Object} session - Session configuration\n   * @param {Object} strategy - Coordination strategy\n   */"
        },
        {
          "content": "/**\n   * Build communication graph for session\n   * @param {Array} agentIds - Agent identifiers\n   * @param {Object} strategy - Coordination strategy\n   */"
        },
        {
          "content": "/**\n   * Build star topology (one central node connected to all others)\n   * @param {Map} graph - Communication graph\n   * @param {Array} agentIds - Agent identifiers\n   */"
        },
        {
          "content": "/**\n   * Build mesh topology (all nodes connected to all others)\n   * @param {Map} graph - Communication graph\n   * @param {Array} agentIds - Agent identifiers\n   */"
        },
        {
          "content": "/**\n   * Build ring topology (each node connected to neighbors in a ring)\n   * @param {Map} graph - Communication graph\n   * @param {Array} agentIds - Agent identifiers\n   */"
        },
        {
          "content": "/**\n   * Build neighborhood topology (each node connected to nearby nodes)\n   * @param {Map} graph - Communication graph\n   * @param {Array} agentIds - Agent identifiers\n   * @param {number} radius - Neighborhood radius\n   */"
        },
        {
          "content": "/**\n   * Initialize communication channels for session\n   * @param {Object} session - Coordination session\n   */"
        },
        {
          "content": "/**\n   * Calculate communication latency between agents\n   * @param {string} agentA - First agent ID\n   * @param {string} agentB - Second agent ID\n   */"
        },
        {
          "content": "/**\n   * Calculate communication bandwidth between agents\n   * @param {string} agentA - First agent ID\n   * @param {string} agentB - Second agent ID\n   */"
        },
        {
          "content": "/**\n   * Calculate communication reliability between agents\n   * @param {string} agentA - First agent ID\n   * @param {string} agentB - Second agent ID\n   */"
        },
        {
          "content": "/**\n   * Coordinate agents in session\n   * @param {Object} session - Coordination session\n   */"
        },
        {
          "content": "/**\n   * Execute coordination strategy\n   * @param {Object} session - Coordination session\n   */"
        },
        {
          "content": "/**\n   * Execute hierarchical coordination\n   * @param {Object} session - Coordination session\n   */"
        },
        {
          "content": "/**\n   * Execute peer-to-peer coordination\n   * @param {Object} session - Coordination session\n   */"
        },
        {
          "content": "/**\n   * Execute swarm coordination\n   * @param {Object} session - Coordination session\n   */"
        },
        {
          "content": "/**\n   * Execute market-based coordination\n   * @param {Object} session - Coordination session\n   */"
        },
        {
          "content": "/**\n   * Execute contract net coordination\n   * @param {Object} session - Coordination session\n   */"
        },
        {
          "content": "/**\n   * Execute blackboard coordination\n   * @param {Object} session - Coordination session\n   */"
        },
        {
          "content": "/**\n   * Execute multi-agent reinforcement learning coordination\n   * @param {Object} session - Coordination session\n   */"
        },
        {
          "content": "/**\n   * Execute Byzantine fault tolerant coordination\n   * @param {Object} session - Coordination session\n   */"
        },
        {
          "content": "/**\n   * Execute consensus protocol\n   * @param {Object} session - Coordination session\n   * @param {Object} coordinationResult - Result from coordination strategy\n   */"
        },
        {
          "content": "/**\n   * Get coordination results for session\n   * @param {string} sessionId - Session identifier\n   */"
        },
        {
          "content": "/**\n   * Update coordination metrics after coordination\n   * @param {Object} session - Coordination session\n   * @param {Object} result - Coordination result\n   */"
        },
        {
          "content": "/**\n   * Get coordination statistics\n   */"
        }
      ],
      "exports": [
        {
          "index": 0,
          "type": "export"
        }
      ],
      "lineCount": 1375
    },
    {
      "file": "src/neural/agents/neural-agent.js",
      "jsdoc": [
        {
          "content": "/**\n * Neural Agent Module - Integrates ruv-FANN neural network capabilities\n * into agent processing for cognitive diversity and learning\n */"
        },
        {
          "content": "/**\n * Neural Network wrapper for agent cognitive processing\n */"
        },
        {
          "content": "/**\n * Neural Agent class that enhances base agents with neural network capabilities\n */"
        },
        {
          "content": "/**\n   * Process task through neural network for intelligent routing\n   */"
        },
        {
          "content": "/**\n   * Execute task with neural enhancement\n   */"
        },
        {
          "content": "/**\n   * Convert task to neural network input vector\n   */"
        },
        {
          "content": "/**\n   * Apply cognitive pattern to analysis\n   */"
        },
        {
          "content": "/**\n   * Update cognitive state based on task execution\n   */"
        },
        {
          "content": "/**\n   * Calculate performance metrics\n   */"
        },
        {
          "content": "/**\n   * Learn from task execution\n   */"
        },
        {
          "content": "/**\n   * Update overall performance metrics\n   */"
        },
        {
          "content": "/**\n   * Find similar tasks from history\n   */"
        },
        {
          "content": "/**\n   * Apply secondary cognitive pattern\n   */"
        },
        {
          "content": "/**\n   * Rest the agent to reduce fatigue\n   */"
        },
        {
          "content": "/**\n   * Initialize memory tracking for the agent\n   */"
        },
        {
          "content": "/**\n   * Get current memory usage for this agent\n   */"
        },
        {
          "content": "/**\n   * Get agent status including neural state\n   */"
        },
        {
          "content": "/**\n   * Save neural state for persistence\n   */"
        },
        {
          "content": "/**\n   * Load neural state from saved data\n   */"
        },
        {
          "content": "/**\n * Neural Agent Factory\n */"
        }
      ],
      "exports": [
        {
          "index": 0,
          "type": "export"
        }
      ],
      "lineCount": 842
    },
    {
      "file": "src/database/persistence/unified-lance-persistence.js",
      "jsdoc": [
        {
          "content": "/**\n * 🚀 UNIFIED LANCE-SWARM PERSISTENCE LAYER\n *\n * Revolutionary hybrid architecture combining:\n * - LanceDB vector storage for semantic similarity\n * - SQLite relational data for structured queries\n * - Graph relationships for hive-mind coordination\n * - Neural pattern storage for continuous learning\n *\n * This replaces both the Claude Zen memory plugin AND ruv-swarm persistence\n * with a single, ultra-high-performance unified backend.\n */"
        },
        {
          "content": "/**\n   * Store entity with both vector embedding and relational data\n   */"
        },
        {
          "content": "/**\n   * ULTRA HYBRID QUERY - Combines vector similarity + relational + graph\n   */"
        }
      ],
      "exports": [
        {
          "index": 0,
          "type": "export"
        },
        {
          "index": 1,
          "type": "export"
        }
      ],
      "lineCount": 692
    },
    {
      "file": "src/database/persistence/persistence.js",
      "jsdoc": [
        {
          "content": "/**\n * SQLite Persistence Layer for ruv-swarm MCP\n */"
        },
        {
          "content": "/** @type {import('better-sqlite3').Database} */"
        }
      ],
      "exports": [
        {
          "index": 0,
          "type": "export"
        }
      ],
      "lineCount": 487
    },
    {
      "file": "src/database/persistence/persistence-pooled.js",
      "jsdoc": [
        {
          "content": "/**\n * High-Availability SQLite Persistence Layer with Connection Pooling\n *\n * This is the production-ready version of the persistence layer that addresses\n * the connection pooling concerns identified in the production readiness assessment.\n *\n * Key improvements:\n * - Connection pooling for high concurrency\n * - Deadlock prevention through queuing\n * - Connection health monitoring\n * - Graceful degradation under load\n * - Proper resource lifecycle management\n */"
        }
      ],
      "exports": [
        {
          "index": 0,
          "type": "export"
        }
      ],
      "lineCount": 760
    },
    {
      "file": "src/coordination/diagnostics/health-monitor.js",
      "jsdoc": [
        {
          "content": "/**\n * HealthMonitor - Proactive health monitoring system for session persistence\n * Part of comprehensive solution for Issue #137: Swarm session persistence and recovery\n *\n * Features:\n * - Real-time health checking with configurable intervals\n * - Built-in system checks (memory, CPU, event loop, persistence)\n * - Custom health check registration\n * - Threshold-based alerting and escalation\n * - Performance metrics collection\n * - Integration with recovery workflows\n *\n * Version: 1.0.0 - Production Grade\n * Author: Claude Code Assistant (Swarm Implementation)\n * License: MIT\n */"
        },
        {
          "content": "/**\n * HealthMonitor provides comprehensive system health monitoring\n * with configurable checks and automatic alerting\n */"
        },
        {
          "content": "/**\n   * Start health monitoring\n   */"
        },
        {
          "content": "/**\n   * Stop health monitoring\n   */"
        },
        {
          "content": "/**\n   * Register a custom health check\n   */"
        },
        {
          "content": "/**\n   * Remove a health check\n   */"
        },
        {
          "content": "/**\n   * Run all health checks\n   */"
        },
        {
          "content": "/**\n   * Run a single health check\n   */"
        },
        {
          "content": "/**\n   * Get current system health status\n   */"
        },
        {
          "content": "/**\n   * Get health history\n   */"
        },
        {
          "content": "/**\n   * Get health trends and analysis\n   */"
        },
        {
          "content": "/**\n   * Set persistence checker function\n   */"
        },
        {
          "content": "/**\n   * Cleanup resources\n   */"
        }
      ],
      "exports": [
        {
          "index": 0,
          "type": "export"
        },
        {
          "index": 1,
          "type": "export"
        }
      ],
      "lineCount": 560
    },
    {
      "file": "src/coordination/diagnostics/diagnostics.js",
      "jsdoc": [
        {
          "content": "/**\n * Diagnostic utilities for ruv-swarm\n * Helps debug connection issues and performance problems\n */"
        },
        {
          "content": "/**\n * Connection diagnostics\n */"
        },
        {
          "content": "/**\n   * Record connection event\n   */"
        },
        {
          "content": "/**\n   * Get connection summary\n   */"
        },
        {
          "content": "/**\n   * Analyze connection patterns\n   */"
        },
        {
          "content": "/**\n   * Generate diagnostic report\n   */"
        },
        {
          "content": "/**\n   * Generate recommendations based on patterns\n   */"
        },
        {
          "content": "/**\n * Performance diagnostics\n */"
        },
        {
          "content": "/**\n   * Start tracking an operation\n   */"
        },
        {
          "content": "/**\n   * End tracking an operation\n   */"
        },
        {
          "content": "/**\n   * Get slow operations\n   */"
        },
        {
          "content": "/**\n * System diagnostics\n */"
        },
        {
          "content": "/**\n   * Collect system sample\n   */"
        },
        {
          "content": "/**\n   * Start monitoring\n   */"
        },
        {
          "content": "/**\n   * Stop monitoring\n   */"
        },
        {
          "content": "/**\n   * Get system health\n   */"
        },
        {
          "content": "/**\n * Main diagnostics manager\n */"
        },
        {
          "content": "/**\n   * Enable all diagnostics\n   */"
        },
        {
          "content": "/**\n   * Disable all diagnostics\n   */"
        },
        {
          "content": "/**\n   * Generate full diagnostic report\n   */"
        },
        {
          "content": "/**\n   * Collect recent logs\n   */"
        },
        {
          "content": "/**\n   * Run diagnostic tests\n   */"
        }
      ],
      "exports": [
        {
          "index": 0,
          "type": "export"
        },
        {
          "index": 1,
          "type": "export"
        },
        {
          "index": 2,
          "type": "export"
        },
        {
          "index": 3,
          "type": "export"
        },
        {
          "index": 4,
          "type": "export"
        },
        {
          "index": 5,
          "type": "export"
        }
      ],
      "lineCount": 537
    },
    {
      "file": "src/coordination/diagnostics/cli-diagnostics.js",
      "jsdoc": [
        {
          "content": "/**\n * Diagnostic CLI for ruv-swarm\n * Usage: npx ruv-swarm diagnose [options]\n */"
        }
      ],
      "exports": [
        {
          "index": 0,
          "type": "export"
        }
      ],
      "lineCount": 372
    },
    {
      "file": "src/__tests__/swarm-zen/wasm-integration.test.js",
      "jsdoc": [
        {
          "content": "/**\n * Comprehensive test suite for WASM integration\n * Tests progressive loading, neural networks, and swarm orchestration\n */"
        }
      ],
      "exports": [
        {
          "index": 0,
          "type": "export"
        }
      ],
      "lineCount": 444
    },
    {
      "file": "src/__tests__/swarm-zen/verify-wasm-no-warnings.js",
      "jsdoc": [
        {
          "content": "/**\n * Verify WASM loads without warnings\n */"
        }
      ],
      "exports": [],
      "lineCount": 66
    },
    {
      "file": "src/__tests__/swarm-zen/validate-wasm-loading.js",
      "jsdoc": [
        {
          "content": "/**\n * WASM Loading Validation Test for ruv-swarm v1.0.6\n * Ensures WASM loads without fallback and validates memory allocation\n */"
        }
      ],
      "exports": [],
      "lineCount": 278
    },
    {
      "file": "src/__tests__/swarm-zen/validate-setup.js",
      "jsdoc": [
        {
          "content": "/**\n * Test Setup Validation Script\n * Ensures all test dependencies and files are properly configured\n */"
        }
      ],
      "exports": [],
      "lineCount": 115
    }
  ],
  "interfaces": [
    {
      "file": "src/index.ts",
      "interfaces": [
        {
          "name": "ClaudeZenConfig",
          "definition": "interface ClaudeZenConfig {\n  // MCP Server settings\n  mcp: {\n    enabled: boolean;\n    port?: number;\n    host?: string;\n  }"
        }
      ]
    },
    {
      "file": "src/workflows/engine.ts",
      "interfaces": [
        {
          "name": "WorkflowStep",
          "definition": "interface WorkflowStep {\n  type: string;\n  name?: string;\n  params?: Record<string, any>;\n  retries?: number;\n  timeout?: number;\n  output?: string;\n  onError?: 'stop' | 'continue' | 'skip';\n}"
        },
        {
          "name": "WorkflowDefinition",
          "definition": "interface WorkflowDefinition {\n  name: string;\n  steps: WorkflowStep[];\n  description?: string;\n  version?: string;\n}"
        },
        {
          "name": "WorkflowContext",
          "definition": "interface WorkflowContext {\n  [key: string]: any;\n}"
        },
        {
          "name": "WorkflowState",
          "definition": "interface WorkflowState {\n  id: string;\n  definition: WorkflowDefinition;\n  status: 'pending' | 'running' | 'paused' | 'completed' | 'failed' | 'cancelled';\n  context: WorkflowContext;\n  currentStep: number;\n  steps: WorkflowStep[];\n  stepResults: Record<string, any>;\n  completedSteps: Array<{\n    index: number;\n    step: WorkflowStep;\n    result: any;\n    duration: number;\n    timestamp: string;\n  }"
        },
        {
          "name": "WorkflowEngineConfig",
          "definition": "interface WorkflowEngineConfig {\n  maxConcurrentWorkflows?: number;\n  persistWorkflows?: boolean;\n  persistencePath?: string;\n  stepTimeout?: number;\n  retryDelay?: number;\n  enableVisualization?: boolean;\n}"
        }
      ]
    },
    {
      "file": "src/types/workflow-types.ts",
      "interfaces": [
        {
          "name": "WorkflowParameterObject",
          "definition": "interface WorkflowParameterObject {\n  readonly [key: string]: WorkflowParameterValue;\n}"
        },
        {
          "name": "DocumentContent",
          "definition": "interface DocumentContent {\n  readonly id: string;\n  readonly type: DocumentType;\n  readonly title: string;\n  readonly content: string;\n  readonly metadata: DocumentMetadata;\n  readonly created: Date;\n  readonly updated: Date;\n  readonly version: string;\n}"
        },
        {
          "name": "DocumentMetadata",
          "definition": "interface DocumentMetadata {\n  readonly author?: string;\n  readonly tags: readonly string[];\n  readonly status: 'draft' | 'review' | 'approved' | 'archived';\n  readonly priority: 'low' | 'medium' | 'high' | 'critical';\n  readonly dependencies: readonly string[];\n  readonly relatedDocuments: readonly string[];\n  readonly checksum?: string;\n}"
        },
        {
          "name": "StepExecutionResult",
          "definition": "interface StepExecutionResult {\n  readonly success: boolean;\n  readonly data?: WorkflowData;\n  readonly error?: WorkflowError;\n  readonly duration: number;\n  readonly timestamp: Date;\n  readonly metadata?: WorkflowResultMetadata;\n}"
        },
        {
          "name": "WorkflowResultMetadata",
          "definition": "interface WorkflowResultMetadata {\n  readonly stepType: string;\n  readonly attemptNumber: number;\n  readonly resourcesUsed?: ResourceUsage;\n  readonly warnings: readonly string[];\n}"
        },
        {
          "name": "ResourceUsage",
          "definition": "interface ResourceUsage {\n  readonly cpuTime: number;\n  readonly memoryPeak: number;\n  readonly diskIo: number;\n  readonly networkRequests: number;\n}"
        },
        {
          "name": "WorkflowError",
          "definition": "interface WorkflowError {\n  readonly code: string;\n  readonly message: string;\n  readonly stack?: string;\n  readonly context?: WorkflowErrorContext;\n  readonly recoverable: boolean;\n}"
        },
        {
          "name": "WorkflowErrorContext",
          "definition": "interface WorkflowErrorContext {\n  readonly stepIndex: number;\n  readonly stepName: string;\n  readonly input: WorkflowData;\n  readonly timestamp: Date;\n  readonly retryCount: number;\n}"
        },
        {
          "name": "WorkflowData",
          "definition": "interface WorkflowData {\n  readonly [key: string]: WorkflowDataValue;\n}"
        },
        {
          "name": "WorkflowDataObject",
          "definition": "interface WorkflowDataObject {\n  readonly [key: string]: WorkflowDataValue;\n}"
        },
        {
          "name": "WorkflowStep",
          "definition": "interface WorkflowStep {\n  readonly type: string;\n  readonly name?: string;\n  readonly description?: string;\n  readonly params?: WorkflowParameterObject;\n  readonly retries?: number;\n  readonly timeout?: number;\n  readonly output?: string;\n  readonly onError?: ErrorHandlingStrategy;\n  readonly dependencies?: readonly string[];\n  readonly conditions?: readonly WorkflowCondition[];\n  readonly validators?: readonly WorkflowValidator[];\n}"
        },
        {
          "name": "WorkflowCondition",
          "definition": "interface WorkflowCondition {\n  readonly field: string;\n  readonly operator: 'equals' | 'notEquals' | 'contains' | 'exists' | 'isEmpty';\n  readonly value?: WorkflowDataValue;\n  readonly description?: string;\n}"
        },
        {
          "name": "WorkflowValidator",
          "definition": "interface WorkflowValidator {\n  readonly type: 'required' | 'format' | 'range' | 'custom';\n  readonly field: string;\n  readonly params?: WorkflowParameterObject;\n  readonly message?: string;\n}"
        },
        {
          "name": "WorkflowDefinition",
          "definition": "interface WorkflowDefinition {\n  readonly name: string;\n  readonly description?: string;\n  readonly version: string;\n  readonly steps: readonly WorkflowStep[];\n  readonly documentTypes?: readonly DocumentType[];\n  readonly triggers?: readonly WorkflowTrigger[];\n  readonly variables?: readonly WorkflowVariable[];\n  readonly timeout?: number;\n  readonly maxRetries?: number;\n  readonly parallel?: boolean;\n}"
        },
        {
          "name": "WorkflowTrigger",
          "definition": "interface WorkflowTrigger {\n  readonly event: WorkflowEvent;\n  readonly condition?: string;\n  readonly priority?: number;\n  readonly debounce?: number;\n}"
        },
        {
          "name": "WorkflowVariable",
          "definition": "interface WorkflowVariable {\n  readonly name: string;\n  readonly type: 'string' | 'number' | 'boolean' | 'array' | 'object';\n  readonly defaultValue?: WorkflowDataValue;\n  readonly required?: boolean;\n  readonly description?: string;\n}"
        },
        {
          "name": "WorkflowContext",
          "definition": "interface WorkflowContext {\n  readonly workspaceId: string;\n  readonly workspacePath?: string;\n  readonly userId?: string;\n  readonly sessionId: string;\n  readonly documents: WorkflowDocumentRegistry;\n  readonly currentDocument?: DocumentContent;\n  readonly variables: WorkflowData;\n  readonly environment: WorkflowEnvironment;\n  readonly permissions: WorkflowPermissions;\n}"
        },
        {
          "name": "WorkflowDocumentRegistry",
          "definition": "interface WorkflowDocumentRegistry {\n  readonly [documentId: string]: DocumentContent;\n}"
        },
        {
          "name": "WorkflowEnvironment",
          "definition": "interface WorkflowEnvironment {\n  readonly type: 'development' | 'staging' | 'production';\n  readonly nodeVersion: string;\n  readonly workflowVersion: string;\n  readonly features: readonly string[];\n  readonly limits: WorkflowLimits;\n}"
        },
        {
          "name": "WorkflowLimits",
          "definition": "interface WorkflowLimits {\n  readonly maxSteps: number;\n  readonly maxDuration: number;\n  readonly maxMemory: number;\n  readonly maxFileSize: number;\n  readonly maxConcurrency: number;\n}"
        },
        {
          "name": "WorkflowPermissions",
          "definition": "interface WorkflowPermissions {\n  readonly canReadDocuments: boolean;\n  readonly canWriteDocuments: boolean;\n  readonly canDeleteDocuments: boolean;\n  readonly canExecuteSteps: readonly string[];\n  readonly canAccessResources: readonly string[];\n}"
        },
        {
          "name": "WorkflowState",
          "definition": "interface WorkflowState {\n  readonly id: string;\n  readonly definition: WorkflowDefinition;\n  readonly status: WorkflowStatus;\n  readonly context: WorkflowContext;\n  readonly currentStepIndex: number;\n  readonly steps: readonly WorkflowStepState[];\n  readonly stepResults: WorkflowStepResults;\n  readonly completedSteps: readonly CompletedStepInfo[];\n  readonly startTime: Date;\n  readonly endTime?: Date;\n  readonly pausedAt?: Date;\n  readonly error?: WorkflowError;\n  readonly progress: WorkflowProgress;\n  readonly metrics: WorkflowMetrics;\n}"
        },
        {
          "name": "WorkflowStepState",
          "definition": "interface WorkflowStepState {\n  readonly step: WorkflowStep;\n  readonly status: StepStatus;\n  readonly startTime?: Date;\n  readonly endTime?: Date;\n  readonly attempts: number;\n  readonly result?: StepExecutionResult;\n  readonly error?: WorkflowError;\n}"
        },
        {
          "name": "WorkflowStepResults",
          "definition": "interface WorkflowStepResults {\n  readonly [stepName: string]: StepExecutionResult;\n}"
        },
        {
          "name": "CompletedStepInfo",
          "definition": "interface CompletedStepInfo {\n  readonly index: number;\n  readonly step: WorkflowStep;\n  readonly result: StepExecutionResult;\n  readonly duration: number;\n  readonly timestamp: Date;\n  readonly retryCount: number;\n}"
        },
        {
          "name": "WorkflowProgress",
          "definition": "interface WorkflowProgress {\n  readonly percentage: number;\n  readonly completedSteps: number;\n  readonly totalSteps: number;\n  readonly estimatedTimeRemaining?: number;\n  readonly currentStepName?: string;\n}"
        },
        {
          "name": "WorkflowMetrics",
          "definition": "interface WorkflowMetrics {\n  readonly totalDuration: number;\n  readonly avgStepDuration: number;\n  readonly successRate: number;\n  readonly retryRate: number;\n  readonly resourceUsage: ResourceUsage;\n  readonly throughput: number;\n}"
        },
        {
          "name": "WorkflowExecutionOptions",
          "definition": "interface WorkflowExecutionOptions {\n  readonly dryRun?: boolean;\n  readonly skipValidation?: boolean;\n  readonly maxConcurrency?: number;\n  readonly timeout?: number;\n  readonly retryPolicy?: RetryPolicy;\n  readonly notifications?: NotificationConfig;\n  readonly logging?: LoggingConfig;\n}"
        },
        {
          "name": "RetryPolicy",
          "definition": "interface RetryPolicy {\n  readonly maxAttempts: number;\n  readonly initialDelay: number;\n  readonly maxDelay: number;\n  readonly backoffMultiplier: number;\n  readonly retryableErrors: readonly string[];\n}"
        },
        {
          "name": "NotificationConfig",
          "definition": "interface NotificationConfig {\n  readonly onComplete?: boolean;\n  readonly onError?: boolean;\n  readonly onStepComplete?: boolean;\n  readonly channels: readonly NotificationChannel[];\n}"
        },
        {
          "name": "NotificationChannel",
          "definition": "interface NotificationChannel {\n  readonly type: 'email' | 'slack' | 'webhook' | 'console';\n  readonly config: NotificationChannelConfig;\n}"
        },
        {
          "name": "NotificationChannelConfig",
          "definition": "interface NotificationChannelConfig {\n  readonly [key: string]: WorkflowDataValue;\n}"
        },
        {
          "name": "LoggingConfig",
          "definition": "interface LoggingConfig {\n  readonly level: 'debug' | 'info' | 'warn' | 'error';\n  readonly includeStepDetails: boolean;\n  readonly includeContext: boolean;\n  readonly structuredLogging: boolean;\n}"
        },
        {
          "name": "WorkflowEngineConfig",
          "definition": "interface WorkflowEngineConfig {\n  readonly workspaceRoot: string;\n  readonly templatesPath: string;\n  readonly outputPath: string;\n  readonly maxConcurrentWorkflows: number;\n  readonly defaultTimeout: number;\n  readonly enableMetrics: boolean;\n  readonly enablePersistence: boolean;\n  readonly storageBackend: StorageBackend;\n}"
        },
        {
          "name": "StorageBackend",
          "definition": "interface StorageBackend {\n  readonly type: 'memory' | 'file' | 'database';\n  readonly config: StorageBackendConfig;\n}"
        },
        {
          "name": "StorageBackendConfig",
          "definition": "interface StorageBackendConfig {\n  readonly [key: string]: WorkflowDataValue;\n}"
        }
      ]
    },
    {
      "file": "src/types/shared-types.ts",
      "interfaces": [
        {
          "name": "RuvSwarm",
          "definition": "interface RuvSwarm {\n  id: string;\n  name?: string;\n  topology: SwarmTopology;\n  agents: SwarmAgent[];\n  status: SwarmStatus;\n  config: SwarmConfig;\n  created: Date;\n  updated: Date;\n}"
        },
        {
          "name": "SwarmAgent",
          "definition": "interface SwarmAgent {\n  id: string;\n  name: string;\n  type: AgentType;\n  status: AgentStatus;\n  capabilities: string[];\n  metadata?: Record<string, any>;\n}"
        },
        {
          "name": "SwarmConfig",
          "definition": "interface SwarmConfig {\n  maxAgents: number;\n  topology: SwarmTopology;\n  strategy: CoordinationStrategy;\n  enableMemory?: boolean;\n  heartbeatInterval?: number;\n  timeout?: number;\n}"
        },
        {
          "name": "MemoryEntry",
          "definition": "interface MemoryEntry {\n  key: string;\n  value: any;\n  timestamp: Date;\n  ttl?: number;\n  metadata?: Record<string, any>;\n}"
        },
        {
          "name": "StorageProvider",
          "definition": "interface StorageProvider {\n  get(key: string): Promise<any>;\n  set(key: string, value: any, ttl?: number): Promise<void>;\n  delete(key: string): Promise<void>;\n  clear(): Promise<void>;\n  keys(): Promise<string[]>;\n}"
        },
        {
          "name": "SystemEvent",
          "definition": "interface SystemEvent {\n  id: string;\n  type: string;\n  source: string;\n  target?: string;\n  data: any;\n  timestamp: Date;\n  correlationId?: string;\n}"
        },
        {
          "name": "Message",
          "definition": "interface Message {\n  id: string;\n  from: string;\n  to: string;\n  type: string;\n  payload: any;\n  timestamp: Date;\n  priority?: 'low' | 'medium' | 'high' | 'urgent';\n}"
        },
        {
          "name": "ComponentConfig",
          "definition": "interface ComponentConfig {\n  enabled: boolean;\n  [key: string]: any;\n}"
        },
        {
          "name": "SystemHealth",
          "definition": "interface SystemHealth {\n  status: 'healthy' | 'degraded' | 'unhealthy';\n  components: Record<string, ComponentHealth>;\n  uptime: number;\n  version: string;\n  timestamp: Date;\n}"
        },
        {
          "name": "ComponentHealth",
          "definition": "interface ComponentHealth {\n  status: 'healthy' | 'degraded' | 'unhealthy';\n  message?: string;\n  lastCheck: Date;\n  metrics?: Record<string, number>;\n}"
        },
        {
          "name": "Task",
          "definition": "interface Task {\n  id: string;\n  name: string;\n  description?: string;\n  status: TaskStatus;\n  priority: TaskPriority;\n  assignee?: string;\n  dependencies?: string[];\n  metadata?: Record<string, any>;\n  created: Date;\n  updated: Date;\n  completed?: Date;\n}"
        },
        {
          "name": "NeuralModel",
          "definition": "interface NeuralModel {\n  id: string;\n  name: string;\n  type: NeuralModelType;\n  status: ModelStatus;\n  parameters: number;\n  accuracy?: number;\n  lastTrained?: Date;\n  weights?: ArrayBuffer;\n  metadata?: ModelMetadata;\n}"
        },
        {
          "name": "ModelMetadata",
          "definition": "interface ModelMetadata {\n  layers: number;\n  inputSize: number;\n  outputSize: number;\n  learningRate: number;\n  epochs: number;\n  batchSize: number;\n  [key: string]: any;\n}"
        },
        {
          "name": "APIError",
          "definition": "interface APIError {\n  code: string;\n  message: string;\n  details?: any;\n  stack?: string;\n}"
        },
        {
          "name": "CoordinationProvider",
          "definition": "interface CoordinationProvider {\n  createCoordinator(config: SwarmConfig): Promise<any>;\n  getSwarm(id: string): Promise<RuvSwarm | null>;\n  listSwarms(): Promise<RuvSwarm[]>;\n  terminateSwarm(id: string): Promise<void>;\n}"
        },
        {
          "name": "MemoryProvider",
          "definition": "interface MemoryProvider {\n  store(key: string, value: any, ttl?: number): Promise<void>;\n  retrieve(key: string): Promise<any>;\n  delete(key: string): Promise<void>;\n  clear(): Promise<void>;\n}"
        },
        {
          "name": "LoggingProvider",
          "definition": "interface LoggingProvider {\n  debug(message: string, ...args: any[]): void;\n  info(message: string, ...args: any[]): void;\n  warn(message: string, ...args: any[]): void;\n  error(message: string, ...args: any[]): void;\n}"
        }
      ]
    },
    {
      "file": "src/types/event-types.ts",
      "interfaces": [
        {
          "name": "BaseEventPayload",
          "definition": "interface BaseEventPayload {\n  readonly timestamp: Date;\n  readonly source: string;\n  readonly id: string;\n  readonly version: string;\n}"
        },
        {
          "name": "SystemEvents",
          "definition": "interface SystemEvents {\n  'system:started': SystemStartedPayload;\n  'system:stopped': SystemStoppedPayload;\n  'system:error': SystemErrorPayload;\n  'system:health:changed': SystemHealthChangedPayload;\n}"
        },
        {
          "name": "WorkflowEvents",
          "definition": "interface WorkflowEvents {\n  'workflow:started': WorkflowStartedPayload;\n  'workflow:completed': WorkflowCompletedPayload;\n  'workflow:failed': WorkflowFailedPayload;\n  'workflow:paused': WorkflowPausedPayload;\n  'workflow:resumed': WorkflowResumedPayload;\n  'workflow:cancelled': WorkflowCancelledPayload;\n  'workflow:step:started': WorkflowStepStartedPayload;\n  'workflow:step:completed': WorkflowStepCompletedPayload;\n  'workflow:step:failed': WorkflowStepFailedPayload;\n}"
        },
        {
          "name": "CoordinationEvents",
          "definition": "interface CoordinationEvents {\n  'agent:created': AgentCreatedPayload;\n  'agent:destroyed': AgentDestroyedPayload;\n  'agent:status:changed': AgentStatusChangedPayload;\n  'task:assigned': TaskAssignedPayload;\n  'task:completed': TaskCompletedPayload;\n  'task:failed': TaskFailedPayload;\n  'swarm:initialized': SwarmInitializedPayload;\n  'swarm:topology:changed': SwarmTopologyChangedPayload;\n}"
        },
        {
          "name": "NeuralEvents",
          "definition": "interface NeuralEvents {\n  'neural:network:created': NeuralNetworkCreatedPayload;\n  'neural:network:training:started': NeuralTrainingStartedPayload;\n  'neural:network:training:completed': NeuralTrainingCompletedPayload;\n  'neural:network:training:failed': NeuralTrainingFailedPayload;\n  'neural:prediction:made': NeuralPredictionMadePayload;\n}"
        },
        {
          "name": "MemoryEvents",
          "definition": "interface MemoryEvents {\n  'memory:store:created': MemoryStoreCreatedPayload;\n  'memory:key:set': MemoryKeySetPayload;\n  'memory:key:get': MemoryKeyGetPayload;\n  'memory:key:deleted': MemoryKeyDeletedPayload;\n  'memory:sync:started': MemorySyncStartedPayload;\n  'memory:sync:completed': MemorySyncCompletedPayload;\n}"
        },
        {
          "name": "SystemConfig",
          "definition": "interface SystemConfig {\n  readonly [key: string]: unknown;\n}"
        },
        {
          "name": "SystemError",
          "definition": "interface SystemError {\n  readonly code: string;\n  readonly message: string;\n  readonly stack?: string;\n  readonly cause?: unknown;\n}"
        },
        {
          "name": "SystemErrorContext",
          "definition": "interface SystemErrorContext {\n  readonly module: string;\n  readonly operation: string;\n  readonly [key: string]: unknown;\n}"
        },
        {
          "name": "ServiceHealthMap",
          "definition": "interface ServiceHealthMap {\n  readonly [serviceName: string]: HealthState;\n}"
        },
        {
          "name": "WorkflowEventContext",
          "definition": "interface WorkflowEventContext {\n  readonly [key: string]: unknown;\n}"
        },
        {
          "name": "WorkflowResults",
          "definition": "interface WorkflowResults {\n  readonly [key: string]: unknown;\n}"
        },
        {
          "name": "WorkflowEventError",
          "definition": "interface WorkflowEventError {\n  readonly code: string;\n  readonly message: string;\n  readonly details?: unknown;\n}"
        },
        {
          "name": "StepEventResult",
          "definition": "interface StepEventResult {\n  readonly [key: string]: unknown;\n}"
        },
        {
          "name": "TaskEventResult",
          "definition": "interface TaskEventResult {\n  readonly [key: string]: unknown;\n}"
        },
        {
          "name": "TaskEventError",
          "definition": "interface TaskEventError {\n  readonly code: string;\n  readonly message: string;\n  readonly details?: unknown;\n}"
        },
        {
          "name": "NeuralEventError",
          "definition": "interface NeuralEventError {\n  readonly code: string;\n  readonly message: string;\n  readonly details?: unknown;\n}"
        },
        {
          "name": "MemoryStoreConfig",
          "definition": "interface MemoryStoreConfig {\n  readonly [key: string]: unknown;\n}"
        },
        {
          "name": "EventBusConfig",
          "definition": "interface EventBusConfig {\n  readonly maxListeners: number;\n  readonly enableMiddleware: boolean;\n  readonly enableMetrics: boolean;\n  readonly enableLogging: boolean;\n  readonly logLevel: 'debug' | 'info' | 'warn' | 'error';\n}"
        },
        {
          "name": "EventMetrics",
          "definition": "interface EventMetrics {\n  readonly eventCount: number;\n  readonly eventTypes: Record<string, number>;\n  readonly avgProcessingTime: number;\n  readonly errorCount: number;\n  readonly listenerCount: number;\n}"
        }
      ]
    },
    {
      "file": "src/types/agent-types.ts",
      "interfaces": [
        {
          "name": "AgentId",
          "definition": "interface AgentId {\n  id: string;\n  swarmId: string;\n  type: AgentType;\n  instance: number;\n}"
        },
        {
          "name": "AgentState",
          "definition": "interface AgentState {\n  id: AgentId;\n  name: string;\n  type: AgentType;\n  status: AgentStatus;\n  capabilities: AgentCapabilities;\n  metrics: AgentMetrics;\n  workload: number;\n  health: number;\n  config: AgentConfig;\n  environment: AgentEnvironment;\n  endpoints: string[];\n  lastHeartbeat: Date;\n  taskHistory: string[];\n  errorHistory: AgentError[];\n  childAgents: AgentId[];\n  collaborators: AgentId[];\n  currentTask?: string | null;\n}"
        },
        {
          "name": "AgentCapabilities",
          "definition": "interface AgentCapabilities {\n  codeGeneration: boolean;\n  codeReview: boolean;\n  testing: boolean;\n  documentation: boolean;\n  research: boolean;\n  analysis: boolean;\n  webSearch: boolean;\n  apiIntegration: boolean;\n  fileSystem: boolean;\n  terminalAccess: boolean;\n  languages: string[];\n  frameworks: string[];\n  domains: string[];\n  tools: string[];\n  maxConcurrentTasks: number;\n  maxMemoryUsage: number;\n  maxExecutionTime: number;\n  reliability: number;\n  speed: number;\n  quality: number;\n}"
        },
        {
          "name": "AgentConfig",
          "definition": "interface AgentConfig {\n  id?: string;\n  name: string;\n  type: AgentType;\n  swarmId: string;\n  capabilities?: string[];\n  autonomyLevel: number;\n  learningEnabled: boolean;\n  adaptationEnabled: boolean;\n  maxTasksPerHour: number;\n  maxConcurrentTasks: number;\n  timeoutThreshold: number;\n  reportingInterval: number;\n  heartbeatInterval: number;\n  permissions: string[];\n  trustedAgents: string[];\n  expertise: Record<string, number>;\n  preferences: Record<string, any>;\n}"
        },
        {
          "name": "AgentEnvironment",
          "definition": "interface AgentEnvironment {\n  runtime: 'deno' | 'node' | 'claude' | 'browser';\n  version: string;\n  workingDirectory: string;\n  tempDirectory: string;\n  logDirectory: string;\n  apiEndpoints: Record<string, string>;\n  credentials: Record<string, string>;\n  availableTools: string[];\n  toolConfigs: Record<string, any>;\n}"
        },
        {
          "name": "AgentMetrics",
          "definition": "interface AgentMetrics {\n  tasksCompleted: number;\n  tasksFailed: number;\n  averageExecutionTime: number;\n  successRate: number;\n  cpuUsage: number;\n  memoryUsage: number;\n  diskUsage: number;\n  networkUsage: number;\n  codeQuality: number;\n  testCoverage: number;\n  bugRate: number;\n  userSatisfaction: number;\n  totalUptime: number;\n  lastActivity: Date;\n  responseTime: number;\n  tasksInProgress?: number;\n  resourceUsage?: {\n    memory: number;\n    cpu: number;\n  }"
        },
        {
          "name": "AgentError",
          "definition": "interface AgentError {\n  timestamp: Date;\n  type: string;\n  message: string;\n  context: Record<string, any>;\n  severity: 'low' | 'medium' | 'high' | 'critical';\n  resolved: boolean;\n  code?: string;\n  agentId?: string;\n  taskId?: string;\n}"
        },
        {
          "name": "ExecutionResult",
          "definition": "interface ExecutionResult {\n  success: boolean;\n  data: any;\n  executionTime: number;\n  agentId: string;\n  metadata?: Record<string, any>;\n}"
        },
        {
          "name": "AgentCapability",
          "definition": "interface AgentCapability {\n  name: string;\n  version: string;\n  description: string;\n  requirements: string[];\n}"
        },
        {
          "name": "Task",
          "definition": "interface Task {\n  id: string;\n  swarmId: string;\n  description: string;\n  priority: string;\n  strategy: string;\n  status: string;\n  progress: number;\n  dependencies: string[];\n  assignedAgents: string[];\n  requireConsensus: boolean;\n  maxAgents: number;\n  requiredCapabilities: string[];\n  createdAt: Date;\n  metadata: Record<string, any>;\n}"
        },
        {
          "name": "Message",
          "definition": "interface Message {\n  id: string;\n  fromAgentId: string;\n  toAgentId: string | null;\n  swarmId: string;\n  type: string;\n  content: any;\n  timestamp: Date;\n  requiresResponse: boolean;\n}"
        }
      ]
    },
    {
      "file": "src/neural/neural-bridge.ts",
      "interfaces": [
        {
          "name": "NeuralConfig",
          "definition": "interface NeuralConfig {\n  wasmPath?: string;\n  gpuAcceleration?: boolean;\n  modelPath?: string;\n  enableTraining?: boolean;\n}"
        },
        {
          "name": "NeuralNetwork",
          "definition": "interface NeuralNetwork {\n  id: string;\n  type: 'feedforward' | 'lstm' | 'transformer' | 'autoencoder';\n  layers: number[];\n  weights?: Float64Array;\n  status: 'idle' | 'training' | 'predicting' | 'error';\n}"
        },
        {
          "name": "TrainingData",
          "definition": "interface TrainingData {\n  inputs: number[][];\n  outputs: number[][];\n}"
        },
        {
          "name": "PredictionResult",
          "definition": "interface PredictionResult {\n  outputs: number[];\n  confidence: number;\n  processingTime: number;\n}"
        }
      ]
    }
  ],
  "exports": [
    {
      "file": "src/index.ts",
      "exports": [
        {
          "name": "ClaudeZenConfig",
          "type": "export"
        },
        {
          "name": "defaultConfig",
          "type": "export"
        },
        {
          "name": "getVersion",
          "type": "export"
        }
      ]
    },
    {
      "file": "src/workflows/index.ts",
      "exports": [
        {
          "name": "WorkflowUtils",
          "type": "export"
        },
        {
          "name": "WorkflowFactory",
          "type": "export"
        }
      ]
    },
    {
      "file": "src/workflows/engine.ts",
      "exports": [
        {
          "name": "WorkflowStep",
          "type": "export"
        },
        {
          "name": "WorkflowDefinition",
          "type": "export"
        },
        {
          "name": "WorkflowContext",
          "type": "export"
        },
        {
          "name": "WorkflowState",
          "type": "export"
        },
        {
          "name": "WorkflowEngineConfig",
          "type": "export"
        },
        {
          "name": "WorkflowEngine",
          "type": "export"
        }
      ]
    },
    {
      "file": "src/types/workflow-types.ts",
      "exports": [
        {
          "name": "WorkflowParameterObject",
          "type": "export"
        },
        {
          "name": "DocumentContent",
          "type": "export"
        },
        {
          "name": "DocumentMetadata",
          "type": "export"
        },
        {
          "name": "StepExecutionResult",
          "type": "export"
        },
        {
          "name": "WorkflowResultMetadata",
          "type": "export"
        },
        {
          "name": "ResourceUsage",
          "type": "export"
        },
        {
          "name": "WorkflowError",
          "type": "export"
        },
        {
          "name": "WorkflowErrorContext",
          "type": "export"
        },
        {
          "name": "WorkflowData",
          "type": "export"
        },
        {
          "name": "WorkflowDataObject",
          "type": "export"
        },
        {
          "name": "WorkflowStep",
          "type": "export"
        },
        {
          "name": "WorkflowCondition",
          "type": "export"
        },
        {
          "name": "WorkflowValidator",
          "type": "export"
        },
        {
          "name": "WorkflowDefinition",
          "type": "export"
        },
        {
          "name": "WorkflowTrigger",
          "type": "export"
        },
        {
          "name": "WorkflowVariable",
          "type": "export"
        },
        {
          "name": "WorkflowContext",
          "type": "export"
        },
        {
          "name": "WorkflowDocumentRegistry",
          "type": "export"
        },
        {
          "name": "WorkflowEnvironment",
          "type": "export"
        },
        {
          "name": "WorkflowLimits",
          "type": "export"
        },
        {
          "name": "WorkflowPermissions",
          "type": "export"
        },
        {
          "name": "WorkflowState",
          "type": "export"
        },
        {
          "name": "WorkflowStepState",
          "type": "export"
        },
        {
          "name": "WorkflowStepResults",
          "type": "export"
        },
        {
          "name": "CompletedStepInfo",
          "type": "export"
        },
        {
          "name": "WorkflowProgress",
          "type": "export"
        },
        {
          "name": "WorkflowMetrics",
          "type": "export"
        },
        {
          "name": "WorkflowExecutionOptions",
          "type": "export"
        },
        {
          "name": "RetryPolicy",
          "type": "export"
        },
        {
          "name": "NotificationConfig",
          "type": "export"
        },
        {
          "name": "NotificationChannel",
          "type": "export"
        },
        {
          "name": "NotificationChannelConfig",
          "type": "export"
        },
        {
          "name": "LoggingConfig",
          "type": "export"
        },
        {
          "name": "WorkflowEngineConfig",
          "type": "export"
        },
        {
          "name": "StorageBackend",
          "type": "export"
        },
        {
          "name": "StorageBackendConfig",
          "type": "export"
        }
      ]
    },
    {
      "file": "src/types/shared-types.ts",
      "exports": [
        {
          "name": "RuvSwarm",
          "type": "export"
        },
        {
          "name": "SwarmAgent",
          "type": "export"
        },
        {
          "name": "SwarmConfig",
          "type": "export"
        },
        {
          "name": "MemoryEntry",
          "type": "export"
        },
        {
          "name": "StorageProvider",
          "type": "export"
        },
        {
          "name": "SystemEvent",
          "type": "export"
        },
        {
          "name": "Message",
          "type": "export"
        },
        {
          "name": "ComponentConfig",
          "type": "export"
        },
        {
          "name": "SystemHealth",
          "type": "export"
        },
        {
          "name": "ComponentHealth",
          "type": "export"
        },
        {
          "name": "Task",
          "type": "export"
        },
        {
          "name": "NeuralModel",
          "type": "export"
        },
        {
          "name": "ModelMetadata",
          "type": "export"
        },
        {
          "name": "APIResponse",
          "type": "export"
        },
        {
          "name": "APIError",
          "type": "export"
        },
        {
          "name": "CoordinationProvider",
          "type": "export"
        },
        {
          "name": "MemoryProvider",
          "type": "export"
        },
        {
          "name": "LoggingProvider",
          "type": "export"
        }
      ]
    },
    {
      "file": "src/types/index.ts",
      "exports": [
        {
          "name": "isRuvSwarm",
          "type": "export"
        },
        {
          "name": "isSwarmAgent",
          "type": "export"
        },
        {
          "name": "isSystemEvent",
          "type": "export"
        }
      ]
    },
    {
      "file": "src/types/event-types.ts",
      "exports": [
        {
          "name": "BaseEventPayload",
          "type": "export"
        },
        {
          "name": "SystemEvents",
          "type": "export"
        },
        {
          "name": "SystemStartedPayload",
          "type": "export"
        },
        {
          "name": "SystemStoppedPayload",
          "type": "export"
        },
        {
          "name": "SystemErrorPayload",
          "type": "export"
        },
        {
          "name": "SystemHealthChangedPayload",
          "type": "export"
        },
        {
          "name": "WorkflowEvents",
          "type": "export"
        },
        {
          "name": "WorkflowStartedPayload",
          "type": "export"
        },
        {
          "name": "WorkflowCompletedPayload",
          "type": "export"
        },
        {
          "name": "WorkflowFailedPayload",
          "type": "export"
        },
        {
          "name": "WorkflowPausedPayload",
          "type": "export"
        },
        {
          "name": "WorkflowResumedPayload",
          "type": "export"
        },
        {
          "name": "WorkflowCancelledPayload",
          "type": "export"
        },
        {
          "name": "WorkflowStepStartedPayload",
          "type": "export"
        },
        {
          "name": "WorkflowStepCompletedPayload",
          "type": "export"
        },
        {
          "name": "WorkflowStepFailedPayload",
          "type": "export"
        },
        {
          "name": "CoordinationEvents",
          "type": "export"
        },
        {
          "name": "AgentCreatedPayload",
          "type": "export"
        },
        {
          "name": "AgentDestroyedPayload",
          "type": "export"
        },
        {
          "name": "AgentStatusChangedPayload",
          "type": "export"
        },
        {
          "name": "TaskAssignedPayload",
          "type": "export"
        },
        {
          "name": "TaskCompletedPayload",
          "type": "export"
        },
        {
          "name": "TaskFailedPayload",
          "type": "export"
        },
        {
          "name": "SwarmInitializedPayload",
          "type": "export"
        },
        {
          "name": "SwarmTopologyChangedPayload",
          "type": "export"
        },
        {
          "name": "NeuralEvents",
          "type": "export"
        },
        {
          "name": "NeuralNetworkCreatedPayload",
          "type": "export"
        },
        {
          "name": "NeuralTrainingStartedPayload",
          "type": "export"
        },
        {
          "name": "NeuralTrainingCompletedPayload",
          "type": "export"
        },
        {
          "name": "NeuralTrainingFailedPayload",
          "type": "export"
        },
        {
          "name": "NeuralPredictionMadePayload",
          "type": "export"
        },
        {
          "name": "MemoryEvents",
          "type": "export"
        },
        {
          "name": "MemoryStoreCreatedPayload",
          "type": "export"
        },
        {
          "name": "MemoryKeySetPayload",
          "type": "export"
        },
        {
          "name": "MemoryKeyGetPayload",
          "type": "export"
        },
        {
          "name": "MemoryKeyDeletedPayload",
          "type": "export"
        },
        {
          "name": "MemorySyncStartedPayload",
          "type": "export"
        },
        {
          "name": "MemorySyncCompletedPayload",
          "type": "export"
        },
        {
          "name": "SystemConfig",
          "type": "export"
        },
        {
          "name": "SystemError",
          "type": "export"
        },
        {
          "name": "SystemErrorContext",
          "type": "export"
        },
        {
          "name": "ServiceHealthMap",
          "type": "export"
        },
        {
          "name": "WorkflowEventContext",
          "type": "export"
        },
        {
          "name": "WorkflowResults",
          "type": "export"
        },
        {
          "name": "WorkflowEventError",
          "type": "export"
        },
        {
          "name": "StepEventResult",
          "type": "export"
        },
        {
          "name": "TaskEventResult",
          "type": "export"
        },
        {
          "name": "TaskEventError",
          "type": "export"
        },
        {
          "name": "NeuralEventError",
          "type": "export"
        },
        {
          "name": "MemoryStoreConfig",
          "type": "export"
        },
        {
          "name": "EventBusConfig",
          "type": "export"
        },
        {
          "name": "EventMetrics",
          "type": "export"
        }
      ]
    },
    {
      "file": "src/types/agent-types.ts",
      "exports": [
        {
          "name": "AgentId",
          "type": "export"
        },
        {
          "name": "AgentState",
          "type": "export"
        },
        {
          "name": "AgentCapabilities",
          "type": "export"
        },
        {
          "name": "AgentConfig",
          "type": "export"
        },
        {
          "name": "AgentEnvironment",
          "type": "export"
        },
        {
          "name": "AgentMetrics",
          "type": "export"
        },
        {
          "name": "AgentError",
          "type": "export"
        },
        {
          "name": "ExecutionResult",
          "type": "export"
        },
        {
          "name": "AgentCapability",
          "type": "export"
        },
        {
          "name": "Task",
          "type": "export"
        },
        {
          "name": "Message",
          "type": "export"
        }
      ]
    },
    {
      "file": "src/neural/neural-bridge.ts",
      "exports": [
        {
          "name": "NeuralConfig",
          "type": "export"
        },
        {
          "name": "NeuralNetwork",
          "type": "export"
        },
        {
          "name": "TrainingData",
          "type": "export"
        },
        {
          "name": "PredictionResult",
          "type": "export"
        },
        {
          "name": "NeuralBridge",
          "type": "export"
        }
      ]
    }
  ]
}