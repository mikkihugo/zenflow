{"version":3,"file":"BhSolc2x.js","sources":["../../../../../../../../node_modules/.pnpm/svelte@5.38.1/node_modules/svelte/src/internal/client/dom/blocks/each.js","../../../../../../../../node_modules/.pnpm/svelte@5.38.1/node_modules/svelte/src/internal/shared/attributes.js","../../../../../../../../node_modules/.pnpm/svelte@5.38.1/node_modules/svelte/src/internal/client/dom/elements/class.js"],"sourcesContent":["/** @import { EachItem, EachState, Effect, MaybeSource, Source, TemplateNode, TransitionManager, Value } from '#client' */\n/** @import { Batch } from '../../reactivity/batch.js'; */\nimport {\n\tEACH_INDEX_REACTIVE,\n\tEACH_IS_ANIMATED,\n\tEACH_IS_CONTROLLED,\n\tEACH_ITEM_IMMUTABLE,\n\tEACH_ITEM_REACTIVE,\n\tHYDRATION_END,\n\tHYDRATION_START_ELSE\n} from '../../../../constants.js';\nimport {\n\thydrate_next,\n\thydrate_node,\n\thydrating,\n\tread_hydration_instruction,\n\tremove_nodes,\n\tset_hydrate_node,\n\tset_hydrating\n} from '../hydration.js';\nimport {\n\tclear_text_content,\n\tcreate_text,\n\tget_first_child,\n\tget_next_sibling,\n\tshould_defer_append\n} from '../operations.js';\nimport {\n\tblock,\n\tbranch,\n\tdestroy_effect,\n\trun_out_transitions,\n\tpause_children,\n\tpause_effect,\n\tresume_effect\n} from '../../reactivity/effects.js';\nimport { source, mutable_source, internal_set } from '../../reactivity/sources.js';\nimport { array_from, is_array } from '../../../shared/utils.js';\nimport { COMMENT_NODE, INERT } from '#client/constants';\nimport { queue_micro_task } from '../task.js';\nimport { active_effect, get } from '../../runtime.js';\nimport { DEV } from 'esm-env';\nimport { derived_safe_equal } from '../../reactivity/deriveds.js';\nimport { current_batch } from '../../reactivity/batch.js';\n\n/**\n * The row of a keyed each block that is currently updating. We track this\n * so that `animate:` directives have something to attach themselves to\n * @type {EachItem | null}\n */\nexport let current_each_item = null;\n\n/** @param {EachItem | null} item */\nexport function set_current_each_item(item) {\n\tcurrent_each_item = item;\n}\n\n/**\n * @param {any} _\n * @param {number} i\n */\nexport function index(_, i) {\n\treturn i;\n}\n\n/**\n * Pause multiple effects simultaneously, and coordinate their\n * subsequent destruction. Used in each blocks\n * @param {EachState} state\n * @param {EachItem[]} items\n * @param {null | Node} controlled_anchor\n */\nfunction pause_effects(state, items, controlled_anchor) {\n\tvar items_map = state.items;\n\n\t/** @type {TransitionManager[]} */\n\tvar transitions = [];\n\tvar length = items.length;\n\n\tfor (var i = 0; i < length; i++) {\n\t\tpause_children(items[i].e, transitions, true);\n\t}\n\n\tvar is_controlled = length > 0 && transitions.length === 0 && controlled_anchor !== null;\n\t// If we have a controlled anchor, it means that the each block is inside a single\n\t// DOM element, so we can apply a fast-path for clearing the contents of the element.\n\tif (is_controlled) {\n\t\tvar parent_node = /** @type {Element} */ (\n\t\t\t/** @type {Element} */ (controlled_anchor).parentNode\n\t\t);\n\t\tclear_text_content(parent_node);\n\t\tparent_node.append(/** @type {Element} */ (controlled_anchor));\n\t\titems_map.clear();\n\t\tlink(state, items[0].prev, items[length - 1].next);\n\t}\n\n\trun_out_transitions(transitions, () => {\n\t\tfor (var i = 0; i < length; i++) {\n\t\t\tvar item = items[i];\n\t\t\tif (!is_controlled) {\n\t\t\t\titems_map.delete(item.k);\n\t\t\t\tlink(state, item.prev, item.next);\n\t\t\t}\n\t\t\tdestroy_effect(item.e, !is_controlled);\n\t\t}\n\t});\n}\n\n/**\n * @template V\n * @param {Element | Comment} node The next sibling node, or the parent node if this is a 'controlled' block\n * @param {number} flags\n * @param {() => V[]} get_collection\n * @param {(value: V, index: number) => any} get_key\n * @param {(anchor: Node, item: MaybeSource<V>, index: MaybeSource<number>) => void} render_fn\n * @param {null | ((anchor: Node) => void)} fallback_fn\n * @returns {void}\n */\nexport function each(node, flags, get_collection, get_key, render_fn, fallback_fn = null) {\n\tvar anchor = node;\n\n\t/** @type {EachState} */\n\tvar state = { flags, items: new Map(), first: null };\n\n\tvar is_controlled = (flags & EACH_IS_CONTROLLED) !== 0;\n\n\tif (is_controlled) {\n\t\tvar parent_node = /** @type {Element} */ (node);\n\n\t\tanchor = hydrating\n\t\t\t? set_hydrate_node(/** @type {Comment | Text} */ (get_first_child(parent_node)))\n\t\t\t: parent_node.appendChild(create_text());\n\t}\n\n\tif (hydrating) {\n\t\thydrate_next();\n\t}\n\n\t/** @type {Effect | null} */\n\tvar fallback = null;\n\n\tvar was_empty = false;\n\n\t/** @type {Map<any, EachItem>} */\n\tvar offscreen_items = new Map();\n\n\t// TODO: ideally we could use derived for runes mode but because of the ability\n\t// to use a store which can be mutated, we can't do that here as mutating a store\n\t// will still result in the collection array being the same from the store\n\tvar each_array = derived_safe_equal(() => {\n\t\tvar collection = get_collection();\n\n\t\treturn is_array(collection) ? collection : collection == null ? [] : array_from(collection);\n\t});\n\n\t/** @type {V[]} */\n\tvar array;\n\n\t/** @type {Effect} */\n\tvar each_effect;\n\n\tfunction commit() {\n\t\treconcile(\n\t\t\teach_effect,\n\t\t\tarray,\n\t\t\tstate,\n\t\t\toffscreen_items,\n\t\t\tanchor,\n\t\t\trender_fn,\n\t\t\tflags,\n\t\t\tget_key,\n\t\t\tget_collection\n\t\t);\n\n\t\tif (fallback_fn !== null) {\n\t\t\tif (array.length === 0) {\n\t\t\t\tif (fallback) {\n\t\t\t\t\tresume_effect(fallback);\n\t\t\t\t} else {\n\t\t\t\t\tfallback = branch(() => fallback_fn(anchor));\n\t\t\t\t}\n\t\t\t} else if (fallback !== null) {\n\t\t\t\tpause_effect(fallback, () => {\n\t\t\t\t\tfallback = null;\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\n\tblock(() => {\n\t\t// store a reference to the effect so that we can update the start/end nodes in reconciliation\n\t\teach_effect ??= /** @type {Effect} */ (active_effect);\n\n\t\tarray = /** @type {V[]} */ (get(each_array));\n\t\tvar length = array.length;\n\n\t\tif (was_empty && length === 0) {\n\t\t\t// ignore updates if the array is empty,\n\t\t\t// and it already was empty on previous run\n\t\t\treturn;\n\t\t}\n\t\twas_empty = length === 0;\n\n\t\t/** `true` if there was a hydration mismatch. Needs to be a `let` or else it isn't treeshaken out */\n\t\tlet mismatch = false;\n\n\t\tif (hydrating) {\n\t\t\tvar is_else = read_hydration_instruction(anchor) === HYDRATION_START_ELSE;\n\n\t\t\tif (is_else !== (length === 0)) {\n\t\t\t\t// hydration mismatch â€” remove the server-rendered DOM and start over\n\t\t\t\tanchor = remove_nodes();\n\n\t\t\t\tset_hydrate_node(anchor);\n\t\t\t\tset_hydrating(false);\n\t\t\t\tmismatch = true;\n\t\t\t}\n\t\t}\n\n\t\t// this is separate to the previous block because `hydrating` might change\n\t\tif (hydrating) {\n\t\t\t/** @type {EachItem | null} */\n\t\t\tvar prev = null;\n\n\t\t\t/** @type {EachItem} */\n\t\t\tvar item;\n\n\t\t\tfor (var i = 0; i < length; i++) {\n\t\t\t\tif (\n\t\t\t\t\thydrate_node.nodeType === COMMENT_NODE &&\n\t\t\t\t\t/** @type {Comment} */ (hydrate_node).data === HYDRATION_END\n\t\t\t\t) {\n\t\t\t\t\t// The server rendered fewer items than expected,\n\t\t\t\t\t// so break out and continue appending non-hydrated items\n\t\t\t\t\tanchor = /** @type {Comment} */ (hydrate_node);\n\t\t\t\t\tmismatch = true;\n\t\t\t\t\tset_hydrating(false);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tvar value = array[i];\n\t\t\t\tvar key = get_key(value, i);\n\t\t\t\titem = create_item(\n\t\t\t\t\thydrate_node,\n\t\t\t\t\tstate,\n\t\t\t\t\tprev,\n\t\t\t\t\tnull,\n\t\t\t\t\tvalue,\n\t\t\t\t\tkey,\n\t\t\t\t\ti,\n\t\t\t\t\trender_fn,\n\t\t\t\t\tflags,\n\t\t\t\t\tget_collection\n\t\t\t\t);\n\t\t\t\tstate.items.set(key, item);\n\n\t\t\t\tprev = item;\n\t\t\t}\n\n\t\t\t// remove excess nodes\n\t\t\tif (length > 0) {\n\t\t\t\tset_hydrate_node(remove_nodes());\n\t\t\t}\n\t\t}\n\n\t\tif (hydrating) {\n\t\t\tif (length === 0 && fallback_fn) {\n\t\t\t\tfallback = branch(() => fallback_fn(anchor));\n\t\t\t}\n\t\t} else {\n\t\t\tif (should_defer_append()) {\n\t\t\t\tvar keys = new Set();\n\t\t\t\tvar batch = /** @type {Batch} */ (current_batch);\n\n\t\t\t\tfor (i = 0; i < length; i += 1) {\n\t\t\t\t\tvalue = array[i];\n\t\t\t\t\tkey = get_key(value, i);\n\n\t\t\t\t\tvar existing = state.items.get(key) ?? offscreen_items.get(key);\n\n\t\t\t\t\tif (existing) {\n\t\t\t\t\t\t// update before reconciliation, to trigger any async updates\n\t\t\t\t\t\tif ((flags & (EACH_ITEM_REACTIVE | EACH_INDEX_REACTIVE)) !== 0) {\n\t\t\t\t\t\t\tupdate_item(existing, value, i, flags);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\titem = create_item(\n\t\t\t\t\t\t\tnull,\n\t\t\t\t\t\t\tstate,\n\t\t\t\t\t\t\tnull,\n\t\t\t\t\t\t\tnull,\n\t\t\t\t\t\t\tvalue,\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\ti,\n\t\t\t\t\t\t\trender_fn,\n\t\t\t\t\t\t\tflags,\n\t\t\t\t\t\t\tget_collection,\n\t\t\t\t\t\t\ttrue\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\toffscreen_items.set(key, item);\n\t\t\t\t\t}\n\n\t\t\t\t\tkeys.add(key);\n\t\t\t\t}\n\n\t\t\t\tfor (const [key, item] of state.items) {\n\t\t\t\t\tif (!keys.has(key)) {\n\t\t\t\t\t\tbatch.skipped_effects.add(item.e);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tbatch.add_callback(commit);\n\t\t\t} else {\n\t\t\t\tcommit();\n\t\t\t}\n\t\t}\n\n\t\tif (mismatch) {\n\t\t\t// continue in hydration mode\n\t\t\tset_hydrating(true);\n\t\t}\n\n\t\t// When we mount the each block for the first time, the collection won't be\n\t\t// connected to this effect as the effect hasn't finished running yet and its deps\n\t\t// won't be assigned. However, it's possible that when reconciling the each block\n\t\t// that a mutation occurred and it's made the collection MAYBE_DIRTY, so reading the\n\t\t// collection again can provide consistency to the reactive graph again as the deriveds\n\t\t// will now be `CLEAN`.\n\t\tget(each_array);\n\t});\n\n\tif (hydrating) {\n\t\tanchor = hydrate_node;\n\t}\n}\n\n/**\n * Add, remove, or reorder items output by an each block as its input changes\n * @template V\n * @param {Effect} each_effect\n * @param {Array<V>} array\n * @param {EachState} state\n * @param {Map<any, EachItem>} offscreen_items\n * @param {Element | Comment | Text} anchor\n * @param {(anchor: Node, item: MaybeSource<V>, index: number | Source<number>, collection: () => V[]) => void} render_fn\n * @param {number} flags\n * @param {(value: V, index: number) => any} get_key\n * @param {() => V[]} get_collection\n * @returns {void}\n */\nfunction reconcile(\n\teach_effect,\n\tarray,\n\tstate,\n\toffscreen_items,\n\tanchor,\n\trender_fn,\n\tflags,\n\tget_key,\n\tget_collection\n) {\n\tvar is_animated = (flags & EACH_IS_ANIMATED) !== 0;\n\tvar should_update = (flags & (EACH_ITEM_REACTIVE | EACH_INDEX_REACTIVE)) !== 0;\n\n\tvar length = array.length;\n\tvar items = state.items;\n\tvar first = state.first;\n\tvar current = first;\n\n\t/** @type {undefined | Set<EachItem>} */\n\tvar seen;\n\n\t/** @type {EachItem | null} */\n\tvar prev = null;\n\n\t/** @type {undefined | Set<EachItem>} */\n\tvar to_animate;\n\n\t/** @type {EachItem[]} */\n\tvar matched = [];\n\n\t/** @type {EachItem[]} */\n\tvar stashed = [];\n\n\t/** @type {V} */\n\tvar value;\n\n\t/** @type {any} */\n\tvar key;\n\n\t/** @type {EachItem | undefined} */\n\tvar item;\n\n\t/** @type {number} */\n\tvar i;\n\n\tif (is_animated) {\n\t\tfor (i = 0; i < length; i += 1) {\n\t\t\tvalue = array[i];\n\t\t\tkey = get_key(value, i);\n\t\t\titem = items.get(key);\n\n\t\t\tif (item !== undefined) {\n\t\t\t\titem.a?.measure();\n\t\t\t\t(to_animate ??= new Set()).add(item);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0; i < length; i += 1) {\n\t\tvalue = array[i];\n\t\tkey = get_key(value, i);\n\n\t\titem = items.get(key);\n\n\t\tif (item === undefined) {\n\t\t\tvar pending = offscreen_items.get(key);\n\n\t\t\tif (pending !== undefined) {\n\t\t\t\toffscreen_items.delete(key);\n\t\t\t\titems.set(key, pending);\n\n\t\t\t\tvar next = prev ? prev.next : current;\n\n\t\t\t\tlink(state, prev, pending);\n\t\t\t\tlink(state, pending, next);\n\n\t\t\t\tmove(pending, next, anchor);\n\t\t\t\tprev = pending;\n\t\t\t} else {\n\t\t\t\tvar child_anchor = current ? /** @type {TemplateNode} */ (current.e.nodes_start) : anchor;\n\n\t\t\t\tprev = create_item(\n\t\t\t\t\tchild_anchor,\n\t\t\t\t\tstate,\n\t\t\t\t\tprev,\n\t\t\t\t\tprev === null ? state.first : prev.next,\n\t\t\t\t\tvalue,\n\t\t\t\t\tkey,\n\t\t\t\t\ti,\n\t\t\t\t\trender_fn,\n\t\t\t\t\tflags,\n\t\t\t\t\tget_collection\n\t\t\t\t);\n\t\t\t}\n\n\t\t\titems.set(key, prev);\n\n\t\t\tmatched = [];\n\t\t\tstashed = [];\n\n\t\t\tcurrent = prev.next;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (should_update) {\n\t\t\tupdate_item(item, value, i, flags);\n\t\t}\n\n\t\tif ((item.e.f & INERT) !== 0) {\n\t\t\tresume_effect(item.e);\n\t\t\tif (is_animated) {\n\t\t\t\titem.a?.unfix();\n\t\t\t\t(to_animate ??= new Set()).delete(item);\n\t\t\t}\n\t\t}\n\n\t\tif (item !== current) {\n\t\t\tif (seen !== undefined && seen.has(item)) {\n\t\t\t\tif (matched.length < stashed.length) {\n\t\t\t\t\t// more efficient to move later items to the front\n\t\t\t\t\tvar start = stashed[0];\n\t\t\t\t\tvar j;\n\n\t\t\t\t\tprev = start.prev;\n\n\t\t\t\t\tvar a = matched[0];\n\t\t\t\t\tvar b = matched[matched.length - 1];\n\n\t\t\t\t\tfor (j = 0; j < matched.length; j += 1) {\n\t\t\t\t\t\tmove(matched[j], start, anchor);\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (j = 0; j < stashed.length; j += 1) {\n\t\t\t\t\t\tseen.delete(stashed[j]);\n\t\t\t\t\t}\n\n\t\t\t\t\tlink(state, a.prev, b.next);\n\t\t\t\t\tlink(state, prev, a);\n\t\t\t\t\tlink(state, b, start);\n\n\t\t\t\t\tcurrent = start;\n\t\t\t\t\tprev = b;\n\t\t\t\t\ti -= 1;\n\n\t\t\t\t\tmatched = [];\n\t\t\t\t\tstashed = [];\n\t\t\t\t} else {\n\t\t\t\t\t// more efficient to move earlier items to the back\n\t\t\t\t\tseen.delete(item);\n\t\t\t\t\tmove(item, current, anchor);\n\n\t\t\t\t\tlink(state, item.prev, item.next);\n\t\t\t\t\tlink(state, item, prev === null ? state.first : prev.next);\n\t\t\t\t\tlink(state, prev, item);\n\n\t\t\t\t\tprev = item;\n\t\t\t\t}\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tmatched = [];\n\t\t\tstashed = [];\n\n\t\t\twhile (current !== null && current.k !== key) {\n\t\t\t\t// If the each block isn't inert and an item has an effect that is already inert,\n\t\t\t\t// skip over adding it to our seen Set as the item is already being handled\n\t\t\t\tif ((current.e.f & INERT) === 0) {\n\t\t\t\t\t(seen ??= new Set()).add(current);\n\t\t\t\t}\n\t\t\t\tstashed.push(current);\n\t\t\t\tcurrent = current.next;\n\t\t\t}\n\n\t\t\tif (current === null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\titem = current;\n\t\t}\n\n\t\tmatched.push(item);\n\t\tprev = item;\n\t\tcurrent = item.next;\n\t}\n\n\tif (current !== null || seen !== undefined) {\n\t\tvar to_destroy = seen === undefined ? [] : array_from(seen);\n\n\t\twhile (current !== null) {\n\t\t\t// If the each block isn't inert, then inert effects are currently outroing and will be removed once the transition is finished\n\t\t\tif ((current.e.f & INERT) === 0) {\n\t\t\t\tto_destroy.push(current);\n\t\t\t}\n\t\t\tcurrent = current.next;\n\t\t}\n\n\t\tvar destroy_length = to_destroy.length;\n\n\t\tif (destroy_length > 0) {\n\t\t\tvar controlled_anchor = (flags & EACH_IS_CONTROLLED) !== 0 && length === 0 ? anchor : null;\n\n\t\t\tif (is_animated) {\n\t\t\t\tfor (i = 0; i < destroy_length; i += 1) {\n\t\t\t\t\tto_destroy[i].a?.measure();\n\t\t\t\t}\n\n\t\t\t\tfor (i = 0; i < destroy_length; i += 1) {\n\t\t\t\t\tto_destroy[i].a?.fix();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpause_effects(state, to_destroy, controlled_anchor);\n\t\t}\n\t}\n\n\tif (is_animated) {\n\t\tqueue_micro_task(() => {\n\t\t\tif (to_animate === undefined) return;\n\t\t\tfor (item of to_animate) {\n\t\t\t\titem.a?.apply();\n\t\t\t}\n\t\t});\n\t}\n\n\teach_effect.first = state.first && state.first.e;\n\teach_effect.last = prev && prev.e;\n\n\tfor (var unused of offscreen_items.values()) {\n\t\tdestroy_effect(unused.e);\n\t}\n\n\toffscreen_items.clear();\n}\n\n/**\n * @param {EachItem} item\n * @param {any} value\n * @param {number} index\n * @param {number} type\n * @returns {void}\n */\nfunction update_item(item, value, index, type) {\n\tif ((type & EACH_ITEM_REACTIVE) !== 0) {\n\t\tinternal_set(item.v, value);\n\t}\n\n\tif ((type & EACH_INDEX_REACTIVE) !== 0) {\n\t\tinternal_set(/** @type {Value<number>} */ (item.i), index);\n\t} else {\n\t\titem.i = index;\n\t}\n}\n\n/**\n * @template V\n * @param {Node | null} anchor\n * @param {EachState} state\n * @param {EachItem | null} prev\n * @param {EachItem | null} next\n * @param {V} value\n * @param {unknown} key\n * @param {number} index\n * @param {(anchor: Node, item: V | Source<V>, index: number | Value<number>, collection: () => V[]) => void} render_fn\n * @param {number} flags\n * @param {() => V[]} get_collection\n * @param {boolean} [deferred]\n * @returns {EachItem}\n */\nfunction create_item(\n\tanchor,\n\tstate,\n\tprev,\n\tnext,\n\tvalue,\n\tkey,\n\tindex,\n\trender_fn,\n\tflags,\n\tget_collection,\n\tdeferred\n) {\n\tvar previous_each_item = current_each_item;\n\tvar reactive = (flags & EACH_ITEM_REACTIVE) !== 0;\n\tvar mutable = (flags & EACH_ITEM_IMMUTABLE) === 0;\n\n\tvar v = reactive ? (mutable ? mutable_source(value, false, false) : source(value)) : value;\n\tvar i = (flags & EACH_INDEX_REACTIVE) === 0 ? index : source(index);\n\n\tif (DEV && reactive) {\n\t\t// For tracing purposes, we need to link the source signal we create with the\n\t\t// collection + index so that tracing works as intended\n\t\t/** @type {Value} */ (v).trace = () => {\n\t\t\tvar collection_index = typeof i === 'number' ? index : i.v;\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-unused-expressions\n\t\t\tget_collection()[collection_index];\n\t\t};\n\t}\n\n\t/** @type {EachItem} */\n\tvar item = {\n\t\ti,\n\t\tv,\n\t\tk: key,\n\t\ta: null,\n\t\t// @ts-expect-error\n\t\te: null,\n\t\tprev,\n\t\tnext\n\t};\n\n\tcurrent_each_item = item;\n\n\ttry {\n\t\tif (anchor === null) {\n\t\t\tvar fragment = document.createDocumentFragment();\n\t\t\tfragment.append((anchor = create_text()));\n\t\t}\n\n\t\titem.e = branch(() => render_fn(/** @type {Node} */ (anchor), v, i, get_collection), hydrating);\n\n\t\titem.e.prev = prev && prev.e;\n\t\titem.e.next = next && next.e;\n\n\t\tif (prev === null) {\n\t\t\tif (!deferred) {\n\t\t\t\tstate.first = item;\n\t\t\t}\n\t\t} else {\n\t\t\tprev.next = item;\n\t\t\tprev.e.next = item.e;\n\t\t}\n\n\t\tif (next !== null) {\n\t\t\tnext.prev = item;\n\t\t\tnext.e.prev = item.e;\n\t\t}\n\n\t\treturn item;\n\t} finally {\n\t\tcurrent_each_item = previous_each_item;\n\t}\n}\n\n/**\n * @param {EachItem} item\n * @param {EachItem | null} next\n * @param {Text | Element | Comment} anchor\n */\nfunction move(item, next, anchor) {\n\tvar end = item.next ? /** @type {TemplateNode} */ (item.next.e.nodes_start) : anchor;\n\n\tvar dest = next ? /** @type {TemplateNode} */ (next.e.nodes_start) : anchor;\n\tvar node = /** @type {TemplateNode} */ (item.e.nodes_start);\n\n\twhile (node !== null && node !== end) {\n\t\tvar next_node = /** @type {TemplateNode} */ (get_next_sibling(node));\n\t\tdest.before(node);\n\t\tnode = next_node;\n\t}\n}\n\n/**\n * @param {EachState} state\n * @param {EachItem | null} prev\n * @param {EachItem | null} next\n */\nfunction link(state, prev, next) {\n\tif (prev === null) {\n\t\tstate.first = next;\n\t} else {\n\t\tprev.next = next;\n\t\tprev.e.next = next && next.e;\n\t}\n\n\tif (next !== null) {\n\t\tnext.prev = prev;\n\t\tnext.e.prev = prev && prev.e;\n\t}\n}\n","import { escape_html } from '../../escaping.js';\nimport { clsx as _clsx } from 'clsx';\n\n/**\n * `<div translate={false}>` should be rendered as `<div translate=\"no\">` and _not_\n * `<div translate=\"false\">`, which is equivalent to `<div translate=\"yes\">`. There\n * may be other odd cases that need to be added to this list in future\n * @type {Record<string, Map<any, string>>}\n */\nconst replacements = {\n\ttranslate: new Map([\n\t\t[true, 'yes'],\n\t\t[false, 'no']\n\t])\n};\n\n/**\n * @template V\n * @param {string} name\n * @param {V} value\n * @param {boolean} [is_boolean]\n * @returns {string}\n */\nexport function attr(name, value, is_boolean = false) {\n\tif (value == null || (!value && is_boolean)) return '';\n\tconst normalized = (name in replacements && replacements[name].get(value)) || value;\n\tconst assignment = is_boolean ? '' : `=\"${escape_html(normalized, true)}\"`;\n\treturn ` ${name}${assignment}`;\n}\n\n/**\n * Small wrapper around clsx to preserve Svelte's (weird) handling of falsy values.\n * TODO Svelte 6 revisit this, and likely turn all falsy values into the empty string (what clsx also does)\n * @param  {any} value\n */\nexport function clsx(value) {\n\tif (typeof value === 'object') {\n\t\treturn _clsx(value);\n\t} else {\n\t\treturn value ?? '';\n\t}\n}\n\nconst whitespace = [...' \\t\\n\\r\\f\\u00a0\\u000b\\ufeff'];\n\n/**\n * @param {any} value\n * @param {string | null} [hash]\n * @param {Record<string, boolean>} [directives]\n * @returns {string | null}\n */\nexport function to_class(value, hash, directives) {\n\tvar classname = value == null ? '' : '' + value;\n\n\tif (hash) {\n\t\tclassname = classname ? classname + ' ' + hash : hash;\n\t}\n\n\tif (directives) {\n\t\tfor (var key in directives) {\n\t\t\tif (directives[key]) {\n\t\t\t\tclassname = classname ? classname + ' ' + key : key;\n\t\t\t} else if (classname.length) {\n\t\t\t\tvar len = key.length;\n\t\t\t\tvar a = 0;\n\n\t\t\t\twhile ((a = classname.indexOf(key, a)) >= 0) {\n\t\t\t\t\tvar b = a + len;\n\n\t\t\t\t\tif (\n\t\t\t\t\t\t(a === 0 || whitespace.includes(classname[a - 1])) &&\n\t\t\t\t\t\t(b === classname.length || whitespace.includes(classname[b]))\n\t\t\t\t\t) {\n\t\t\t\t\t\tclassname = (a === 0 ? '' : classname.substring(0, a)) + classname.substring(b + 1);\n\t\t\t\t\t} else {\n\t\t\t\t\t\ta = b;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn classname === '' ? null : classname;\n}\n\n/**\n *\n * @param {Record<string,any>} styles\n * @param {boolean} important\n */\nfunction append_styles(styles, important = false) {\n\tvar separator = important ? ' !important;' : ';';\n\tvar css = '';\n\n\tfor (var key in styles) {\n\t\tvar value = styles[key];\n\t\tif (value != null && value !== '') {\n\t\t\tcss += ' ' + key + ': ' + value + separator;\n\t\t}\n\t}\n\n\treturn css;\n}\n\n/**\n * @param {string} name\n * @returns {string}\n */\nfunction to_css_name(name) {\n\tif (name[0] !== '-' || name[1] !== '-') {\n\t\treturn name.toLowerCase();\n\t}\n\treturn name;\n}\n\n/**\n * @param {any} value\n * @param {Record<string, any> | [Record<string, any>, Record<string, any>]} [styles]\n * @returns {string | null}\n */\nexport function to_style(value, styles) {\n\tif (styles) {\n\t\tvar new_style = '';\n\n\t\t/** @type {Record<string,any> | undefined} */\n\t\tvar normal_styles;\n\n\t\t/** @type {Record<string,any> | undefined} */\n\t\tvar important_styles;\n\n\t\tif (Array.isArray(styles)) {\n\t\t\tnormal_styles = styles[0];\n\t\t\timportant_styles = styles[1];\n\t\t} else {\n\t\t\tnormal_styles = styles;\n\t\t}\n\n\t\tif (value) {\n\t\t\tvalue = String(value)\n\t\t\t\t.replaceAll(/\\s*\\/\\*.*?\\*\\/\\s*/g, '')\n\t\t\t\t.trim();\n\n\t\t\t/** @type {boolean | '\"' | \"'\"} */\n\t\t\tvar in_str = false;\n\t\t\tvar in_apo = 0;\n\t\t\tvar in_comment = false;\n\n\t\t\tvar reserved_names = [];\n\n\t\t\tif (normal_styles) {\n\t\t\t\treserved_names.push(...Object.keys(normal_styles).map(to_css_name));\n\t\t\t}\n\t\t\tif (important_styles) {\n\t\t\t\treserved_names.push(...Object.keys(important_styles).map(to_css_name));\n\t\t\t}\n\n\t\t\tvar start_index = 0;\n\t\t\tvar name_index = -1;\n\n\t\t\tconst len = value.length;\n\t\t\tfor (var i = 0; i < len; i++) {\n\t\t\t\tvar c = value[i];\n\n\t\t\t\tif (in_comment) {\n\t\t\t\t\tif (c === '/' && value[i - 1] === '*') {\n\t\t\t\t\t\tin_comment = false;\n\t\t\t\t\t}\n\t\t\t\t} else if (in_str) {\n\t\t\t\t\tif (in_str === c) {\n\t\t\t\t\t\tin_str = false;\n\t\t\t\t\t}\n\t\t\t\t} else if (c === '/' && value[i + 1] === '*') {\n\t\t\t\t\tin_comment = true;\n\t\t\t\t} else if (c === '\"' || c === \"'\") {\n\t\t\t\t\tin_str = c;\n\t\t\t\t} else if (c === '(') {\n\t\t\t\t\tin_apo++;\n\t\t\t\t} else if (c === ')') {\n\t\t\t\t\tin_apo--;\n\t\t\t\t}\n\n\t\t\t\tif (!in_comment && in_str === false && in_apo === 0) {\n\t\t\t\t\tif (c === ':' && name_index === -1) {\n\t\t\t\t\t\tname_index = i;\n\t\t\t\t\t} else if (c === ';' || i === len - 1) {\n\t\t\t\t\t\tif (name_index !== -1) {\n\t\t\t\t\t\t\tvar name = to_css_name(value.substring(start_index, name_index).trim());\n\n\t\t\t\t\t\t\tif (!reserved_names.includes(name)) {\n\t\t\t\t\t\t\t\tif (c !== ';') {\n\t\t\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tvar property = value.substring(start_index, i).trim();\n\t\t\t\t\t\t\t\tnew_style += ' ' + property + ';';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tstart_index = i + 1;\n\t\t\t\t\t\tname_index = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (normal_styles) {\n\t\t\tnew_style += append_styles(normal_styles);\n\t\t}\n\n\t\tif (important_styles) {\n\t\t\tnew_style += append_styles(important_styles, true);\n\t\t}\n\n\t\tnew_style = new_style.trim();\n\t\treturn new_style === '' ? null : new_style;\n\t}\n\n\treturn value == null ? null : String(value);\n}\n","import { to_class } from '../../../shared/attributes.js';\nimport { hydrating } from '../hydration.js';\n\n/**\n * @param {Element} dom\n * @param {boolean | number} is_html\n * @param {string | null} value\n * @param {string} [hash]\n * @param {Record<string, any>} [prev_classes]\n * @param {Record<string, any>} [next_classes]\n * @returns {Record<string, boolean> | undefined}\n */\nexport function set_class(dom, is_html, value, hash, prev_classes, next_classes) {\n\t// @ts-expect-error need to add __className to patched prototype\n\tvar prev = dom.__className;\n\n\tif (\n\t\thydrating ||\n\t\tprev !== value ||\n\t\tprev === undefined // for edge case of `class={undefined}`\n\t) {\n\t\tvar next_class_name = to_class(value, hash, next_classes);\n\n\t\tif (!hydrating || next_class_name !== dom.getAttribute('class')) {\n\t\t\t// Removing the attribute when the value is only an empty string causes\n\t\t\t// performance issues vs simply making the className an empty string. So\n\t\t\t// we should only remove the class if the value is nullish\n\t\t\t// and there no hash/directives :\n\t\t\tif (next_class_name == null) {\n\t\t\t\tdom.removeAttribute('class');\n\t\t\t} else if (is_html) {\n\t\t\t\tdom.className = next_class_name;\n\t\t\t} else {\n\t\t\t\tdom.setAttribute('class', next_class_name);\n\t\t\t}\n\t\t}\n\n\t\t// @ts-expect-error need to add __className to patched prototype\n\t\tdom.__className = value;\n\t} else if (next_classes && prev_classes !== next_classes) {\n\t\tfor (var key in next_classes) {\n\t\t\tvar is_present = !!next_classes[key];\n\n\t\t\tif (prev_classes == null || is_present !== !!prev_classes[key]) {\n\t\t\t\tdom.classList.toggle(key, is_present);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn next_classes;\n}\n"],"names":["index","_","i","pause_effects","state","items","controlled_anchor","items_map","transitions","length","pause_children","is_controlled","parent_node","clear_text_content","link","run_out_transitions","item","destroy_effect","each","node","flags","get_collection","get_key","render_fn","fallback_fn","anchor","EACH_IS_CONTROLLED","hydrating","set_hydrate_node","get_first_child","create_text","hydrate_next","fallback","was_empty","offscreen_items","each_array","derived_safe_equal","collection","is_array","array_from","array","each_effect","commit","reconcile","resume_effect","branch","pause_effect","block","active_effect","get","mismatch","is_else","read_hydration_instruction","HYDRATION_START_ELSE","remove_nodes","set_hydrating","prev","hydrate_node","COMMENT_NODE","HYDRATION_END","value","key","create_item","should_defer_append","keys","batch","current_batch","existing","EACH_ITEM_REACTIVE","EACH_INDEX_REACTIVE","update_item","is_animated","EACH_IS_ANIMATED","should_update","first","current","seen","to_animate","matched","stashed","pending","next","move","child_anchor","INERT","start","j","a","b","to_destroy","destroy_length","queue_micro_task","unused","type","internal_set","deferred","reactive","mutable","EACH_ITEM_IMMUTABLE","v","mutable_source","source","fragment","end","dest","next_node","get_next_sibling","whitespace","to_class","hash","directives","classname","len","to_style","styles","set_class","dom","is_html","prev_classes","next_classes","next_class_name","is_present"],"mappings":"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","x_google_ignoreList":[0,1,2]}