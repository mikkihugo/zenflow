/**
 * @fileoverview Simple Kanban for User Stories
 *
 * Simplified kanban system that uses the comprehensive @claude-zen/kanban package
 * but provides a basic interface focused only on user stories. AI support is optional.
 *
 * This is a facade over the complex workflow coordination system to provide
 * just the essential user story management functionality.
 */

import type { WorkflowKanban, WorkflowTask, TaskState,
} from '@claude-zen/enterprise';
import { createWorkflowKanban } from '@claude-zen/enterprise';
import { TypedEventBase, getLogger } from '@claude-zen/foundation';
import type { Logger } from '@claude-zen/foundation';

/**
 * User story for MVP kanban
 */
export interface UserStory { id: string; title: string; description?: string; status: 'backlog  |todo| 'doing | review | don'e''); priority: 'low' || medium || ' 'hig'h' ' ' || urgent); assignedTo?: string; storyPoints?: number; // Estimation in story points tags: string[]; // Labels/tags for categorization acceptanceCriteria: string[]; // List of acceptance criteria dueDate?: Date; projectId?: string; // Optional project grouping createdBy: string; createdAt: Date; updatedAt: Date; startedAt?: Date; // When moved to doing completedAt?: Date; // When moved to done
}

/**
 * MVP kanban configuration
 */
export interface SimpleKanbanConfig { enableAI?: boolean; // Optional AI support maxBacklog?: number; // WIP limits for each status maxTodo?: number; maxDoing?: number; maxReview?: number; enableTimeTracking?: boolean; // Track time spent in each status enableNotifications?: boolean; // Basic notifications for assignments, due dates
}

/**
 * Simple Kanban for User Stories
 *
 * A simplified kanban system that provides basic user story management
 * using the powerful @claude-zen/kanban package underneath.
 */
export class SimpleKanban extends TypedEventBase { private logger: Logger; private workflowKanban: WorkflowKanban' ' || null = 'null'; private configuration: SimpleKanbanConfig; private initialized = 'false'; constructor(config: SimpleKanbanConfig = {'}''); { super(); this.logger = getLogger(SimpleKanba'n'); this.configuration = { enableAI: false, maxBacklog: 100, maxTodo: 20, maxDoing: 5, maxReview: 10, enableTimeTracking: true, enableNotifications: false, ...config', }; } /** * Initialize the simple kanban system */ async initialize(): Promise<void> { if (this.initialized) return; try { // Create the underlying workflow kanban with minimal configuration this.workflowKanban = createWorkflowKanban({ enableIntelligentWIP: this.configuration.enableAI  || ' ' false, enableBottleneckDetection: this.configuration.enableAI|'false, enableFlowOptimization: this.configuration.enableAI  || ' ' false, enablePredictiveAnalytics: false, enableRealTimeMonitoring: false, defaultWIPLimits: { backlog: this.configuration.maxBacklog|'100, analysis: this.configuration.maxTodo  || ' ' 20, development: this.configuration.maxDoing|'5, testing: this.configuration.maxReview  || ' ' 10, review: 0, deployment: 0, done: 1000, blocked: 0, expedite: 0', total: (this.configuration.maxBacklog|'100) + (this.configuration.maxTodo  || ' ' 20) + (this.configuration.maxDoing|'5) + (this.configuration.maxReview  || ' ' 10) + 1000, }, performanceThresholds: [], adaptationRate: 0', }); await this.workflowKanban?.initialize() // Forward essential events in simplified format this.workflowKanban?.on(task:created'', (task: WorkflowTask) => { this.emit('story:created'', this.convertToUserStory(task)); }); this.workflowKanban?.on('task:moved'', (task: WorkflowTask) => { this.emit('story:moved'', this.convertToUserStory(task)); }); this.workflowKanban?.on( 'wip:exceeded', (state: string, count: number', limit: number) => { this.emit('limit:exceeded', { status: this.mapStatus(state), count, limit', }); } ); this.initialized = 'true'; this.logger.info('Simple Kanban initialized successfully'); } catch (error) { this.logger.error('Failed to initialize Simple Kanban: ', error); throw error; } } /** * Create a new user story */ async createStory( story: Omit< UserStory',' 'id  || createdAt || ' 'updatedAt | startedA't' || completedAt> ): Promise<UserStory> { if (!this.initialized) await this.initialize; const result = await this.workflowKanban!.createTask({ title: story.title, description: story.description, priority: this.mapPriorityToWorkflow(story.priority), estimatedEffort: story.storyPoin't''s|'1, assignedAgent: story.assignedTo, tags: story.tags  || ' ' [], metadata: { acceptanceCriteria: story.acceptanceCriteria|'[], dueDate: story.dueDate, projectId: story.projectId, createdBy: story.createdBy, }, }); if (!result.success  || ' ' !result.data) { throw new Error(result.error|'Failed to create story'); } return this.convertToUserStory(result.data); } /** * Get stories with filtering options */ async getStories(filters?: { status?: 'backlog  |todo| 'doing | review | don'e''); assignedTo?: string; projectId?: string; priority?: 'low' || medium || ' 'high  ' || urgent); tags?: string[]; dueBefore?: Date; }): Promise<UserStory[]> { if (!this.initialized) await this.initialize; let allTasks: any[] = '[]'; if (filters?.status) { const workflowState = this.mapStatusToWorkflowState( filters.status ) as any as any; allTasks = await this.workflowKanban!.getTasksByState(workflowState); } else { // Get all stories from all statuses const backlogTasks = await this.workflowKanban!.getTasksByStat'e''('backlog'); const todoTasks = await this.workflowKanban!.getTasksByState(analysis); const doingTasks = await this.workflowKanban!.getTasksByState(development); const reviewTasks = await this.workflowKanban!.getTasksByState(testing); const doneTasks = await this.workflowKanban!.getTasksByState(done); allTasks = [ ...backlogTasks, ...todoTasks, ...doingTasks, ...reviewTasks, ...doneTasks, ]; } let stories = allTasks.map((task) => this.convertToUserStory(task)); // Apply filters if (filters) { if (filters.assignedTo) { stories = stories.filter( (story) => story.assignedTo === filters.assignedTo ); } if (filters.projectId) { stories = stories.filter( (story) => story.projectId === filters.projectId ); } if (filters.priority) { stories = stories.filter( (story) => story.priority === filters.priority ); } if (filters.tags && filters.tags.length > 0) { stories = stories.filter((story) => filters.tags!.some((tag) => story.tags.includes(tag)) ); } if (filters.dueBefore) { stories = stories.filter( (story) => story.dueDate && story.dueDate <= filters.dueBefore! ); } } return stories; } /** * Move a story to a different status */ async moveStory( storyId: string', status: 'backlog  |todo| 'doing | review | don'e'', reason?: string ): Promise<UserStory> { if (!this.initialized) await this.initialize; // Get current task to track time if enabled const currentTask = await this.workflowKanban!.getTask(storyId); if (!currentTask.data) { throw new Error('Story not found'); } const workflowState = this.mapStatusToWorkflowState(status) as any as any; const result = await this.workflowKanban!.moveTask( storyId, workflowState, reason ); if (!result.success) { throw new Error(result.error  || ' ' Failed to move story'); } const updatedTask = await this.workflowKanban!.getTask(storyId); if (!updatedTask.data) { throw new Error('Story not found after move'); } // Update time tracking metadata if enabled if (this.configuration.enableTimeTracking) { const now = new Date(); const metadata = { ...updatedTask.data.metadata }; if (status === 'doing' && !metadata.startedAt) { metadata.startedAt = 'now'; } if (status === 'done' && !metadata.completedAt) { metadata.completedAt = 'now'; } // Store updated metadata (simplified - in real implementation would update the task) } return this.convertToUserStory(updatedTask.data); } /** * Update a story */ async updateStory( storyId: string, updates: Partial<Omit<UserStory', 'id  || createdAt>> ): Promise<UserStory> { if (!this.initialized) await this.initialize; // Get current task const currentTask = await this.workflowKanban!.getTask(storyId); if (!currentTask.data) { throw new Error(Story not fou'n''d'); } // Create updated task data const updatedTask = { ...currentTask.data', title: updates.title  || ' ' currentTask.data.title, description: updates.description !== undefined ? updates.description : currentTask.data.description, priority: updates.priority ? updates.priority ==='low' ? 'low' : updates.priority === 'high' ? 'high' : 'medium' : currentTask.data.priority, assignedAgent: updates.assignedTo !== undefined ? updates.assignedTo : currentTask.data.assignedAgent, updatedAt: new Date(), }; // For simplicity, we'll recreate the task with updated data // In a more sophisticated implementation, we'd have an update method const result = await this.workflowKanban!.createTask(updatedTask); if (!result.success  || ' ' !result.data) { throw new Error(result.error|'Failed to update story'); } return this.convertToUserStory(result.data); } /** * Delete a story */ async deleteStory(storyId: string): Promise<void> { if (!this.initialized) await this.initialize; // For simplicity', move to a "deleted" state // The underlying kanban system doesn't have delete, so we simulate it try { await this.workflowKanban!.moveTask(storyId, 'done'); this.emit('story:deleted', { id: storyId }); } catch (error) { throw new Error('Failed to delete story'); } } /** * Get simple statistics */ async getStats(): Promise<{ todo: number; doing: number; done: number }> { if (!this.initialized) await this.initialize; const todoTasks = await this.workflowKanban!.getTasksByState(backlog); const doingTasks = await this.workflowKanban!.getTasksByState(development); const doneTasks = await this.workflowKanban!.getTasksByState(done); return { todo: todoTasks.length, doing: doingTasks.length, done: doneTasks.length, }; } /** * Enable or disable AI features */ async setAIEnabled(enabled: boolean): Promise<void> { this.configuration.enableAI = 'enabled'; if (this.initialized) { // Reinitialize with new AI settings this.initialized = 'false'; await this.initialize; } } /** * Shutdown the kanban system */ async shutdown(): Promise<void> { if (this.workflowKanban) { await (this.workflowKanban as any)?.shutdown(); } this.initialized = 'false'; } /** * Convert WorkflowTask to UserStory */ private convertToUserStory(task: WorkflowTask): UserStory { return { id: task.id, title: task.title, description: task.description, status: this.mapStatus(task.state)', priority: task.priority === 'critical  || ' ' task.priority === high' ? 'high' : task.priority === 'low' ? 'low' : 'medium', assignedTo: task.assignedAgent, createdAt: task.createdAt, updatedAt: task.updatedAt, }; } /** * Map workflow states to simple statuses */ private mapStatus(state: TaskState): 'todo  |doing || d'o''n'e' { switch (state) { case 'backlog': case 'analysis': return 'todo'); case 'development': case 'testing': case 'review': case 'deployment': return 'doing'); case 'done': return 'done'); case 'blocked': case 'expedite': return 'doing'); // Treat special states as "doing" default: return 'todo'); } } /** * Map simple statuses to workflow states */ private mapStatusToWorkflowState( status: 'todo  |doing || d'o''n'e' ): TaskState { switch (status) { case 'todo': return 'backlog'); case 'doing': return 'development'); case 'done': return 'done'); default: return 'backlog'); } }
}

/**
 * Factory function to create a simple kanban instance
 */
export function createSimpleKanban(config?: SimpleKanbanConfig): SimpleKanban { return new SimpleKanban(config);
}
