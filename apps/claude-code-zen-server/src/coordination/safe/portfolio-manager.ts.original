/**
 * @file Portfolio Manager - Phase 3, Day 15 (Task 14.1-14.3)
 *
 * Implements SAFe Lean Portfolio Management with portfolio budget allocation,
 * strategic theme tracking, epic investment planning, value stream funding,
 * and Lean-Agile budgeting with cost center integration.
 *
 * ARCHITECTURE:
 * - Portfolio budget planning and allocation
 * - Strategic theme definition and tracking
 * - Epic investment analysis and prioritization
 * - Value stream funding allocation
 * - Lean-Agile budget governance
 * - Cost center integration and tracking
 */

import { EventEmitter } from 'eventemitter3';
import type { Logger } from '../../config/logging-config';
import { getLogger } from '../../config/logging-config';
import type { MemorySystem } from '../../core/memory-coordinator';
import type { TypeSafeEventBus } from '@claude-zen/event-system';
import {
  createEvent,
  EventPriority,
} from '@claude-zen/event-system';
import type { PortfolioOrchestrator } from '../orchestration/portfolio-orchestrator';
import type { WorkflowGatesManager } from '../orchestration/workflow-gates';
import { WorkflowHumanGateType } from '../orchestration/workflow-gates';
import type {
  Epic,
  EpicStatus,
  Portfolio,
  PortfolioBacklog,
  PortfolioBudget,
  SAFeIntegrationConfig,
  StrategicTheme,
  ValueStream,
} from './index';
import type { ProgramIncrementManager } from './program-increment-manager';
import type { ValueStreamMapper } from './value-stream-mapper';

// ============================================================================
// PORTFOLIO MANAGER CONFIGURATION
// ============================================================================

/**
 * Portfolio Manager configuration
 */
export interface PortfolioManagerConfig {
  readonly enableBudgetTracking: boolean;
  readonly enableStrategicThemeTracking: boolean;
  readonly enableEpicInvestmentAnalysis: boolean;
  readonly enableValueStreamFunding: boolean;
  readonly enableLeanAgileBudgeting: boolean;
  readonly enableAGUIIntegration: boolean;
  readonly budgetPlanningCycle: 'quarterly' | 'annually' | 'continuous';
  readonly investmentAnalysisInterval: number; // milliseconds
  readonly budgetTrackingInterval: number; // milliseconds
  readonly portfolioReviewInterval: number; // milliseconds
  readonly maxEpicsInPortfolio: number;
  readonly maxValueStreamsPerPortfolio: number;
  readonly budgetThresholdAlertPercentage: number;
  readonly investmentApprovalThreshold: number; // $
}

/**
 * Portfolio budget configuration
 */
export interface PortfolioBudgetConfig {
  readonly portfolioId: string;
  readonly budgetCycle: BudgetCycle;
  readonly totalBudget: number;
  readonly allocations: BudgetAllocation[];
  readonly reserves: BudgetReserve[];
  readonly costCenters: CostCenter[];
  readonly approvalWorkflow: BudgetApprovalWorkflow;
  readonly trackingConfiguration: BudgetTrackingConfig;
}

/**
 * Budget cycle definition
 */
export interface BudgetCycle {
  readonly cycleId: string;
  readonly type: 'quarterly' | 'annual' | 'continuous';
  readonly startDate: Date;
  readonly endDate: Date;
  readonly planningPhases: BudgetPlanningPhase[];
  readonly reviewMilestones: BudgetReviewMilestone[];
}

/**
 * Budget planning phase
 */
export interface BudgetPlanningPhase {
  readonly phaseId: string;
  readonly name: string;
  readonly description: string;
  readonly startDate: Date;
  readonly endDate: Date;
  readonly activities: string[];
  readonly deliverables: string[];
  readonly participants: string[];
  readonly aguiGateRequired: boolean;
}

/**
 * Budget allocation
 */
export interface BudgetAllocation {
  readonly allocationId: string;
  readonly name: string;
  readonly type:
    | 'epic'
    | 'value-stream'
    | 'enabler'
    | 'operational'
    | 'innovation';
  readonly allocatedAmount: number;
  readonly spentAmount: number;
  readonly commitmentLevel: 'committed' | 'uncommitted' | 'exploration';
  readonly priority: number;
  readonly strategicAlignment: StrategicAlignment;
  readonly valueStreamId?: string;
  readonly epicIds?: string[];
  readonly costCenterId?: string;
  readonly owner: string;
  readonly startDate: Date;
  readonly endDate: Date;
  readonly fundingSource: FundingSource;
}

/**
 * Strategic alignment assessment
 */
export interface StrategicAlignment {
  readonly themeAlignment: Record<string, number>; // theme ID -> alignment score (0-10)
  readonly businessValue: number; // 0-10
  readonly strategicImportance: number; // 0-10
  readonly timeCriticality: number; // 0-10
  readonly riskAdjustment: number; // 0-10
  readonly overallScore: number; // calculated weighted score
}

/**
 * Funding source
 */
export interface FundingSource {
  readonly sourceId: string;
  readonly name: string;
  readonly type: 'capex' | 'opex' | 'innovation' | 'maintenance';
  readonly totalFunding: number;
  readonly availableFunding: number;
  readonly constraints: string[];
  readonly renewalDate?: Date;
}

/**
 * Budget reserve
 */
export interface BudgetReserve {
  readonly reserveId: string;
  readonly name: string;
  readonly purpose:
    | 'contingency'
    | 'innovation'
    | 'strategic-opportunity'
    | 'compliance';
  readonly amount: number;
  readonly usedAmount: number;
  readonly triggerCriteria: string[];
  readonly approvalRequired: boolean;
  readonly expirationDate?: Date;
}

/**
 * Cost center
 */
export interface CostCenter {
  readonly costCenterId: string;
  readonly name: string;
  readonly description: string;
  readonly manager: string;
  readonly budget: number;
  readonly actualSpend: number;
  readonly forecastSpend: number;
  readonly allocations: string[]; // Allocation Ds
  readonly trackingCategories: CostCategory[];
  readonly reportingFrequency: 'weekly' | 'monthly' | 'quarterly';
}

/**
 * Cost category
 */
export interface CostCategory {
  readonly categoryId: string;
  readonly name: string;
  readonly budget: number;
  readonly actualSpend: number;
  readonly forecasted: number;
  readonly variance: number;
  readonly variancePercentage: number;
}

/**
 * Epic investment analysis
 */
export interface EpicInvestmentAnalysis {
  readonly analysisId: string;
  readonly epicId: string;
  readonly analysisDate: Date;
  readonly investmentSummary: InvestmentSummary;
  readonly businessCase: BusinessCase;
  readonly financialProjection: FinancialProjection;
  readonly riskAssessment: InvestmentRiskAssessment;
  readonly recommendedAction: InvestmentRecommendation;
  readonly comparisonMetrics: EpicComparisonMetrics;
  readonly sensitivityAnalysis: SensitivityAnalysis;
}

/**
 * Investment summary
 */
export interface InvestmentSummary {
  readonly totalInvestment: number;
  readonly expectedReturn: number;
  readonly roi: number; // Return on Investment percentage
  readonly paybackPeriod: number; // months
  readonly npv: number; // Net Present Value
  readonly irr: number; // Internal Rate of Return percentage
  readonly investmentHorizon: number; // months
  readonly riskLevel: 'low' | 'medium' | 'high' | 'very-high';
}

/**
 * Business case
 */
export interface BusinessCase {
  readonly problemStatement: string;
  readonly proposedSolution: string;
  readonly businessObjectives: string[];
  readonly successCriteria: string[];
  readonly assumptions: string[];
  readonly constraints: string[];
  readonly alternativesConsidered: string[];
  readonly recommendedApproach: string;
}

/**
 * Financial projection
 */
export interface FinancialProjection {
  readonly projectionPeriod: number; // months
  readonly developmentCosts: CostBreakdown;
  readonly operationalCosts: CostBreakdown;
  readonly revenueProjection: RevenueProjection;
  readonly cashFlow: CashFlowProjection[];
  readonly breakEvenPoint: number; // months
  readonly financialRisks: FinancialRisk[];
}

/**
 * Cost breakdown
 */
export interface CostBreakdown {
  readonly personnel: number;
  readonly technology: number;
  readonly infrastructure: number;
  readonly external: number;
  readonly overhead: number;
  readonly contingency: number;
  readonly total: number;
}

/**
 * Revenue projection
 */
export interface RevenueProjection {
  readonly directRevenue: number;
  readonly indirectRevenue: number;
  readonly costSavings: number;
  readonly riskMitigation: number;
  readonly strategicValue: number;
  readonly total: number;
}

/**
 * Cash flow projection
 */
export interface CashFlowProjection {
  readonly period: number; // month
  readonly investment: number; // negative for outflows
  readonly returns: number; // positive for inflows
  readonly netCashFlow: number;
  readonly cumulativeCashFlow: number;
}

/**
 * Investment risk assessment
 */
export interface InvestmentRiskAssessment {
  readonly overallRiskScore: number; // 0-10
  readonly riskCategories: RiskCategory[];
  readonly mitigationStrategies: RiskMitigation[];
  readonly riskTolerance: 'low' | 'medium' | 'high';
  readonly contingencyRecommendations: string[];
}

/**
 * Risk category
 */
export interface RiskCategory {
  readonly category:
    | 'technical'
    | 'market'
    | 'execution'
    | 'financial'
    | 'regulatory';
  readonly riskScore: number; // 0-10
  readonly impact: 'low' | 'medium' | 'high' | 'critical';
  readonly probability: 'low' | 'medium' | 'high' | 'very-high';
  readonly description: string;
  readonly mitigationActions: string[];
}

/**
 * Risk mitigation
 */
export interface RiskMitigation {
  readonly riskId: string;
  readonly mitigationStrategy: string;
  readonly estimatedCost: number;
  readonly timeline: number; // days
  readonly effectiveness: number; // 0-10
  readonly responsible: string;
}

/**
 * Investment recommendation
 */
export interface InvestmentRecommendation {
  readonly recommendation:
    | 'approve'
    | 'approve-conditional'
    | 'defer'
    | 'reject';
  readonly rationale: string;
  readonly conditions?: string[];
  readonly alternativeOptions?: string[];
  readonly nextSteps: string[];
  readonly reviewDate?: Date;
  readonly confidenceLevel: number; // 0-10
}

/**
 * Epic comparison metrics
 */
export interface EpicComparisonMetrics {
  readonly valueScore: number; // 0-100
  readonly feasibilityScore: number; // 0-100
  readonly riskScore: number; // 0-100 (lower is better)
  readonly strategicFitScore: number; // 0-100
  readonly competitiveRanking: number; // rank among all epics
  readonly priorityWeightedScore: number;
}

/**
 * Sensitivity analysis
 */
export interface SensitivityAnalysis {
  readonly scenarios: InvestmentScenario[];
  readonly keyVariables: SensitivityVariable[];
  readonly breakEvenAnalysis: BreakEvenAnalysis;
  readonly monteCarlo?: MonteCarloResults;
}

/**
 * Investment scenario
 */
export interface InvestmentScenario {
  readonly scenarioName: string;
  readonly probability: number; // 0-1
  readonly assumptions: Record<string, number>;
  readonly projectedRoi: number;
  readonly projectedNpv: number;
  readonly projectedPayback: number;
}

/**
 * Sensitivity variable
 */
export interface SensitivityVariable {
  readonly variable: string;
  readonly baseValue: number;
  readonly lowValue: number;
  readonly highValue: number;
  readonly impactOnRoi: number; // percentage change in ROI
  readonly impactOnNpv: number; // change in NPV
}

/**
 * Strategic theme tracking
 */
export interface StrategicThemeTracking {
  readonly themeId: string;
  readonly trackingPeriod: DateRange;
  readonly progressMetrics: ThemeProgressMetrics;
  readonly budgetUtilization: ThemeBudgetUtilization;
  readonly epicContributions: EpicContribution[];
  readonly kpiPerformance: KPIPerformance[];
  readonly milestoneTracking: MilestoneTracking[];
  readonly riskIndicators: ThemeRiskIndicator[];
}

/**
 * Theme progress metrics
 */
export interface ThemeProgressMetrics {
  readonly overallProgress: number; // 0-100%
  readonly epicsProgress: number; // 0-100%
  readonly milestonesAchieved: number;
  readonly totalMilestones: number;
  readonly valueDelivered: number; // $
  readonly targetValue: number; // $
  readonly scheduleVariance: number; // days
  readonly scopeVariance: number; // percentage
}

/**
 * Theme budget utilization
 */
export interface ThemeBudgetUtilization {
  readonly allocatedBudget: number;
  readonly committedBudget: number;
  readonly actualSpend: number;
  readonly forecastedSpend: number;
  readonly burnRate: number; // $ per day
  readonly projectedCompletion: Date;
  readonly budgetVariance: number;
  readonly costPerformanceIndex: number; // earned value / actual cost
}

/**
 * Epic contribution to theme
 */
export interface EpicContribution {
  readonly epicId: string;
  readonly epicName: string;
  readonly contributionPercentage: number; // 0-100
  readonly currentProgress: number; // 0-100
  readonly budgetContribution: number;
  readonly valueContribution: number;
  readonly riskContribution: number;
  readonly strategicAlignment: number; // 0-10
}

/**
 * KPI performance
 */
export interface KPIPerformance {
  readonly kpiId: string;
  readonly kpiName: string;
  readonly targetValue: number;
  readonly currentValue: number;
  readonly previousValue: number;
  readonly trend: 'improving' | 'stable' | 'declining';
  readonly performanceGap: number;
  readonly achievementRate: number; // 0-100%
}

/**
 * Milestone tracking
 */
export interface MilestoneTracking {
  readonly milestoneId: string;
  readonly milestoneName: string;
  readonly plannedDate: Date;
  readonly forecastedDate: Date;
  readonly actualDate?: Date;
  readonly status:
    | 'not-started'
    | 'in-progress'
    | 'at-risk'
    | 'completed'
    | 'delayed';
  readonly criticalPath: boolean;
  readonly dependencies: string[];
  readonly deliverables: string[];
}

/**
 * Theme risk indicator
 */
export interface ThemeRiskIndicator {
  readonly indicatorId: string;
  readonly riskType: 'budget' | 'schedule' | 'scope' | 'quality' | 'strategic';
  readonly riskLevel: 'low' | 'medium' | 'high' | 'critical';
  readonly description: string;
  readonly impact: string;
  readonly mitigation: string;
  readonly owner: string;
  readonly dueDate: Date;
}

// ============================================================================
// PORTFOLIO MANAGER STATE
// ============================================================================

/**
 * Portfolio Manager state
 */
export interface PortfolioManagerState {
  readonly portfolios: Map<string, Portfolio>;
  readonly portfolioBudgets: Map<string, PortfolioBudgetConfig>;
  readonly strategicThemes: Map<string, StrategicTheme>;
  readonly epicInvestmentAnalyses: Map<string, EpicInvestmentAnalysis>;
  readonly themeTracking: Map<string, StrategicThemeTracking>;
  readonly budgetAllocations: Map<string, BudgetAllocation>;
  readonly costCenters: Map<string, CostCenter>;
  readonly fundingSources: Map<string, FundingSource>;
  readonly lastBudgetReview: Date;
  readonly lastThemeReview: Date;
  readonly lastInvestmentAnalysis: Date;
}

// ============================================================================
// PORTFOLIO MANAGER - Main Implementation
// ============================================================================

/**
 * Portfolio Manager - SAFe Lean Portfolio Management
 */
export class PortfolioManager extends EventEmitter {
  private readonly logger: Logger;
  private readonly eventBus: TypeSafeEventBus;
  private readonly memory: MemorySystem;
  private readonly gatesManager: WorkflowGatesManager;
  private readonly portfolioOrchestrator: PortfolioOrchestrator;
  private readonly valueStreamMapper: ValueStreamMapper;
  private readonly piManager: ProgramIncrementManager;
  private readonly config: PortfolioManagerConfig;

  private state: PortfolioManagerState;
  private budgetTrackingTimer?: NodeJS.Timeout;
  private investmentAnalysisTimer?: NodeJS.Timeout;
  private portfolioReviewTimer?: NodeJS.Timeout;

  constructor(
    eventBus: TypeSafeEventBus,
    memory: MemorySystem,
    gatesManager: WorkflowGatesManager,
    portfolioOrchestrator: PortfolioOrchestrator,
    valueStreamMapper: ValueStreamMapper,
    piManager: ProgramIncrementManager,
    config: Partial<PortfolioManagerConfig> = {}
  ) {
    super();

    this.logger = getLogger('portfolio-manager');
    this.eventBus = eventBus;
    this.memory = memory;
    this.gatesManager = gatesManager;
    this.portfolioOrchestrator = portfolioOrchestrator;
    this.valueStreamMapper = valueStreamMapper;
    this.piManager = piManager;

    this.config = {
      enableBudgetTracking: true,
      enableStrategicThemeTracking: true,
      enableEpicInvestmentAnalysis: true,
      enableValueStreamFunding: true,
      enableLeanAgileBudgeting: true,
      enableAGUIIntegration: true,
      budgetPlanningCycle: 'quarterly',
      investmentAnalysisInterval: 86400000, // 24 hours
      budgetTrackingInterval: 3600000, // 1 hour
      portfolioReviewInterval: 604800000, // 7 days
      maxEpicsInPortfolio: 100,
      maxValueStreamsPerPortfolio: 10,
      budgetThresholdAlertPercentage: 85,
      investmentApprovalThreshold: 1000000, // $1M
      ...config,
    };

    this.state = this.initializeState();
  }

  // ============================================================================
  // LIFECYCLE MANAGEMENT
  // ============================================================================

  /**
   * Initialize the Portfolio Manager
   */
  async initialize(): Promise<void> {
    this.logger.info('Initializing Portfolio Manager', {
      config: this.config,
    });

    try {
      // Load persisted state
      await this.loadPersistedState();

      // Start background processes
      if (this.config.enableBudgetTracking) {
        this.startBudgetTracking();
      }

      if (this.config.enableEpicInvestmentAnalysis) {
        this.startInvestmentAnalysis();
      }

      this.startPortfolioReview();

      // Register event handlers
      this.registerEventHandlers();

      this.logger.info('Portfolio Manager initialized successfully');
      this.emit('initialized');
    } catch (error) {
      this.logger.error('Failed to initialize Portfolio Manager', { error });
      throw error;
    }
  }

  /**
   * Shutdown the Portfolio Manager
   */
  async shutdown(): Promise<void> {
    this.logger.info('Shutting down Portfolio Manager');

    // Stop background processes
    if (this.budgetTrackingTimer) clearInterval(this.budgetTrackingTimer);
    if (this.investmentAnalysisTimer)
      clearInterval(this.investmentAnalysisTimer);
    if (this.portfolioReviewTimer) clearInterval(this.portfolioReviewTimer);

    await this.persistState();
    this.removeAllListeners();

    this.logger.info('Portfolio Manager shutdown complete');
  }

  // ============================================================================
  // PORTFOLIO BUDGET MANAGEMENT - Task 14.1
  // ============================================================================

  /**
   * Plan portfolio budget allocation
   */
  async planPortfolioBudget(
    portfolioId: string,
    budgetCycle: BudgetCycle,
    totalBudget: number,
    strategicThemes: StrategicTheme[],
    valueStreams: ValueStream[]
  ): Promise<PortfolioBudgetConfig> {
    this.logger.info('Planning portfolio budget allocation', {
      portfolioId,
      totalBudget,
      themeCount: strategicThemes.length,
    });

    // Create budget planning workflow with AGUI integration
    const planningWorkflow = await this.createBudgetPlanningWorkflow(
      portfolioId,
      budgetCycle,
      totalBudget,
      strategicThemes
    );

    // Execute budget planning phases with gates
    const budgetAllocations = await this.executeBudgetPlanningPhases(
      planningWorkflow,
      valueStreams
    );

    // Create cost centers and funding sources
    const costCenters = await this.createCostCenters(
      portfolioId,
      budgetAllocations
    );
    const fundingSources = await this.createFundingSources(
      totalBudget,
      budgetAllocations
    );

    // Create budget reserves
    const reserves = await this.calculateBudgetReserves(
      totalBudget,
      budgetAllocations
    );

    // Setup budget tracking configuration
    const trackingConfig = await this.createBudgetTrackingConfig(
      portfolioId,
      budgetCycle
    );

    // Create approval workflow
    const approvalWorkflow = await this.createBudgetApprovalWorkflow(
      portfolioId,
      totalBudget,
      budgetAllocations
    );

    const portfolioBudgetConfig: PortfolioBudgetConfig = {
      portfolioId,
      budgetCycle,
      totalBudget,
      allocations: budgetAllocations,
      reserves,
      costCenters,
      approvalWorkflow,
      trackingConfiguration: trackingConfig,
    };

    // Store in state
    this.state.portfolioBudgets.set(portfolioId, portfolioBudgetConfig);
    budgetAllocations.forEach((allocation) =>
      this.state.budgetAllocations.set(allocation.allocationId, allocation)
    );
    costCenters.forEach((center) =>
      this.state.costCenters.set(center.costCenterId, center)
    );
    fundingSources.forEach((source) =>
      this.state.fundingSources.set(source.sourceId, source)
    );

    this.logger.info('Portfolio budget planning completed', {
      portfolioId,
      totalAllocations: budgetAllocations.length,
      totalReserves: reserves.length,
    });

    this.emit('portfolio-budget-planned', portfolioBudgetConfig);
    return portfolioBudgetConfig;
  }

  /**
   * Allocate budget to value streams
   */
  async allocateValueStreamFunding(
    portfolioId: string,
    valueStreamId: string,
    fundingRequest: ValueStreamFundingRequest
  ): Promise<BudgetAllocation> {
    this.logger.info('Allocating value stream funding', {
      portfolioId,
      valueStreamId,
      requestedAmount: fundingRequest.requestedAmount,
    });

    const portfolioBudget = this.state.portfolioBudgets.get(portfolioId);
    if (!portfolioBudget) {
      throw new Error(`Portfolio budget not found: ${portfolioId}`);
    }

    // Analyze funding request
    const fundingAnalysis = await this.analyzeValueStreamFundingRequest(
      fundingRequest,
      portfolioBudget
    );

    // Create AGUI gate for funding approval if above threshold
    if (
      fundingRequest.requestedAmount > this.config.investmentApprovalThreshold
    ) {
      await this.createFundingApprovalGate(fundingRequest, fundingAnalysis);
    }

    // Create strategic alignment assessment
    const strategicAlignment = await this.assessStrategicAlignment(
      valueStreamId,
      fundingRequest,
      this.state.strategicThemes
    );

    // Create budget allocation
    const allocation: BudgetAllocation = {
      allocationId: `alloc-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
      name: fundingRequest.name,
      type: fundingRequest.type,
      allocatedAmount: fundingRequest.requestedAmount,
      spentAmount: 0,
      commitmentLevel: fundingRequest.commitmentLevel,
      priority: fundingRequest.priority,
      strategicAlignment,
      valueStreamId,
      epicIds: fundingRequest.epicIds,
      costCenterId: fundingRequest.costCenterId,
      owner: fundingRequest.owner,
      startDate: fundingRequest.startDate,
      endDate: fundingRequest.endDate,
      fundingSource: await this.selectOptimalFundingSource(
        fundingRequest.requestedAmount,
        fundingRequest.type
      ),
    };

    // Update portfolio budget
    this.updatePortfolioBudgetWithAllocation(portfolioId, allocation);

    // Store allocation
    this.state.budgetAllocations.set(allocation.allocationId, allocation);

    this.logger.info('Value stream funding allocated', {
      allocationId: allocation.allocationId,
      valueStreamId,
      amount: allocation.allocatedAmount,
    });

    this.emit('value-stream-funding-allocated', allocation);
    return allocation;
  }

  /**
   * Track budget utilization and spend
   */
  async trackBudgetUtilization(
    portfolioId: string
  ): Promise<PortfolioBudgetUtilization> {
    const portfolioBudget = this.state.portfolioBudgets.get(portfolioId);
    if (!portfolioBudget) {
      throw new Error(`Portfolio budget not found: ${portfolioId}`);
    }

    this.logger.debug('Tracking budget utilization', { portfolioId });

    // Calculate overall utilization
    const totalAllocated = portfolioBudget.allocations.reduce(
      (sum, alloc) => sum + alloc.allocatedAmount,
      0
    );
    const totalSpent = portfolioBudget.allocations.reduce(
      (sum, alloc) => sum + alloc.spentAmount,
      0
    );

    // Calculate by category
    const utilizationByCategory = await this.calculateUtilizationByCategory(
      portfolioBudget.allocations
    );

    // Calculate burn rate and forecast
    const burnRateAnalysis = await this.analyzeBurnRate(portfolioBudget);

    // Identify budget risks and alerts
    const budgetRisks = await this.identifyBudgetRisks(portfolioBudget);
    const budgetAlerts = await this.generateBudgetAlerts(
      portfolioBudget,
      burnRateAnalysis
    );

    const utilization: PortfolioBudgetUtilization = {
      portfolioId,
      totalBudget: portfolioBudget.totalBudget,
      totalAllocated,
      totalSpent,
      totalAvailable: portfolioBudget.totalBudget - totalAllocated,
      utilizationPercentage:
        (totalAllocated / portfolioBudget.totalBudget) * 100,
      spendPercentage: (totalSpent / portfolioBudget.totalBudget) * 100,
      burnRate: burnRateAnalysis.averageBurnRate,
      projectedCompletion: burnRateAnalysis.projectedCompletion,
      utilizationByCategory,
      budgetRisks,
      budgetAlerts,
      forecastAccuracy: await this.calculateForecastAccuracy(portfolioId),
      lastUpdated: new Date(),
    };

    // Check for threshold alerts
    if (
      utilization.utilizationPercentage >
      this.config.budgetThresholdAlertPercentage
    ) {
      await this.createBudgetThresholdAlert(utilization);
    }

    this.emit('budget-utilization-updated', utilization);
    return utilization;
  }

  // ============================================================================
  // STRATEGIC THEME MANAGEMENT - Task 14.2
  // ============================================================================

  /**
   * Define and track strategic themes
   */
  async defineStrategicTheme(
    portfolioId: string,
    themeDefinition: StrategicThemeDefinition
  ): Promise<StrategicTheme> {
    this.logger.info('Defining strategic theme', {
      portfolioId,
      themeName: themeDefinition.name,
    });

    // Create strategic theme with comprehensive tracking
    const strategicTheme: StrategicTheme = {
      id: `theme-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
      name: themeDefinition.name,
      description: themeDefinition.description,
      objectives: themeDefinition.objectives,
      kpis: await this.createThemeKPIs(themeDefinition),
      budgetAllocation: themeDefinition.budgetAllocation,
      timeHorizon: themeDefinition.timeHorizon,
      owner: themeDefinition.owner,
      stakeholders: themeDefinition.stakeholders,
      status: 'active',
      portfolioId,
      createdAt: new Date(),
      milestones: await this.createThemeMilestones(themeDefinition),
      riskProfile: await this.assessThemeRiskProfile(themeDefinition),
    };

    // Setup theme tracking
    const themeTracking = await this.setupThemeTracking(strategicTheme);

    // Store in state
    this.state.strategicThemes.set(strategicTheme.id, strategicTheme);
    this.state.themeTracking.set(strategicTheme.id, themeTracking);

    // Create AGUI gate for theme approval
    if (this.config.enableAGUIIntegration) {
      await this.createThemeApprovalGate(strategicTheme, themeDefinition);
    }

    this.logger.info('Strategic theme defined', {
      themeId: strategicTheme.id,
      portfolioId,
    });

    this.emit('strategic-theme-defined', strategicTheme);
    return strategicTheme;
  }

  /**
   * Track strategic theme progress and alignment
   */
  async trackStrategicThemeProgress(
    themeId: string
  ): Promise<StrategicThemeTracking> {
    const theme = this.state.strategicThemes.get(themeId);
    if (!theme) {
      throw new Error(`Strategic theme not found: ${themeId}`);
    }

    this.logger.debug('Tracking strategic theme progress', { themeId });

    const trackingPeriod: DateRange = {
      start: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000), // Last 30 days
      end: new Date(),
    };

    // Calculate progress metrics
    const progressMetrics = await this.calculateThemeProgressMetrics(theme);

    // Calculate budget utilization
    const budgetUtilization = await this.calculateThemeBudgetUtilization(theme);

    // Assess epic contributions
    const epicContributions = await this.assessEpicContributionsToTheme(theme);

    // Track KPI performance
    const kpiPerformance = await this.trackThemeKPIPerformance(theme);

    // Update milestone tracking
    const milestoneTracking = await this.updateThemeMilestoneTracking(theme);

    // Identify risk indicators
    const riskIndicators = await this.identifyThemeRiskIndicators(
      theme,
      progressMetrics
    );

    const themeTracking: StrategicThemeTracking = {
      themeId,
      trackingPeriod,
      progressMetrics,
      budgetUtilization,
      epicContributions,
      kpiPerformance,
      milestoneTracking,
      riskIndicators,
    };

    // Update state
    this.state.themeTracking.set(themeId, themeTracking);

    // Create alerts if needed
    await this.createThemeProgressAlerts(themeTracking);

    this.emit('strategic-theme-progress-updated', themeTracking);
    return themeTracking;
  }

  // ============================================================================
  // EPIC NVESTMENT ANALYSIS - Task 14.3
  // ============================================================================

  /**
   * Analyze epic investment and ROI
   */
  async analyzeEpicInvestment(
    epicId: string,
    epic: Epic
  ): Promise<EpicInvestmentAnalysis> {
    this.logger.info('Analyzing epic investment', {
      epicId,
      epicName: epic.name,
    });

    const analysisId = `analysis-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;

    // Create business case
    const businessCase = await this.createEpicBusinessCase(epic);

    // Calculate financial projections
    const financialProjection =
      await this.calculateEpicFinancialProjection(epic);

    // Calculate investment summary metrics
    const investmentSummary = await this.calculateInvestmentSummary(
      epic,
      financialProjection
    );

    // Assess investment risks
    const riskAssessment = await this.assessEpicInvestmentRisks(
      epic,
      financialProjection
    );

    // Generate comparison metrics
    const comparisonMetrics = await this.generateEpicComparisonMetrics(epic);

    // Perform sensitivity analysis
    const sensitivityAnalysis = await this.performSensitivityAnalysis(
      epic,
      financialProjection
    );

    // Generate investment recommendation
    const recommendedAction = await this.generateInvestmentRecommendation(
      investmentSummary,
      riskAssessment,
      comparisonMetrics
    );

    const analysis: EpicInvestmentAnalysis = {
      analysisId,
      epicId,
      analysisDate: new Date(),
      investmentSummary,
      businessCase,
      financialProjection,
      riskAssessment,
      recommendedAction,
      comparisonMetrics,
      sensitivityAnalysis,
    };

    // Store analysis
    this.state.epicInvestmentAnalyses.set(epicId, analysis);

    // Create AGUI gate for high-value investments
    if (
      investmentSummary.totalInvestment >
      this.config.investmentApprovalThreshold
    ) {
      await this.createEpicInvestmentApprovalGate(analysis);
    }

    this.logger.info('Epic investment analysis completed', {
      epicId,
      totalInvestment: investmentSummary.totalInvestment,
      expectedROI: investmentSummary.roi,
      recommendation: recommendedAction.recommendation,
    });

    this.emit('epic-investment-analyzed', analysis);
    return analysis;
  }

  /**
   * Compare and prioritize epic investments
   */
  async prioritizeEpicInvestments(
    portfolioId: string
  ): Promise<EpicInvestmentPrioritization> {
    this.logger.info('Prioritizing epic investments', { portfolioId });

    const portfolio = this.state.portfolios.get(portfolioId);
    if (!portfolio) {
      throw new Error(`Portfolio not found: ${portfolioId}`);
    }

    // Get all epic analyses for the portfolio
    const epicAnalyses = Array.from(
      this.state.epicInvestmentAnalyses.values()
    ).filter((analysis) => {
      // Check if epic belongs to this portfolio (simplified logic)
      return true; // Would need proper portfolio-epic relationship
    });

    // Apply multi-criteria decision analysis
    const prioritizationCriteria =
      await this.definePrioritizationCriteria(portfolioId);
    const scoredEpics = await this.scoreEpicsAgainstCriteria(
      epicAnalyses,
      prioritizationCriteria
    );

    // Create portfolio optimization model
    const optimizationResult = await this.optimizeEpicPortfolio(
      scoredEpics,
      this.state.portfolioBudgets.get(portfolioId)
    );

    // Generate final prioritization
    const prioritization: EpicInvestmentPrioritization = {
      portfolioId,
      analysisDate: new Date(),
      criteria: prioritizationCriteria,
      scoredEpics,
      optimizationResult,
      recommendedPortfolio: optimizationResult.recommendedEpics,
      budgetUtilization: optimizationResult.totalBudgetRequired,
      expectedReturn: optimizationResult.totalExpectedReturn,
      riskProfile: optimizationResult.portfolioRiskProfile,
      alternativeScenarios:
        await this.generateAlternativePortfolioScenarios(optimizationResult),
    };

    this.emit('epic-investments-prioritized', prioritization);
    return prioritization;
  }

  // ============================================================================
  // PRIVATE MPLEMENTATION METHODS
  // ============================================================================

  private initializeState(): PortfolioManagerState {
    return {
      portfolios: new Map(),
      portfolioBudgets: new Map(),
      strategicThemes: new Map(),
      epicInvestmentAnalyses: new Map(),
      themeTracking: new Map(),
      budgetAllocations: new Map(),
      costCenters: new Map(),
      fundingSources: new Map(),
      lastBudgetReview: new Date(),
      lastThemeReview: new Date(),
      lastInvestmentAnalysis: new Date(),
    };
  }

  private async loadPersistedState(): Promise<void> {
    try {
      const persistedState = await this.memory.retrieve(
        'portfolio-manager:state'
      );
      if (persistedState) {
        this.state = {
          ...this.state,
          ...persistedState,
          portfolios: new Map(persistedState.portfolios || []),
          portfolioBudgets: new Map(persistedState.portfolioBudgets || []),
          strategicThemes: new Map(persistedState.strategicThemes || []),
          epicInvestmentAnalyses: new Map(
            persistedState.epicInvestmentAnalyses || []
          ),
          themeTracking: new Map(persistedState.themeTracking || []),
          budgetAllocations: new Map(persistedState.budgetAllocations || []),
          costCenters: new Map(persistedState.costCenters || []),
          fundingSources: new Map(persistedState.fundingSources || []),
        };
        this.logger.info('Portfolio Manager state loaded');
      }
    } catch (error) {
      this.logger.warn('Failed to load persisted state', { error });
    }
  }

  private async persistState(): Promise<void> {
    try {
      const stateToSerialize = {
        ...this.state,
        portfolios: Array.from(this.state.portfolios.entries()),
        portfolioBudgets: Array.from(this.state.portfolioBudgets.entries()),
        strategicThemes: Array.from(this.state.strategicThemes.entries()),
        epicInvestmentAnalyses: Array.from(
          this.state.epicInvestmentAnalyses.entries()
        ),
        themeTracking: Array.from(this.state.themeTracking.entries()),
        budgetAllocations: Array.from(this.state.budgetAllocations.entries()),
        costCenters: Array.from(this.state.costCenters.entries()),
        fundingSources: Array.from(this.state.fundingSources.entries()),
      };

      await this.memory.store('portfolio-manager:state', stateToSerialize);
    } catch (error) {
      this.logger.error('Failed to persist state', { error });
    }
  }

  private startBudgetTracking(): void {
    this.budgetTrackingTimer = setInterval(async () => {
      try {
        await this.updateAllBudgetUtilization();
      } catch (error) {
        this.logger.error('Budget tracking update failed', { error });
      }
    }, this.config.budgetTrackingInterval);
  }

  private startInvestmentAnalysis(): void {
    this.investmentAnalysisTimer = setInterval(async () => {
      try {
        await this.updateAllInvestmentAnalyses();
      } catch (error) {
        this.logger.error('Investment analysis update failed', { error });
      }
    }, this.config.investmentAnalysisInterval);
  }

  private startPortfolioReview(): void {
    this.portfolioReviewTimer = setInterval(async () => {
      try {
        await this.performPortfolioHealthCheck();
      } catch (error) {
        this.logger.error('Portfolio review failed', { error });
      }
    }, this.config.portfolioReviewInterval);
  }

  private registerEventHandlers(): void {
    this.eventBus.registerHandler('epic-completed', async (event) => {
      await this.handleEpicCompletion(event.payload.epicId);
    });

    this.eventBus.registerHandler(
      'budget-threshold-exceeded',
      async (event) => {
        await this.handleBudgetThresholdExceeded(event.payload);
      }
    );

    this.eventBus.registerHandler(
      'strategic-theme-milestone-reached',
      async (event) => {
        await this.handleThemeMilestoneReached(event.payload);
      }
    );
  }

  // Many placeholder implementations would follow...

  private async createBudgetPlanningWorkflow(
    portfolioId: string,
    budgetCycle: BudgetCycle,
    totalBudget: number,
    strategicThemes: StrategicTheme[]
  ): Promise<unknown> {
    // Placeholder implementation
    return {};
  }

  private async executeBudgetPlanningPhases(
    workflow: unknown,
    valueStreams: ValueStream[]
  ): Promise<BudgetAllocation[]> {
    // Placeholder implementation
    return [];
  }

  // Additional placeholder methods would continue...
  private async createCostCenters(
    portfolioId: string,
    allocations: BudgetAllocation[]
  ): Promise<CostCenter[]> {
    return [];
  }
  private async createFundingSources(
    totalBudget: number,
    allocations: BudgetAllocation[]
  ): Promise<FundingSource[]> {
    return [];
  }
  private async calculateBudgetReserves(
    totalBudget: number,
    allocations: BudgetAllocation[]
  ): Promise<BudgetReserve[]> {
    return [];
  }
  private async createBudgetTrackingConfig(
    portfolioId: string,
    budgetCycle: BudgetCycle
  ): Promise<BudgetTrackingConfig> {
    return {} as BudgetTrackingConfig;
  }
  private async createBudgetApprovalWorkflow(
    portfolioId: string,
    totalBudget: number,
    allocations: BudgetAllocation[]
  ): Promise<BudgetApprovalWorkflow> {
    return {} as BudgetApprovalWorkflow;
  }
  private async analyzeValueStreamFundingRequest(
    request: ValueStreamFundingRequest,
    budget: PortfolioBudgetConfig
  ): Promise<unknown> {
    return {};
  }
  private async createFundingApprovalGate(
    request: any,
    analysis: unknown
  ): Promise<void> {}
  private async assessStrategicAlignment(
    valueStreamId: string,
    request: any,
    themes: Map<string, StrategicTheme>
  ): Promise<StrategicAlignment> {
    return {} as StrategicAlignment;
  }
  private async selectOptimalFundingSource(
    amount: number,
    type: string
  ): Promise<FundingSource> {
    return {} as FundingSource;
  }
  private updatePortfolioBudgetWithAllocation(
    portfolioId: string,
    allocation: BudgetAllocation
  ): void {}
  private async calculateUtilizationByCategory(
    allocations: BudgetAllocation[]
  ): Promise<unknown> {
    return {};
  }
  private async analyzeBurnRate(
    budget: PortfolioBudgetConfig
  ): Promise<unknown> {
    return { averageBurnRate: 0, projectedCompletion: new Date() };
  }
  private async identifyBudgetRisks(
    budget: PortfolioBudgetConfig
  ): Promise<any[]> {
    return [];
  }
  private async generateBudgetAlerts(
    budget: PortfolioBudgetConfig,
    burnRate: unknown
  ): Promise<any[]> {
    return [];
  }
  private async calculateForecastAccuracy(
    portfolioId: string
  ): Promise<number> {
    return 0;
  }
  private async createBudgetThresholdAlert(
    utilization: unknown
  ): Promise<void> {}
  private async createThemeKPIs(definition: unknown): Promise<any[]> {
    return [];
  }
  private async createThemeMilestones(definition: unknown): Promise<any[]> {
    return [];
  }
  private async assessThemeRiskProfile(definition: unknown): Promise<unknown> {
    return {};
  }
  private async setupThemeTracking(
    theme: StrategicTheme
  ): Promise<StrategicThemeTracking> {
    return {} as StrategicThemeTracking;
  }
  private async createThemeApprovalGate(
    theme: StrategicTheme,
    definition: unknown
  ): Promise<void> {}
  private async calculateThemeProgressMetrics(
    theme: StrategicTheme
  ): Promise<ThemeProgressMetrics> {
    return {} as ThemeProgressMetrics;
  }
  private async calculateThemeBudgetUtilization(
    theme: StrategicTheme
  ): Promise<ThemeBudgetUtilization> {
    return {} as ThemeBudgetUtilization;
  }
  private async assessEpicContributionsToTheme(
    theme: StrategicTheme
  ): Promise<EpicContribution[]> {
    return [];
  }
  private async trackThemeKPIPerformance(
    theme: StrategicTheme
  ): Promise<KPIPerformance[]> {
    return [];
  }
  private async updateThemeMilestoneTracking(
    theme: StrategicTheme
  ): Promise<MilestoneTracking[]> {
    return [];
  }
  private async identifyThemeRiskIndicators(
    theme: StrategicTheme,
    progress: ThemeProgressMetrics
  ): Promise<ThemeRiskIndicator[]> {
    return [];
  }
  private async createThemeProgressAlerts(
    tracking: StrategicThemeTracking
  ): Promise<void> {}
  private async createEpicBusinessCase(epic: Epic): Promise<BusinessCase> {
    return {} as BusinessCase;
  }
  private async calculateEpicFinancialProjection(
    epic: Epic
  ): Promise<FinancialProjection> {
    return {} as FinancialProjection;
  }
  private async calculateInvestmentSummary(
    epic: Epic,
    projection: FinancialProjection
  ): Promise<InvestmentSummary> {
    return {} as InvestmentSummary;
  }
  private async assessEpicInvestmentRisks(
    epic: Epic,
    projection: FinancialProjection
  ): Promise<InvestmentRiskAssessment> {
    return {} as InvestmentRiskAssessment;
  }
  private async generateEpicComparisonMetrics(
    epic: Epic
  ): Promise<EpicComparisonMetrics> {
    return {} as EpicComparisonMetrics;
  }
  private async performSensitivityAnalysis(
    epic: Epic,
    projection: FinancialProjection
  ): Promise<SensitivityAnalysis> {
    return {} as SensitivityAnalysis;
  }
  private async generateInvestmentRecommendation(
    summary: InvestmentSummary,
    risk: InvestmentRiskAssessment,
    comparison: EpicComparisonMetrics
  ): Promise<InvestmentRecommendation> {
    return {} as InvestmentRecommendation;
  }
  private async createEpicInvestmentApprovalGate(
    analysis: EpicInvestmentAnalysis
  ): Promise<void> {}
  private async definePrioritizationCriteria(
    portfolioId: string
  ): Promise<unknown> {
    return {};
  }
  private async scoreEpicsAgainstCriteria(
    analyses: EpicInvestmentAnalysis[],
    criteria: unknown
  ): Promise<any[]> {
    return [];
  }
  private async optimizeEpicPortfolio(
    scoredEpics: unknown[],
    budget?: PortfolioBudgetConfig
  ): Promise<unknown> {
    return {
      recommendedEpics: [],
      totalBudgetRequired: 0,
      totalExpectedReturn: 0,
      portfolioRiskProfile: {},
    };
  }
  private async generateAlternativePortfolioScenarios(
    optimization: unknown
  ): Promise<any[]> {
    return [];
  }
  private async updateAllBudgetUtilization(): Promise<void> {}
  private async updateAllInvestmentAnalyses(): Promise<void> {}
  private async performPortfolioHealthCheck(): Promise<void> {}
  private async handleEpicCompletion(epicId: string): Promise<void> {}
  private async handleBudgetThresholdExceeded(
    payload: unknown
  ): Promise<void> {}
  private async handleThemeMilestoneReached(payload: any): Promise<void> {}
}

// ============================================================================
// SUPPORTING TYPES
// ============================================================================

export interface BudgetApprovalWorkflow {
  readonly workflowId: string;
  readonly approvalSteps: ApprovalStep[];
  readonly escalationRules: EscalationRule[];
  readonly notificationConfig: NotificationConfig;
}

export interface ApprovalStep {
  readonly stepId: string;
  readonly name: string;
  readonly approvers: string[];
  readonly requiredApprovals: number;
  readonly timeoutHours: number;
  readonly escalationRules: string[];
}

export interface EscalationRule {
  readonly ruleId: string;
  readonly trigger: string;
  readonly escalateTo: string[];
  readonly delayHours: number;
  readonly maxEscalations: number;
}

export interface NotificationConfig {
  readonly channels: string[];
  readonly recipients: string[];
  readonly templates: Record<string, string>;
  readonly frequency: 'immediate' | 'daily' | 'weekly';
}

export interface BudgetTrackingConfig {
  readonly portfolioId: string;
  readonly trackingFrequency: 'real-time' | 'hourly' | 'daily' | 'weekly';
  readonly alertThresholds: AlertThreshold[];
  readonly reportingSchedule: ReportingSchedule;
  readonly integrations: Integration[];
}

export interface AlertThreshold {
  readonly metric: string;
  readonly threshold: number;
  readonly severity: 'info' | 'warning' | 'critical';
  readonly actions: string[];
}

export interface ReportingSchedule {
  readonly frequency: 'daily' | 'weekly' | 'monthly' | 'quarterly';
  readonly recipients: string[];
  readonly format: 'dashboard' | 'email' | 'pdf' | 'api';
  readonly includeDetails: boolean;
}

export interface Integration {
  readonly system: string;
  readonly endpoint: string;
  readonly frequency: 'real-time' | 'hourly' | 'daily';
  readonly dataMapping: Record<string, string>;
}

export interface ValueStreamFundingRequest {
  readonly requestId: string;
  readonly name: string;
  readonly type:
    | 'epic'
    | 'value-stream'
    | 'enabler'
    | 'operational'
    | 'innovation';
  readonly requestedAmount: number;
  readonly commitmentLevel: 'committed' | 'uncommitted' | 'exploration';
  readonly priority: number;
  readonly owner: string;
  readonly startDate: Date;
  readonly endDate: Date;
  readonly epicIds?: string[];
  readonly costCenterId?: string;
  readonly justification: string;
  readonly expectedOutcomes: string[];
  readonly risks: string[];
}

export interface PortfolioBudgetUtilization {
  readonly portfolioId: string;
  readonly totalBudget: number;
  readonly totalAllocated: number;
  readonly totalSpent: number;
  readonly totalAvailable: number;
  readonly utilizationPercentage: number;
  readonly spendPercentage: number;
  readonly burnRate: number;
  readonly projectedCompletion: Date;
  readonly utilizationByCategory: Record<string, number>;
  readonly budgetRisks: unknown[];
  readonly budgetAlerts: unknown[];
  readonly forecastAccuracy: number;
  readonly lastUpdated: Date;
}

export interface StrategicThemeDefinition {
  readonly name: string;
  readonly description: string;
  readonly objectives: string[];
  readonly budgetAllocation: number;
  readonly timeHorizon: number; // months
  readonly owner: string;
  readonly stakeholders: string[];
}

export interface EpicInvestmentPrioritization {
  readonly portfolioId: string;
  readonly analysisDate: Date;
  readonly criteria: unknown;
  readonly scoredEpics: unknown[];
  readonly optimizationResult: unknown;
  readonly recommendedPortfolio: string[];
  readonly budgetUtilization: number;
  readonly expectedReturn: number;
  readonly riskProfile: unknown;
  readonly alternativeScenarios: unknown[];
}

export interface DateRange {
  readonly start: Date;
  readonly end: Date;
}

export interface BreakEvenAnalysis {
  readonly breakEvenPoint: number; // months
  readonly breakEvenValue: number; // $
  readonly sensitivity: number;
  readonly scenarios: unknown[];
}

export interface MonteCarloResults {
  readonly iterations: number;
  readonly confidenceInterval: {
    readonly low: number;
    readonly high: number;
  };
  readonly meanRoi: number;
  readonly standardDeviation: number;
  readonly riskOfLoss: number; // probability of negative ROI
}

// ============================================================================
// EXPORTS
// ============================================================================

export default PortfolioManager;

export type {
  PortfolioManagerConfig,
  PortfolioBudgetConfig,
  BudgetCycle,
  BudgetAllocation,
  StrategicAlignment,
  FundingSource,
  BudgetReserve,
  CostCenter,
  EpicInvestmentAnalysis,
  InvestmentSummary,
  BusinessCase,
  FinancialProjection,
  InvestmentRiskAssessment,
  InvestmentRecommendation,
  StrategicThemeTracking,
  ThemeProgressMetrics,
  PortfolioManagerState,
};
